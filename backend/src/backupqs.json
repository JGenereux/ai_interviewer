{
  "3sum": {
    "title": "3Sum",
    "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n\nConstraints:\n\n3 <= nums.length <= 3000\n-105 <= nums[i] <= 105\n\n",
    "difficulty": "Medium",
    "hints": [
      "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
      "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ThreeSum(nums) {}",
      "testCalls": [
        "if(JSON.stringify(ThreeSum([-1,0,1,2,-1,-4])) !== JSON.stringify([[-1,-1,2],[-1,0,1]]) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(ThreeSum([0,1,1])) !== JSON.stringify([]) { throw new Error('Test Case 2 Failed'); }",
        "if(JSON.stringify(ThreeSum([0,0,0])) !== JSON.stringify([[0,0,0]]) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ThreeSum(nums: number[]): number[][] {}",
      "testCalls": [
        "const test1 = ThreeSum([-1,0,1,2,-1,-4]); if (JSON.stringify(test1) !== JSON.stringify([[-1,-1,2],[-1,0,1]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ThreeSum([0,1,1]); if (JSON.stringify(test2) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = ThreeSum([0,0,0]); if (JSON.stringify(test3) !== JSON.stringify([[0,0,0]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> ThreeSum(vector<int>& nums);",
      "testCalls": [
        "auto result1 = ThreeSum({-1,0,1,2,-1,-4});\nif (result1 != vector<vector<int>>{{-1,-1,2},{-1,0,1}}) throw std::runtime_error(\"Test 1 failed\");",
        "auto result2 = ThreeSum({0,1,1});\nif (result2 != vector<vector<int>>{}) throw std::runtime_error(\"Test 2 failed\");",
        "auto result3 = ThreeSum({0,0,0});\nif (result3 != vector<vector<int>>{{0,0,0}}) throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": "bool compareVectors(const vector<vector<int>>& v1, const vector<vector<int>>& v2) {\n    if (v1.size() != v2.size()) return false;\n    for (int i = 0; i < v1.size(); ++i) {\n        if (v1[i] != v2[i]) return false;\n    }\n    return true;\n}"
    },
    "python": {
      "functionDeclaration": "def ThreeSum(nums):",
      "testCalls": [
        "assert ThreeSum([-1,0,1,2,-1,-4]) == [[-1,-1,2],[-1,0,1]]",
        "assert ThreeSum([0,1,1]) == []",
        "assert ThreeSum([0,0,0]) == [[0,0,0]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> threeSum(int[] nums) {}",
      "testCalls": [
        "List<List<Integer>> result1 = threeSum(new int[]{-1,0,1,2,-1,-4});\nif (!compareLists(result1, Arrays.asList(Arrays.asList(-1,-1,2), Arrays.asList(-1,0,1)))) throw new AssertionError();",
        "List<List<Integer>> result2 = threeSum(new int[]{0,1,1});\nif (!compareLists(result2, Collections.emptyList())) throw new AssertionError();",
        "List<List<Integer>> result3 = threeSum(new int[]{0,0,0});\nif (!compareLists(result3, Collections.singletonList(Arrays.asList(0,0,0)))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) {\n    if (list1.size() != list2.size()) return false;\n    for (List<Integer> l : list1) {\n        if (!list2.contains(l)) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int** ThreeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int returnSize1; int* returnColumnSizes1; int** result1 = ThreeSum((int[]){-1,0,1,2,-1,-4}, 6, &returnSize1, &returnColumnSizes1); if (returnSize1 == 2 && compareArrays(result1, returnSize1, 3, (int*[]){(int[]){-1,-1,2}, (int[]){-1,0,1}})) { printf(\"Test case 1 passed.\"); } else { printf(\"Test case 1 failed.\"); }",
        "int returnSize2; int* returnColumnSizes2; int** result2 = ThreeSum((int[]){0,1,1}, 3, &returnSize2, &returnColumnSizes2); if (returnSize2 == 0) { printf(\"Test case 2 passed.\"); } else { printf(\"Test case 2 failed.\"); }"
      ],
      "compareHelper": "int compareArrays(int** arr1, int size1, int size2, int** arr2) { if (size1 != size2) { return 0; } for (int i = 0; i < size1; i++) { if (memcmp(arr1[i], arr2[i], sizeof(int) * 3) != 0) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func ThreeSum(nums []int) [][]int {}",
      "testCalls": [
        "if !compareArrays(ThreeSum([]int{-1,0,1,2,-1,-4}), [][]int{{-1,-1,2},{-1,0,1}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(ThreeSum([]int{0,1,1}), [][]int{}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(ThreeSum([]int{0,0,0}), [][]int{{0,0,0}}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if !compareArray(arr1[i], arr2[i]) { return false } } return true } func compareArray(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "ruby": {
      "functionDeclaration": "def ThreeSum(nums)\n  \nend",
      "testCalls": [
        "nums1 = [-1,0,1,2,-1,-4]\nexpected1 = [[-1,-1,2],[-1,0,1]]\nresult1 = ThreeSum(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected1",
        "nums2 = [0,1,1]\nexpected2 = []\nresult2 = ThreeSum(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected2"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[-1,0,1,2,-1,-4]"
        },
        "expected": "[[-1,-1,2],[-1,0,1]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1,1]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[0,0,0]"
        },
        "expected": "[[0,0,0]]"
      }
    ]
  },
  "add-two-numbers": {
    "title": "Add Two Numbers",
    "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sumas a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nExample 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function AddTwoNumbers(l1, l2) {}",
      "testCalls": [
        "let l1 = buildLinkedList([2,4,3]); let l2 = buildLinkedList([5,6,4]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l1, l2))) !== JSON.stringify([7,0,8])) throw 'Test 1 Failed';",
        "let l3 = buildLinkedList([0]); let l4 = buildLinkedList([0]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l3, l4))) !== JSON.stringify([0])) throw 'Test 2 Failed';",
        "let l5 = buildLinkedList([9,9,9,9,9,9]); let l6 = buildLinkedList([9,9,9,9]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l5, l6))) !== JSON.stringify([8,9,9,9,0,0,0,1])) throw 'Test 3 Failed';"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function AddTwoNumbers(l1: number[], l2: number[]): number[] { }",
      "testCalls": [
        "let l1 = buildLinkedList([2,4,3]); let l2 = buildLinkedList([5,6,4]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l1, l2))) !== JSON.stringify([7,0,8])) throw 'Test 1 Failed';"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}",
      "typeDefs": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}",
      "builders": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
      "testCalls": [
        "ListNode* result1 = AddTwoNumbers(createLinkedList({2,4,3}), createLinkedList({5,6,4})); if (!compareLinkedLists(result1, createLinkedList({7,0,8}))) throw std::runtime_error(\"Test Case 1 Failed\");",
        "ListNode* result2 = AddTwoNumbers(createLinkedList({0}), createLinkedList({0})); if (!compareLinkedLists(result2, createLinkedList({0}))) throw std::runtime_error(\"Test Case 2 Failed\");",
        "ListNode* result3 = AddTwoNumbers(createLinkedList({9,9,9,9,9,9,9}), createLinkedList({9,9,9,9})); if (!compareLinkedLists(result3, createLinkedList({8,9,9,9,0,0,0,1}))) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) {\n    while (l1 && l2) {\n        if (l1->val != l2->val) return false;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    return l1 == nullptr && l2 == nullptr;\n}",
      "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} }; ListNode* createLinkedList(std::vector<int> values) { ListNode* head = new ListNode(values[0]); ListNode* curr = head; for (int i = 1; i < values.size(); i++) { curr->next = new ListNode(values[i]); curr = curr->next; } return head; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values) { ListNode* head = new ListNode(values[0]); ListNode* curr = head; for (int i = 1; i < values.size(); i++) { curr->next = new ListNode(values[i]); curr = curr->next; } return head; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def AddTwoNumbers(l1, l2):",
      "testCalls": [
        "l1 = buildLinkedList([2,4,3]); l2 = buildLinkedList([5,6,4]); if linkedListToArray(AddTwoNumbers(l1, l2)) != [7,0,8]: raise Exception('Test 1 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) { }",
      "testCalls": [
        "ListNode l1 = buildLinkedList(new int[]{2,4,3}); ListNode l2 = buildLinkedList(new int[]{5,6,4}); ListNode result1 = addTwoNumbers(l1, l2); if (!Arrays.equals(linkedListToArray(result1), new int[]{7,0,8})) throw new AssertionError();",
        "ListNode l3 = buildLinkedList(new int[]{0}); ListNode l4 = buildLinkedList(new int[]{0}); ListNode result2 = addTwoNumbers(l3, l4); if (!Arrays.equals(linkedListToArray(result2), new int[]{0})) throw new AssertionError();",
        "ListNode l5 = buildLinkedList(new int[]{9,9,9,9,9,9,9}); ListNode l6 = buildLinkedList(new int[]{9,9,9,9}); ListNode result3 = addTwoNumbers(l5, l6); if (!Arrays.equals(linkedListToArray(result3), new int[]{8,9,9,9,0,0,0,1})) throw new AssertionError();"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode l1, ListNode l2) {\n    while (l1 != null && l2 != null) {\n        if (l1.val != l2.val) {\n            throw new AssertionError(\"Test case failed\");\n        }\n        l1 = l1.next;\n        l2 = l2.next;\n    }\n    if (l1 != null || l2 != null) {\n        throw new AssertionError(\"Test case failed\");\n    }\n}",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\nListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "ListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
      "testCalls": [
        "ListNode* result1 = AddTwoNumbers(createLinkedList((int[]){2,4,3}, 3), createLinkedList((int[]){5,6,4}, 3));\nif (!compareLinkedLists(result1, createLinkedList((int[]){7,0,8}, 3))) { printf(\"Test Case 1 Failed\"); }",
        "ListNode* result2 = AddTwoNumbers(createLinkedList((int[]){0}, 1), createLinkedList((int[]){0}, 1));\nif (!compareLinkedLists(result2, createLinkedList((int[]){0}, 1))) { printf(\"Test Case 2 Failed\"); }",
        "ListNode* result3 = AddTwoNumbers(createLinkedList((int[]){9,9,9,9,9,9,9}, 7), createLinkedList((int[]){9,9,9,9}, 4));\nif (!compareLinkedLists(result3, createLinkedList((int[]){8,9,9,9,0,0,0,1}, 8))) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": "int compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return 0; l1 = l1->next; l2 = l2->next; } return l1 == NULL && l2 == NULL; }",
      "helpers": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;\nListNode* createLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* createLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
    },
    "go": {
      "functionDeclaration": "func AddTwoNumbers(l1 []int, l2 []int) []int {}",
      "testCalls": [
        "l1 := buildLinkedList([]int{2, 4, 3}); l2 := buildLinkedList([]int{5, 6, 4}); if !compareArrays(linkedListToArray(AddTwoNumbers(l1, l2)), []int{7, 0, 8}) { t.Error(\"Test 1 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {}",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn AddTwoNumbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let l1 = build_linked_list(&[2, 4, 3]);\nlet l2 = build_linked_list(&[5, 6, 4]);\nassert_eq!(linked_list_to_array(AddTwoNumbers(l1, l2)), vec![7, 0, 8]);"
      ],
      "compareHelper": "fn compare_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> bool { if list1.is_none() && list2.is_none() { return true; } let mut current1 = list1; let mut current2 = list2; while let (Some(node1), Some(node2)) = (current1, current2) { if node1.val != node2.val { return false; } current1 = node1.next.clone(); current2 = node2.next.clone(); } current1.is_none() && current2.is_none() }",
      "helpers": "use std::collections::LinkedList;\n\n#[derive(Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: &[i32]) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr {\n        *curr = Some(Box::new(ListNode::new(val)));\n        curr = &mut (*curr).as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: &[i32]) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr {\n        *curr = Some(Box::new(ListNode::new(val)));\n        curr = &mut (*curr).as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def AddTwoNumbers(l1, l2)\nend",
      "testCalls": [
        "l1 = build_linked_list([2,4,3])\nl2 = build_linked_list([5,6,4])\nif linked_list_to_array(AddTwoNumbers(l1, l2)) != [7,0,8]\n  raise 'Test 1 Failed'\nend"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef build_linked_list(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linked_list_to_array(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def build_linked_list(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linked_list_to_array(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "l1": "[2,4,3]",
          "l2": "[5,6,4]"
        },
        "expected": "[7,0,8]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "l1": "[0]",
          "l2": "[0]"
        },
        "expected": "[0]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "l1": "[9,9,9,9,9,9,9]",
          "l2": "[9,9,9,9]"
        },
        "expected": "[8,9,9,9,0,0,0,1]"
      }
    ]
  },
  "average-of-levels-in-binary-tree": {
    "title": "Average of Levels in Binary Tree",
    "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n\nExample 2:\n\n\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function AverageOfLevelsInBinaryTree(root) {}",
      "testCalls": [
        "let root1 = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root1))) !== JSON.stringify([3,14.5,11])) throw 'Test 1 Failed';",
        "let root2 = buildTree([3,9,20,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root2))) !== JSON.stringify([3,14.5,11])) throw 'Test 2 Failed';"
      ],
      "compareHelper": "function arraysAreEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function AverageOfLevelsInBinaryTree(root: TreeNode | null): number[]",
      "testCalls": [
        "let root = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root))) !== JSON.stringify([3.00000,14.50000,11.00000])) throw 'Test 1 Failed';"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction buildTree(arr: (number | null)[]): TreeNode | null {\n  if (!arr.length || arr[0] === null) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (queue.length && i < arr.length) {\n    const node = queue.shift()!;\n    if (i < arr.length && arr[i] !== null) {\n      node.left = new TreeNode(arr[i] as number);\n      queue.push(node.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      node.right = new TreeNode(arr[i] as number);\n      queue.push(node.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) result.pop();\n  return result;\n}",
      "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}",
      "builders": "function buildTree(arr: (number | null)[]): TreeNode | null {\n  if (!arr.length || arr[0] === null) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (queue.length && i < arr.length) {\n    const node = queue.shift()!;\n    if (i < arr.length && arr[i] !== null) {\n      node.left = new TreeNode(arr[i] as number);\n      queue.push(node.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      node.right = new TreeNode(arr[i] as number);\n      queue.push(node.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) result.pop();\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "vector<double> AverageOfLevelsInBinaryTree(TreeNode* root)",
      "testCalls": [
        "auto result1 = AverageOfLevelsInBinaryTree(createTree({3,9,20,{}, {}, 15, 7})); if (!compareArrays(result1, {3.0, 14.5, 11.0})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = AverageOfLevelsInBinaryTree(createTree({3,9,20,15,7})); if (!compareArrays(result2, {3.0, 14.5, 11.0})) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "bool compareArrays(vector<double>& arr1, vector<double>& arr2) {\n    if (arr1.size() != arr2.size()) return false;\n    for (int i = 0; i < arr1.size(); ++i) {\n        if (abs(arr1[i] - arr2[i]) > 1e-5) return false;\n    }\n    return true;\n}",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} }; TreeNode* createTree(std::vector<std::optional<int>> values) { if (values.empty() || !values[0].has_value()) return nullptr; TreeNode* root = new TreeNode(values[0].value()); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (i < values.size() && values[i].has_value()) { node->left = new TreeNode(values[i].value()); q.push(node->left); } i++; if (i < values.size() && values[i].has_value()) { node->right = new TreeNode(values[i].value()); q.push(node->right); } i++; } return root; } std::vector<std::optional<int>> treeToArray(TreeNode* root) { std::vector<std::optional<int>> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); if (node->left || node->right) { q.push(node->left); q.push(node->right); } } else { result.push_back(std::nullopt); } } while (!result.empty() && !result.back().has_value()) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} };",
      "builders": "TreeNode* createTree(std::vector<std::optional<int>> values) { if (values.empty() || !values[0].has_value()) return nullptr; TreeNode* root = new TreeNode(values[0].value()); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (i < values.size() && values[i].has_value()) { node->left = new TreeNode(values[i].value()); q.push(node->left); } i++; if (i < values.size() && values[i].has_value()) { node->right = new TreeNode(values[i].value()); q.push(node->right); } i++; } return root; } std::vector<std::optional<int>> treeToArray(TreeNode* root) { std::vector<std::optional<int>> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); if (node->left || node->right) { q.push(node->left); q.push(node->right); } } else { result.push_back(std::nullopt); } } while (!result.empty() && !result.back().has_value()) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def AverageOfLevelsInBinaryTree(root: TreeNode) -> List[float]:",
      "testCalls": [
        "root = buildTree([3,9,20,None,None,15,7]); if treeToArray(AverageOfLevelsInBinaryTree(root)) != [3.00000,14.50000,11.00000]: raise Exception('Test 1 Failed')"
      ],
      "compareHelper": "def assertArrayEquals(arr1, arr2): assert len(arr1) == len(arr2) and all(a == b for a, b in zip(arr1, arr2)), 'Arrays not equal'",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public double[] AverageOfLevels(TreeNode root)",
      "testCalls": [
        "TreeNode root1 = buildTree(new Integer[]{3, 9, 20, null, null, 15, 7}); double[] result1 = AverageOfLevels(root1); assertArrayEquals(new double[]{3.00000, 14.50000, 11.00000}, result1);",
        "TreeNode root2 = buildTree(new Integer[]{3, 9, 20, 15, 7}); double[] result2 = AverageOfLevels(root2); assertArrayEquals(new double[]{3.00000, 14.50000, 11.00000}, result2);"
      ],
      "compareHelper": "private static void assertArrayEquals(double[] expected, double[] actual) {\n    if (!Arrays.equals(expected, actual)) {\n        throw new AssertionError(\"Arrays not equal: expected \" + Arrays.toString(expected) + \" but was \" + Arrays.toString(actual));\n    }\n}",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }\nTreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\nint[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }",
      "builders": "TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\nint[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "double* AverageOfLevelsInBinaryTree(struct TreeNode* root, int* returnSize)",
      "testCalls": [
        "double* result1 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]){3,9,20,0,0,15,7}, 7), &returnSize); assert(compareDoubleArrays(result1, 3, (double[]){3.00000,14.50000,11.00000}, 3));",
        "double* result2 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]){3,9,20,15,7}, 5), &returnSize); assert(compareDoubleArrays(result2, 3, (double[]){3.00000,14.50000,11.00000}, 3));"
      ],
      "compareHelper": "int compareDoubleArrays(double* arr1, int size1, double* arr2, int size2) { if (size1 != size2) return 0; for (int i = 0; i < size1; i++) { if (fabs(arr1[i] - arr2[i]) > 0.00001) return 0; } return 1; }",
      "helpers": "typedef struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;\nTreeNode* createTreeFromArray(int* arr, int size);\ndouble* treeToArray(TreeNode* root);",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;",
      "builders": "TreeNode* createTreeFromArray(int* arr, int size);\ndouble* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func AverageOfLevels(root *TreeNode) []float64 {}",
      "testCalls": [
        "root := buildTree([]int{3, 9, 20, null, null, 15, 7}); if !compareFloatArrays(AverageOfLevels(root), []float64{3.00000, 14.50000, 11.00000}) { t.Error(\"Test Case 1 Failed\") }"
      ],
      "compareHelper": "func compareFloatArrays(arr1, arr2 []float64) bool {}",
      "helpers": "type TreeNode struct { Val int Left *TreeNode Right *TreeNode }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int Left *TreeNode Right *TreeNode }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn AverageOfLevelsInBinaryTree(root: Option<Box<TreeNode>>) -> Vec<f64> { }",
      "testCalls": [
        "let root = build_tree(&[Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);\nassert_eq!(tree_to_array(AverageOfLevelsInBinaryTree(root)), vec![Some(3), Some(14), Some(11)]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Clone, Debug)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}\n\nfn build_tree(arr: &[Option<i32>]) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() { return None; }\n    let mut root = Some(Box::new(TreeNode { val: arr[0].unwrap(), left: None, right: None }));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_mut().unwrap());\n    let mut i = 1;\n    while !queue.is_empty() && i < arr.len() {\n        let node = queue.pop_front().unwrap();\n        if let Some(val) = arr[i] {\n            node.left = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.left.as_mut().unwrap());\n        }\n        i += 1;\n        if let Some(val) = arr[i] {\n            node.right = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.right.as_mut().unwrap());\n        }\n        i += 1;\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Clone, Debug)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}",
      "builders": "fn build_tree(arr: &[Option<i32>]) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() { return None; }\n    let mut root = Some(Box::new(TreeNode { val: arr[0].unwrap(), left: None, right: None }));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_mut().unwrap());\n    let mut i = 1;\n    while !queue.is_empty() && i < arr.len() {\n        let node = queue.pop_front().unwrap();\n        if let Some(val) = arr[i] {\n            node.left = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.left.as_mut().unwrap());\n        }\n        i += 1;\n        if let Some(val) = arr[i] {\n            node.right = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.right.as_mut().unwrap());\n        }\n        i += 1;\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def AverageOfLevelsInBinaryTree(root)\nend",
      "testCalls": [
        "root = build_tree([3,9,20,nil,nil,15,7])\nif tree_to_array(AverageOfLevelsInBinaryTree(root)) != [3.00000,14.50000,11.00000]\n  raise 'Test Case 1 Failed'\nend"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef build_tree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef tree_to_array(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def build_tree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef tree_to_array(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "[3.00000,14.50000,11.00000]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[3,9,20,15,7]"
        },
        "expected": "[3.00000,14.50000,11.00000]"
      }
    ]
  },
  "basic-calculator": {
    "title": "Basic Calculator",
    "content": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\nExample 1:\n\nInput: s = &quot;1 + 1&quot;\nOutput: 2\n\nExample 2:\n\nInput: s = &quot; 2-1 + 2 &quot;\nOutput: 3\n\nExample 3:\n\nInput: s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\nOutput: 23\n\n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists of digits, &#39;+&#39;, &#39;-&#39;, &#39;(&#39;, &#39;)&#39;, and &#39; &#39;.\ns represents a valid expression.\n&#39;+&#39; is not used as a unary operation (i.e., &quot;+1&quot; and &quot;+(2 + 3)&quot; is invalid).\n&#39;-&#39; could be used as a unary operation (i.e., &quot;-1&quot; and &quot;-(2 + 3)&quot; is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Math",
      "String",
      "Stack",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "BasicCalculator(s)",
      "testCalls": [
        "if(BasicCalculator(\"1+1\") !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BasicCalculator(\"2-1+2\") !== 3) { throw new Error('Test Case 2 Failed'); }",
        "if(BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BasicCalculator(s: string): number {}",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") !== 2) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (BasicCalculator(\"2-1+2\") !== 3) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") !== 23) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int BasicCalculator(string s);",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") != 2) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (BasicCalculator(\"2-1+2\") != 3) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BasicCalculator(s: str) -> int:",
      "testCalls": [
        "assert BasicCalculator(\"1+1\") == 2",
        "assert BasicCalculator(\"2-1+2\") == 3",
        "assert BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") == 23"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BasicCalculator(String s) { }",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") != 2) throw new AssertionError();",
        "if (BasicCalculator(\"2-1+2\") != 3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BasicCalculator(char* s)",
      "testCalls": [
        "if(BasicCalculator(\"1+1\") != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(BasicCalculator(\"2-1+2\") != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BasicCalculator(s string) int {}",
      "testCalls": [
        "if BasicCalculator(\"1+1\") != 2 { t.Error(\"Test case 1 failed\") }",
        "if BasicCalculator(\"2-1+2\") != 3 { t.Error(\"Test case 2 failed\") }",
        "if BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") != 23 { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BasicCalculator(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(BasicCalculator(String::from(\"1+1\")), 2);",
        "assert_eq!(BasicCalculator(String::from(\"2-1+2\")), 3);",
        "assert_eq!(BasicCalculator(String::from(\"(1+(4+5+2)-3)+(6+8)\")), 23);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BasicCalculator(s)",
      "testCalls": [
        "result1 = BasicCalculator(\"1+1\"); raise 'Test Case 1 Failed' unless result1 == 2",
        "result2 = BasicCalculator(\"2-1+2\"); raise 'Test Case 2 Failed' unless result2 == 3",
        "result3 = BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\"); raise 'Test Case 3 Failed' unless result3 == 23"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;1+1&quot;"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;2-1+2&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;(1+(4+5+2)-3)+(6+8)&quot;"
        },
        "expected": "23"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock-ii": {
    "title": "Best Time to Buy and Sell Stock II",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.\nFind and return the maximum profit you can achieve.\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\nConstraints:\n\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockII(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(BestTimeToBuyAndSellStockII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockII(prices: number[]): number {}",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (BestTimeToBuyAndSellStockII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfit(std::vector<int>& prices);",
      "testCalls": [
        "assert(MaxProfit({7,1,5,3,6,4}) == 7);",
        "assert(MaxProfit({1,2,3,4,5}) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockII(prices: List[int]) -> int:",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) == 7",
        "assert BestTimeToBuyAndSellStockII([1,2,3,4,5]) == 4",
        "assert BestTimeToBuyAndSellStockII([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockII(int[] prices) { }",
      "testCalls": [
        "int[] testInput1 = {7, 1, 5, 3, 6, 4};\nint expectedOutput1 = 7;\nint result1 = BestTimeToBuyAndSellStockII(testInput1);\nif (result1 != expectedOutput1) { throw new AssertionError(); }",
        "int[] testInput2 = {1, 2, 3, 4, 5};\nint expectedOutput2 = 4;\nint result2 = BestTimeToBuyAndSellStockII(testInput2);\nif (result2 != expectedOutput2) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit((int[]){7,1,5,3,6,4}, 6) != 7) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfit((int[]){1,2,3,4,5}, 5) != 4) { printf(\"Test Case 2 Failed\"); }",
        "if(MaxProfit((int[]){7,6,4,3,1}, 5) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxProfit(prices []int) int {}",
      "testCalls": [
        "if MaxProfit([]int{7,1,5,3,6,4}) != 7 {panic(\"Test case 1 failed\")}",
        "if MaxProfit([]int{1,2,3,4,5}) != 4 {panic(\"Test case 2 failed\")}",
        "if MaxProfit([]int{7,6,4,3,1}) != 0 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockII(prices: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![7,1,5,3,6,4]), 7);",
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![1,2,3,4,5]), 4);",
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![7,6,4,3,1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockII(prices)\nend",
      "testCalls": [
        "test_case_1 = BestTimeToBuyAndSellStockII([7,1,5,3,6,4])\nraise 'Test Case 1 Failed' unless test_case_1 == 7",
        "test_case_2 = BestTimeToBuyAndSellStockII([1,2,3,4,5])\nraise 'Test Case 2 Failed' unless test_case_2 == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "prices": "[7,1,5,3,6,4]"
        },
        "expected": "7"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "prices": "[1,2,3,4,5]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "prices": "[7,6,4,3,1]"
        },
        "expected": "0"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock-iii": {
    "title": "Best Time to Buy and Sell Stock III",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n\n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 105\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIII(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(BestTimeToBuyAndSellStockIII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIII(prices: number[]): number {}",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BestTimeToBuyAndSellStockIII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if (BestTimeToBuyAndSellStockIII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfitIII(vector<int>& prices)",
      "testCalls": [
        "assert(MaxProfitIII({3,3,5,0,0,3,1,4}) == 6);",
        "assert(MaxProfitIII({1,2,3,4,5}) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIII(prices: List[int]) -> int:",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) == 6",
        "assert BestTimeToBuyAndSellStockIII([1,2,3,4,5]) == 4",
        "assert BestTimeToBuyAndSellStockIII([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockIII(int[] prices) {}",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIII(new int[]{3,3,5,0,0,3,1,4}) == 6;",
        "assert BestTimeToBuyAndSellStockIII(new int[]{1,2,3,4,5}) == 4;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfitIII(int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfitIII((int[]){3,3,5,0,0,3,1,4}, 8) != 6) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfitIII((int[]){1,2,3,4,5}, 5) != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BestTimeToBuyAndSellStockIII(prices []int) int {}",
      "testCalls": [
        "if BestTimeToBuyAndSellStockIII([]int{3,3,5,0,0,3,1,4}) != 6 {panic(\"Test case 1 failed\")}",
        "if BestTimeToBuyAndSellStockIII([]int{1,2,3,4,5}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockIII(prices: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockIII(vec![3,3,5,0,0,3,1,4]), 6);",
        "assert_eq!(BestTimeToBuyAndSellStockIII(vec![1,2,3,4,5]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIII(prices)\nend",
      "testCalls": [
        "result1 = BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4])\nraise 'Test Case 1 Failed' unless result1 == 6",
        "result2 = BestTimeToBuyAndSellStockIII([1,2,3,4,5])\nraise 'Test Case 2 Failed' unless result2 == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "prices": "[3,3,5,0,0,3,1,4]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "prices": "[1,2,3,4,5]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "prices": "[7,6,4,3,1]"
        },
        "expected": "0"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock-iv": {
    "title": "Best Time to Buy and Sell Stock IV",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\nExample 2:\n\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n\nConstraints:\n\n1 <= k <= 100\n1 <= prices.length <= 1000\n0 <= prices[i] <= 1000\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIV(k, prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIV(2, [2,4,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) !== 7) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIV(k: number, prices: number[]): number {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIV(2, [2,4,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) !== 7) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfit(int k, vector<int>& prices);",
      "testCalls": [
        "assert(MaxProfit(2, {2,4,1}) == 2);",
        "assert(MaxProfit(2, {3,2,6,5,0,3}) == 7);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIV(k: int, prices: List[int]) -> int:",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIV(2, [2,4,1]) == 2",
        "assert BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) == 7"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockIV(int k, int[] prices) {}",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIV(2, new int[]{2,4,1}) == 2;",
        "assert BestTimeToBuyAndSellStockIV(2, new int[]{3,2,6,5,0,3}) == 7;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int k, int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit(2, (int[]){2,4,1}, 3) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfit(2, (int[]){3,2,6,5,0,3}, 6) != 7) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BestTimeToBuyAndSellStockIV(k int, prices []int) int {}",
      "testCalls": [
        "if result := BestTimeToBuyAndSellStockIV(2, []int{2,4,1}); result != 2 { t.Errorf(\"Test 1 failed. Expected: %v, but got: %v\", 2, result) }",
        "if result := BestTimeToBuyAndSellStockIV(2, []int{3,2,6,5,0,3}); result != 7 { t.Errorf(\"Test 2 failed. Expected: %v, but got: %v\", 7, result) }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockIV(k: i32, prices: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockIV(2, vec![2, 4, 1]), 2);",
        "assert_eq!(BestTimeToBuyAndSellStockIV(2, vec![3, 2, 6, 5, 0, 3]), 7);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIV(k, prices)\nend",
      "testCalls": [
        "result1 = BestTimeToBuyAndSellStockIV(2, [2,4,1])\nraise 'Test Case 1 Failed' unless result1 == 2",
        "result2 = BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3])\nraise 'Test Case 2 Failed' unless result2 == 7"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "k": "2",
          "prices": "[2,4,1]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "k": "2",
          "prices": "[3,2,6,5,0,3]"
        },
        "expected": "7"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock": {
    "title": "Best Time to Buy and Sell Stock",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStock(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStock([7,1,5,3,6,4]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStock([7,6,4,3,1]) !== 0) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxProfit(prices: number[]): number {}",
      "testCalls": [
        "if(MaxProfit([7,1,5,3,6,4]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxProfit([7,6,4,3,1]) !== 0) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfit(vector<int>& prices);",
      "testCalls": [
        "if(MaxProfit({7,1,5,3,6,4}) != 5) throw std::runtime_error(\"Test 1 failed\");",
        "if(MaxProfit({7,6,4,3,1}) != 0) throw std::runtime_error(\"Test 2 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStock(prices: List[int]) -> int",
      "testCalls": [
        "assert BestTimeToBuyAndSellStock([7,1,5,3,6,4]) == 5",
        "assert BestTimeToBuyAndSellStock([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaxProfit(int[] prices) { }",
      "testCalls": [
        "if(MaxProfit(new int[]{7,1,5,3,6,4}) != 5) throw new AssertionError();",
        "if(MaxProfit(new int[]{7,6,4,3,1}) != 0) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit((int[]) {7,1,5,3,6,4}, 6) != 5) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfit((int[]) {7,6,4,3,1}, 5) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxProfit(prices []int) int {}",
      "testCalls": [
        "if MaxProfit([]int{7,1,5,3,6,4}) != 5 { panic(\"Test case 1 failed\") }",
        "if MaxProfit([]int{7,6,4,3,1}) != 0 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStock(prices: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStock(vec![7, 1, 5, 3, 6, 4]), 5);",
        "assert_eq!(BestTimeToBuyAndSellStock(vec![7, 6, 4, 3, 1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStock(prices)\nend",
      "testCalls": [
        "test 'Example 1' do\n  expect(BestTimeToBuyAndSellStock([7,1,5,3,6,4])).to eq(5)\nend",
        "test 'Example 2' do\n  expect(BestTimeToBuyAndSellStock([7,6,4,3,1])).to eq(0)\nend"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "prices": "[7,1,5,3,6,4]"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "prices": "[7,6,4,3,1]"
        },
        "expected": "0"
      }
    ]
  },
  "binary-tree-level-order-traversal": {
    "title": "Binary Tree Level Order Traversal",
    "content": "Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000\n\n",
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS."
    ],
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeLevelOrderTraversal(root) {}",
      "testCalls": [
        "let root1 = buildTree([3,9,20,null,null,15,7]); BinaryTreeLevelOrderTraversal(root1);",
        "let root2 = buildTree([1]); BinaryTreeLevelOrderTraversal(root2);",
        "let root3 = buildTree([]); BinaryTreeLevelOrderTraversal(root3);"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeLevelOrderTraversal(root: TreeNode | null): number[][] {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(buildTree([3,9,20,null,null,15,7]))) !== '[[3],[9,20],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(buildTree([1]))) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(null)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null {\n  // implementation here\n}\n",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> BinaryTreeLevelOrderTraversal(TreeNode* root)",
      "testCalls": [
        "assert(BinaryTreeLevelOrderTraversal(createTree({3,9,20,null,null,15,7})) == vector<vector<int>>{{3},{9,20},{15,7}});",
        "assert(BinaryTreeLevelOrderTraversal(createTree({1})) == vector<vector<int>>{{1}});",
        "assert(BinaryTreeLevelOrderTraversal(nullptr) == vector<vector<int>>{});"
      ],
      "compareHelper": "vector<int> treeToArray(TreeNode* root) { if (!root) return {}; vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int size = q.size(); vector<int> level; for (int i = 0; i < size; ++i) { TreeNode* node = q.front(); q.pop(); level.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } result.insert(result.end(), level.begin(), level.end()); } return result; }",
      "helpers": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nvector<vector<int>> BinaryTreeLevelOrderTraversal(TreeNode* root); \nTreeNode* createTree(const vector<int>& arr); \nvector<int> treeToArray(TreeNode* root);",
      "typeDefs": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "vector<vector<int>> BinaryTreeLevelOrderTraversal(TreeNode* root); \nTreeNode* createTree(const vector<int>& arr); \nvector<int> treeToArray(TreeNode* root);"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeLevelOrderTraversal(root):",
      "testCalls": [
        "root = buildTree([3,9,20,None,None,15,7])\nassert treeToArray(BinaryTreeLevelOrderTraversal(root)) == [[3],[9,20],[15,7]], 'Test Case 1 Failed'",
        "root = buildTree([1])\nassert treeToArray(BinaryTreeLevelOrderTraversal(root)) == [[1]], 'Test Case 2 Failed'",
        "root = buildTree([])\nassert treeToArray(BinaryTreeLevelOrderTraversal(root)) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i] if i < len(arr) else None\n            node.right = nodes[i + 1] if i + 1 < len(arr) else None\n            queue.append(node.left)\n            queue.append(node.right)\n        i += 2\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result\n",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i] if i < len(arr) else None\n            node.right = nodes[i + 1] if i + 1 < len(arr) else None\n            queue.append(node.left)\n            queue.append(node.right)\n        i += 2\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result\n"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> BinaryTreeLevelOrderTraversal(TreeNode root) {}",
      "testCalls": [
        "List<List<Integer>> result1 = BinaryTreeLevelOrderTraversal(buildTree(new Integer[]{3, 9, 20, null, null, 15, 7}));\nif (!Arrays.deepEquals(result1.toArray(), new Integer[][]{{3}, {9, 20}, {15, 7}})) throw new AssertionError();",
        "List<List<Integer>> result2 = BinaryTreeLevelOrderTraversal(buildTree(new Integer[]{1}));\nif (!Arrays.deepEquals(result2.toArray(), new Integer[][]{{1}})) throw new AssertionError();",
        "List<List<Integer>> result3 = BinaryTreeLevelOrderTraversal(buildTree(new Integer[]{}));\nif (!Arrays.deepEquals(result3.toArray(), new Integer[][]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, List<List<Integer>> arr2) {\n    return Arrays.deepEquals(arr1.toArray(), arr2.toArray());\n}",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<List<Integer>> treeToArray(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) return result; Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { int size = queue.size(); List<Integer> level = new ArrayList<>(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } result.add(level); } return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<List<Integer>> treeToArray(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) return result; Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { int size = queue.size(); List<Integer> level = new ArrayList<>(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } result.add(level); } return result; }"
    },
    "c": {
      "functionDeclaration": "void BinaryTreeLevelOrderTraversal(struct TreeNode* root)",
      "testCalls": [
        "struct TreeNode* root1 = buildTree((int[]){3, 9, 20, -1, -1, 15, 7}, 7); BinaryTreeLevelOrderTraversal(root1);",
        "struct TreeNode* root2 = buildTree((int[]){1}, 1); BinaryTreeLevelOrderTraversal(root2);",
        "BinaryTreeLevelOrderTraversal(NULL);"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createTree(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == -1) return NULL; struct TreeNode* root = createTree(arr[0]); struct TreeNode* queue[size]; int qFront = 0, qRear = 0; queue[qRear++] = root; int i = 1; while (qFront < qRear && i < size) { struct TreeNode* node = queue[qFront++]; if (i < size && arr[i] != -1) { node->left = createTree(arr[i]); queue[qRear++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = createTree(arr[i]); queue[qRear++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 2000); int resultIdx = 0; struct TreeNode* queue[2000]; int qFront = 0, qRear = 0; queue[qRear++] = root; while (qFront < qRear) { struct TreeNode* node = queue[qFront++]; if (node) { result[resultIdx++] = node->val; if (node->left) queue[qRear++] = node->left; if (node->right) queue[qRear++] = node->right; } } *returnSize = resultIdx; return result; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTree(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == -1) return NULL; struct TreeNode* root = createTree(arr[0]); struct TreeNode* queue[size]; int qFront = 0, qRear = 0; queue[qRear++] = root; int i = 1; while (qFront < qRear && i < size) { struct TreeNode* node = queue[qFront++]; if (i < size && arr[i] != -1) { node->left = createTree(arr[i]); queue[qRear++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = createTree(arr[i]); queue[qRear++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 2000); int resultIdx = 0; struct TreeNode* queue[2000]; int qFront = 0, qRear = 0; queue[qRear++] = root; while (qFront < qRear) { struct TreeNode* node = queue[qFront++]; if (node) { result[resultIdx++] = node->val; if (node->left) queue[qRear++] = node->left; if (node->right) queue[qRear++] = node->right; } } *returnSize = resultIdx; return result; }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeLevelOrderTraversal(root *TreeNode) [][]int {}",
      "testCalls": [
        "let root = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(BinaryTreeLevelOrderTraversal(root)) !== JSON.stringify([[3],[9,20],[15,7]])) throw 'Test Case 1 Failed';",
        "let root = buildTree([1]); if (JSON.stringify(BinaryTreeLevelOrderTraversal(root)) !== JSON.stringify([[1]])) throw 'Test Case 2 Failed';"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { return reflect.DeepEqual(arr1, arr2) }",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeLevelOrderTraversal(root: Option<Rc<RefCell<TreeNode>>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "let root1 = buildTree(vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]); let result1 = BinaryTreeLevelOrderTraversal(root1); assert_eq!(result1, vec![vec![3], vec![9, 20], vec![15, 7]]);",
        "let root2 = buildTree(vec![Some(1), None, None]); let result2 = BinaryTreeLevelOrderTraversal(root2); assert_eq!(result2, vec![vec![1]]);",
        "let root3 = buildTree(vec![]); let result3 = BinaryTreeLevelOrderTraversal(root3); assert_eq!(result3, vec![]);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeLevelOrderTraversal(root)\nend",
      "testCalls": [
        "root = buildTree([3,9,20,nil,nil,15,7])\nif treeToArray(BinaryTreeLevelOrderTraversal(root)) != [[3],[9,20],[15,7]]\n  raise 'Test Case 1 Failed'\nend",
        "root = buildTree([1])\nif treeToArray(BinaryTreeLevelOrderTraversal(root)) != [[1]]\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val=0, left=nil, right=nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  while result[-1] == nil\n    result.pop\n  end\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val=0, left=nil, right=nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  while result[-1] == nil\n    result.pop\n  end\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "[[3],[9,20],[15,7]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1]"
        },
        "expected": "[[1]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "binary-tree-maximum-path-sum": {
    "title": "Binary Tree Maximum Path Sum",
    "content": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\nExample 1:\n\n\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\nExample 2:\n\n\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 3 * 104].\n-1000 <= Node.val <= 1000\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeMaximumPathSum(root) {}",
      "testCalls": [
        "let root1 = buildTree([1,2,3]); if (BinaryTreeMaximumPathSum(root1) !== 6) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([-10,9,20,null,null,15,7]); if (BinaryTreeMaximumPathSum(root2) !== 42) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeMaximumPathSum(root: TreeNode | null): number {}",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(arrayToBinaryTree([1,2,3])) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BinaryTreeMaximumPathSum(arrayToBinaryTree([-10,9,20,null,null,15,7])) !== 42) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arrayToBinaryTree(arr: (number | null)[]): TreeNode | null {}",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction arrayToBinaryTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction binaryTreeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function arrayToBinaryTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction binaryTreeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int BinaryTreeMaximumPathSum(TreeNode* root)",
      "testCalls": [
        "assert(BinaryTreeMaximumPathSum(buildTree({1,2,3})) == 6);",
        "assert(BinaryTreeMaximumPathSum(buildTree({-10,9,20,INT_MIN,INT_MIN,15,7})) == 42);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeMaximumPathSum(root):",
      "testCalls": [
        "root = buildTree([1,2,3]); assert BinaryTreeMaximumPathSum(root) == 6",
        "root = buildTree([-10,9,20,None,None,15,7]); assert BinaryTreeMaximumPathSum(root) == 42"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public int BinaryTreeMaximumPathSum(TreeNode root) { }",
      "testCalls": [
        "TreeNode root1 = buildTree(new Integer[]{1,2,3}); if (BinaryTreeMaximumPathSum(root1) != 6) throw new AssertionError();",
        "TreeNode root2 = buildTree(new Integer[]{-10,9,20,null,null,15,7}); if (BinaryTreeMaximumPathSum(root2) != 42) throw new AssertionError();"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "int BinaryTreeMaximumPathSum(struct TreeNode* root)",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(createTreeFromArray((int[]) {1,2,3}, 3)) != 6) { printf(\"Test Case 1 Failed\"); }",
        "if (BinaryTreeMaximumPathSum(createTreeFromArray((int[]) {-10,9,20,INT_MIN,INT_MIN,15,7}, 7)) != 42) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeMaximumPathSum(root *TreeNode) int {}",
      "testCalls": [
        "let root = BuildTree([]int{1, 2, 3}); BinaryTreeMaximumPathSum(root)",
        "let root = BuildTree([]int{-10, 9, 20, math.MinInt32, math.MinInt32, 15, 7}); BinaryTreeMaximumPathSum(root)"
      ],
      "compareHelper": "func BuildTree(nodes []int) *TreeNode {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc BuildTree(arr []int) *TreeNode {}\nfunc TreeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func BuildTree(arr []int) *TreeNode {}\nfunc TreeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeMaximumPathSum(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "let root1 = buildTree(vec![Some(1), Some(2), Some(3)]); assert_eq!(BinaryTreeMaximumPathSum(root1), 6);",
        "let root2 = buildTree(vec![Some(-10), Some(9), Some(20), None, None, Some(15), Some(7)]); assert_eq!(BinaryTreeMaximumPathSum(root2), 42);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    fn helper(arr: &[Option<i32>], index: usize) -> Option<Rc<RefCell<TreeNode>>> {\n        if index < arr.len() {\n            if let Some(val) = arr[index] {\n                let node = Rc::new(RefCell::new(TreeNode::new(val)));\n                node.borrow_mut().left = helper(arr, 2 * index + 1);\n                node.borrow_mut().right = helper(arr, 2 * index + 2);\n                Some(node)\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n    helper(&arr, 0)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.borrow().val));\n            queue.push_back(n.borrow().left.clone());\n            queue.push_back(n.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    fn helper(arr: &Vec<Option<i32>>, index: usize) -> Option<Rc<RefCell<TreeNode>>> {\n        if index < arr.len() {\n            if let Some(val) = arr[index] {\n                let node = Rc::new(RefCell::new(TreeNode::new(val)));\n                node.borrow_mut().left = helper(arr, 2 * index + 1);\n                node.borrow_mut().right = helper(arr, 2 * index + 2);\n                return Some(node);\n            }\n        }\n        None\n    }\n    helper(&arr, 0)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.borrow().val));\n            queue.push_back(n.borrow().left.clone());\n            queue.push_back(n.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeMaximumPathSum(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3]); result = BinaryTreeMaximumPathSum(root); raise 'Test Case 1 Failed' unless result == 6",
        "root = buildTree([-10,9,20,nil,nil,15,7]); result = BinaryTreeMaximumPathSum(root); raise 'Test Case 2 Failed' unless result == 42"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[-10,9,20,null,null,15,7]"
        },
        "expected": "42"
      }
    ]
  },
  "binary-tree-right-side-view": {
    "title": "Binary Tree Right Side View",
    "content": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\nExample 1:\n\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\nExplanation:\n\n\nExample 2:\n\nInput: root = [1,2,3,4,null,null,null,5]\nOutput: [1,3,4,5]\nExplanation:\n\n\nExample 3:\n\nInput: root = [1,null,3]\nOutput: [1,3]\n\nExample 4:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeRightSideView(root) {}",
      "testCalls": [
        "let root1 = buildTree([1,2,3,null,5,null,4]); if (JSON.stringify(BinaryTreeRightSideView(root1)) !== JSON.stringify([1,3,4])) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([1,2,3,4,null,null,null,5]); if (JSON.stringify(BinaryTreeRightSideView(root2)) !== JSON.stringify([1,3,4,5])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeRightSideView(root: TreeNode | null): number[] {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,2,3,null,5,null,4]))) !== JSON.stringify([1,3,4])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,2,3,4,null,null,null,5]))) !== JSON.stringify([1,3,4,5])) throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,null,3]))) !== JSON.stringify([1,3])) throw new Error('Test Case 3 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(null)) !== JSON.stringify([])) throw new Error('Test Case 4 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift(); if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "vector<int> BinaryTreeRightSideView(TreeNode* root)",
      "testCalls": [
        "assert(BinaryTreeRightSideView(buildTree({1,2,3,INT_MIN,5,INT_MIN,4})) == vector<int>({1,3,4}));",
        "assert(BinaryTreeRightSideView(buildTree({1,2,3,4,INT_MIN,INT_MIN,INT_MIN,5})) == vector<int>({1,3,4,5}));",
        "assert(BinaryTreeRightSideView(buildTree({1,INT_MIN,3})) == vector<int>({1,3}));",
        "assert(BinaryTreeRightSideView(nullptr) == vector<int>({}));"
      ],
      "compareHelper": "bool compareVectors(vector<int>& v1, vector<int>& v2) { return v1 == v2; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeRightSideView(root):",
      "testCalls": [
        "root = buildTree([1,2,3,None,5,None,4]); assert BinaryTreeRightSideView(root) == [1,3,4]",
        "root = buildTree([1,2,3,4,None,None,None,5]); assert BinaryTreeRightSideView(root) == [1,3,4,5]",
        "root = buildTree([1,None,3]); assert BinaryTreeRightSideView(root) == [1,3]",
        "root = buildTree([]); assert BinaryTreeRightSideView(root) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 == arr2:\n        return True\n    else:\n        raise AssertionError(f'Arrays not equal: {arr1} != {arr2}')",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public List<Integer> BinaryTreeRightSideView(TreeNode root) {}",
      "testCalls": [
        "TreeNode root1 = buildTree(new Integer[]{1,2,3,null,5,null,4}); List<Integer> result1 = BinaryTreeRightSideView(root1); if (!Arrays.equals(result1.toArray(), new Integer[]{1,3,4})) throw new AssertionError();",
        "TreeNode root2 = buildTree(new Integer[]{1,2,3,4,null,null,null,5}); List<Integer> result2 = BinaryTreeRightSideView(root2); if (!Arrays.equals(result2.toArray(), new Integer[]{1,3,4,5})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "void BinaryTreeRightSideView(struct TreeNode* root)",
      "testCalls": [
        "BinaryTreeRightSideView(createTreeFromArray((int[]) {1,2,3,INT_MIN,5,INT_MIN,4}, 7)); // Compare result with expected for test case 1",
        "BinaryTreeRightSideView(createTreeFromArray((int[]) {1,2,3,4,INT_MIN,INT_MIN,INT_MIN,5}, 8)); // Compare result with expected for test case 2"
      ],
      "compareHelper": "void compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { printf(\"Test Failed\"); exit(1); } } }",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeRightSideView(root *TreeNode) []int {}",
      "testCalls": [
        "let root = BuildTree([]int{1, 2, 3, null, 5, null, 4}); BinaryTreeRightSideView(root)",
        "let root = BuildTree([]int{1, 2, 3, 4, null, null, null, 5}); BinaryTreeRightSideView(root)"
      ],
      "compareHelper": "func Deserialize(data string) *TreeNode {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc BuildTree(arr []int) *TreeNode {}\nfunc TreeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func BuildTree(arr []int) *TreeNode {}\nfunc TreeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeRightSideView(root: Option<Rc<RefCell<TreeNode>>) -> Vec<i32> { }",
      "testCalls": [
        "let root1 = buildTree(vec![Some(1), Some(2), Some(3), None, Some(5), None, Some(4)]); assert_eq!(BinaryTreeRightSideView(root1), vec![1, 3, 4]);",
        "let root2 = buildTree(vec![Some(1), Some(2), Some(3), Some(4), None, None, None, Some(5)]); assert_eq!(BinaryTreeRightSideView(root2), vec![1, 3, 4, 5]);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() { return None; }\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(Rc::clone(&root));\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(Some(node)) = queue.pop_front() {\n            if let Some(Some(val)) = arr.get(i) {\n                let left_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().left = Some(Rc::clone(&left_child));\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if let Some(Some(val)) = arr.get(i) {\n                let right_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().right = Some(Rc::clone(&right_child));\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(Some(node));\n    }\n    while !queue.is_empty() {\n        if let Some(Some(node)) = queue.pop_front() {\n            result.push(Some(node.borrow().val));\n            queue.push_back(node.borrow().left.clone());\n            queue.push_back(node.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    fn helper(arr: &Vec<Option<i32>>, index: usize) -> Option<Rc<RefCell<TreeNode>>> {\n        if index < arr.len() {\n            if let Some(val) = arr[index] {\n                let node = Rc::new(RefCell::new(TreeNode::new(val)));\n                node.borrow_mut().left = helper(arr, 2 * index + 1);\n                node.borrow_mut().right = helper(arr, 2 * index + 2);\n                return Some(node);\n            }\n        }\n        None\n    }\n    helper(&arr, 0)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.borrow().val));\n            queue.push_back(n.borrow().left.clone());\n            queue.push_back(n.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeRightSideView(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,nil,5,nil,4]); result = BinaryTreeRightSideView(root); assert_equal [1,3,4], result",
        "root = buildTree([1,2,3,4,nil,nil,nil,5]); result = BinaryTreeRightSideView(root); assert_equal [1,3,4,5], result",
        "root = buildTree([1,nil,3]); result = BinaryTreeRightSideView(root); assert_equal [1,3], result",
        "root = buildTree([]); result = BinaryTreeRightSideView(root); assert_equal [], result"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3,null,5,null,4]"
        },
        "expected": "[1,3,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,2,3,4,null,null,null,5]"
        },
        "expected": "[1,3,4,5]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[1,null,3]"
        },
        "expected": "[1,3]"
      },
      {
        "caseNumber": 4,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "binary-tree-zigzag-level-order-traversal": {
    "title": "Binary Tree Zigzag Level Order Traversal",
    "content": "Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeZigzagLevelOrderTraversal(root) {}",
      "testCalls": [
        "let root1 = buildTree([3,9,20,null,null,15,7]); if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(root1)) !== '[[3],[20,9],[15,7]]') throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([1]); if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(root2)) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "let root3 = buildTree([]); if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(root3)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}",
      "builders": "function buildTree(arr) {\n  if (!arr.length) return null;\n  let root = new TreeNode(arr[0]);\n  let queue = [root];\n  let i = 1;\n  while (i < arr.length) {\n    let current = queue.shift();\n    if (arr[i] !== null) {\n      current.left = new TreeNode(arr[i]);\n      queue.push(current.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      current.right = new TreeNode(arr[i]);\n      queue.push(current.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  while (queue.length) {\n    let node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeZigzagLevelOrderTraversal(root: TreeNode | null): number[][]",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(createTreeNode([3,9,20,null,null,15,7]))) !== '[[3],[20,9],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(createTreeNode([1]))) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(null)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift(); if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> ZigzagLevelOrder(TreeNode* root)",
      "testCalls": [
        "assert(ZigzagLevelOrder(buildTree({3,9,20,INT_MIN,INT_MIN,15,7})) == vector<vector<int>>({{3},{20,9},{15,7}}));",
        "assert(ZigzagLevelOrder(buildTree({1})) == vector<vector<int>>({{1}}));",
        "assert(ZigzagLevelOrder(nullptr) == vector<vector<int>>({}));"
      ],
      "compareHelper": "bool compareVectors(vector<vector<int>>& v1, vector<vector<int>>& v2) { return v1 == v2; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeZigzagLevelOrderTraversal(root):",
      "testCalls": [
        "root = buildTree([3,9,20,None,None,15,7]); assert BinaryTreeZigzagLevelOrderTraversal(root) == [[3],[20,9],[15,7]], 'Test Case 1 Failed'",
        "root = buildTree([1]); assert BinaryTreeZigzagLevelOrderTraversal(root) == [[1]], 'Test Case 2 Failed'",
        "root = buildTree([]); assert BinaryTreeZigzagLevelOrderTraversal(root) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None): ...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> BinaryTreeZigzagLevelOrderTraversal(TreeNode root) {}",
      "testCalls": [
        "TreeNode root1 = buildTree(new Integer[]{3,9,20,null,null,15,7}); List<List<Integer>> result1 = BinaryTreeZigzagLevelOrderTraversal(root1); if (!Arrays.deepEquals(result1.toArray(), new Integer[][]{{3}, {20, 9}, {15, 7}})) throw new AssertionError();",
        "TreeNode root2 = buildTree(new Integer[]{1}); List<List<Integer>> result2 = BinaryTreeZigzagLevelOrderTraversal(root2); if (!Arrays.deepEquals(result2.toArray(), new Integer[][]{{1}})) throw new AssertionError();",
        "TreeNode root3 = buildTree(new Integer[]{}); List<List<Integer>> result3 = BinaryTreeZigzagLevelOrderTraversal(root3); if (!Arrays.deepEquals(result3.toArray(), new Integer[][]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, List<List<Integer>> arr2) {\n    return Arrays.deepEquals(arr1.toArray(), arr2.toArray());\n}",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "void BinaryTreeZigzagLevelOrderTraversal(struct TreeNode* root)",
      "testCalls": [
        "BinaryTreeZigzagLevelOrderTraversal(createTreeFromArray((int[]) {3,9,20,INT_MIN,INT_MIN,15,7}, 7)); // Compare result with expected for test case 1",
        "BinaryTreeZigzagLevelOrderTraversal(createTreeFromArray((int[]) {1}, 1)); // Compare result with expected for test case 2",
        "BinaryTreeZigzagLevelOrderTraversal(createTreeFromArray((int[]) {}, 0)); // Compare result with expected for test case 3"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func ZigzagLevelOrderTraversal(root *TreeNode) [][]int {}",
      "testCalls": [
        "let root = BuildTree([]int{3, 9, 20, null, null, 15, 7}); ZigzagLevelOrderTraversal(root)",
        "let root = BuildTree([]int{1}); ZigzagLevelOrderTraversal(root)",
        "let root = BuildTree([]int{}); ZigzagLevelOrderTraversal(root)"
      ],
      "compareHelper": "func compareTwoDimIntArray(arr1, arr2 [][]int) bool {}\nfunc createTreeNodeFromString(str string) *TreeNode {}\nfunc createTwoDimIntArrayFromString(str string) [][]int {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc BuildTree(arr []int) *TreeNode {}\nfunc TreeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func BuildTree(arr []int) *TreeNode {}\nfunc TreeToArray(root *TreeNode) []int {}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeZigzagLevelOrderTraversal(root)\nend",
      "testCalls": [
        "root = buildTree([3,9,20,nil,nil,15,7]); result = BinaryTreeZigzagLevelOrderTraversal(root); raise 'Test Case 1 Failed' unless result == [[3],[20,9],[15,7]]",
        "root = buildTree([1]); result = BinaryTreeZigzagLevelOrderTraversal(root); raise 'Test Case 2 Failed' unless result == [[1]]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "[[3],[20,9],[15,7]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1]"
        },
        "expected": "[[1]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "bitwise-and-of-numbers-range": {
    "title": "Bitwise AND of Numbers Range",
    "content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n\n\nConstraints:\n\n0 <= left <= right <= 231 - 1\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BitwiseAndOfNumbersRange(left, right) {}",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(BitwiseAndOfNumbersRange(0, 0) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BitwiseAndOfNumbersRange(left: number, right: number): number {}",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(BitwiseAndOfNumbersRange(0, 0) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int BitwiseAndOfNumbersRange(int left, int right);",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) != 4) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(0, 0) != 0) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BitwiseAndOfNumbersRange(left: int, right: int) -> int:",
      "testCalls": [
        "assert BitwiseAndOfNumbersRange(5, 7) == 4, 'Test Case 1 Failed'",
        "assert BitwiseAndOfNumbersRange(0, 0) == 0, 'Test Case 2 Failed'",
        "assert BitwiseAndOfNumbersRange(1, 2147483647) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BitwiseAndOfNumbersRange(int left, int right) { }",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) != 4) throw new AssertionError();",
        "if(BitwiseAndOfNumbersRange(0, 0) != 0) throw new AssertionError();",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BitwiseAndOfNumbersRange(int left, int right);",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(0, 0) != 0) { printf(\"Test Case 2 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BitwiseAndOfNumbersRange(left int, right int) int {}",
      "testCalls": [
        "if result := BitwiseAndOfNumbersRange(5, 7); result != 4 { t.Errorf(\"Test 1 failed, expected: %v, got: %v\", 4, result) }",
        "if result := BitwiseAndOfNumbersRange(0, 0); result != 0 { t.Errorf(\"Test 2 failed, expected: %v, got: %v\", 0, result) }",
        "if result := BitwiseAndOfNumbersRange(1, 2147483647); result != 0 { t.Errorf(\"Test 3 failed, expected: %v, got: %v\", 0, result) }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BitwiseAndOfNumbersRange(left: i32, right: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(BitwiseAndOfNumbersRange(5, 7), 4);",
        "assert_eq!(BitwiseAndOfNumbersRange(0, 0), 0);",
        "assert_eq!(BitwiseAndOfNumbersRange(1, 2147483647), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BitwiseAndOfNumbersRange(left, right)\nend",
      "testCalls": [
        "result = BitwiseAndOfNumbersRange(5, 7)\nraise 'Test Case 1 Failed' unless result == 4",
        "result = BitwiseAndOfNumbersRange(0, 0)\nraise 'Test Case 2 Failed' unless result == 0",
        "result = BitwiseAndOfNumbersRange(1, 2147483647)\nraise 'Test Case 3 Failed' unless result == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "left": "5",
          "right": "7"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "left": "0",
          "right": "0"
        },
        "expected": "0"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "left": "1",
          "right": "2147483647"
        },
        "expected": "0"
      }
    ]
  },
  "candy": {
    "title": "Candy",
    "content": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n\nConstraints:\n\nn == ratings.length\n1 <= n <= 2 * 104\n0 <= ratings[i] <= 2 * 104\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Candy(ratings) {}",
      "testCalls": [
        "let ratings1 = [1,0,2]; let head1 = buildLinkedList(ratings1); if (Candy(head1) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "let ratings2 = [1,2,2]; let head2 = buildLinkedList(ratings2); if (Candy(head2) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function buildLinkedList(arr) { if (!arr.length) return null; let head = { val: arr[0], next: null }; let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = { val: arr[i], next: null }; curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "",
      "builders": "function ListNode(val, next = null) {\n  this.val = val;\n  this.next = next;\n}\n\nfunction buildLinkedList(arr) {\n  if (!arr.length) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head) {\n  let arr = [];\n  let current = head;\n  while (current) {\n    arr.push(current.val);\n    current = current.next;\n  }\n  return arr;\n}"
    },
    "typescript": {
      "functionDeclaration": "function Candy(ratings: number[]): number {}",
      "testCalls": [
        "let ratings1 = [1,0,2]; let head1 = buildLinkedList(ratings1); if (Candy(head1) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "let ratings2 = [1,2,2]; let head2 = buildLinkedList(ratings2); if (Candy(head2) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "",
      "builders": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val: number, next: ListNode | null = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "int Candy(vector<int>& ratings);",
      "testCalls": [
        "ListNode* head1 = buildLinkedList({1,0,2}); if (Candy(head1) != 5) throw std::runtime_error(\"Test 1 failed!\");",
        "ListNode* head2 = buildLinkedList({1,2,2}); if (Candy(head2) != 4) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": "",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; \nListNode* buildLinkedList(vector<int>& arr) { ListNode* head = new ListNode(0); ListNode* curr = head; for (int num : arr) { curr->next = new ListNode(num); curr = curr->next; } return head->next; } \nvector<int> linkedListToArray(ListNode* head) { vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(vector<int>& arr) { ListNode* head = new ListNode(0); ListNode* curr = head; for (int num : arr) { curr->next = new ListNode(num); curr = curr->next; } return head->next; } \nvector<int> linkedListToArray(ListNode* head) { vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def Candy(ratings: List[int]) -> int",
      "testCalls": [
        "assert Candy([1,0,2]) == 5",
        "assert Candy([1,2,2]) == 4"
      ],
      "compareHelper": "",
      "helpers": "from typing import List",
      "typeDefs": "",
      "builders": "from typing import List"
    },
    "java": {
      "functionDeclaration": "public int Candy(int[] ratings) {}",
      "testCalls": [
        "ListNode head1 = buildLinkedList(new int[]{1,0,2}); assert Candy(head1) == 5;",
        "ListNode head2 = buildLinkedList(new int[]{1,2,2}); assert Candy(head2) == 4;"
      ],
      "compareHelper": "",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\nListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "int Candy(int* ratings, int ratingsSize)",
      "testCalls": [
        "ListNode* ratings1 = buildLinkedList((int[]) {1,0,2}, 3); if (Candy(ratings1, 3) != 5) { printf(\"Test Case 1 Failed\"); }",
        "ListNode* ratings2 = buildLinkedList((int[]) {1,2,2}, 3); if (Candy(ratings2, 3) != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "helpers": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;\nListNode* buildLinkedList(int* arr, int size) { ListNode* head = NULL; ListNode* curr = NULL; for (int i = 0; i < size; i++) { ListNode* newNode = (ListNode*)malloc(sizeof(ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(ListNode* head, int* size) { int count = 0; ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* buildLinkedList(int* arr, int size) { ListNode* head = NULL; ListNode* curr = NULL; for (int i = 0; i < size; i++) { ListNode* newNode = (ListNode*)malloc(sizeof(ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(ListNode* head, int* size) { int count = 0; ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func Candy(ratings []int) int {}",
      "testCalls": [
        "if Candy(buildLinkedList([]int{1,0,2})) != 5 {panic(\"Test case 1 failed\")}",
        "if Candy(buildLinkedList([]int{1,2,2})) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn Candy(ratings: Vec<i32>) -> i32 {}",
      "testCalls": [
        "let children = buildCandyChildren(vec![1, 0, 2]); assert_eq!(Candy(buildCandyVec(children)), 5);",
        "let children = buildCandyChildren(vec![1, 2, 2]); assert_eq!(Candy(buildCandyVec(children)), 4);"
      ],
      "compareHelper": "",
      "helpers": "struct CandyChild { rating: i32, candy: i32 }\nfn buildCandyChildren(ratings: Vec<i32>) -> Vec<CandyChild> {}\nfn buildCandyVec(candy_children: Vec<CandyChild>) -> Vec<i32> {}",
      "typeDefs": "struct CandyChild { rating: i32, candy: i32 }",
      "builders": "fn buildCandyChildren(ratings: Vec<i32>) -> Vec<CandyChild> {}\nfn buildCandyVec(candy_children: Vec<CandyChild>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def Candy(ratings)\nend",
      "testCalls": [
        "head = buildLinkedList([1,0,2])\nresult = Candy(head)\nputs(result == 5 ? 'Test case 1 passed' : 'Test case 1 failed')",
        "head = buildLinkedList([1,2,2])\nresult = Candy(head)\nputs(result == 4 ? 'Test case 2 passed' : 'Test case 2 failed')"
      ],
      "compareHelper": "",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "ratings": "[1,0,2]"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "ratings": "[1,2,2]"
        },
        "expected": "4"
      }
    ]
  },
  "climbing-stairs": {
    "title": "Climbing Stairs",
    "content": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\nConstraints:\n\n1 <= n <= 45\n\n",
    "difficulty": "Easy",
    "hints": [
      "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
    ],
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ClimbingStairs(n) {}",
      "testCalls": [
        "if (ClimbingStairs(2) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (ClimbingStairs(3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ClimbingStairs(n: number): number {}",
      "testCalls": [
        "if (ClimbingStairs(2) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (ClimbingStairs(3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int ClimbStairs(int n);",
      "testCalls": [
        "if (ClimbStairs(2) != 2) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if (ClimbStairs(3) != 3) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ClimbingStairs(n: int) -> int:",
      "testCalls": [
        "assert ClimbingStairs(2) == 2",
        "assert ClimbingStairs(3) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int ClimbingStairs(int n) { }",
      "testCalls": [
        "if(ClimbingStairs(2) != 2) throw new AssertionError();",
        "if(ClimbingStairs(3) != 3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int ClimbingStairs(int n);",
      "testCalls": [
        "if (ClimbingStairs(2) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if (ClimbingStairs(3) != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ClimbStairs(n int) int {}",
      "testCalls": [
        "if ClimbStairs(2) != 2 { t.Errorf(\"Test case 1 failed\") }",
        "if ClimbStairs(3) != 3 { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ClimbingStairs(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(ClimbingStairs(2), 2);",
        "assert_eq!(ClimbingStairs(3), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ClimbingStairs(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ClimbingStairs(2) == 2",
        "raise 'Test Case 2 Failed' unless ClimbingStairs(3) == 3"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "2"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "3"
        },
        "expected": "3"
      }
    ]
  },
  "clone-graph": {
    "title": "Clone Graph",
    "content": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\nTest case format:\nFor simplicity, each node value is the same as the node index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\nExample 1:\n\n\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1) neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2) neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3) neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4) neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\nExample 2:\n\n\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\nExample 3:\n\nInput: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.\n\n\nConstraints:\n\nThe number of nodes in the graph is in the range [0, 100].\n1 <= Node.val <= 100\nNode.val is unique for each node.\nThere are no repeated edges and no self-loops in the graph.\nThe Graph is connected and all nodes can be visited starting from the given node.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CloneGraph(adjList) {}",
      "testCalls": [
        "const test1 = buildGraph([[2,4],[1,3],[2,4],[1,3]]); if(JSON.stringify(graphToArray(CloneGraph(test1))) !== '[[1,[2,4]],[2,[1,3]],[3,[2,4]],[4,[1,3]]]') throw new Error('Test Case 1 Failed');",
        "const test2 = buildGraph([[]]); if(JSON.stringify(graphToArray(CloneGraph(test2))) !== '[[1,[]]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "class Node { constructor(val, neighbors) { this.val = val === undefined ? 0 : val; this.neighbors = neighbors === undefined ? [] : neighbors; } }\nfunction buildGraph(adjList) { let nodes = new Map(); for (let i = 0; i < adjList.length; i++) { nodes.set(i + 1, new Node(i + 1)); } for (let i = 0; i < adjList.length; i++) { let neighbors = adjList[i]; let currNode = nodes.get(i + 1); for (let neighbor of neighbors) { currNode.neighbors.push(nodes.get(neighbor)); } } return nodes.get(1); }\nfunction graphToArray(node) { let visited = new Set(); let result = []; function dfs(curr) { if (!curr || visited.has(curr.val)) return; visited.add(curr.val); result.push([curr.val, curr.neighbors.map(neighbor => neighbor.val)]); for (let neighbor of curr.neighbors) { dfs(neighbor); } } dfs(node); return result; }",
      "typeDefs": "class Node {\n  constructor(val, neighbors = []) {\n    this.val = val;\n    this.neighbors = neighbors;\n  }\n}",
      "builders": "function buildGraph(adjList) {\n  if (!adjList.length) return null;\n  const nodes = adjList.map((_, i) => new Node(i + 1));\n  adjList.forEach((neighbors, i) => {\n    nodes[i].neighbors = neighbors.map(j => nodes[j - 1]);\n  });\n  return nodes[0];\n}\n\nfunction graphToArray(node) {\n  if (!node) return [];\n  const visited = new Map();\n  const result = [];\n  const queue = [node];\n  visited.set(node, 0);\n  while (queue.length) {\n    const current = queue.shift();\n    const index = visited.get(current);\n    result[index] = current.neighbors.map(neighbor => {\n      if (!visited.has(neighbor)) {\n        visited.set(neighbor, visited.size);\n        queue.push(neighbor);\n      }\n      return visited.get(neighbor) + 1;\n    });\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function CloneGraph(node: Node | null): Node | null",
      "testCalls": [
        "const testInput1 = [[2,4],[1,3],[2,4],[1,3]]; const graph1 = buildGraph(testInput1); const result1 = CloneGraph(graph1); if(JSON.stringify(graphToAdjList(result1)) !== '[[2,4],[1,3],[2,4],[1,3]]') throw new Error('Test Case 1 Failed');",
        "const testInput2 = [[]]; const graph2 = buildGraph(testInput2); const result2 = CloneGraph(graph2); if(JSON.stringify(graphToAdjList(result2)) !== '[[]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "class Node { val: number; neighbors: Node[]; constructor(val?: number, neighbors?: Node[]) { this.val = val === undefined ? 0 : val; this.neighbors = neighbors === undefined ? [] : neighbors; } }\nfunction buildGraph(adjList: number[][]): Node | null { if (!adjList.length) return null; const nodes = new Map<number, Node>(); for (let i = 0; i < adjList.length; i++) { nodes.set(i + 1, new Node(i + 1)); } for (let i = 0; i < adjList.length; i++) { const currNode = nodes.get(i + 1)!; for (const neighborIdx of adjList[i]) { currNode.neighbors.push(nodes.get(neighborIdx)!); } } return nodes.get(1)!; }\nfunction graphToAdjList(node: Node | null): number[][] { if (!node) return []; const adjList: number[][] = []; const visited = new Set<number>(); const queue: Node[] = [node]; while (queue.length) { const currNode = queue.shift()!; if (visited.has(currNode.val)) continue; visited.add(currNode.val); const neighborsIdx = currNode.neighbors.map(neighbor => neighbor.val); adjList.push(neighborsIdx); for (const neighbor of currNode.neighbors) { queue.push(neighbor); } } return adjList; }",
      "typeDefs": "class Node { val: number; neighbors: Node[]; ...",
      "builders": "class Node {\n  val: number;\n  neighbors: Node[];\n  constructor(val?: number, neighbors?: Node[]) {\n    this.val = val === undefined ? 0 : val;\n    this.neighbors = neighbors === undefined ? [] : neighbors;\n  }\n}\n\nfunction buildGraph(adjList: number[][]): Node | null {\n  if (adjList.length === 0) return null;\n  const nodes: Node[] = adjList.map((_, i) => new Node(i + 1));\n  for (let i = 0; i < adjList.length; i++) {\n    nodes[i].neighbors = adjList[i].map(j => nodes[j - 1]);\n  }\n  return nodes[0];\n}\n\nfunction graphToAdjList(node: Node | null): number[][] {\n  if (!node) return [];\n  const adjList: number[][] = [];\n  const visited = new Map<Node, number>();\n  const queue: Node[] = [node];\n  visited.set(node, 0);\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    const index = visited.get(current)!;\n    adjList[index] = current.neighbors.map(neighbor => {\n      if (!visited.has(neighbor)) {\n        visited.set(neighbor, visited.size);\n        queue.push(neighbor);\n      }\n      return visited.get(neighbor)! + 1;\n    });\n  }\n  return adjList;\n}"
    },
    "cpp": {
      "functionDeclaration": "Node* CloneGraph(Node* node)",
      "testCalls": [
        "assert(compareGraph(CloneGraph(buildGraph({{2,4},{1,3},{2,4},{1,3}})), buildGraph({{2,4},{1,3},{2,4},{1,3}}));",
        "assert(compareGraph(CloneGraph(buildGraph({{}})), buildGraph({{}}));",
        "assert(compareGraph(CloneGraph(buildGraph({})), buildGraph({}));"
      ],
      "compareHelper": "bool compareGraph(Node* node1, Node* node2) { return graphToArray(node1) == graphToArray(node2); }",
      "helpers": "class Node { public: int val; vector<Node*> neighbors; }; \nNode* buildGraph(vector<vector<int>>& adjList) { unordered_map<int, Node*> nodes; for (const auto& edge : adjList) { int val = edge[0]; if (!nodes.count(val)) nodes[val] = new Node{val, {}}; for (int i = 1; i < edge.size(); ++i) { int neighborVal = edge[i]; if (!nodes.count(neighborVal)) nodes[neighborVal] = new Node{neighborVal, {}}; nodes[val]->neighbors.push_back(nodes[neighborVal]); } } return nodes.empty() ? nullptr : nodes.begin()->second; }\nvector<vector<int>> graphToArray(Node* node) { vector<vector<int>> result; unordered_set<Node*> visited; queue<Node*> q; q.push(node); while (!q.empty()) { Node* curr = q.front(); q.pop(); if (visited.count(curr)) continue; visited.insert(curr); vector<int> neighbors; for (Node* neighbor : curr->neighbors) { neighbors.push_back(neighbor->val); q.push(neighbor); } result.push_back({curr->val, neighbors}); } return result; }",
      "typeDefs": "class Node { public: int val; vector<Node*> neighbors; };",
      "builders": "Node* buildGraph(vector<vector<int>>& adjList) { unordered_map<int, Node*> nodes; for (const auto& edge : adjList) { int val = edge[0]; if (!nodes.count(val)) nodes[val] = new Node{val, {}}; for (int i = 1; i < edge.size(); ++i) { int neighborVal = edge[i]; if (!nodes.count(neighborVal)) nodes[neighborVal] = new Node{neighborVal, {}}; nodes[val]->neighbors.push_back(nodes[neighborVal]); } } return nodes.empty() ? nullptr : nodes.begin()->second; }\nvector<vector<int>> graphToArray(Node* node) { vector<vector<int>> result; unordered_set<Node*> visited; queue<Node*> q; q.push(node); while (!q.empty()) { Node* curr = q.front(); q.pop(); if (visited.count(curr)) continue; visited.insert(curr); vector<int> neighbors; for (Node* neighbor : curr->neighbors) { neighbors.push_back(neighbor->val); q.push(neighbor); } result.push_back({curr->val, neighbors}); } return result; }"
    },
    "python": {
      "functionDeclaration": "def CloneGraph(adjList: List[List[int]]) -> List[List[int]]:",
      "testCalls": [
        "graph = buildGraph([[2,4],[1,3],[2,4],[1,3]])\nresult1 = graphToAdjList(CloneGraph(graph))\nif result1 != [[2,4],[1,3],[2,4],[1,3]]:\n    raise AssertionError('Test Case 1 Failed')",
        "graph = buildGraph([[]])\nresult2 = graphToAdjList(CloneGraph(graph))\nif result2 != [[]]:\n    raise AssertionError('Test Case 2 Failed')"
      ],
      "compareHelper": "",
      "helpers": "class Node:\n    def __init__(self, val = 0, neighbors = []):\n        self.val = val\n        self.neighbors = neighbors\n\ndef buildGraph(adjList):\n    nodes = {}\n    for i in range(len(adjList)):\n        nodes[i+1] = Node(i+1)\n    for i in range(len(adjList)):\n        for neighbor in adjList[i]:\n            nodes[i+1].neighbors.append(nodes[neighbor])\n    return nodes[1] if nodes else None\n\ndef graphToAdjList(node):\n    adjList = []\n    if not node:\n        return adjList\n    visited = set()\n    queue = [node]\n    while queue:\n        curr = queue.pop(0)\n        if curr.val not in visited:\n            visited.add(curr.val)\n            neighbors = [neighbor.val for neighbor in curr.neighbors]\n            adjList.append(neighbors)\n            for neighbor in curr.neighbors:\n                queue.append(neighbor)\n    return adjList",
      "typeDefs": "class Node:\n    def __init__(self, val = 0, neighbors = []):\n        self.val = val\n        self.neighbors = neighbors",
      "builders": "def buildGraph(adjList):\n    nodes = {}\n    for i in range(len(adjList)):\n        nodes[i+1] = Node(i+1)\n    for i in range(len(adjList)):\n        for neighbor in adjList[i]:\n            nodes[i+1].neighbors.append(nodes[neighbor])\n    return nodes[1] if nodes else None\n\ndef graphToAdjList(node):\n    adjList = []\n    if not node:\n        return adjList\n    visited = set()\n    queue = [node]\n    while queue:\n        curr = queue.pop(0)\n        if curr.val not in visited:\n            visited.add(curr.val)\n            neighbors = [neighbor.val for neighbor in curr.neighbors]\n            adjList.append(neighbors)\n            for neighbor in curr.neighbors:\n                queue.append(neighbor)\n    return adjList"
    },
    "java": {
      "functionDeclaration": "public Node cloneGraph(Node node)",
      "testCalls": [
        "Node test1 = cloneGraph(buildGraph(new int[][]{{2,4},{1,3},{2,4},{1,3}}));\nif (!compareGraph(test1, buildGraph(new int[][]{{2,4},{1,3},{2,4},{1,3}}))) throw new AssertionError();",
        "Node test2 = cloneGraph(buildGraph(new int[][]{{}}));\nif (!compareGraph(test2, buildGraph(new int[][]{{}}))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareGraph(Node node1, Node node2) {\n    // Implement comparison logic here\n}",
      "helpers": "class Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\npublic Node buildGraph(int[][] edges) { return null; }\n\npublic boolean compareGraph(Node node1, Node node2) { return false; }",
      "typeDefs": "class Node {\n    public int val;\n    public List<Node> neighbors;\n}",
      "builders": "public Node buildGraph(int[][] edges) { return null; }\n\npublic boolean compareGraph(Node node1, Node node2) { return false; }"
    },
    "c": {
      "functionDeclaration": "Node* CloneGraph(Node* node)",
      "testCalls": [
        "int adjacencyList1_1[] = {2}; int adjacencyList1_2[] = {1}; int* adjacencyList1[] = {adjacencyList1_1, adjacencyList1_2}; int adjacencyListSize1 = 2; int adjacencyListColSize1[] = {1, 1}; Node* node1 = buildGraph(2, adjacencyList1, adjacencyListSize1, adjacencyListColSize1); Node* test1 = CloneGraph(node1); int returnSize1; int* returnColumnSizes1; int** result1 = graphToArray(test1, &returnSize1, &returnColumnSizes1); if (returnSize1 != 1 || result1[0][0] != 2) { printf(\"Test Case 1 Failed\"); }",
        "int adjacencyList2_1[] = {2, 4}; int adjacencyList2_2[] = {1, 3}; int adjacencyList2_3[] = {2, 4}; int adjacencyList2_4[] = {1, 3}; int* adjacencyList2[] = {adjacencyList2_1, adjacencyList2_2, adjacencyList2_3, adjacencyList2_4}; int adjacencyListSize2 = 4; int adjacencyListColSize2[] = {2, 2, 2, 2}; Node* node2 = buildGraph(4, adjacencyList2, adjacencyListSize2, adjacencyListColSize2); Node* test2 = CloneGraph(node2); int returnSize2; int* returnColumnSizes2; int** result2 = graphToArray(test2, &returnSize2, &returnColumnSizes2); if (returnSize2 != 2 || (result2[0][0] != 2 && result2[1][0] != 4)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareGraph(Node* graph1, Node* graph2) { // Comparison logic here }",
      "helpers": "typedef struct Node { int val; struct Node** neighbors; int neighborsSize; } Node;\nNode* createNode(int val, int neighborsSize) { Node* newNode = (Node*)malloc(sizeof(Node)); newNode->val = val; newNode->neighbors = (Node**)malloc(neighborsSize * sizeof(Node*)); newNode->neighborsSize = neighborsSize; return newNode; }\nNode* buildGraph(int numNodes, int** adjacencyList, int adjacencyListSize, int* adjacencyListColSize) { Node** nodes = (Node**)malloc(numNodes * sizeof(Node*)); for (int i = 0; i < numNodes; i++) { nodes[i] = createNode(i+1, adjacencyListColSize[i]); } for (int i = 0; i < numNodes; i++) { for (int j = 0; j < adjacencyListColSize[i]; j++) { nodes[i]->neighbors[j] = nodes[adjacencyList[i][j]-1]; } } return nodes[0]; }\nint** graphToArray(Node* node, int* returnSize, int** returnColumnSizes) { *returnSize = node->neighborsSize; *returnColumnSizes = (int*)malloc(node->neighborsSize * sizeof(int)); int** result = (int**)malloc(node->neighborsSize * sizeof(int*)); for (int i = 0; i < node->neighborsSize; i++) { (*returnColumnSizes)[i] = 1; result[i] = (int*)malloc(sizeof(int)); result[i][0] = node->neighbors[i]->val; } return result; }",
      "typeDefs": "typedef struct Node { int val; struct Node** neighbors; int neighborsSize; } Node;",
      "builders": "Node* createNode(int val, int neighborsSize) { Node* newNode = (Node*)malloc(sizeof(Node)); newNode->val = val; newNode->neighbors = (Node**)malloc(neighborsSize * sizeof(Node*)); newNode->neighborsSize = neighborsSize; return newNode; }\nNode* buildGraph(int numNodes, int** adjacencyList, int adjacencyListSize, int* adjacencyListColSize) { Node** nodes = (Node**)malloc(numNodes * sizeof(Node*)); for (int i = 0; i < numNodes; i++) { nodes[i] = createNode(i+1, adjacencyListColSize[i]); } for (int i = 0; i < numNodes; i++) { for (int j = 0; j < adjacencyListColSize[i]; j++) { nodes[i]->neighbors[j] = nodes[adjacencyList[i][j]-1]; } } return nodes[0]; }\nint** graphToArray(Node* node, int* returnSize, int** returnColumnSizes) { *returnSize = node->neighborsSize; *returnColumnSizes = (int*)malloc(node->neighborsSize * sizeof(int)); int** result = (int**)malloc(node->neighborsSize * sizeof(int*)); for (int i = 0; i < node->neighborsSize; i++) { (*returnColumnSizes)[i] = 1; result[i] = (int*)malloc(sizeof(int)); result[i][0] = node->neighbors[i]->val; } return result; }"
    },
    "go": {
      "functionDeclaration": "func CloneGraph(node *Node) *Node",
      "testCalls": [
        "if result := CloneGraph(buildGraph([[2,4],[1,3],[2,4],[1,3]])); !reflect.DeepEqual(result, buildGraph([[2,4],[1,3],[2,4],[1,3]])) { t.Errorf(\"Test Case 1 Failed\") }",
        "if result := CloneGraph(buildGraph([[]])); !reflect.DeepEqual(result, buildGraph([[]])) { t.Errorf(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func buildGraph(adjList [][]int) *Node {\n    // Build the graph from the adjacency list\n}",
      "helpers": "type Node struct {\n    Val       int\n    Neighbors []*Node\n}\n\nfunc buildGraph(adjList [][]int) *Node {\n    if len(adjList) == 0 {\n        return nil\n    }\n\n    nodes := make(map[int]*Node)\n\n    for i := range adjList {\n        val := i + 1\n        if _, ok := nodes[val]; !ok {\n            nodes[val] = &Node{Val: val}\n        }\n\n        for _, neighborVal := range adjList[i] {\n            if _, ok := nodes[neighborVal]; !ok {\n                nodes[neighborVal] = &Node{Val: neighborVal}\n            }\n            nodes[val].Neighbors = append(nodes[val].Neighbors, nodes[neighborVal])\n        }\n    }\n\n    return nodes[1]\n}\n",
      "typeDefs": "type Node struct {\n    Val       int\n    Neighbors []*Node\n}",
      "builders": "func buildGraph(adjList [][]int) *Node {\n    if len(adjList) == 0 {\n        return nil\n    }\n\n    nodes := make(map[int]*Node)\n\n    for i := range adjList {\n        val := i + 1\n        if _, ok := nodes[val]; !ok {\n            nodes[val] = &Node{Val: val}\n        }\n\n        for _, neighborVal := range adjList[i] {\n            if _, ok := nodes[neighborVal]; !ok {\n                nodes[neighborVal] = &Node{Val: neighborVal}\n            }\n            nodes[val].Neighbors = append(nodes[val].Neighbors, nodes[neighborVal])\n        }\n    }\n\n    return nodes[1]\n}\n"
    },
    "rust": {
      "functionDeclaration": "fn CloneGraph(adj_list: Vec<Vec<i32>>) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let test_case_1 = buildGraph(vec![vec![2, 4], vec![1, 3], vec![2, 4], vec![1, 3]]); assert_eq!(graphToAdjList(CloneGraph(test_case_1)), vec![vec![2, 4], vec![1, 3], vec![2, 4], vec![1, 3]]);",
        "let test_case_2 = buildGraph(vec![vec![]]); assert_eq!(graphToAdjList(CloneGraph(test_case_2)), vec![vec![]]);",
        "let test_case_3 = buildGraph(vec![]); assert_eq!(graphToAdjList(CloneGraph(test_case_3)), vec![]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: &Vec<Vec<i32>>, arr2: &Vec<Vec<i32>>) { assert_eq!(arr1, arr2); }",
      "helpers": "struct Node { val: i32, neighbors: Vec<Node> }\nfn buildGraph(adj_list: Vec<Vec<i32>>) -> Vec<Node> { let mut nodes = vec![]; for _ in 0..adj_list.len() { nodes.push(Node { val: 0, neighbors: vec![] }); } for (i, neighbors) in adj_list.iter().enumerate() { nodes[i].val = (i + 1) as i32; for &neighbor in neighbors { nodes[i].neighbors.push(nodes[(neighbor - 1) as usize].clone()); } } nodes }\nfn graphToAdjList(nodes: Vec<Node>) -> Vec<Vec<i32>> { let mut adj_list = vec![]; for node in nodes { let mut neighbors = vec![]; for neighbor in node.neighbors { neighbors.push(neighbor.val); } adj_list.push(neighbors); } adj_list }",
      "typeDefs": "struct Node { val: i32, neighbors: Vec<Node> }",
      "builders": "fn buildGraph(adj_list: Vec<Vec<i32>>) -> Vec<Node> { let mut nodes = vec![]; for _ in 0..adj_list.len() { nodes.push(Node { val: 0, neighbors: vec![] }); } for (i, neighbors) in adj_list.iter().enumerate() { nodes[i].val = (i + 1) as i32; for &neighbor in neighbors { nodes[i].neighbors.push(nodes[(neighbor - 1) as usize].clone()); } } nodes }\nfn graphToAdjList(nodes: Vec<Node>) -> Vec<Vec<i32>> { let mut adj_list = vec![]; for node in nodes { let mut neighbors = vec![]; for neighbor in node.neighbors { neighbors.push(neighbor.val); } adj_list.push(neighbors); } adj_list }"
    },
    "ruby": {
      "functionDeclaration": "def CloneGraph(node)",
      "testCalls": [
        "node1 = Node.new(1); node2 = Node.new(2); node3 = Node.new(3); node4 = Node.new(4); node1.neighbors = [node2, node4]; node2.neighbors = [node1, node3]; node3.neighbors = [node2, node4]; node4.neighbors = [node1, node3]; result1 = CloneGraph(node1); raise 'Test Case 1 Failed' unless result1.neighbors[0].val == 2 && result1.neighbors[1].val == 4",
        "node1 = Node.new(1); result2 = CloneGraph(node1); raise 'Test Case 2 Failed' unless result2.neighbors.empty?",
        "node = nil; result3 = CloneGraph(node); raise 'Test Case 3 Failed' unless result3.nil?"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class Node\n  attr_accessor :val, :neighbors\n  def initialize(val = 0, neighbors = [])\n    @val = val\n    @neighbors = neighbors\n  end\nend\n\ndef buildGraph(nodes)\n  return nil if nodes.empty?\n  node_map = {}\n  nodes.each { |val, neighbors| node_map[val] = Node.new(val) }\n  nodes.each do |val, neighbors|\n    node = node_map[val]\n    neighbors.each { |neighbor_val| node.neighbors << node_map[neighbor_val] }\n  end\n  node_map[nodes[0][0]]\nend\n\ndef graphToNodes(node)\n  return [] if node.nil?\n  visited = Set.new\n  result = []\n  queue = [node]\n  while !queue.empty?\n    current = queue.shift\n    next if visited.include?(current)\n    visited.add(current)\n    neighbors = current.neighbors.map { |neighbor| neighbor.val }\n    result << [current.val, neighbors]\n    queue.concat(current.neighbors)\n  end\n  result\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :neighbors\n  def initialize(val = 0, neighbors = [])\n    @val = val\n    @neighbors = neighbors\n  end\nend",
      "builders": "def buildGraph(nodes)\n  return nil if nodes.empty?\n  node_map = {}\n  nodes.each { |val, neighbors| node_map[val] = Node.new(val) }\n  nodes.each do |val, neighbors|\n    node = node_map[val]\n    neighbors.each { |neighbor_val| node.neighbors << node_map[neighbor_val] }\n  end\n  node_map[nodes[0][0]]\nend\n\ndef graphToNodes(node)\n  return [] if node.nil?\n  visited = Set.new\n  result = []\n  queue = [node]\n  while !queue.empty?\n    current = queue.shift\n    next if visited.include?(current)\n    visited.add(current)\n    neighbors = current.neighbors.map { |neighbor| neighbor.val }\n    result << [current.val, neighbors]\n    queue.concat(current.neighbors)\n  end\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "adjList": "[[2,4],[1,3],[2,4],[1,3]]"
        },
        "expected": "[[2,4],[1,3],[2,4],[1,3]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "adjList": "[[]]"
        },
        "expected": "[[]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "adjList": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "coin-change": {
    "title": "Coin Change",
    "content": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\n\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\n\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0\n\n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CoinChange(coins, amount) {}",
      "testCalls": [
        "if(CoinChange([1,2,5], 11) !== 3) throw new Error('Test Case 1 Failed');",
        "if(CoinChange([2], 3) !== -1) throw new Error('Test Case 2 Failed');",
        "if(CoinChange([1], 0) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function CoinChange(coins: number[], amount: number): number {}",
      "testCalls": [
        "if (CoinChange([1,2,5], 11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (CoinChange([2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }",
        "if (CoinChange([1], 0) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int CoinChange(vector<int>& coins, int amount);",
      "testCalls": [
        "assert(CoinChange({1,2,5}, 11) == 3);",
        "assert(CoinChange({2}, 3) == -1);",
        "assert(CoinChange({1}, 0) == 0);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def CoinChange(coins: List[int], amount: int) -> int:",
      "testCalls": [
        "assert CoinChange([1,2,5], 11) == 3, 'Test Case 1 Failed'",
        "assert CoinChange([2], 3) == -1, 'Test Case 2 Failed'",
        "assert CoinChange([1], 0) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int coinChange(int[] coins, int amount) {}",
      "testCalls": [
        "assert coinChange(new int[]{1,2,5}, 11) == 3 : \"Test Case 1 Failed\";",
        "assert coinChange(new int[]{2}, 3) == -1 : \"Test Case 2 Failed\";",
        "assert coinChange(new int[]{1}, 0) == 0 : \"Test Case 3 Failed\";"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int CoinChange(int* coins, int coinsSize, int amount)",
      "testCalls": [
        "if (CoinChange((int[]) {1, 2, 5}, 3, 11) != 3) { printf(\"Test case 1 failed\"); }",
        "if (CoinChange((int[]) {2}, 1, 3) != -1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func CoinChange(coins []int, amount int) int {}",
      "testCalls": [
        "if CoinChange([]int{1,2,5}, 11) != 3 { panic(\"Test case 1 failed\") }",
        "if CoinChange([]int{2}, 3) != -1 { panic(\"Test case 2 failed\") }",
        "if CoinChange([]int{1}, 0) != 0 { panic(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn CoinChange(coins: Vec<i32>, amount: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(CoinChange(vec![1, 2, 5], 11), 3);",
        "assert_eq!(CoinChange(vec![2], 3), -1);",
        "assert_eq!(CoinChange(vec![1], 0), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def CoinChange(coins, amount)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless CoinChange([1,2,5], 11) == 3",
        "raise 'Test Case 2 Failed' unless CoinChange([2], 3) == -1",
        "raise 'Test Case 3 Failed' unless CoinChange([1], 0) == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "coins": "[1,2,5]",
          "amount": "11"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "coins": "[2]",
          "amount": "3"
        },
        "expected": "-1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "coins": "[1]",
          "amount": "0"
        },
        "expected": "0"
      }
    ]
  },
  "combination-sum": {
    "title": "Combination Sum",
    "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n\n\nConstraints:\n\n1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CombinationSum(candidates, target) {}",
      "testCalls": [
        "const testOutput1 = CombinationSum([2,3,6,7], 7); if(JSON.stringify(testOutput1) !== '[[2,2,3],[7]]') { throw new Error('Test Case 1 Failed'); }",
        "const testOutput2 = CombinationSum([2,3,5], 8); if(JSON.stringify(testOutput2) !== '[[2,2,2,2],[2,3,3],[3,5]]') { throw new Error('Test Case 2 Failed'); }",
        "const testOutput3 = CombinationSum([2], 1); if(JSON.stringify(testOutput3) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function CombinationSum(candidates: number[], target: number): number[][] { }",
      "testCalls": [
        "if (JSON.stringify(CombinationSum([2,3,6,7], 7)) !== '[[2,2,3],[7]]') { throw new Error('Test Case 1 Failed'); }",
        "if (JSON.stringify(CombinationSum([2,3,5], 8)) !== '[[2,2,2,2],[2,3,3],[3,5]]') { throw new Error('Test Case 2 Failed'); }",
        "if (JSON.stringify(CombinationSum([2], 1)) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> CombinationSum(vector<int>& candidates, int target);",
      "testCalls": [
        "auto result1 = CombinationSum({2,3,6,7}, 7); if (result1 != vector<vector<int>>{{2,2,3},{7}}) throw std::runtime_error(\"Test 1 Failed!\");",
        "auto result2 = CombinationSum({2,3,5}, 8); if (result2 != vector<vector<int>>{{2,2,2,2},{2,3,3},{3,5}}) throw std::runtime_error(\"Test 2 Failed!\");",
        "auto result3 = CombinationSum({2}, 1); if (result3 != vector<vector<int>>{}) throw std::runtime_error(\"Test 3 Failed!\");"
      ],
      "compareHelper": "bool CompareArrays(const vector<vector<int>>& arr1, const vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def CombinationSum(candidates: List[int], target: int) -> List[List[int]]:",
      "testCalls": [
        "result1 = CombinationSum([2,3,6,7], 7)\nassert result1 == [[2,2,3],[7]], f'Expected [[2,2,3],[7]], but got {result1}'",
        "result2 = CombinationSum([2,3,5], 8)\nassert result2 == [[2,2,2,2],[2,3,3],[3,5]], f'Expected [[2,2,2,2],[2,3,3],[3,5]], but got {result2}'",
        "result3 = CombinationSum([2], 1)\nassert result3 == [], f'Expected [], but got {result3}'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> combinationSum(int[] candidates, int target) {}",
      "testCalls": [
        "List<List<Integer>> result1 = combinationSum(new int[]{2,3,6,7}, 7); if (!Arrays.deepEquals(result1.toArray(), new int[][]{{2,2,3},{7}})) throw new AssertionError();",
        "List<List<Integer>> result2 = combinationSum(new int[]{2,3,5}, 8); if (!Arrays.deepEquals(result2.toArray(), new int[][]{{2,2,2,2},{2,3,3},{3,5}})) throw new AssertionError();",
        "List<List<Integer>> result3 = combinationSum(new int[]{2}, 1); if (!Arrays.deepEquals(result3.toArray(), new int[][]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, int[][] arr2) { return Arrays.deepEquals(arr1.toArray(), arr2); }"
    },
    "c": {
      "functionDeclaration": "void CombinationSum(int* candidates, int candidatesSize, int target)",
      "testCalls": [
        "CombinationSum((int[]){2,3,6,7}, 4, 7); // [[2,2,3],[7]]",
        "CombinationSum((int[]){2,3,5}, 3, 8); // [[2,2,2,2],[2,3,3],[3,5]]",
        "CombinationSum((int[]){2}, 1, 1); // []"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n  if(size1 != size2) return 0;\n  for(int i = 0; i < size1; i++) {\n    if(arr1[i] != arr2[i]) return 0;\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func CombinationSum(candidates []int, target int) [][]int {}",
      "testCalls": [
        "result1 := CombinationSum([]int{2,3,6,7}, 7); if !compareArrays(result1, [][]int{{2,2,3},{7}}) {panic(\"Test case 1 failed\")}",
        "result2 := CombinationSum([]int{2,3,5}, 8); if !compareArrays(result2, [][]int{{2,2,2,2},{2,3,3},{3,5}}) {panic(\"Test case 2 failed\")}",
        "result3 := CombinationSum([]int{2}, 1); if !compareArrays(result3, [][]int{}) {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn CombinationSum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = CombinationSum(vec![2,3,6,7], 7); assert_eq!(result1, vec![vec![2,2,3], vec![7]]);",
        "let result2 = CombinationSum(vec![2,3,5], 8); assert_eq!(result2, vec![vec![2,2,2,2], vec![2,3,3], vec![3,5]]);",
        "let result3 = CombinationSum(vec![2], 1); assert_eq!(result3, vec![]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) -> bool { arr1.len() == arr2.len() && arr1.iter().all(|x| arr2.contains(x)) }"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "candidates": "[2,3,6,7]",
          "target": "7"
        },
        "expected": "[[2,2,3],[7]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "candidates": "[2,3,5]",
          "target": "8"
        },
        "expected": "[[2,2,2,2],[2,3,3],[3,5]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "candidates": "[2]",
          "target": "1"
        },
        "expected": "[]"
      }
    ]
  },
  "combinations": {
    "title": "Combinations",
    "content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\n\nExample 1:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\n\n\nConstraints:\n\n1 <= n <= 20\n1 <= k <= n\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Combinations(n, k) {}",
      "testCalls": [
        "const test1 = Combinations(4, 2); if(JSON.stringify(test1) !== '[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Combinations(1, 1); if(JSON.stringify(test2) !== '[[1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function Combinations(n: number, k: number): number[][] {}",
      "testCalls": [
        "const test1 = Combinations(4, 2); if(JSON.stringify(test1) !== '[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Combinations(1, 1); if(JSON.stringify(test2) !== '[[1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> Combinations(int n, int k);",
      "testCalls": [
        "auto result1 = Combinations(4, 2); assert(result1 == vector<vector<int>>{{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}});",
        "auto result2 = Combinations(1, 1); assert(result2 == vector<vector<int>>{{1}});"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def Combinations(n: int, k: int) -> List[List[int]]:",
      "testCalls": [
        "assert Combinations(4, 2) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]], 'Test Case 1 Failed'",
        "assert Combinations(1, 1) == [[1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> Combinations(int n, int k) {}",
      "testCalls": [
        "List<List<Integer>> result1 = Combinations(4, 2); if (!compareLists(result1, Arrays.asList(Arrays.asList(1,2), Arrays.asList(1,3), Arrays.asList(1,4), Arrays.asList(2,3), Arrays.asList(2,4), Arrays.asList(3,4)))) throw new AssertionError();",
        "List<List<Integer>> result2 = Combinations(1, 1); if (!compareLists(result2, Arrays.asList(Arrays.asList(1)))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) { return list1.containsAll(list2) && list2.containsAll(list1); }"
    },
    "c": {
      "functionDeclaration": "int** Combinations(int n, int k)",
      "testCalls": [
        "int** result1 = Combinations(4, 2);",
        "int** result2 = Combinations(1, 1);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n    for (int i = 0; i < size; i++) {\n        if (arr1[i] != arr2[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func Combinations(n int, k int) [][]int {}",
      "testCalls": [
        "if !compareArrays(Combinations(4, 2), [][]int{{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}}) { t.Errorf(\"Test case 1 failed\") }",
        "if !compareArrays(Combinations(1, 1), [][]int{{1}}) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 [][]int, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn Combinations(n: i32, k: i32) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(Combinations(4, 2), vec![vec![1, 2], vec![1, 3], vec![1, 4], vec![2, 3], vec![2, 4], vec![3, 4]]);",
        "assert_eq!(Combinations(1, 1), vec![vec![1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: &Vec<Vec<i32>>, arr2: &Vec<Vec<i32>>) { assert_eq!(arr1.len(), arr2.len()); for i in 0..arr1.len() { assert_eq!(arr1[i], arr2[i]); }}"
    },
    "ruby": {
      "functionDeclaration": "def Combinations(n, k)\nend",
      "testCalls": [
        "test_case_1 = Combinations(4, 2)\nraise 'Test Case 1 Failed' unless test_case_1 == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
        "test_case_2 = Combinations(1, 1)\nraise 'Test Case 2 Failed' unless test_case_2 == [[1]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "4",
          "k": "2"
        },
        "expected": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "1",
          "k": "1"
        },
        "expected": "[[1]]"
      }
    ]
  },
  "construct-binary-tree-from-inorder-and-postorder-traversal": {
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "content": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nExample 1:\n\n\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n\n\nConstraints:\n\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder) {}",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3]); if (JSON.stringify(treeToArray(result1)) !== JSON.stringify([3,9,20,null,null,15,7])) throw new Error('Test Case 1 Failed');",
        "let result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1]); if (JSON.stringify(treeToArray(result2)) !== JSON.stringify([-1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(inorder, postorder) { if (!inorder.length) return null; const rootVal = postorder.pop(); const root = new TreeNode(rootVal); const rootIndex = inorder.indexOf(rootVal); root.right = buildTree(inorder.slice(rootIndex + 1), postorder); root.left = buildTree(inorder.slice(0, rootIndex), postorder); return root; }\nfunction treeToArray(root) { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}",
      "builders": "function buildTree(inorder, postorder) {\n  if (!inorder.length || !postorder.length) return null;\n  const rootVal = postorder.pop();\n  const root = new TreeNode(rootVal);\n  const index = inorder.indexOf(rootVal);\n  root.right = buildTree(inorder.slice(index + 1), postorder);\n  root.left = buildTree(inorder.slice(0, index), postorder);\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function BuildTree(inorder: number[], postorder: number[]): TreeNode | null",
      "testCalls": [
        "let result1 = BuildTree([9,3,15,20,7], [9,15,7,20,3]); if (!compareTrees(result1, buildTree([3,9,20,null,null,15,7]))) throw new Error('Test Case 1 Failed');",
        "let result2 = BuildTree([-1], [-1]); if (!compareTrees(result2, buildTree([-1]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "compareTrees",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(inorder, postorder) { if (!inorder.length) return null; const rootVal = postorder.pop(); const root = new TreeNode(rootVal); const rootIndex = inorder.indexOf(rootVal); root.right = buildTree(inorder.slice(rootIndex + 1), postorder); root.left = buildTree(inorder.slice(0, rootIndex), postorder); return root; }\nfunction compareTrees(tree1, tree2) { if (!tree1 && !tree2) return true; if (!tree1 || !tree2 || tree1.val !== tree2.val) return false; return compareTrees(tree1.left, tree2.left) && compareTrees(tree1.right, tree2.right); }",
      "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "builders": "function buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n  if (!inorder.length || !postorder.length) return null;\n  const rootVal = postorder.pop()!;\n  const root = new TreeNode(rootVal);\n  const index = inorder.indexOf(rootVal);\n  root.right = buildTree(inorder.slice(index + 1), postorder);\n  root.left = buildTree(inorder.slice(0, index), postorder);\n  return root;\n}\n\nfunction compareTrees(tree1: TreeNode | null, tree2: TreeNode | null): boolean {\n  if (!tree1 && !tree2) return true;\n  if (!tree1 || !tree2 || tree1.val !== tree2.val) return false;\n  return compareTrees(tree1.left, tree2.left) && compareTrees(tree1.right, tree2.right);\n}"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* BuildTreeFromInorderAndPostorder(vector<int>& inorder, vector<int>& postorder)",
      "testCalls": [
        "TreeNode* result1 = BuildTreeFromInorderAndPostorder({9,3,15,20,7}, {9,15,7,20,3}); if (treeToArray(result1) != std::vector<int>{3,9,20,null,null,15,7}) throw 'Test 1 Failed';",
        "TreeNode* result2 = BuildTreeFromInorderAndPostorder({-1}, {-1}); if (treeToArray(result2) != std::vector<int>{-1}) throw 'Test 2 Failed';"
      ],
      "compareHelper": "bool compareTrees(TreeNode* t1, TreeNode* t2) { return true; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTreeFromInorderAndPostorder(vector<int>& inorder, vector<int>& postorder) { return nullptr; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTreeFromInorderAndPostorder(vector<int>& inorder, vector<int>& postorder) { return nullptr; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; return result; }"
    },
    "python": {
      "functionDeclaration": "def ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:",
      "testCalls": [
        "inorder = [9,3,15,20,7]; postorder = [9,15,7,20,3]; result = ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder); if treeToArray(result) != [3,9,20,None,None,15,7]: raise Exception('Test Case 1 Failed')",
        "inorder = [-1]; postorder = [-1]; result = ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder); if treeToArray(result) != [-1]: raise Exception('Test Case 2 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(inorder):\n    if not inorder:\n        return None\n    def build(in_start, in_end, post_start, post_end):\n        if in_start > in_end:\n            return None\n        root_val = postorder[post_end]\n        root = TreeNode(root_val)\n        in_index = inorder.index(root_val)\n        left_size = in_index - in_start\n        root.left = build(in_start, in_index - 1, post_start, post_start + left_size - 1)\n        root.right = build(in_index + 1, in_end, post_start + left_size, post_end - 1)\n        return root\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(inorder):\n    if not inorder:\n        return None\n    def build(in_start, in_end, post_start, post_end):\n        if in_start > in_end:\n            return None\n        root_val = postorder[post_end]\n        root = TreeNode(root_val)\n        in_index = inorder.index(root_val)\n        left_size = in_index - in_start\n        root.left = build(in_start, in_index - 1, post_start, post_start + left_size - 1)\n        root.right = build(in_index + 1, in_end, post_start + left_size, post_end - 1)\n        return root\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode buildTree(int[] inorder, int[] postorder) {}",
      "testCalls": [
        "TreeNode result1 = buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3});\nif (!compareTrees(result1, new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7))))) throw new AssertionError();",
        "TreeNode result2 = buildTree(new int[]{-1}, new int[]{-1});\nif (!compareTrees(result2, new TreeNode(-1))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}",
      "helpers": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }\npublic TreeNode buildTree(int[] inorder, int[] postorder) {}\npublic boolean compareTrees(TreeNode t1, TreeNode t2) {}",
      "typeDefs": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode buildTree(int[] inorder, int[] postorder) {}\npublic boolean compareTrees(TreeNode t1, TreeNode t2) {}"
    },
    "c": {
      "functionDeclaration": "TreeNode* BuildTree(int* inorder, int inorderSize, int* postorder, int postorderSize)",
      "testCalls": [
        "TreeNode* result1 = BuildTree((int[]){9,3,15,20,7}, 5, (int[]){9,15,7,20,3}, 5); int expected1[] = {3,9,20,-1,-1,15,7}; if (!CompareTrees(result1, CreateTree(expected1, 7))) { printf(\"Test case 1 failed\"); }",
        "TreeNode* result2 = BuildTree((int[]){-1}, 1, (int[]){-1}, 1); int expected2[] = {-1}; if (!CompareTrees(result2, CreateTree(expected2, 1))) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "void compareArrays(TreeNode* result, int* expected, int size) { int* resultArr = treeToArray(result); for (int i = 0; i < size; i++) { if (resultArr[i] != expected[i]) { printf(\"Test case failed\"); return; } } }",
      "helpers": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\nTreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize);\nint* treeToArray(TreeNode* root);",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func BuildTree(inorder []int, postorder []int) *TreeNode",
      "testCalls": [
        "let root = buildTree([]int{9,3,15,20,7}, []int{9,15,7,20,3}); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([3,9,20,null,null,15,7])) throw 'Test case 1 failed';",
        "let root = buildTree([]int{-1}, []int{-1}); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([-1])) throw 'Test case 2 failed';"
      ],
      "compareHelper": "func compareTrees(tree1 *TreeNode, tree2 *TreeNode) bool {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\nfunc buildTree(inorder []int, postorder []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(inorder []int, postorder []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Box<TreeNode>> { }",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal(vec![9,3,15,20,7], vec![9,15,7,20,3]); assert_eq!(treeToArray(result1), vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);",
        "let result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal(vec![-1], vec![-1]); assert_eq!(treeToArray(result2), vec![Some(-1)]);"
      ],
      "compareHelper": "fn compare_trees(tree1: Option<Box<TreeNode>>, tree2: Option<Box<TreeNode>>) -> bool { if let (Some(node1), Some(node2)) = (tree1, tree2) { node1.val == node2.val && compare_trees(node1.left.clone(), node2.left.clone()) && compare_trees(node1.right.clone(), node2.right.clone()) } else { tree1.is_none() && tree2.is_none() } }",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}",
      "typeDefs": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}"
    },
    "ruby": {
      "functionDeclaration": "def ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder)\nend",
      "testCalls": [
        "result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3]); raise 'Test Case 1 Failed' unless treeToArray(result1) == [3,9,20,nil,nil,15,7]",
        "result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1]); raise 'Test Case 2 Failed' unless treeToArray(result2) == [-1]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(inorder, postorder)\nend\n\ndef treeToArray(root)\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(inorder, postorder)\nend\n\ndef treeToArray(root)\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "inorder": "[9,3,15,20,7]",
          "postorder": "[9,15,7,20,3]"
        },
        "expected": "[3,9,20,null,null,15,7]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "inorder": "[-1]",
          "postorder": "[-1]"
        },
        "expected": "[-1]"
      }
    ]
  },
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "content": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\nExample 1:\n\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n\n\nConstraints:\n\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder) {}",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); if (JSON.stringify(treeToArray(result1)) !== JSON.stringify([3,9,20,null,null,15,7])) throw new Error('Test Case 1 Failed');",
        "let result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); if (JSON.stringify(treeToArray(result2)) !== JSON.stringify([-1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(preorder, inorder) { if (!preorder.length) return null; const rootVal = preorder.shift(); const root = new TreeNode(rootVal); const rootIndex = inorder.indexOf(rootVal); root.left = buildTree(preorder, inorder.slice(0, rootIndex)); root.right = buildTree(preorder, inorder.slice(rootIndex + 1)); return root; }\nfunction treeToArray(root) { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "class TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "builders": "function buildTree(preorder, inorder) {\n  if (!preorder.length || !inorder.length) return null;\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n  const mid = inorder.indexOf(rootVal);\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}\n\nfunction TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}"
    },
    "typescript": {
      "functionDeclaration": "function ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder: number[], inorder: number[]): TreeNode | null {}",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); if (!compareTrees(result1, buildTree([3,9,20,null,null,15,7]))) throw new Error('Test Case 1 Failed');",
        "let result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); if (!compareTrees(result2, buildTree([-1]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "compareTrees",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(preorder, inorder) { if (!preorder.length) return null; const rootVal = preorder.shift(); const root = new TreeNode(rootVal); const rootIndex = inorder.indexOf(rootVal); root.left = buildTree(preorder, inorder.slice(0, rootIndex)); root.right = buildTree(preorder, inorder.slice(rootIndex + 1)); return root; }\nfunction compareTrees(tree1, tree2) { if (!tree1 && !tree2) return true; if (!tree1 || !tree2 || tree1.val !== tree2.val) return false; return compareTrees(tree1.left, tree2.left) && compareTrees(tree1.right, tree2.right); }",
      "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "builders": "function buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n  if (!preorder.length || !inorder.length) return null;\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n  const mid = inorder.indexOf(rootVal);\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n  return root;\n}\n\nfunction compareTrees(tree1: TreeNode | null, tree2: TreeNode | null): boolean {\n  if (!tree1 && !tree2) return true;\n  if (!tree1 || !tree2) return false;\n  return (\n    tree1.val === tree2.val &&\n    compareTrees(tree1.left, tree2.left) &&\n    compareTrees(tree1.right, tree2.right)\n  );\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* ConstructBinaryTreeFromPreorderAndInorderTraversal(vector<int>& preorder, vector<int>& inorder)",
      "testCalls": [
        "TreeNode* result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal({3,9,20,15,7}, {9,3,15,20,7}); if (treeToArray(result1) != std::vector<int>{3,9,20,null,null,15,7}) throw 'Test 1 Failed';",
        "TreeNode* result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal({-1}, {-1}); if (treeToArray(result2) != std::vector<int>{-1}) throw 'Test 2 Failed';"
      ],
      "compareHelper": "string TreeNodeToString(TreeNode* root) { ... }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* constructBinaryTreeFromPreorderAndInorderTraversal(vector<int>& preorder, vector<int>& inorder) { return nullptr; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* constructBinaryTreeFromPreorderAndInorderTraversal(vector<int>& preorder, vector<int>& inorder) { return nullptr; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; return result; }"
    },
    "python": {
      "functionDeclaration": "def ConstructBinaryTreeFromPreorderAndInorder(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:",
      "testCalls": [
        "preorder = [3,9,20,15,7]; inorder = [9,3,15,20,7]; result = ConstructBinaryTreeFromPreorderAndInorder(preorder, inorder); if treeToArray(result) != [3,9,20,None,None,15,7]: raise Exception('Test Case 1 Failed')",
        "preorder = [-1]; inorder = [-1]; result = ConstructBinaryTreeFromPreorderAndInorder(preorder, inorder); if treeToArray(result) != [-1]: raise Exception('Test Case 2 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(preorder):\n    if not preorder:\n        return None\n    def build(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        in_index = inorder.index(root_val)\n        left_size = in_index - in_start\n        root.left = build(pre_start + 1, pre_start + left_size, in_start, in_index - 1)\n        root.right = build(pre_start + left_size + 1, pre_end, in_index + 1, in_end)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(preorder):\n    if not preorder:\n        return None\n    def build(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        in_index = inorder.index(root_val)\n        left_size = in_index - in_start\n        root.left = build(pre_start + 1, pre_start + left_size, in_start, in_index - 1)\n        root.right = build(pre_start + left_size + 1, pre_end, in_index + 1, in_end)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode buildTree(int[] preorder, int[] inorder) { }",
      "testCalls": [
        "TreeNode result1 = buildTree(new int[]{3,9,20,15,7}, new int[]{9,3,15,20,7});\nif (!compareTrees(result1, new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7))))) throw new AssertionError();",
        "TreeNode result2 = buildTree(new int[]{-1}, new int[]{-1});\nif (!compareTrees(result2, new TreeNode(-1))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}",
      "helpers": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }\npublic TreeNode buildTree(int[] preorder, int[] inorder) {}\npublic boolean compareTrees(TreeNode t1, TreeNode t2) {}",
      "typeDefs": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode buildTree(int[] preorder, int[] inorder) {}\npublic boolean compareTrees(TreeNode t1, TreeNode t2) {}"
    },
    "c": {
      "functionDeclaration": "TreeNode* BuildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)",
      "testCalls": [
        "TreeNode* result1 = BuildTree((int[]){3,9,20,15,7}, 5, (int[]){9,3,15,20,7}, 5); int expected1[] = {3,9,20,-1,-1,15,7}; if (!CompareTrees(result1, CreateTree(expected1, 7))) { printf(\"Test case 1 failed\"); }",
        "TreeNode* result2 = BuildTree((int[]){-1}, 1, (int[]){-1}, 1); int expected2[] = {-1}; if (!CompareTrees(result2, CreateTree(expected2, 1))) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "bool CompareTrees(TreeNode* tree1, TreeNode* tree2) { if (!tree1 && !tree2) return true; if (!tree1 || !tree2) return false; return tree1->val == tree2->val && CompareTrees(tree1->left, tree2->left) && CompareTrees(tree1->right, tree2->right); }",
      "helpers": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\nTreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize);\nint* treeToArray(TreeNode* root);",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder []int, inorder []int) *TreeNode",
      "testCalls": [
        "let root = buildTree([]int{3,9,20,15,7}, []int{9,3,15,20,7}); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([3,9,20,null,null,15,7])) throw 'Test 1 Failed';",
        "let root = buildTree([]int{-1}, []int{-1}); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([-1])) throw 'Test 2 Failed';"
      ],
      "compareHelper": "func compareBinaryTrees(tree1 *TreeNode, tree2 *TreeNode) bool {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\nfunc buildTree(preorder []int, inorder []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(preorder []int, inorder []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {}",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal(vec![3,9,20,15,7], vec![9,3,15,20,7]); assert_eq!(treeToArray(result1), vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);",
        "let result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal(vec![-1], vec![-1]); assert_eq!(treeToArray(result2), vec![Some(-1)]);"
      ],
      "compareHelper": "fn compare_trees(a: Option<Rc<RefCell<TreeNode>>>, b: Option<Rc<RefCell<TreeNode>>>) -> bool { if a.is_none() && b.is_none() { return true; } if a.is_none() || b.is_none() { return false; } let a = a.unwrap(); let b = b.unwrap(); a.borrow().val == b.borrow().val && compare_trees(a.borrow().left.clone(), b.borrow().left.clone()) && compare_trees(a.borrow().right.clone(), b.borrow().right.clone()) }",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}",
      "typeDefs": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}"
    },
    "ruby": {
      "functionDeclaration": "def ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder)\nend",
      "testCalls": [
        "result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); raise 'Test Case 1 Failed' unless treeToArray(result1) == [3,9,20,nil,nil,15,7]",
        "result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); raise 'Test Case 2 Failed' unless treeToArray(result2) == [-1]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(preorder, inorder)\nend\n\ndef treeToArray(root)\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(preorder, inorder)\nend\n\ndef treeToArray(root)\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "preorder": "[3,9,20,15,7]",
          "inorder": "[9,3,15,20,7]"
        },
        "expected": "[3,9,20,null,null,15,7]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "preorder": "[-1]",
          "inorder": "[-1]"
        },
        "expected": "[-1]"
      }
    ]
  },
  "construct-quad-tree": {
    "title": "Construct Quad Tree",
    "content": "Given a n * n matrix grid of 0 and 1 only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1 or False if the node represents a grid of 0. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1 or all 0) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don&#39;t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nExample 1:\n\n\nInput: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n\n\nExample 2:\n\n\nInput: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:\n\n\n\nConstraints:\n\nn == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "ConstructQuadTree(grid)",
      "testCalls": [
        "const testOutput1 = buildTree([[0,1],[1,0]]); if(JSON.stringify(treeToArray(testOutput1)) !== '[[false,false],[true,true],[true,true],[true,true],[true,false]]') throw new Error('Test Case 1 Failed');",
        "const testOutput2 = buildTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if(JSON.stringify(treeToArray(testOutput2)) !== '[[false,false],[true,true],[false,true],[true,true],[true,false],null,null,null,null,[true,false],[true,false],[true,true],[true,true]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function Node(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight) { this.val = val === undefined ? false : val; this.isLeaf = isLeaf === undefined ? false : isLeaf; this.topLeft = topLeft === undefined ? null : topLeft; this.topRight = topRight === undefined ? null : topRight; this.bottomLeft = bottomLeft === undefined ? null : bottomLeft; this.bottomRight = bottomRight === undefined ? null : bottomRight; }\nfunction buildTree(grid) { if (!grid.length) return null; let root = new Node(); if (grid.length === 1) { root.val = grid[0][0] === 1; root.isLeaf = true; } else { let n = grid.length; let half = n / 2; let topLeft = [], topRight = [], bottomLeft = [], bottomRight = []; for (let i = 0; i < half; i++) { topLeft.push(grid[i].slice(0, half)); topRight.push(grid[i].slice(half)); } for (let i = half; i < n; i++) { bottomLeft.push(grid[i].slice(0, half)); bottomRight.push(grid[i].slice(half)); } root.topLeft = buildTree(topLeft); root.topRight = buildTree(topRight); root.bottomLeft = buildTree(bottomLeft); root.bottomRight = buildTree(bottomRight); if (root.topLeft.isLeaf && root.topRight.isLeaf && root.bottomLeft.isLeaf && root.bottomRight.isLeaf && root.topLeft.val === root.topRight.val && root.topRight.val === root.bottomLeft.val && root.bottomLeft.val === root.bottomRight.val) { root.isLeaf = true; root.val = root.topLeft.val; root.topLeft = root.topRight = root.bottomLeft = root.bottomRight = null; } } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push([node.val, node.isLeaf]); queue.push(node.topLeft); queue.push(node.topRight); queue.push(node.bottomLeft); queue.push(node.bottomRight); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function Node(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight) {\n  this.val = val;\n  this.isLeaf = isLeaf;\n  this.topLeft = topLeft;\n  this.topRight = topRight;\n  this.bottomLeft = bottomLeft;\n  this.bottomRight = bottomRight;\n}",
      "builders": "class Node {\n    constructor(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight) {\n        this.val = val;\n        this.isLeaf = isLeaf;\n        this.topLeft = topLeft;\n        this.topRight = topRight;\n        this.bottomLeft = bottomLeft;\n        this.bottomRight = bottomRight;\n    }\n}\n\nfunction buildTree(grid) {\n    function construct(x, y, length) {\n        if (length === 1) {\n            return new Node(grid[x][y] === 1, true, null, null, null, null);\n        }\n        const half = length / 2;\n        const topLeft = construct(x, y, half);\n        const topRight = construct(x, y + half, half);\n        const bottomLeft = construct(x + half, y, half);\n        const bottomRight = construct(x + half, y + half, half);\n        if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf &&\n            topLeft.val === topRight.val && topRight.val === bottomLeft.val && bottomLeft.val === bottomRight.val) {\n            return new Node(topLeft.val, true, null, null, null, null);\n        }\n        return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\n    }\n    return construct(0, 0, grid.length);\n}\n\nfunction treeToArray(root) {\n    const result = [];\n    function traverse(node) {\n        if (!node) return;\n        result.push([node.val, node.isLeaf]);\n        if (!node.isLeaf) {\n            traverse(node.topLeft);\n            traverse(node.topRight);\n            traverse(node.bottomLeft);\n            traverse(node.bottomRight);\n        }\n    }\n    traverse(root);\n    return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function ConstructQuadTree(grid: number[][]): Node | null {}",
      "testCalls": [
        "let result1 = ConstructQuadTree([[0,1],[1,0]]); if(JSON.stringify(treeToArray(result1)) !== JSON.stringify([[0,1],[1,0],[1,1],[1,1],[1,0]])) { throw new Error('Test Case 1 Failed'); }",
        "let result2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if(JSON.stringify(treeToArray(result2)) !== JSON.stringify([[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "class Node { val: boolean; isLeaf: boolean; topLeft: Node | null; topRight: Node | null; bottomLeft: Node | null; bottomRight: Node | null; constructor(val = false, isLeaf = false, topLeft = null, topRight = null, bottomLeft = null, bottomRight = null) { this.val = val; this.isLeaf = isLeaf; this.topLeft = topLeft; this.topRight = topRight; this.bottomLeft = bottomLeft; this.bottomRight = bottomRight; } }\nfunction buildTree(grid: number[][], rowStart = 0, rowEnd = grid.length, colStart = 0, colEnd = grid[0].length): Node | null { /* Implementation not provided */ return null; }\nfunction treeToArray(root: Node | null): any[] { /* Implementation not provided */ return []; }",
      "typeDefs": "class Node { val: boolean; isLeaf: boolean; topLeft: Node | null; topRight: Node | null; bottomLeft: Node | null; bottomRight: Node | null; constructor(val = false, isLeaf = false, topLeft = null, topRight = null, bottomLeft = null, bottomRight = null) { this.val = val; this.isLeaf = isLeaf; this.topLeft = topLeft; this.topRight = topRight; this.bottomLeft = bottomLeft; this.bottomRight = bottomRight; } }",
      "builders": "function buildTree(grid: number[][], rowStart = 0, rowEnd = grid.length, colStart = 0, colEnd = grid[0].length): Node | null { /* Implementation not provided */ return null; }\nfunction treeToArray(root: Node | null): any[] { /* Implementation not provided */ return []; }"
    },
    "cpp": {
      "functionDeclaration": "Node* ConstructQuadTree(vector<vector<int>>& grid)",
      "testCalls": [
        "auto result1 = ConstructQuadTree(buildMatrix({{0,1},{1,0}}));",
        "auto result2 = ConstructQuadTree(buildMatrix({{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0}}));"
      ],
      "compareHelper": "bool compareNodes(Node* node1, Node* node2) { if (!node1 && !node2) return true; if (!node1 || !node2) return false; return node1->val == node2->val && node1->isLeaf == node2->isLeaf && compareNodes(node1->topLeft, node2->topLeft) && compareNodes(node1->topRight, node2->topRight) && compareNodes(node1->bottomLeft, node2->bottomLeft) && compareNodes(node1->bottomRight, node2->bottomRight); }",
      "helpers": "struct Node { bool val; bool isLeaf; Node* topLeft; Node* topRight; Node* bottomLeft; Node* bottomRight; Node(bool val, bool isLeaf, Node* topLeft, Node* topRight, Node* bottomLeft, Node* bottomRight) : val(val), isLeaf(isLeaf), topLeft(topLeft), topRight(topRight), bottomLeft(bottomLeft), bottomRight(bottomRight) {} };",
      "typeDefs": "struct Node { bool val; bool isLeaf; Node* topLeft; Node* topRight; Node* bottomLeft; Node* bottomRight; Node(bool val, bool isLeaf, Node* topLeft, Node* topRight, Node* bottomLeft, Node* bottomRight) : val(val), isLeaf(isLeaf), topLeft(topLeft), topRight(topRight), bottomLeft(bottomLeft), bottomRight(bottomRight) {} };",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def ConstructQuadTree(grid: List[List[int]]) -> 'Node':",
      "testCalls": [
        "result1 = ConstructQuadTree([[0,1],[1,0]]); if treeToArray(result1).count(None) != 7: raise Exception('Test Case 1 Failed')",
        "result2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if treeToArray(result2).count(None) != 31: raise Exception('Test Case 2 Failed')"
      ],
      "compareHelper": "",
      "helpers": "class Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef buildTree(grid):\n    def helper(row, col, size):\n        if size == 1:\n            return Node(grid[row][col] == 1, True, None, None, None, None)\n        half = size // 2\n        topLeft = helper(row, col, half)\n        topRight = helper(row, col + half, half)\n        bottomLeft = helper(row + half, col, half)\n        bottomRight = helper(row + half, col + half, half)\n        if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and \\\n                topLeft.val == topRight.val == bottomLeft.val == bottomRight.val:\n            return Node(topLeft.val, True, None, None, None, None)\n        return Node(True, False, topLeft, topRight, bottomLeft, bottomRight)\n    return helper(0, 0, len(grid))\n\ndef treeToArray(root):\n    def helper(node):\n        if not node:\n            return [None]\n        result = [node.val]\n        result += helper(node.topLeft)\n        result += helper(node.topRight)\n        result += helper(node.bottomLeft)\n        result += helper(node.bottomRight)\n        return result\n    return helper(root)",
      "typeDefs": "class Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight): ...",
      "builders": "def buildTree(grid): ...\n\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "Node constructQuadTree(int[][] grid)",
      "testCalls": [
        "int[][] grid1 = new int[][]{{0,1},{1,0}}; Node result1 = constructQuadTree(grid1); if (!Arrays.deepEquals(treeToArray(result1), new int[][]{{0,1},{1,0},{1,1},{1,1},{1,0}})) throw new AssertionError();",
        "int[][] grid2 = new int[][]{{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0}}; Node result2 = constructQuadTree(grid2); if (!Arrays.deepEquals(treeToArray(result2), new int[][]{{0,1},{1,1},{0,1},{1,1},{1,0},null,null,null,null,{1,0},{1,0},{1,1},{1,1}})) throw new AssertionError();"
      ],
      "compareHelper": "public boolean compareQuadTrees(Node node1, Node node2) { if (node1 == null && node2 == null) return true; if (node1 == null || node2 == null) return false; return node1.val == node2.val && node1.isLeaf == node2.isLeaf && compareQuadTrees(node1.topLeft, node2.topLeft) && compareQuadTrees(node1.topRight, node2.topRight) && compareQuadTrees(node1.bottomLeft, node2.bottomLeft) && compareQuadTrees(node1.bottomRight, node2.bottomRight); }",
      "helpers": "class Node { public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; public Node() {} public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) { this.val = val; this.isLeaf = isLeaf; this.topLeft = topLeft; this.topRight = topRight; this.bottomLeft = bottomLeft; this.bottomRight = bottomRight; } }\npublic Node buildQuadTree(int[][] grid) { return buildQuadTreeHelper(grid, 0, 0, grid.length); }\nprivate Node buildQuadTreeHelper(int[][] grid, int row, int col, int size) { if (size == 1) { return new Node(grid[row][col] == 1, true, null, null, null, null); } int newSize = size / 2; Node topLeft = buildQuadTreeHelper(grid, row, col, newSize); Node topRight = buildQuadTreeHelper(grid, row, col + newSize, newSize); Node bottomLeft = buildQuadTreeHelper(grid, row + newSize, col, newSize); Node bottomRight = buildQuadTreeHelper(grid, row + newSize, col + newSize, newSize); if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf && topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) { return new Node(topLeft.val, true, null, null, null, null); } else { return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight); } }",
      "typeDefs": "class Node { public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; public Node() {} public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) { this.val = val; this.isLeaf = isLeaf; this.topLeft = topLeft; this.topRight = topRight; this.bottomLeft = bottomLeft; this.bottomRight = bottomRight; } }",
      "builders": "public Node buildQuadTree(int[][] grid) { return buildQuadTreeHelper(grid, 0, 0, grid.length); }\nprivate Node buildQuadTreeHelper(int[][] grid, int row, int col, int size) { if (size == 1) { return new Node(grid[row][col] == 1, true, null, null, null, null); } int newSize = size / 2; Node topLeft = buildQuadTreeHelper(grid, row, col, newSize); Node topRight = buildQuadTreeHelper(grid, row, col + newSize, newSize); Node bottomLeft = buildQuadTreeHelper(grid, row + newSize, col, newSize); Node bottomRight = buildQuadTreeHelper(grid, row + newSize, col + newSize, newSize); if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf && topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) { return new Node(topLeft.val, true, null, null, null, null); } else { return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight); } }"
    },
    "c": {
      "functionDeclaration": "Node* ConstructQuadTree(int** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "int grid1[2][2] = {{1,1},{1,1}}; int* gridColSize1 = malloc(2 * sizeof(int)); gridColSize1[0] = 2; gridColSize1[1] = 2; Node* result1 = ConstructQuadTree(grid1, 2, gridColSize1);",
        "int grid2[8][8] = {{1,0,1,0,0,0,1,1},{1,0,1,0,0,0,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,0,1,0,0,0,1,1},{1,0,1,0,0,0,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1}}; int* gridColSize2 = malloc(8 * sizeof(int)); gridColSize2[0] = 8; gridColSize2[1] = 8; gridColSize2[2] = 8; gridColSize2[3] = 8; gridColSize2[4] = 8; gridColSize2[5] = 8; gridColSize2[6] = 8; gridColSize2[7] = 8; Node* result2 = ConstructQuadTree(grid2, 8, gridColSize2);"
      ],
      "compareHelper": "",
      "helpers": "typedef struct Node { bool val; bool isLeaf; struct Node* topLeft; struct Node* topRight; struct Node* bottomLeft; struct Node* bottomRight; } Node;\nNode* buildQuadTree(int** grid, int gridSize, int* gridColSize);\nint** quadTreeToArray(Node* root);",
      "typeDefs": "typedef struct Node { bool val; bool isLeaf; struct Node* topLeft; struct Node* topRight; struct Node* bottomLeft; struct Node* bottomRight; } Node;",
      "builders": "Node* buildQuadTree(int** grid, int gridSize, int* gridColSize);\nint** quadTreeToArray(Node* root);"
    },
    "go": {
      "functionDeclaration": "ConstructQuadTree(grid [][]int) *Node",
      "testCalls": [
        "if result := ConstructQuadTree(buildTree([]int{0,1,1,0})); !reflect.DeepEqual(result, &Node{Val: false, IsLeaf: false, TopLeft: &Node{Val: false, IsLeaf: true}, TopRight: &Node{Val: true, IsLeaf: true}, BottomLeft: &Node{Val: true, IsLeaf: true}, BottomRight: &Node{Val: false, IsLeaf: true}}) { t.Errorf(\"Test 1 Failed\") }",
        "if result := ConstructQuadTree(buildTree([]int{1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0})); !reflect.DeepEqual(result, &Node{Val: false, IsLeaf: false, TopLeft: &Node{Val: false, IsLeaf: true}, TopRight: &Node{Val: true, IsLeaf: true}, BottomLeft: &Node{Val: true, IsLeaf: true}, BottomRight: nil}) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func buildTree(arr []int) [][]int { // Implement the function }",
      "helpers": "type Node struct { Val bool IsLeaf bool TopLeft *Node TopRight *Node BottomLeft *Node BottomRight *Node }\nfunc ConstructQuadTree(grid [][]int) *Node { // Implement the function }\n",
      "typeDefs": "type Node struct { Val bool IsLeaf bool TopLeft *Node TopRight *Node BottomLeft *Node BottomRight *Node }",
      "builders": "func ConstructQuadTree(grid [][]int) *Node { // Implement the function }\n"
    },
    "rust": {
      "functionDeclaration": "fn ConstructQuadTree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> { }",
      "testCalls": [
        "let test_input1 = vec![vec![0, 1], vec![1, 0]]; let result1 = ConstructQuadTree(test_input1); assert_eq!(result1, Some(Box::new(Node { val: false, is_leaf: false, top_left: Some(Box::new(Node { val: false, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), top_right: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_left: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_right: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })) }));",
        "let test_input2 = vec![vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 1, 1, 1, 1], vec![1, 1, 1, 1, 1, 1, 1, 1], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0]]; let result2 = ConstructQuadTree(test_input2); assert_eq!(result2, Some(Box::new(Node { val: false, is_leaf: false, top_left: Some(Box::new(Node { val: false, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), top_right: Some(Box::new(Node { val: true, is_leaf: false, top_left: Some(Box::new(Node { val: false, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), top_right: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_left: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_right: None })) }));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashMap;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: bool,\n    pub is_leaf: bool,\n    pub top_left: Option<Box<Node>>,\n    pub top_right: Option<Box<Node>>,\n    pub bottom_left: Option<Box<Node>>,\n    pub bottom_right: Option<Box<Node>>,\n}\n\nfn build_tree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> {\n    build_tree_helper(&grid, 0, 0, grid.len())\n}\n\nfn build_tree_helper(grid: &Vec<Vec<i32>>, row: usize, col: usize, size: usize) -> Option<Box<Node>> {\n    if size == 1 {\n        return Some(Box::new(Node {\n            val: grid[row][col] == 1,\n            is_leaf: true,\n            top_left: None,\n            top_right: None,\n            bottom_left: None,\n            bottom_right: None,\n        }));\n    }\n    let new_size = size / 2;\n    let top_left = build_tree_helper(grid, row, col, new_size);\n    let top_right = build_tree_helper(grid, row, col + new_size, new_size);\n    let bottom_left = build_tree_helper(grid, row + new_size, col, new_size);\n    let bottom_right = build_tree_helper(grid, row + new_size, col + new_size, new_size);\n\n    if let (Some(tl), Some(tr), Some(bl), Some(br)) = (&top_left, &top_right, &bottom_left, &bottom_right) {\n        if tl.is_leaf && tr.is_leaf && bl.is_leaf && br.is_leaf &&\n           tl.val == tr.val && tr.val == bl.val && bl.val == br.val {\n            return Some(Box::new(Node {\n                val: tl.val,\n                is_leaf: true,\n                top_left: None,\n                top_right: None,\n                bottom_left: None,\n                bottom_right: None,\n            }));\n        }\n    }\n    Some(Box::new(Node {\n        val: true,\n        is_leaf: false,\n        top_left,\n        top_right,\n        bottom_left,\n        bottom_right,\n    }))\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: bool,\n    pub is_leaf: bool,\n    pub top_left: Option<Box<Node>>,\n    pub top_right: Option<Box<Node>>,\n    pub bottom_left: Option<Box<Node>>,\n    pub bottom_right: Option<Box<Node>>,\n}",
      "builders": "struct Node {\n    val: bool,\n    is_leaf: bool,\n    top_left: Option<Box<Node>>,\n    top_right: Option<Box<Node>>,\n    bottom_left: Option<Box<Node>>,\n    bottom_right: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(val: bool, is_leaf: bool, top_left: Option<Box<Node>>, top_right: Option<Box<Node>>, bottom_left: Option<Box<Node>>, bottom_right: Option<Box<Node>>) -> Self {\n        Node { val, is_leaf, top_left, top_right, bottom_left, bottom_right }\n    }\n}\n\nfn build_tree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> {\n    fn build_tree_helper(grid: &Vec<Vec<i32>>, row: usize, col: usize, size: usize) -> Option<Box<Node>> {\n        if size == 1 {\n            return Some(Box::new(Node::new(grid[row][col] == 1, true, None, None, None, None)));\n        }\n        let new_size = size / 2;\n        let top_left = build_tree_helper(grid, row, col, new_size);\n        let top_right = build_tree_helper(grid, row, col + new_size, new_size);\n        let bottom_left = build_tree_helper(grid, row + new_size, col, new_size);\n        let bottom_right = build_tree_helper(grid, row + new_size, col + new_size, new_size);\n        if let (Some(tl), Some(tr), Some(bl), Some(br)) = (&top_left, &top_right, &bottom_left, &bottom_right) {\n            if tl.is_leaf && tr.is_leaf && bl.is_leaf && br.is_leaf &&\n               tl.val == tr.val && tr.val == bl.val && bl.val == br.val {\n                return Some(Box::new(Node::new(tl.val, true, None, None, None, None)));\n            }\n        }\n        Some(Box::new(Node::new(true, false, top_left, top_right, bottom_left, bottom_right)))\n    }\n    build_tree_helper(&grid, 0, 0, grid.len())\n}"
    },
    "ruby": {
      "functionDeclaration": "def ConstructQuadTree(grid)\nend",
      "testCalls": [
        "result1 = ConstructQuadTree([[0,1],[1,0]]); raise 'Test Case 1 Failed' unless quadTreeToArray(result1) == [[0,1],[1,0],[1,1],[1,1],[1,0]]",
        "result2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); raise 'Test Case 2 Failed' unless quadTreeToArray(result2) == [[0,1],[1,1],[0,1],[1,1],[1,0],nil,nil,nil,nil,[1,0],[1,0],[1,1],[1,1]]"
      ],
      "compareHelper": "empty string",
      "helpers": "class Node\n  attr_accessor :val, :is_leaf, :top_left, :top_right, :bottom_left, :bottom_right\n  def initialize(val=false, is_leaf=false, top_left=nil, top_right=nil, bottom_left=nil, bottom_right=nil)\n    @val = val\n    @is_leaf = is_leaf\n    @top_left = top_left\n    @top_right = top_right\n    @bottom_left = bottom_left\n    @bottom_right = bottom_right\n  end\nend\n\ndef buildQuadTree(grid)\nend\n\ndef quadTreeToArray(root)\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :is_leaf, :top_left, :top_right, :bottom_left, :bottom_right\n  def initialize(val=false, is_leaf=false, top_left=nil, top_right=nil, bottom_left=nil, bottom_right=nil)\n    @val = val\n    @is_leaf = is_leaf\n    @top_left = top_left\n    @top_right = top_right\n    @bottom_left = bottom_left\n    @bottom_right = bottom_right\n  end\nend",
      "builders": "def buildQuadTree(grid)\nend\n\ndef quadTreeToArray(root)\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "grid": "[[0,1],[1,0]]"
        },
        "expected": "[[0,1],[1,0],[1,1],[1,1],[1,0]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "grid": "[[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]"
        },
        "expected": "[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]"
      }
    ]
  },
  "container-with-most-water": {
    "title": "Container With Most Water",
    "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n\nExample 1:\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\nConstraints:\n\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      "If you simulate the problem, it will be O(n^2) which is not efficient.",
      "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
      "How can you calculate the amount of water at each step?"
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ContainerWithMostWater(height) {}",
      "testCalls": [
        "if(ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) !== 49) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainerWithMostWater([1,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ContainerWithMostWater(height: number[]): number { }",
      "testCalls": [
        "if(ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) !== 49) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainerWithMostWater([1,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxArea(vector<int>& height)",
      "testCalls": [
        "if(MaxArea({1,8,6,2,5,4,8,3,7}) != 49) throw runtime_error(\"Test 1 failed\");",
        "if(MaxArea({1,1}) != 1) throw runtime_error(\"Test 2 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "ContainerWithMostWater(height: List[int]) -> int",
      "testCalls": [
        "assert ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) == 49",
        "assert ContainerWithMostWater([1,1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int maxArea(int[] height) {}",
      "testCalls": [
        "if (maxArea(new int[]{1,8,6,2,5,4,8,3,7}) != 49) throw new AssertionError();",
        "if (maxArea(new int[]{1,1}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxArea(int* height, int heightSize)",
      "testCalls": [
        "if(MaxArea((int[]){1,8,6,2,5,4,8,3,7}, 9) != 49) { printf(\"Test case 1 failed\"); }",
        "if(MaxArea((int[]){1,1}, 2) != 1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxArea(height []int) int {}",
      "testCalls": [
        "if MaxArea([]int{1,8,6,2,5,4,8,3,7}) != 49 {panic(\"Test case 1 failed\")}",
        "if MaxArea([]int{1,1}) != 1 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ContainerWithMostWater(height: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(ContainerWithMostWater(vec![1,8,6,2,5,4,8,3,7]), 49);",
        "assert_eq!(ContainerWithMostWater(vec![1,1]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ContainerWithMostWater(height)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) == 49",
        "raise 'Test Case 2 Failed' unless ContainerWithMostWater([1,1]) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "height": "[1,8,6,2,5,4,8,3,7]"
        },
        "expected": "49"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "height": "[1,1]"
        },
        "expected": "1"
      }
    ]
  },
  "contains-duplicate-ii": {
    "title": "Contains Duplicate II",
    "content": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\n\nExample 1:\n\nInput: nums = [1,2,3,1], k = 3\nOutput: true\n\nExample 2:\n\nInput: nums = [1,0,1,1], k = 1\nOutput: true\n\nExample 3:\n\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\n\n\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n0 <= k <= 105\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ContainsDuplicateII(nums, k) { }",
      "testCalls": [
        "if(ContainsDuplicateII([1,2,3,1], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainsDuplicateII([1,0,1,1], 1) !== true) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ContainsDuplicateII(nums: number[], k: number): boolean {}",
      "testCalls": [
        "if (ContainsDuplicateII([1,2,3,1], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (ContainsDuplicateII([1,0,1,1], 1) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (ContainsDuplicateII([1,2,3,1,2,3], 2) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool ContainsDuplicateII(vector<int>& nums, int k);",
      "testCalls": [
        "if (ContainsDuplicateII({1,2,3,1}, 3) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (ContainsDuplicateII({1,0,1,1}, 1) != true) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ContainsDuplicateII(nums: List[int], k: int) -> bool:",
      "testCalls": [
        "assert ContainsDuplicateII([1,2,3,1], 3) == True",
        "assert ContainsDuplicateII([1,0,1,1], 1) == True"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean ContainsDuplicateII(int[] nums, int k) { }",
      "testCalls": [
        "if (!ContainsDuplicateII(new int[]{1,2,3,1}, 3)) { throw new AssertionError(); }",
        "if (!ContainsDuplicateII(new int[]{1,0,1,1}, 1)) { throw new AssertionError(); }"
      ],
      "compareHelper": "Arrays.equals(expectedArray, actualArray)"
    },
    "c": {
      "functionDeclaration": "bool ContainsDuplicateII(int* nums, int numsSize, int k)",
      "testCalls": [
        "if (!ContainsDuplicateII((int[]){1,2,3,1}, 4, 3)) { printf(\"Test Case 1 Failed\"); }",
        "if (!ContainsDuplicateII((int[]){1,0,1,1}, 4, 1)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ContainsNearbyDuplicate(nums []int, k int) bool {}",
      "testCalls": [
        "if !ContainsNearbyDuplicate([]int{1,2,3,1}, 3) {panic(\"Test case 1 failed\")}",
        "if !ContainsNearbyDuplicate([]int{1,0,1,1}, 1) {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ContainsDuplicateII(nums: Vec<i32>, k: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(ContainsDuplicateII(vec![1, 2, 3, 1], 3), true);",
        "assert_eq!(ContainsDuplicateII(vec![1, 0, 1, 1], 1), true); assert_eq!(ContainsDuplicateII(vec![1, 2, 3, 1, 2, 3], 2), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ContainsDuplicateII(nums, k)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ContainsDuplicateII([1,2,3,1], 3) == true",
        "raise 'Test Case 2 Failed' unless ContainsDuplicateII([1,0,1,1], 1) == true",
        "raise 'Test Case 3 Failed' unless ContainsDuplicateII([1,2,3,1,2,3], 2) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,1]",
          "k": "3"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,0,1,1]",
          "k": "1"
        },
        "expected": "true"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1,2,3,1,2,3]",
          "k": "2"
        },
        "expected": "false"
      }
    ]
  },
  "convert-sorted-array-to-binary-search-tree": {
    "title": "Convert Sorted Array to Binary Search Tree",
    "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n\nExample 1:\n\n\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\n\n\nExample 2:\n\n\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in a strictly increasing order.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SortedArrayToBinarySearchTree(nums) {}",
      "testCalls": [
        "if(JSON.stringify(SortedArrayToBinarySearchTree(buildTree([-10,-3,0,5,9]))) !== JSON.stringify([0,-3,9,-10,null,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(SortedArrayToBinarySearchTree(buildTree([1,3]))) !== JSON.stringify([3,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length) return null; let build = function(i, j) { if (i > j) return null; let mid = Math.floor((i + j) / 2); let node = new TreeNode(arr[mid]); node.left = build(i, mid - 1); node.right = build(mid + 1, j); return node; }; return build(0, arr.length - 1); }\nfunction treeToArray(root) { let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}",
      "builders": "function buildTree(arr) {\n  if (!arr.length) return null;\n  const mid = Math.floor(arr.length / 2);\n  const root = new TreeNode(arr[mid]);\n  root.left = buildTree(arr.slice(0, mid));\n  root.right = buildTree(arr.slice(mid + 1));\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node ? node.val : null);\n    if (node) {\n      queue.push(node.left);\n      queue.push(node.right);\n    }\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function SortedArrayToBinarySearchTree(nums: number[]): TreeNode | null {}",
      "testCalls": [
        "if(JSON.stringify(ConvertSortedArrayToBinarySearchTree(buildTree([-10,-3,0,5,9]))) !== JSON.stringify([0,-3,9,-10,null,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(ConvertSortedArrayToBinarySearchTree(buildTree([1,3]))) !== JSON.stringify([3,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "",
      "builders": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction buildTree(arr: number[]): TreeNode | null {\n  if (!arr.length) return null;\n  const mid = Math.floor(arr.length / 2);\n  const root = new TreeNode(arr[mid]);\n  root.left = buildTree(arr.slice(0, mid));\n  root.right = buildTree(arr.slice(mid + 1));\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node ? node.val : null);\n    if (node) {\n      queue.push(node.left);\n      queue.push(node.right);\n    }\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* SortedArrayToBST(vector<int>& nums)",
      "testCalls": [
        "assert(TreeNodeToString(SortedArrayToBST({-10,-3,0,5,9})) == \"[0,-3,9,-10,null,5]\");",
        "assert(TreeNodeToString(SortedArrayToBST({1,3})) == \"[3,1]\");"
      ],
      "compareHelper": "string TreeNodeToString(TreeNode* root) { ... }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(vector<int>& arr) { if (arr.empty()) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; } \nvector<int> treeToArray(TreeNode* root) { vector<int> result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};",
      "builders": "TreeNode* sortedArrayToBST(vector<int>& nums, int start, int end) {\n    if (start > end) return NULL;\n    int mid = start + (end - start) / 2;\n    TreeNode* node = new TreeNode(nums[mid]);\n    node->left = sortedArrayToBST(nums, start, mid - 1);\n    node->right = sortedArrayToBST(nums, mid + 1, end);\n    return node;\n}\n\nTreeNode* buildTree(vector<int>& arr) {\n    return sortedArrayToBST(arr, 0, arr.size() - 1);\n}\n\nvoid treeToArrayHelper(TreeNode* root, vector<int>& result) {\n    if (!root) return;\n    treeToArrayHelper(root->left, result);\n    result.push_back(root->val);\n    treeToArrayHelper(root->right, result);\n}\n\nvector<int> treeToArray(TreeNode* root) {\n    vector<int> result;\n    treeToArrayHelper(root, result);\n    return result;\n}"
    },
    "python": {
      "functionDeclaration": "def ConvertSortedArrayToBinarySearchTree(nums: List[int]) -> TreeNode:",
      "testCalls": [
        "result1 = ConvertSortedArrayToBinarySearchTree(buildTree([-10,-3,0,5,9])); assert treeToArray(result1) == [0,-3,9,-10,5]",
        "result2 = ConvertSortedArrayToBinarySearchTree(buildTree([1,3])); assert treeToArray(result2) == [3,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2): return arr1 == arr2",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    def helper(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        node = TreeNode(arr[mid])\n        node.left = helper(left, mid - 1)\n        node.right = helper(mid + 1, right)\n        return node\n    return helper(0, len(arr) - 1)\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None): ...",
      "builders": "def buildTree(arr): ...\n\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public TreeNode sortedArrayToBST(int[] nums) {}",
      "testCalls": [
        "assert Arrays.equals(TreeNode.toArray(sortedArrayToBST(buildTree(new int[]{-10,-3,0,5,9}))), TreeNode.toArray(buildTree(new Integer[]{0,-3,9,-10,null,5}));",
        "assert Arrays.equals(TreeNode.toArray(sortedArrayToBST(buildTree(new int[]{1,3}))), TreeNode.toArray(buildTree(new Integer[]{3,1}));"
      ],
      "compareHelper": "private static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } static Integer[] toArray(TreeNode root) { if (root == null) return new Integer[0]; List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node == null) { list.add(null); } else { list.add(node.val); queue.add(node.left); queue.add(node.right); } } while (list.get(list.size() - 1) == null) { list.remove(list.size() - 1); } return list.toArray(new Integer[0]); } static TreeNode fromArray(Integer[] arr) { if (arr.length == 0) return null; TreeNode[] nodes = new TreeNode[arr.length]; for (int i = 0; i < arr.length; i++) { if (arr[i] != null) { nodes[i] = new TreeNode(arr[i]); } } TreeNode root = nodes[0]; for (int i = 0; i < arr.length; i++) { if (nodes[i] != null) { int leftIndex = 2 * i + 1; int rightIndex = 2 * i + 2; if (leftIndex < arr.length) nodes[i].left = nodes[leftIndex]; if (rightIndex < arr.length) nodes[i].right = nodes[rightIndex]; } } return root; } }",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic static TreeNode sortedArrayToBST(int[] nums) {}\n",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public static TreeNode sortedArrayToBST(int[] nums) {}\n"
    },
    "c": {
      "functionDeclaration": "TreeNode* SortedArrayToBST(int* nums, int numsSize)",
      "testCalls": [
        "assert(strcmp(treeToArray(SortedArrayToBST((int[]){-10,-3,0,5,9}, 5)), \"[0,-3,9,-10,null,5]\") == 0;",
        "assert(strcmp(treeToArray(SortedArrayToBST((int[]){1,3}, 2)), \"[3,1]\") == 0;"
      ],
      "compareHelper": "char* TreeNodeToString(TreeNode* root) { /* Helper function implementation for converting TreeNode to string */ }",
      "helpers": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\nTreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func SortedArrayToBST(nums []int) *TreeNode {}",
      "testCalls": [
        "if result := SortedArrayToBST(buildTree([]int{-10,-3,0,5,9})); !compareTrees(result, buildTree([]int{0,-3,9,-10,0,5})) { t.Errorf(\"Test case 1 failed\") }",
        "if result := SortedArrayToBST(buildTree([]int{1,3})); !compareTrees(result, buildTree([]int{3,1})) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareTrees(t1 *TreeNode, t2 *TreeNode) bool {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "pub fn ConvertSortedArrayToBinarySearchTree(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {}",
      "testCalls": [
        "let result1 = ConvertSortedArrayToBinarySearchTree(vec![-10,-3,0,5,9]); assert_eq!(tree_to_array(result1), vec![Some(0), Some(-3), Some(9), Some(-10), None, Some(5)]);",
        "let result2 = ConvertSortedArrayToBinarySearchTree(vec![1,3]); assert_eq!(tree_to_array(result2), vec![Some(3), Some(1)]);"
      ],
      "compareHelper": "fn compare_trees(tree1: Option<Rc<RefCell<TreeNode>>>, tree2: Option<Rc<RefCell<TreeNode>>>) -> bool { if tree1.is_none() && tree2.is_none() { return true; } if tree1.is_none() || tree2.is_none() { return false; } let tree1_val = tree1.as_ref().unwrap().borrow().val; let tree2_val = tree2.as_ref().unwrap().borrow().val; let left_result = compare_trees(tree1.as_ref().unwrap().borrow().left.clone(), tree2.as_ref().unwrap().borrow().left.clone()); let right_result = compare_trees(tree1.as_ref().unwrap().borrow().right.clone(), tree2.as_ref().unwrap().borrow().right.clone()); return tree1_val == tree2_val && left_result && right_result; }",
      "helpers": "use std::{cell::RefCell, rc::Rc};\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn build_tree(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def ConvertSortedArrayToBinarySearchTree(nums)\nend",
      "testCalls": [
        "root = buildTree([-10,-3,0,5,9]); result = ConvertSortedArrayToBinarySearchTree(root); raise 'Test Case 1 Failed' unless treeToArray(result) == [0,-3,9,-10,nil,5]",
        "root = buildTree([1,3]); result = ConvertSortedArrayToBinarySearchTree(root); raise 'Test Case 2 Failed' unless treeToArray(result) == [3,1]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(arr)\n  # Build binary tree from array\nend\n\ndef treeToArray(root)\n  # Convert binary tree to array\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Build binary tree from array\nend\n\ndef treeToArray(root)\n  # Convert binary tree to array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[-10,-3,0,5,9]"
        },
        "expected": "[0,-3,9,-10,null,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,3]"
        },
        "expected": "[3,1]"
      }
    ]
  },
  "copy-list-with-random-pointer": {
    "title": "Copy List with Random Pointer",
    "content": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\n\nYour code will only be given the head of the original linked list.\n\nExample 1:\n\n\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nExample 2:\n\n\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n\nExample 3:\n\n\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n\n\nConstraints:\n\n0 <= n <= 1000\n-104 <= Node.val <= 104\nNode.random is null or is pointing to some node in the linked list.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.",
      "You may want to use extra space to keep old_node ---> new_node mapping to prevent creating multiple copies of the same node.",
      "We can avoid using extra space for old_node ---> new_node mapping by tweaking the original linked list. Simply interweave the nodes of the old and copied list. For example:\r\nOld List: A --> B --> C --> D\r\nInterWeaved List: A --> A' --> B --> B' --> C --> C' --> D --> D'",
      "The interweaving is done using next</b> pointers and we can make use of interweaved structure to get the correct reference nodes for random</b> pointers."
    ],
    "topicTags": [
      "Hash Table",
      "Linked List"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "CopyListWithRandomPointer(head)",
      "testCalls": [
        "const test1 = CopyListWithRandomPointer(buildLinkedList([[7,null],[13,0],[11,4],[10,2],[1,0]])); if(JSON.stringify(test1) !== JSON.stringify([[7,null],[13,0],[11,4],[10,2],[1,0]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = CopyListWithRandomPointer(buildLinkedList([[1,1],[2,1]])); if(JSON.stringify(test2) !== JSON.stringify([[1,1],[2,1]])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = CopyListWithRandomPointer(buildLinkedList([[3,null],[3,0],[3,null]])); if(JSON.stringify(test3) !== JSON.stringify([[3,null],[3,0],[3,null]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function Node(val, next, random) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; this.random = random === undefined ? null : random; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let nodes = arr.map(val => new Node(val)); for (let i = 0; i < nodes.length - 1; i++) { nodes[i].next = nodes[i + 1]; } for (let i = 0; i < arr.length; i++) { if (arr[i][1] !== null) { nodes[i].random = nodes[arr[i][1]]; } } return nodes[0]; }\nfunction linkedListToArray(head) { let arr = []; let curr = head; while (curr) { arr.push([curr.val, curr.random ? curr.random.val : null]); curr = curr.next; } return arr; }",
      "typeDefs": "function Node(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n}",
      "builders": "function Node(val, next = null, random = null) {\n  this.val = val;\n  this.next = next;\n  this.random = random;\n}\n\nfunction buildLinkedList(arr) {\n  if (!arr.length) return null;\n  const nodes = arr.map(([val]) => new Node(val));\n  arr.forEach(([_, nextIndex, randomIndex], i) => {\n    if (nextIndex !== null) nodes[i].next = nodes[nextIndex];\n    if (randomIndex !== null) nodes[i].random = nodes[randomIndex];\n  });\n  return nodes[0];\n}\n\nfunction linkedListToArray(head) {\n  const arr = [];\n  const map = new Map();\n  let node = head;\n  let index = 0;\n  while (node) {\n    map.set(node, index++);\n    node = node.next;\n  }\n  node = head;\n  while (node) {\n    arr.push([\n      node.val,\n      node.next ? map.get(node.next) : null,\n      node.random ? map.get(node.random) : null\n    ]);\n    node = node.next;\n  }\n  return arr;\n}"
    },
    "typescript": {
      "functionDeclaration": "CopyListWithRandomPointer(head: number[][]): number[][]",
      "testCalls": [
        "const test1 = CopyListWithRandomPointer(buildLinkedList([[7,null],[13,0],[11,4],[10,2],[1,0]])); if(JSON.stringify(test1) !== JSON.stringify([[7,null],[13,0],[11,4],[10,2],[1,0]])) throw new Error('Test Case 1 Failed');",
        "const test2 = CopyListWithRandomPointer(buildLinkedList([[1,1],[2,1]])); if(JSON.stringify(test2) !== JSON.stringify([[1,1],[2,1]])) throw new Error('Test Case 2 Failed');",
        "const test3 = CopyListWithRandomPointer(buildLinkedList([[3,null],[3,0],[3,null]])); if(JSON.stringify(test3) !== JSON.stringify([[3,null],[3,0],[3,null]])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "cpp": {
      "functionDeclaration": "CopyListWithRandomPointer(Node* head)",
      "testCalls": [
        "assert(compareLists(CopyListWithRandomPointer(buildLinkedList({{7,-1},{13,0},{11,4},{10,2},{1,0}})), buildLinkedList({{7,-1},{13,0},{11,4},{10,2},{1,0}})));",
        "assert(compareLists(CopyListWithRandomPointer(buildLinkedList({{1,1},{2,1}})), buildLinkedList({{1,1},{2,1}})));",
        "assert(compareLists(CopyListWithRandomPointer(buildLinkedList({{3,-1},{3,0},{3,-1}})), buildLinkedList({{3,-1},{3,0},{3,-1}})));"
      ],
      "compareHelper": "bool compareLists(Node* l1, Node* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; if ((l1->random && !l2->random) || (!l1->random && l2->random) || (l1->random && l2->random && l1->random->val != l2->random->val)) return false; l1 = l1->next; l2 = l2->next; } return !l1 && !l2; }",
      "helpers": "class Node { public: int val; Node* next; Node* random; Node(int x) : val(x), next(nullptr), random(nullptr) {} }; \nNode* buildLinkedList(vector<vector<int>>& nodes) { unordered_map<Node*, Node*> mp; Node* dummy = new Node(0); Node* curr = dummy; for (auto& node : nodes) { if (!mp.count(node[0])) mp[node[0]] = new Node(node[0]); curr->next = mp[node[0]]; if (node[1] != -1) { if (!mp.count(node[1])) mp[node[1]] = new Node(node[1]); curr->next->random = mp[node[1]]; } curr = curr->next; } return dummy->next; } \nvector<vector<int>> linkedListToArray(Node* head) { vector<vector<int>> result; while (head) { vector<int> node = {head->val, head->random ? head->random->val : -1}; result.push_back(node); head = head->next; } return result; }",
      "typeDefs": "class Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    Node(int _val) : val(_val), next(nullptr), random(nullptr) {}\n};",
      "builders": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nNode* buildLinkedList(vector<vector<int>>& nodes) {\n    if (nodes.empty()) return nullptr;\n    vector<Node*> nodeList;\n    for (const auto& node : nodes) {\n        nodeList.push_back(new Node(node[0]));\n    }\n    for (size_t i = 0; i < nodes.size(); ++i) {\n        if (nodes[i][1] != -1) nodeList[i]->next = nodeList[nodes[i][1]];\n        if (nodes[i][2] != -1) nodeList[i]->random = nodeList[nodes[i][2]];\n    }\n    return nodeList[0];\n}\n\nvector<vector<int>> linkedListToArray(Node* head) {\n    vector<vector<int>> result;\n    unordered_map<Node*, int> nodeMap;\n    Node* current = head;\n    int index = 0;\n    while (current) {\n        nodeMap[current] = index++;\n        current = current->next;\n    }\n    current = head;\n    while (current) {\n        result.push_back({\n            current->val,\n            current->next ? nodeMap[current->next] : -1,\n            current->random ? nodeMap[current->random] : -1\n        });\n        current = current->next;\n    }\n    return result;\n}"
    },
    "python": {
      "functionDeclaration": "def CopyListWithRandomPointer(head: List[List[int]]) -> List[List[int]]:",
      "testCalls": [
        "result1 = CopyListWithRandomPointer([[7,null],[13,0],[11,4],[10,2],[1,0]]); assert result1 == [[7,null],[13,0],[11,4],[10,2],[1,0]], 'Test Case 1 Failed'",
        "result2 = CopyListWithRandomPointer([[1,1],[2,1]]); assert result2 == [[1,1],[2,1]], 'Test Case 2 Failed'",
        "result3 = CopyListWithRandomPointer([[3,null],[3,0],[3,null]]); assert result3 == [[3,null],[3,0],[3,null]], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if len(list1) != len(list2):\n        return False\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public Node copyRandomList(Node head)",
      "testCalls": [
        "Node test1 = copyRandomList(buildLinkedList(new int[][]{{7, null}, {13, 0}, {11, 4}, {10, 2}, {1, 0}}));\nif (!compareNodes(test1, buildLinkedList(new int[][]{{7, null}, {13, 0}, {11, 4}, {10, 2}, {1, 0}}))) throw new AssertionError();",
        "Node test2 = copyRandomList(buildLinkedList(new int[][]{{1, 1}, {2, 1}}));\nif (!compareNodes(test2, buildLinkedList(new int[][]{{1, 1}, {2, 1}}))) throw new AssertionError();",
        "Node test3 = copyRandomList(buildLinkedList(new int[][]{{3, null}, {3, 0}, {3, null}}));\nif (!compareNodes(test3, buildLinkedList(new int[][]{{3, null}, {3, 0}, {3, null}}))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareNodes(Node node1, Node node2) {\n    // Implement comparison logic here\n}",
      "helpers": "class Node { int val; Node next; Node random; Node(int x) { val = x; } }\npublic static Node copyRandomList(Node head) {}\n",
      "typeDefs": "class Node {\n    int val;\n    Node next;\n    Node random;\n    \n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}",
      "builders": "public static Node copyRandomList(Node head) {\n    if (head == null) return null;\n    \n    // Step 1: Create new nodes and insert them after each original node\n    Node current = head;\n    while (current != null) {\n        Node newNode = new Node(current.val);\n        newNode.next = current.next;\n        current.next = newNode;\n        current = newNode.next;\n    }\n    \n    // Step 2: Assign random pointers for the new nodes\n    current = head;\n    while (current != null) {\n        if (current.random != null) {\n            current.next.random = current.random.next;\n        }\n        current = current.next.next;\n    }\n    \n    // Step 3: Separate the new nodes to form the copied list\n    Node newHead = head.next;\n    current = head;\n    while (current != null) {\n        Node newNode = current.next;\n        current.next = newNode.next;\n        if (newNode.next != null) {\n            newNode.next = newNode.next.next;\n        }\n        current = current.next;\n    }\n    \n    return newHead;\n}"
    },
    "c": {
      "functionDeclaration": "Node* CopyListWithRandomPointer(Node* head)",
      "testCalls": [
        "Node* head1 = buildLinkedList((int*[]){(int[]){7,0}, (int[]){13,1}, (int[]){11,4}, (int[]){10,2}, (int[]){1,0}}, 5); Node* expected1 = buildLinkedList((int*[]){(int[]){7,0}, (int[]){13,1}, (int[]){11,4}, (int[]){10,2}, (int[]){1,0}}, 5); Node* result1 = CopyListWithRandomPointer(head1); compareLists(expected1, result1);",
        "Node* head2 = buildLinkedList((int*[]){(int[]){1,1}, (int[]){2,1}}, 2); Node* expected2 = buildLinkedList((int*[]){(int[]){1,1}, (int[]){2,1}}, 2); Node* result2 = CopyListWithRandomPointer(head2); compareLists(expected2, result2);",
        "Node* head3 = buildLinkedList((int*[]){(int[]){3,0}, (int[]){3,1}, (int[]){3,0}}, 3); Node* expected3 = buildLinkedList((int*[]){(int[]){3,0}, (int[]){3,1}, (int[]){3,0}}, 3); Node* result3 = CopyListWithRandomPointer(head3); compareLists(expected3, result3);"
      ],
      "compareHelper": "void compareLists(Node* expected, Node* result) { /* Comparison logic */ }",
      "helpers": "typedef struct Node { int val; struct Node *next; struct Node *random; } Node;\nNode* buildLinkedList(int** arr, int size);\nint** linkedListToArray(Node* head);",
      "typeDefs": "#include <stdlib.h>\n\ntypedef struct Node {\n    int val;\n    struct Node* next;\n    struct Node* random;\n} Node;\n\nNode* createNode(int val) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->val = val;\n    newNode->next = NULL;\n    newNode->random = NULL;\n    return newNode;\n}",
      "builders": "typedef struct Node {\n    int val;\n    struct Node* next;\n    struct Node* random;\n} Node;\n\nNode* buildLinkedList(int** arr, int size) {\n    if (size == 0) return NULL;\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->val = arr[0][0];\n    head->next = NULL;\n    head->random = NULL;\n    Node* current = head;\n    Node** nodes = (Node**)malloc(size * sizeof(Node*));\n    nodes[0] = head;\n    for (int i = 1; i < size; i++) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->val = arr[i][0];\n        newNode->next = NULL;\n        newNode->random = NULL;\n        current->next = newNode;\n        current = newNode;\n        nodes[i] = newNode;\n    }\n    current = head;\n    for (int i = 0; i < size; i++) {\n        if (arr[i][1] != -1) {\n            current->random = nodes[arr[i][1]];\n        }\n        current = current->next;\n    }\n    free(nodes);\n    return head;\n}\n\nint** linkedListToArray(Node* head) {\n    if (!head) return NULL;\n    int size = 0;\n    Node* current = head;\n    while (current) {\n        size++;\n        current = current->next;\n    }\n    int** arr = (int**)malloc(size * sizeof(int*));\n    current = head;\n    Node** nodes = (Node**)malloc(size * sizeof(Node*));\n    for (int i = 0; i < size; i++) {\n        arr[i] = (int*)malloc(2 * sizeof(int));\n        arr[i][0] = current->val;\n        nodes[i] = current;\n        current = current->next;\n    }\n    current = head;\n    for (int i = 0; i < size; i++) {\n        if (current->random) {\n            for (int j = 0; j < size; j++) {\n                if (nodes[j] == current->random) {\n                    arr[i][1] = j;\n                    break;\n                }\n            }\n        } else {\n            arr[i][1] = -1;\n        }\n        current = current->next;\n    }\n    free(nodes);\n    return arr;\n}"
    },
    "go": {
      "functionDeclaration": "func CopyListWithRandomPointer(head *Node) *Node {}",
      "testCalls": [
        "if result := CopyListWithRandomPointer(buildList([][]int{{7, -1}, {13, 0}, {11, 4}, {10, 2}, {1, 0}})); !compareLists(result, buildList([][]int{{7, -1}, {13, 0}, {11, 4}, {10, 2}, {1, 0}})) { t.Errorf(\"Test 1 Failed\") }",
        "if result := CopyListWithRandomPointer(buildList([][]int{{1, 1}, {2, 1}})); !compareLists(result, buildList([][]int{{1, 1}, {2, 1}})) { t.Errorf(\"Test 2 Failed\") }",
        "if result := CopyListWithRandomPointer(buildList([][]int{{3, -1}, {3, 0}, {3, -1}})); !compareLists(result, buildList([][]int{{3, -1}, {3, 0}, {3, -1}})) { t.Errorf(\"Test 3 Failed\") }"
      ],
      "compareHelper": "func CompareLists(list1, list2 *Node) bool { for list1 != nil && list2 != nil { if list1.Val != list2.Val || (list1.Random != nil && list2.Random == nil) || (list1.Random == nil && list2.Random != nil) || (list1.Random != nil && list2.Random != nil && list1.Random.Val != list2.Random.Val) { return false } list1 = list1.Next list2 = list2.Next } return list1 == nil && list2 == nil }",
      "helpers": "type Node struct { Val int; Next *Node; Random *Node }\nfunc buildList(arr [][]int) *Node {}\nfunc compareLists(l1 *Node, l2 *Node) bool {}",
      "typeDefs": "type Node struct { Val int; Next *Node; Random *Node }",
      "builders": "func buildList(arr [][]int) *Node {}\nfunc compareLists(l1 *Node, l2 *Node) bool {}"
    },
    "ruby": {
      "functionDeclaration": "def CopyListWithRandomPointer(head)\n  # code here\nend",
      "testCalls": [
        "head = buildLinkedList([[7,nil],[13,0],[11,4],[10,2],[1,0]]); result = CopyListWithRandomPointer(head); raise 'Test Case 1 Failed' unless linkedListToArray(result) == [[7,nil],[13,0],[11,4],[10,2],[1,0]]",
        "head = buildLinkedList([[1,1],[2,1]]); result = CopyListWithRandomPointer(head); raise 'Test Case 2 Failed' unless linkedListToArray(result) == [[1,1],[2,1]]",
        "head = buildLinkedList([[3,nil],[3,0],[3,nil]]); result = CopyListWithRandomPointer(head); raise 'Test Case 3 Failed' unless linkedListToArray(result) == [[3,nil],[3,0],[3,nil]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class Node\n  attr_accessor :val, :next, :random\n  def initialize(val = 0, _next = nil, random = nil)\n    @val = val\n    @next = _next\n    @random = random\n  end\nend\n\ndef buildLinkedList(arr)\n  # Build linked list from array\nend\n\ndef linkedListToArray(head)\n  # Convert linked list to array\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :next, :random\n  def initialize(val = 0, _next = nil, random = nil)\n    @val = val\n    @next = _next\n    @random = random\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  # Build linked list from array\nend\n\ndef linkedListToArray(head)\n  # Convert linked list to array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
        },
        "expected": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[[1,1],[2,1]]"
        },
        "expected": "[[1,1],[2,1]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "head": "[[3,null],[3,0],[3,null]]"
        },
        "expected": "[[3,null],[3,0],[3,null]]"
      }
    ]
  },
  "count-complete-tree-nodes": {
    "title": "Count Complete Tree Nodes",
    "content": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less thanO(n)time complexity.\n\nExample 1:\n\n\nInput: root = [1,2,3,4,5,6]\nOutput: 6\n\nExample 2:\n\nInput: root = []\nOutput: 0\n\nExample 3:\n\nInput: root = [1]\nOutput: 1\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5 * 104].\n0 <= Node.val <= 5 * 104\nThe tree is guaranteed to be complete.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Binary Search",
      "Bit Manipulation",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CountCompleteTreeNodes(root) {}",
      "testCalls": [
        "if(CountCompleteTreeNodes(buildTree([1,2,3,4,5,6])) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(CountCompleteTreeNodes(buildTree([])) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(CountCompleteTreeNodes(buildTree([1])) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length) return null; let build = function(i) { if (i >= arr.length || arr[i] === null) return null; let node = new TreeNode(arr[i]); node.left = build(2 * i + 1); node.right = build(2 * i + 2); return node; }; return build(0); }\nfunction treeToArray(root) { let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n}",
      "builders": "function buildTree(arr) {\n    if (!arr.length) return null;\n    let root = new TreeNode(arr[0]);\n    let queue = [root];\n    let i = 1;\n    while (i < arr.length) {\n        let current = queue.shift();\n        if (arr[i] !== null) {\n            current.left = new TreeNode(arr[i]);\n            queue.push(current.left);\n        }\n        i++;\n        if (i < arr.length && arr[i] !== null) {\n            current.right = new TreeNode(arr[i]);\n            queue.push(current.right);\n        }\n        i++;\n    }\n    return root;\n}\n\nfunction treeToArray(root) {\n    if (!root) return [];\n    let arr = [];\n    let queue = [root];\n    while (queue.length) {\n        let node = queue.shift();\n        if (node) {\n            arr.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            arr.push(null);\n        }\n    }\n    while (arr[arr.length - 1] === null) {\n        arr.pop();\n    }\n    return arr;\n}"
    },
    "typescript": {
      "functionDeclaration": "function CountCompleteTreeNodes(root: number[]): number {}",
      "testCalls": [
        "if(CountCompleteTreeNodes(treeToArray(buildTree([1,2,3,4,5,6]))) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(CountCompleteTreeNodes(treeToArray(buildTree([]))) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(CountCompleteTreeNodes(treeToArray(buildTree([1]))) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction buildTree(arr: number[]): TreeNode | null {\n  if (arr.length === 0) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (i < arr.length) {\n    const current = queue.shift();\n    if (current) {\n      if (i < arr.length && arr[i] !== null) {\n        current.left = new TreeNode(arr[i]);\n        queue.push(current.left);\n      }\n      i++;\n      if (i < arr.length && arr[i] !== null) {\n        current.right = new TreeNode(arr[i]);\n        queue.push(current.right);\n      }\n      i++;\n    }\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): number[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result as number[];\n}"
    },
    "cpp": {
      "functionDeclaration": "int CountCompleteTreeNodes(TreeNode* root)",
      "testCalls": [
        "assert(CountCompleteTreeNodes(createTree({1,2,3,4,5,6})) == 6);",
        "assert(CountCompleteTreeNodes(nullptr) == 0);",
        "assert(CountCompleteTreeNodes(createTree({1})) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* createTree(vector<int> arr) { if (arr.empty()) return nullptr; TreeNode* root = new TreeNode(arr[0]); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "class TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};",
      "builders": "#include <vector>\n#include <queue>\n\nTreeNode* createTree(const std::vector<int>& arr) {\n    if (arr.empty()) return nullptr;\n    TreeNode* root = new TreeNode(arr[0]);\n    std::queue<TreeNode*> queue;\n    queue.push(root);\n    int i = 1;\n    while (i < arr.size()) {\n        TreeNode* current = queue.front();\n        queue.pop();\n        if (i < arr.size() && arr[i] != -1) {\n            current->left = new TreeNode(arr[i]);\n            queue.push(current->left);\n        }\n        i++;\n        if (i < arr.size() && arr[i] != -1) {\n            current->right = new TreeNode(arr[i]);\n            queue.push(current->right);\n        }\n        i++;\n    }\n    return root;\n}\n\nstd::vector<int> treeToArray(TreeNode* root) {\n    if (!root) return {};\n    std::vector<int> result;\n    std::queue<TreeNode*> queue;\n    queue.push(root);\n    while (!queue.empty()) {\n        TreeNode* node = queue.front();\n        queue.pop();\n        if (node) {\n            result.push_back(node->val);\n            queue.push(node->left);\n            queue.push(node->right);\n        } else {\n            result.push_back(-1);\n        }\n    }\n    while (!result.empty() && result.back() == -1) {\n        result.pop_back();\n    }\n    return result;\n}"
    },
    "python": {
      "functionDeclaration": "def CountCompleteTreeNodes(root: List[int]) -> int",
      "testCalls": [
        "assert CountCompleteTreeNodes(buildTree([1,2,3,4,5,6])) == 6",
        "assert CountCompleteTreeNodes(buildTree([])) == 0",
        "assert CountCompleteTreeNodes(buildTree([1])) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int countCompleteTreeNodes(TreeNode root)",
      "testCalls": [
        "assertEquals(6, countCompleteTreeNodes(buildTree(new Integer[]{1,2,3,4,5,6}));",
        "assertEquals(0, countCompleteTreeNodes(null));",
        "assertEquals(1, countCompleteTreeNodes(buildTree(new Integer[]{1}));"
      ],
      "compareHelper": "private static void assertEquals(int expected, int actual) {\n    if (expected != actual) {\n        throw new AssertionError(\"Expected: \" + expected + \", but was: \" + actual);\n    }\n}",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic static int countCompleteTreeNodes(TreeNode root) {}\n",
      "typeDefs": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}",
      "builders": "public static int countCompleteTreeNodes(TreeNode root) {\n    if (root == null) return 0;\n    int leftDepth = getDepth(root.left);\n    int rightDepth = getDepth(root.right);\n    if (leftDepth == rightDepth) {\n        return (1 << leftDepth) + countCompleteTreeNodes(root.right);\n    } else {\n        return (1 << rightDepth) + countCompleteTreeNodes(root.left);\n    }\n}\n\nprivate static int getDepth(TreeNode node) {\n    int depth = 0;\n    while (node != null) {\n        depth++;\n        node = node.left;\n    }\n    return depth;\n}"
    },
    "c": {
      "functionDeclaration": "int CountCompleteTreeNodes(struct TreeNode* root)",
      "testCalls": [
        "assert(CountCompleteTreeNodes(buildTree((int[]){1, 2, 3, 4, 5, 6}, 6)) == 6);",
        "assert(CountCompleteTreeNodes(NULL) == 0);",
        "assert(CountCompleteTreeNodes(buildTree((int[]){1}, 1)) == 1);"
      ],
      "compareHelper": "int* createTreeFromArray(int arr[], int size) { /* implementation here */ }",
      "helpers": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\nTreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func CountCompleteTreeNodes(root *TreeNode) int {}",
      "testCalls": [
        "if CountCompleteTreeNodes(buildTree([]int{1,2,3,4,5,6})) != 6 {panic(\"Test case 1 failed\")}",
        "if CountCompleteTreeNodes(nil) != 0 {panic(\"Test case 2 failed\")}",
        "if CountCompleteTreeNodes(buildTree([]int{1})) != 1 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": "",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn CountCompleteTreeNodes(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "let root = build_tree(&[1,2,3,4,5,6]); assert_eq!(CountCompleteTreeNodes(Some(Box::new(root))), 6);",
        "let root = None; assert_eq!(CountCompleteTreeNodes(root), 0);",
        "let root = build_tree(&[1]); assert_eq!(CountCompleteTreeNodes(Some(Box::new(root))), 1);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<TreeNode>>, \n    pub right: Option<Rc<TreeNode>>, \n}\n\nfn build_tree(arr: &[i32]) -> Option<Rc<TreeNode>> {}\n\nfn tree_to_array(root: Option<Rc<TreeNode>>) -> Vec<i32> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<TreeNode>>, \n    pub right: Option<Rc<TreeNode>>, \n}",
      "builders": "fn build_tree(arr: &[i32]) -> Option<Rc<TreeNode>> {}\n\nfn tree_to_array(root: Option<Rc<TreeNode>>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def CountCompleteTreeNodes(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,4,5,6]); result = CountCompleteTreeNodes(root); assert_equal(6, result)",
        "root = buildTree([]); result = CountCompleteTreeNodes(root); assert_equal(0, result)",
        "root = buildTree([1]); result = CountCompleteTreeNodes(root); assert_equal(1, result)"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(arr)\n  # Build binary tree from array\nend\n\ndef treeToArray(root)\n  # Convert binary tree to array\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Build binary tree from array\nend\n\ndef treeToArray(root)\n  # Convert binary tree to array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3,4,5,6]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[]"
        },
        "expected": "0"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[1]"
        },
        "expected": "1"
      }
    ]
  },
  "course-schedule-ii": {
    "title": "Course Schedule II",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nai != bi\nAll the pairs [ai, bi] are distinct.\n\n",
    "difficulty": "Medium",
    "hints": [
      "This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
      "<a href=\"https://www.youtube.com/watch?v=ozso3xxkVGU\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.",
      "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
    ],
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CourseScheduleII(numCourses, prerequisites) {}",
      "testCalls": [
        "let testInput1 = buildGraph(2, [[1,0]]); const testOutput1 = CourseScheduleII(2, testInput1); if(JSON.stringify(testOutput1) !== '[0,1]') { throw new Error('Test Case 1 Failed'); }",
        "let testInput2 = buildGraph(4, [[1,0],[2,0],[3,1],[3,2]]); const testOutput2 = CourseScheduleII(4, testInput2); if(JSON.stringify(testOutput2) !== '[0,2,1,3]') { throw new Error('Test Case 2 Failed'); }",
        "let testInput3 = buildGraph(1, []); const testOutput3 = CourseScheduleII(1, testInput3); if(JSON.stringify(testOutput3) !== '[0]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function buildGraph(numCourses, prerequisites) { let graph = Array.from({ length: numCourses }, () => []); for (let [course, prereq] of prerequisites) { graph[course].push(prereq); } return graph; }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses, prerequisites) {\n    const graph = Array.from({ length: numCourses }, () => []);\n    const indegree = Array(numCourses).fill(0);\n    for (const [course, prereq] of prerequisites) {\n        graph[prereq].push(course);\n        indegree[course]++;\n    }\n    return { graph, indegree };\n}\n\nfunction findOrder(numCourses, prerequisites) {\n    const { graph, indegree } = buildGraph(numCourses, prerequisites);\n    const order = [];\n    const queue = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (indegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n    while (queue.length > 0) {\n        const course = queue.shift();\n        order.push(course);\n        for (const nextCourse of graph[course]) {\n            indegree[nextCourse]--;\n            if (indegree[nextCourse] === 0) {\n                queue.push(nextCourse);\n            }\n        }\n    }\n    return order.length === numCourses ? order : [];\n}"
    },
    "typescript": {
      "functionDeclaration": "function CourseScheduleII(numCourses: number, prerequisites: number[][]): number[]",
      "testCalls": [
        "let result1 = CourseScheduleII(2, buildGraph(2, [[1,0]])); if(JSON.stringify(result1) !== JSON.stringify([0,1])) throw new Error('Test Case 1 Failed');",
        "let result2 = CourseScheduleII(4, buildGraph(4, [[1,0],[2,0],[3,1],[3,2]])); if(JSON.stringify(result2) !== JSON.stringify([0,2,1,3])) throw new Error('Test Case 2 Failed');",
        "let result3 = CourseScheduleII(1, buildGraph(1, [])); if(JSON.stringify(result3) !== JSON.stringify([0])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function buildGraph(numCourses: number, prerequisites: number[][]): Map<number, number[]> { const graph = new Map(); for (let i = 0; i < numCourses; i++) { graph.set(i, []); } for (const [course, prereq] of prerequisites) { graph.get(course).push(prereq); } return graph; }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses: number, prerequisites: number[][]): Map<number, number[]> {\n  const graph = new Map<number, number[]>();\n  for (let i = 0; i < numCourses; i++) {\n    graph.set(i, []);\n  }\n  for (const [course, prereq] of prerequisites) {\n    graph.get(prereq)?.push(course);\n  }\n  return graph;\n}"
    },
    "cpp": {
      "functionDeclaration": "vector<int> CourseScheduleII(int numCourses, vector<vector<int>>& prerequisites);",
      "testCalls": [
        "assert(CourseScheduleII(2, buildGraph(2, {{1,0}})) == vector<int>({0,1}));",
        "assert(CourseScheduleII(4, buildGraph(4, {{1,0},{2,0},{3,1},{3,2}})) == vector<int>({0,2,1,3}));",
        "assert(CourseScheduleII(1, buildGraph(1, {})) == vector<int>({0}));"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "helpers": "struct GraphNode { int val; vector<GraphNode*> neighbors; }; \nGraphNode* buildGraph(int numCourses, vector<vector<int>>& prerequisites) { vector<GraphNode*> nodes(numCourses); for (int i = 0; i < numCourses; ++i) nodes[i] = new GraphNode({i, {}}); for (auto& pre : prerequisites) { nodes[pre[1]]->neighbors.push_back(nodes[pre[0]]); } return nodes[0]; }",
      "typeDefs": "struct GraphNode {\n  int course;\n  vector<int> prerequisites;\n  GraphNode(int c) : course(c) {}\n};",
      "builders": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nGraphNode* buildGraph(int numCourses, vector<vector<int>>& prerequisites) {\n  unordered_map<int, GraphNode*> graph;\n  for (int i = 0; i < numCourses; ++i) {\n    graph[i] = new GraphNode(i);\n  }\n  for (const auto& pair : prerequisites) {\n    int course = pair[0];\n    int prereq = pair[1];\n    graph[prereq]->prerequisites.push_back(course);\n  }\n  return graph[0]; // Return the first node as an entry point\n}"
    },
    "python": {
      "functionDeclaration": "def CourseScheduleII(numCourses, prerequisites):",
      "testCalls": [
        "graph = buildGraph(2, [[1,0]])\nresult = CourseScheduleII(graph)\nassert result == [0, 1], 'Test Case 1 Failed'",
        "graph = buildGraph(4, [[1,0],[2,0],[3,1],[3,2]])\nresult = CourseScheduleII(graph)\nassert result == [0, 2, 1, 3], 'Test Case 2 Failed'",
        "graph = buildGraph(1, [])\nresult = CourseScheduleII(graph)\nassert result == [0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)",
      "helpers": "class Graph:\n    def __init__(self, numCourses):\n        self.numCourses = numCourses\n        self.adj_list = {i: [] for i in range(numCourses)}\n\n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n\ndef buildGraph(numCourses, prerequisites):\n    graph = Graph(numCourses)\n    for course in prerequisites:\n        graph.add_edge(course[1], course[0])\n    return graph\n",
      "typeDefs": "class Graph:\n    def __init__(self, numCourses): ...",
      "builders": "def buildGraph(numCourses, prerequisites): ..."
    },
    "java": {
      "functionDeclaration": "public int[] CourseScheduleII(int numCourses, int[][] prerequisites) {}",
      "testCalls": [
        "int[] result = CourseScheduleII(2, new int[][]{{1,0}}); if (!Arrays.equals(result, new int[]{0, 1})) throw new AssertionError();",
        "int[] result = CourseScheduleII(4, new int[][]{{1,0},{2,0},{3,1},{3,2}}); if (!Arrays.equals(result, new int[]{0, 2, 1, 3})) throw new AssertionError();",
        "int[] result = CourseScheduleII(1, new int[][]{}); if (!Arrays.equals(result, new int[]{0})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}",
      "helpers": "public class Course { int courseNum; List<Course> prerequisites; public Course(int courseNum) { this.courseNum = courseNum; this.prerequisites = new ArrayList<>(); } }\npublic Course buildGraph(int numCourses, int[][] prerequisites) { Course[] courses = new Course[numCourses]; for (int i = 0; i < numCourses; i++) { courses[i] = new Course(i); } for (int[] prerequisite : prerequisites) { courses[prerequisite[0]].prerequisites.add(courses[prerequisite[1]]); } return courses; }\npublic int[] courseScheduleII(int numCourses, int[][] prerequisites) {}",
      "typeDefs": "public class Course { int courseNum; List<Course> prerequisites; public Course(int courseNum) { this.courseNum = courseNum; this.prerequisites = new ArrayList<>(); } }",
      "builders": "public Course buildGraph(int numCourses, int[][] prerequisites) { Course[] courses = new Course[numCourses]; for (int i = 0; i < numCourses; i++) { courses[i] = new Course(i); } for (int[] prerequisite : prerequisites) { courses[prerequisite[0]].prerequisites.add(courses[prerequisite[1]]); } return courses; }\npublic int[] courseScheduleII(int numCourses, int[][] prerequisites) {}"
    },
    "c": {
      "functionDeclaration": "int* CourseScheduleII(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize)",
      "testCalls": [
        "int numCourses1 = 2; int prerequisites1[][2] = {{1,0}}; CourseNode* graph1 = buildGraph(numCourses1, prerequisites1, 1); int* result1 = CourseScheduleII(numCourses1, prerequisites1, 1, (int[]){2}); if (compareArrays(result1, (int[]){0,1}, 2) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int numCourses2 = 4; int prerequisites2[][2] = {{1,0},{2,0},{3,1},{3,2}}; CourseNode* graph2 = buildGraph(numCourses2, prerequisites2, 4); int* result2 = CourseScheduleII(numCourses2, prerequisites2, 4, (int[]){2,2,2,2}); if (compareArrays(result2, (int[]){0,2,1,3}, 4) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return -1; } return 0; }",
      "helpers": "typedef struct { int val; int* neighbors; int numNeighbors; } CourseNode;\nCourseNode* buildGraph(int numCourses, int** prerequisites, int prerequisitesSize);\nint* CourseScheduleII(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize);",
      "typeDefs": "typedef struct { int val; int* neighbors; int numNeighbors; } CourseNode;",
      "builders": "CourseNode* buildGraph(int numCourses, int** prerequisites, int prerequisitesSize);\nint* CourseScheduleII(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize);"
    },
    "go": {
      "functionDeclaration": "func CourseScheduleII(numCourses int, prerequisites [][]int) []int {}",
      "testCalls": [
        "let graph := buildGraph(2, [][]int{{1,0}}); if !compareArrays(CourseScheduleII(2, graph), []int{0,1}) { panic(\"Test Case 1 Failed\") }",
        "let graph := buildGraph(4, [][]int{{1,0},{2,0},{3,1},{3,2}}); if !compareArrays(CourseScheduleII(4, graph), []int{0,2,1,3}) { panic(\"Test Case 2 Failed\") }",
        "let graph := buildGraph(1, [][]int{}); if !compareArrays(CourseScheduleII(1, graph), []int{0}) { panic(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {}",
      "helpers": "type Graph map[int][]int\n\nfunc buildGraph(numCourses int, prerequisites [][]int) Graph {}\n\nfunc compareArrays(arr1, arr2 []int) bool {}",
      "typeDefs": "type Graph map[int][]int",
      "builders": "func buildGraph(numCourses int, prerequisites [][]int) Graph {}\n\nfunc compareArrays(arr1, arr2 []int) bool {}"
    },
    "rust": {
      "functionDeclaration": "fn CourseScheduleII(numCourses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {}",
      "testCalls": [
        "let course1 = buildCourse(2, vec![vec![1, 0]]); assert_eq!(courseToArray(CourseScheduleII(course1)), (2, vec![vec![0, 1]]));",
        "let course2 = buildCourse(4, vec![vec![1, 0], vec![2, 0], vec![3, 1], vec![3, 2]]); assert_eq!(courseToArray(CourseScheduleII(course2)), (4, vec![vec![0, 2], vec![1, 3], vec![2, 3]]));",
        "let course3 = buildCourse(1, vec![]); assert_eq!(courseToArray(CourseScheduleII(course3)), (1, vec![]));"
      ],
      "compareHelper": "",
      "helpers": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }\nfn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }",
      "typeDefs": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }",
      "builders": "fn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }"
    },
    "ruby": {
      "functionDeclaration": "def CourseScheduleII(numCourses, prerequisites)\n  \nend",
      "testCalls": [
        "graph = Graph.new\ngraph.add_edge(1, 0)\nresult = CourseScheduleII(2, graph.adj_list)\nraise 'Test Case 1 Failed' unless result == [0, 1]",
        "graph = Graph.new\ngraph.add_edge(1, 0)\ngraph.add_edge(2, 0)\ngraph.add_edge(3, 1)\ngraph.add_edge(3, 2)\nresult = CourseScheduleII(4, graph.adj_list)\nraise 'Test Case 2 Failed' unless result == [0, 2, 1, 3]"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend",
      "helpers": "class Graph\n  attr_accessor :adj_list\n  def initialize\n    @adj_list = {}\n  end\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\nend\n",
      "typeDefs": "class Graph\n  attr_accessor :adj_list\n  def initialize\n    @adj_list = {}\n  end\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\nend\n",
      "builders": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "numCourses": "2",
          "prerequisites": "[[1,0]]"
        },
        "expected": "[0,1]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "numCourses": "4",
          "prerequisites": "[[1,0],[2,0],[3,1],[3,2]]"
        },
        "expected": "[0,2,1,3]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "numCourses": "1",
          "prerequisites": "[]"
        },
        "expected": "[0]"
      }
    ]
  },
  "course-schedule": {
    "title": "Course Schedule",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\nExample 2:\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.\n\n",
    "difficulty": "Medium",
    "hints": [
      "This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
      "<a href=\"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf\" target=\"_blank\">Topological Sort via DFS</a> - A great tutorial explaining the basic concepts of Topological Sort.",
      "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
    ],
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CourseSchedule(numCourses, prerequisites) {}",
      "testCalls": [
        "let testInput1 = buildGraph(2, [[1,0]]); if (CourseSchedule(2, testInput1) !== true) { throw new Error('Test Case 1 Failed'); }",
        "let testInput2 = buildGraph(2, [[1,0],[0,1]]); if (CourseSchedule(2, testInput2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function buildGraph(numCourses, prerequisites) { let graph = Array.from({ length: numCourses }, () => []); for (let [course, prereq] of prerequisites) { graph[course].push(prereq); } return graph; }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses, prerequisites) { let graph = Array.from({ length: numCourses }, () => []); for (let [course, prereq] of prerequisites) { graph[course].push(prereq); } return graph; }"
    },
    "typescript": {
      "functionDeclaration": "function CourseSchedule(numCourses: number, prerequisites: number[][]): boolean {}",
      "testCalls": [
        "let result1 = CourseSchedule(2, buildGraph(2, [[1,0]])); if(result1 !== true) throw new Error('Test Case 1 Failed');",
        "let result2 = CourseSchedule(2, buildGraph(2, [[1,0],[0,1]])); if(result2 !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function buildGraph(numCourses: number, prerequisites: number[][]): Map<number, number[]> { const graph = new Map(); for (let i = 0; i < numCourses; i++) { graph.set(i, []); } for (const [course, prereq] of prerequisites) { graph.get(course).push(prereq); } return graph; }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses: number, prerequisites: number[][]): Map<number, number[]> { const graph = new Map(); for (let i = 0; i < numCourses; i++) { graph.set(i, []); } for (const [course, prereq] of prerequisites) { graph.get(course).push(prereq); } return graph; }"
    },
    "cpp": {
      "functionDeclaration": "bool CourseSchedule(int numCourses, vector<vector<int>>& prerequisites);",
      "testCalls": [
        "if (CourseSchedule(2, buildGraph(2, {{1,0}})) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (CourseSchedule(2, buildGraph(2, {{1,0},{0,1}})) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }",
      "helpers": "struct GraphNode { int val; vector<GraphNode*> neighbors; }; \nGraphNode* buildGraph(int numCourses, vector<vector<int>>& prerequisites) { vector<GraphNode*> nodes(numCourses); for (int i = 0; i < numCourses; ++i) nodes[i] = new GraphNode({i, {}}); for (auto& pre : prerequisites) { nodes[pre[1]]->neighbors.push_back(nodes[pre[0]]); } return nodes[0]; }",
      "typeDefs": "struct GraphNode { int val; vector<GraphNode*> neighbors; };",
      "builders": "GraphNode* buildGraph(int numCourses, vector<vector<int>>& prerequisites) { vector<GraphNode*> nodes(numCourses); for (int i = 0; i < numCourses; ++i) nodes[i] = new GraphNode({i, {}}); for (auto& pre : prerequisites) { nodes[pre[1]]->neighbors.push_back(nodes[pre[0]]); } return nodes[0]; }"
    },
    "python": {
      "functionDeclaration": "def CourseSchedule(numCourses, prerequisites):",
      "testCalls": [
        "graph = buildGraph(2, [[1,0]])\nresult = CourseSchedule(graph)\nassert result == True, 'Test Case 1 Failed'",
        "graph = buildGraph(2, [[1,0],[0,1]])\nresult = CourseSchedule(graph)\nassert result == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": "",
      "helpers": "class Graph:\n    def __init__(self, numCourses):\n        self.numCourses = numCourses\n        self.adj_list = {i: [] for i in range(numCourses)}\n\n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n\ndef buildGraph(numCourses, prerequisites):\n    graph = Graph(numCourses)\n    for course in prerequisites:\n        graph.add_edge(course[1], course[0])\n    return graph\n",
      "typeDefs": "class Graph:\n    def __init__(self, numCourses):\n        self.numCourses = numCourses\n        self.adj_list = {i: [] for i in range(numCourses)}\n\n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n",
      "builders": "def buildGraph(numCourses, prerequisites):\n    graph = Graph(numCourses)\n    for course in prerequisites:\n        graph.add_edge(course[1], course[0])\n    return graph\n"
    },
    "java": {
      "functionDeclaration": "public boolean CourseSchedule(int numCourses, int[][] prerequisites) {}",
      "testCalls": [
        "if (!CourseSchedule(2, new int[][]{{1,0}})) throw new AssertionError();",
        "if (CourseSchedule(2, new int[][]{{1,0},{0,1}})) throw new AssertionError();"
      ],
      "compareHelper": "Arrays.deepEquals(expectedArray, actualArray)",
      "helpers": "public class Course { int courseNum; List<Course> prerequisites; public Course(int courseNum) { this.courseNum = courseNum; this.prerequisites = new ArrayList<>(); } }\npublic Course buildGraph(int numCourses, int[][] prerequisites) { Course[] courses = new Course[numCourses]; for (int i = 0; i < numCourses; i++) { courses[i] = new Course(i); } for (int[] prerequisite : prerequisites) { courses[prerequisite[0]].prerequisites.add(courses[prerequisite[1]]); } return courses; }\npublic boolean courseSchedule(int numCourses, int[][] prerequisites) {}",
      "typeDefs": "public class Course { int courseNum; List<Course> prerequisites; public Course(int courseNum) { this.courseNum = courseNum; this.prerequisites = new ArrayList<>(); } }",
      "builders": "public Course buildGraph(int numCourses, int[][] prerequisites) { Course[] courses = new Course[numCourses]; for (int i = 0; i < numCourses; i++) { courses[i] = new Course(i); } for (int[] prerequisite : prerequisites) { courses[prerequisite[0]].prerequisites.add(courses[prerequisite[1]]); } return courses; }\npublic boolean courseSchedule(int numCourses, int[][] prerequisites) {}"
    },
    "c": {
      "functionDeclaration": "bool CourseSchedule(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize)",
      "testCalls": [
        "int numCourses1 = 2; int prerequisites1[][2] = {{1,0}}; CourseNode* graph1 = buildGraph(numCourses1, prerequisites1, 1); if (!CourseSchedule(numCourses1, prerequisites1, 1, (int[]){2})) { printf(\"Test Case 1 Failed\"); }",
        "int numCourses2 = 2; int prerequisites2[][2] = {{1,0},{0,1}}; CourseNode* graph2 = buildGraph(numCourses2, prerequisites2, 2); if (CourseSchedule(numCourses2, prerequisites2, 2, (int[]){2,2})) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "helpers": "typedef struct { int val; int* neighbors; int numNeighbors; } CourseNode;\nCourseNode* buildGraph(int numCourses, int** prerequisites, int prerequisitesSize);\nbool CourseSchedule(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize);",
      "typeDefs": "typedef struct { int val; int* neighbors; int numNeighbors; } CourseNode;",
      "builders": "CourseNode* buildGraph(int numCourses, int** prerequisites, int prerequisitesSize);\nbool CourseSchedule(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize);"
    },
    "go": {
      "functionDeclaration": "func CourseSchedule(numCourses int, prerequisites [][]int) bool {}",
      "testCalls": [
        "let graph := buildGraph(2, [][]int{{1,0}}); if CourseSchedule(2, graph) != true { panic(\"Test case 1 failed\") }",
        "let graph := buildGraph(2, [][]int{{1,0},{0,1}}); if CourseSchedule(2, graph) != false { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {}",
      "helpers": "type Graph map[int][]int\n\nfunc buildGraph(numCourses int, prerequisites [][]int) Graph {}\n\nfunc compareArrays(arr1, arr2 []int) bool {}",
      "typeDefs": "",
      "builders": "func buildGraph(numCourses int, prerequisites [][]int) Graph {}\n\nfunc compareArrays(arr1, arr2 []int) bool {}"
    },
    "rust": {
      "functionDeclaration": "fn CourseSchedule(numCourses: i32, prerequisites: Vec<Vec<i32>>) -> bool {}",
      "testCalls": [
        "let course1 = buildCourse(2, vec![vec![1, 0]]); assert_eq!(courseToArray(CourseSchedule(course1)), (2, vec![vec![0, 1]]));",
        "let course2 = buildCourse(2, vec![vec![1, 0], vec![0, 1]]); assert_eq!(courseToArray(CourseSchedule(course2)), (2, vec![vec![0, 1]]));"
      ],
      "compareHelper": "",
      "helpers": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }\nfn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }",
      "typeDefs": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }",
      "builders": "fn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }"
    },
    "ruby": {
      "functionDeclaration": "def CourseSchedule(numCourses, prerequisites)\nend",
      "testCalls": [
        "graph = Graph.new\ngraph.add_edge(1, 0)\nresult = CourseSchedule(2, graph.adj_list)\nraise 'Test Case 1 Failed' unless result == true",
        "graph = Graph.new\ngraph.add_edge(1, 0)\ngraph.add_edge(0, 1)\nresult = CourseSchedule(2, graph.adj_list)\nraise 'Test Case 2 Failed' unless result == false"
      ],
      "compareHelper": "",
      "helpers": "class Graph\n  attr_accessor :adj_list\n  def initialize\n    @adj_list = {}\n  end\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\nend\n",
      "typeDefs": "class Graph\n  attr_accessor :adj_list\n  def initialize\n    @adj_list = {}\n  end\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\nend\n",
      "builders": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "numCourses": "2",
          "prerequisites": "[[1,0]]"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "numCourses": "2",
          "prerequisites": "[[1,0],[0,1]]"
        },
        "expected": "false"
      }
    ]
  },
  "edit-distance": {
    "title": "Edit Distance",
    "content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n\n\nExample 1:\n\nInput: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\nOutput: 3\nExplanation: \nhorse -> rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -> rose (remove &#39;r&#39;)\nrose -> ros (remove &#39;e&#39;)\n\nExample 2:\n\nInput: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\nOutput: 5\nExplanation: \nintention -> inention (remove &#39;t&#39;)\ninention -> enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -> exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -> exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -> execution (insert &#39;u&#39;)\n\n\nConstraints:\n\n0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EditDistance(word1, word2) {}",
      "testCalls": [
        "if(EditDistance('horse', 'ros') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(EditDistance('intention', 'execution') !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function EditDistance(word1: string, word2: string): number {}",
      "testCalls": [
        "if (EditDistance('horse', 'ros') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (EditDistance('intention', 'execution') !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int EditDistance(string word1, string word2);",
      "testCalls": [
        "if (EditDistance(\"horse\", \"ros\") != 3) throw std::runtime_error(\"Test 1 failed!\");",
        "if (EditDistance(\"intention\", \"execution\") != 5) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def EditDistance(word1: str, word2: str) -> int:",
      "testCalls": [
        "assert EditDistance(\"horse\", \"ros\") == 3",
        "assert EditDistance(\"intention\", \"execution\") == 5"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int EditDistance(String word1, String word2) { }",
      "testCalls": [
        "if (EditDistance(\"horse\", \"ros\") != 3) { throw new AssertionError(); }",
        "if (EditDistance(\"intention\", \"execution\") != 5) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int EditDistance(char* word1, char* word2)",
      "testCalls": [
        "EditDistance(\"horse\", \"ros\")",
        "EditDistance(\"intention\", \"execution\")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func EditDistance(word1 string, word2 string) int {}",
      "testCalls": [
        "if EditDistance(\"horse\", \"ros\") != 3 { t.Error(\"Test Case 1 Failed\") }",
        "if EditDistance(\"intention\", \"execution\") != 5 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn EditDistance(word1: String, word2: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(EditDistance(String::from(\"horse\"), String::from(\"ros\")), 3);",
        "assert_eq!(EditDistance(String::from(\"intention\"), String::from(\"execution\")), 5);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EditDistance(word1, word2)\nend",
      "testCalls": [
        "test1 = EditDistance(\"horse\", \"ros\")\nraise 'Test Case 1 Failed' unless test1 == 3",
        "test2 = EditDistance(\"intention\", \"execution\")\nraise 'Test Case 2 Failed' unless test2 == 5"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "word1": "&quot;horse&quot;",
          "word2": "&quot;ros&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "word1": "&quot;intention&quot;",
          "word2": "&quot;execution&quot;"
        },
        "expected": "5"
      }
    ]
  },
  "evaluate-division": {
    "title": "Evaluate Division",
    "content": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote:The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\nExample 1:\n\nInput: equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\nExplanation: \nGiven: a / b = 2.0, b / c = 3.0\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\nExample 2:\n\nInput: equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\nOutput: [3.75000,0.40000,5.00000,0.20000]\n\nExample 3:\n\nInput: equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\n\n\nConstraints:\n\n1 <= equations.length <= 20\nequations[i].length == 2\n1 <= Ai.length, Bi.length <= 5\nvalues.length == equations.length\n0.0 < values[i] <= 20.0\n1 <= queries.length <= 20\nqueries[i].length == 2\n1 <= Cj.length, Dj.length <= 5\nAi, Bi, Cj, Dj consist of lower case English letters and digits.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Do you recognize this as a graph problem?"
    ],
    "topicTags": [
      "Array",
      "String",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph",
      "Shortest Path"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EvaluateDivision(equations, values, queries) {}",
      "testCalls": [
        "let graph1 = buildGraph([['a','b'],['b','c']], [2.0,3.0]); const testOutput1 = EvaluateDivision(graph1, [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]); if(JSON.stringify(testOutput1) !== '[6.00000,0.50000,-1.00000,1.00000,-1.00000]') throw new Error('Test Case 1 Failed');",
        "let graph2 = buildGraph([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0]); const testOutput2 = EvaluateDivision(graph2, [['a','c'],['c','b'],['bc','cd'],['cd','bc']]); if(JSON.stringify(testOutput2) !== '[3.75000,0.40000,5.00000,0.20000]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function buildGraph(equations, values) { let graph = {}; for (let i = 0; i < equations.length; i++) { const [from, to] = equations[i]; const value = values[i]; if (!graph[from]) graph[from] = {}; if (!graph[to]) graph[to] = {}; graph[from][to] = value; graph[to][from] = 1 / value; } return graph; }",
      "typeDefs": "",
      "builders": "function buildGraph(equations, values) { let graph = {}; for (let i = 0; i < equations.length; i++) { const [from, to] = equations[i]; const value = values[i]; if (!graph[from]) graph[from] = {}; if (!graph[to]) graph[to] = {}; graph[from][to] = value; graph[to][from] = 1 / value; } return graph; }"
    },
    "typescript": {
      "functionDeclaration": "function EvaluateDivision(equations: string[][], values: number[], queries: string[][]): number[] {}",
      "testCalls": [
        "const test1 = EvaluateDivision([['a','b'],['b','c']], [2.0,3.0], [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]);\nif(JSON.stringify(test1) !== '[6.00000,0.50000,-1.00000,1.00000,-1.00000]') throw new Error('Test Case 1 Failed');",
        "const test2 = EvaluateDivision([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0], [['a','c'],['c','b'],['bc','cd'],['cd','bc']]);\nif(JSON.stringify(test2) !== '[3.75000,0.40000,5.00000,0.20000]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "const compareArrays = (arr1: any[], arr2: any[]): boolean => JSON.stringify(arr1) === JSON.stringify(arr2);",
      "helpers": "type Equation = [string, string];\ntype Query = [string, string];\nfunction buildGraph(equations: string[][], values: number[]): Map<string, Map<string, number>> {}\nfunction dfs(graph: Map<string, Map<string, number>>, start: string, end: string, visited: Set<string>): number {}\nfunction EvaluateDivision(equations: string[][], values: number[], queries: string[][]): number[] {}",
      "typeDefs": "type Equation = [string, string];\ntype Query = [string, string];",
      "builders": "function buildGraph(equations: string[][], values: number[]): Map<string, Map<string, number>> {}\nfunction dfs(graph: Map<string, Map<string, number>>, start: string, end: string, visited: Set<string>): number {}\nfunction EvaluateDivision(equations: string[][], values: number[], queries: string[][]): number[] {}"
    },
    "cpp": {
      "functionDeclaration": "vector<double> EvaluateDivision(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries)",
      "testCalls": [
        "vector<vector<string>> equations1 = {{\"a\", \"b\"}, {\"b\", \"c\"}}; vector<double> values1 = {2.0, 3.0}; vector<vector<string>> queries1 = {{\"a\", \"c\"}, {\"b\", \"a\"}, {\"a\", \"e\"}, {\"a\", \"a\"}, {\"x\", \"x\"}}; vector<double> result1 = EvaluateDivision(equations1, values1, queries1); assert(abs(result1[0] - 6.0) < 1e-5 && abs(result1[1] - 0.5) < 1e-5 && result1[2] == -1.0 && result1[3] == 1.0 && result1[4] == -1.0);",
        "vector<vector<string>> equations2 = {{\"a\", \"b\"}, {\"b\", \"c\"}, {\"bc\", \"cd\"}}; vector<double> values2 = {1.5, 2.5, 5.0}; vector<vector<string>> queries2 = {{\"a\", \"c\"}, {\"c\", \"b\"}, {\"bc\", \"cd\"}, {\"cd\", \"bc\"}}; vector<double> result2 = EvaluateDivision(equations2, values2, queries2); assert(abs(result2[0] - 3.75) < 1e-5 && abs(result2[1] - 0.4) < 1e-5 && result2[2] == 5.0 && abs(result2[3] - 0.2) < 1e-5);",
        "vector<vector<string>> equations3 = {{\"a\", \"b\"}}; vector<double> values3 = {0.5}; vector<vector<string>> queries3 = {{\"a\", \"b\"}, {\"b\", \"a\"}, {\"a\", \"c\"}, {\"x\", \"y\"}}; vector<double> result3 = EvaluateDivision(equations3, values3, queries3); assert(abs(result3[0] - 0.5) < 1e-5 && abs(result3[1] - 2.0) < 1e-5 && result3[2] == -1.0 && result3[3] == -1.0);"
      ],
      "compareHelper": "",
      "helpers": "struct UnionFind { vector<int> parent; vector<double> weight; UnionFind(int n) : parent(n), weight(n, 1.0) { iota(parent.begin(), parent.end(), 0); } int find(int x) { if (x != parent[x]) { int origin = parent[x]; parent[x] = find(parent[x]); weight[x] *= weight[origin]; } return parent[x]; } void unite(int x, int y, double val) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return; parent[rootX] = rootY; weight[rootX] = weight[y] * val / weight[x]; } double query(int x, int y) { if (find(x) != find(y)) return -1.0; return weight[x] / weight[y]; } };",
      "typeDefs": "struct UnionFind { vector<int> parent; vector<double> weight; UnionFind(int n) : parent(n), weight(n, 1.0) { iota(parent.begin(), parent.end(), 0); } int find(int x) { if (x != parent[x]) { int origin = parent[x]; parent[x] = find(parent[x]); weight[x] *= weight[origin]; } return parent[x]; } void unite(int x, int y, double val) { int rootX = find(x), rootY = find(y); if (rootX == rootY) return; parent[rootX] = rootY; weight[rootX] = weight[y] * val / weight[x]; } double query(int x, int y) { if (find(x) != find(y)) return -1.0; return weight[x] / weight[y]; } };",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def EvaluateDivision(equations, values, queries):",
      "testCalls": [
        "assert EvaluateDivision([['a','b'],['b','c']], [2.0,3.0], [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]) == [6.00000,0.50000,-1.00000,1.00000,-1.00000]",
        "assert EvaluateDivision([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0], [['a','c'],['c','b'],['bc','cd'],['cd','bc']]) == [3.75000,0.40000,5.00000,0.20000]",
        "assert EvaluateDivision([['a','b']], [0.5], [['a','b'],['b','a'],['a','c'],['x','y']]) == [0.50000,2.00000,-1.00000,-1.00000]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if abs(arr1[i] - arr2[i]) > 0.00001:\n            return False\n    return True",
      "helpers": "class UnionFind:\n    def __init__(self):\n        self.parent = {}\n        self.weight = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.weight[x] = 1.0\n        elif self.parent[x] != x:\n            p, w = self.find(self.parent[x])\n            self.parent[x] = p\n            self.weight[x] *= w\n        return self.parent[x], self.weight[x]\n\n    def union(self, x, y, val):\n        px, wx = self.find(x)\n        py, wy = self.find(y)\n        if px != py:\n            self.parent[px] = py\n            self.weight[px] = val * wy / wx\n\n\ndef EvaluateDivision(equations, values, queries):\n    def helper(x, y):\n        if x not in uf.parent or y not in uf.parent:\n            return -1.0\n        px, wx = uf.find(x)\n        py, wy = uf.find(y)\n        if px != py:\n            return -1.0\n        return wx / wy\n\n    uf = UnionFind()\n    for (x, y), val in zip(equations, values):\n        uf.union(x, y, val)\n    return [helper(x, y) for x, y in queries]",
      "typeDefs": "class UnionFind:\n    def __init__(self):\n        self.parent = {}\n        self.weight = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.weight[x] = 1.0\n        elif self.parent[x] != x:\n            p, w = self.find(self.parent[x])\n            self.parent[x] = p\n            self.weight[x] *= w\n        return self.parent[x], self.weight[x]\n\n    def union(self, x, y, val):\n        px, wx = self.find(x)\n        py, wy = self.find(y)\n        if px != py:\n            self.parent[px] = py\n            self.weight[px] = val * wy / wx\n\n",
      "builders": "def EvaluateDivision(equations, values, queries):\n    def helper(x, y):\n        if x not in uf.parent or y not in uf.parent:\n            return -1.0\n        px, wx = uf.find(x)\n        py, wy = uf.find(y)\n        if px != py:\n            return -1.0\n        return wx / wy\n\n    uf = UnionFind()\n    for (x, y), val in zip(equations, values):\n        uf.union(x, y, val)\n    return [helper(x, y) for x, y in queries]"
    },
    "java": {
      "functionDeclaration": "public double[] EvaluateDivision(String[][] equations, double[] values, String[][] queries) {}",
      "testCalls": [
        "double[] result1 = EvaluateDivision(new String[][]{new String[]{\"a\",\"b\"}, new String[]{\"b\",\"c\"}}, new double[]{2.0, 3.0}, new String[][]{new String[]{\"a\",\"c\"}, new String[]{\"b\",\"a\"}, new String[]{\"a\",\"e\"}, new String[]{\"a\",\"a\"}, new String[]{\"x\",\"x\"});",
        "double[] result2 = EvaluateDivision(new String[][]{new String[]{\"a\",\"b\"}, new String[]{\"b\",\"c\"}, new String[]{\"bc\",\"cd\"}}, new double[]{1.5, 2.5, 5.0}, new String[][]{new String[]{\"a\",\"c\"}, new String[]{\"c\",\"b\"}, new String[]{\"bc\",\"cd\"}, new String[]{\"cd\",\"bc\"});",
        "double[] result3 = EvaluateDivision(new String[][]{new String[]{\"a\",\"b\"}}, new double[]{0.5}, new String[][]{new String[]{\"a\",\"b\"}, new String[]{\"b\",\"a\"}, new String[]{\"a\",\"c\"}, new String[]{\"x\",\"y\"});"
      ],
      "compareHelper": "private boolean arraysEqual(double[] arr1, double[] arr2) { return Arrays.equals(arr1, arr2); }",
      "helpers": "public class Pair { String first; String second; public Pair(String first, String second) { this.first = first; this.second = second; } }\npublic double[] EvaluateDivision(String[][] equations, double[] values, String[][] queries) {}",
      "typeDefs": "public class Pair { String first; String second; public Pair(String first, String second) { this.first = first; this.second = second; } }",
      "builders": "public double[] EvaluateDivision(String[][] equations, double[] values, String[][] queries) {}"
    },
    "c": {
      "functionDeclaration": "double* EvaluateDivision(char*** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char*** queries, int queriesSize, int* queriesColSize)",
      "testCalls": [
        "Pair* result1 = EvaluateDivision((char***)[[\"a\",\"b\"],[\"b\",\"c\"]], 2, (int[]){2, 2}, (double[]){2.0, 3.0}, 2, (char***)[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]], 5, (int[]){2, 2});\nif (memcmp(result1, (Pair[]){createPair(\"a\", 6.0), createPair(\"b\", 0.5), createPair(\"e\", -1.0), createPair(\"a\", 1.0), createPair(\"x\", -1.0)}, 5 * sizeof(Pair)) != 0) { printf(\"Test case 1 failed\"); }",
        "Pair* result2 = EvaluateDivision((char***)[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], 3, (int[]){2, 2, 2}, (double[]){1.5, 2.5, 5.0}, 3, (char***)[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]], 4, (int[]){2, 2});\nif (memcmp(result2, (Pair[]){createPair(\"a\", 3.75), createPair(\"b\", 0.4), createPair(\"cd\", 5.0), createPair(\"bc\", 0.2)}, 4 * sizeof(Pair)) != 0) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "int compareArrays(double* arr1, double* arr2, int size) {\n  for (int i = 0; i < size; i++) {\n    if (arr1[i] != arr2[i]) return 0;\n  }\n  return 1;\n}",
      "helpers": "typedef struct { char* key; double value; } Pair;\nPair* createPair(char* key, double value) { Pair* pair = (Pair*)malloc(sizeof(Pair)); pair->key = key; pair->value = value; return pair; }\n\ntypedef struct { char* val; struct Node* next; double weight; } Node;\nNode* createNode(char* val, double weight) { Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->weight = weight; node->next = NULL; return node; }\n\nNode** createGraph(int size) { return (Node**)malloc(size * sizeof(Node*)); }\n\nvoid addEdge(Node** graph, char* src, char* dest, double weight, int* index) { if (!graph[*index]) graph[*index] = createNode(src, 1.0); Node* node = createNode(dest, weight); node->next = graph[*index]->next; graph[*index]->next = node; }\n\nvoid freeGraph(Node** graph, int size) { for (int i = 0; i < size; i++) { Node* curr = graph[i]; while (curr) { Node* temp = curr; curr = curr->next; free(temp); } } free(graph); }",
      "typeDefs": "typedef struct { char* key; double value; } Pair;\nPair* createPair(char* key, double value) { Pair* pair = (Pair*)malloc(sizeof(Pair)); pair->key = key; pair->value = value; return pair; }\n\ntypedef struct { char* val; struct Node* next; double weight; } Node;\nNode* createNode(char* val, double weight) { Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->weight = weight; node->next = NULL; return node; }\n\nNode** createGraph(int size) { return (Node**)malloc(size * sizeof(Node*)); }\n\nvoid addEdge(Node** graph, char* src, char* dest, double weight, int* index) { if (!graph[*index]) graph[*index] = createNode(src, 1.0); Node* node = createNode(dest, weight); node->next = graph[*index]->next; graph[*index]->next = node; }\n\nvoid freeGraph(Node** graph, int size) { for (int i = 0; i < size; i++) { Node* curr = graph[i]; while (curr) { Node* temp = curr; curr = curr->next; free(temp); } } free(graph); }",
      "builders": ""
    },
    "go": {
      "functionDeclaration": "func CalcEquation(equations [][]string, values []float64, queries [][]string) []float64 {}",
      "testCalls": [
        "let equations = []Equation{{\"a\",\"b\"},{\"b\",\"c\"}}\nvalues := []float64{2.0,3.0}\nqueries := []Query{{\"a\",\"c\"},{\"b\",\"a\"},{\"a\",\"e\"},{\"a\",\"a\"},{\"x\",\"x\"}}\nresult := CalcEquation(equations, values, queries)\nexpected := []float64{6.00000,0.50000,-1.00000,1.00000,-1.00000}\nif !compareFloatArrays(result, expected) { t.Errorf(\"Test 1 Failed\") }",
        "let equations = []Equation{{\"a\",\"b\"},{\"b\",\"c\"},{\"bc\",\"cd\"}}\nvalues := []float64{1.5,2.5,5.0}\nqueries := []Query{{\"a\",\"c\"},{\"c\",\"b\"},{\"bc\",\"cd\"},{\"cd\",\"bc\"}}\nresult := CalcEquation(equations, values, queries)\nexpected := []float64{3.75000,0.40000,5.00000,0.20000}\nif !compareFloatArrays(result, expected) { t.Errorf(\"Test 2 Failed\") }",
        "let equations = []Equation{{\"a\",\"b\"}}\nvalues := []float64{0.5}\nqueries := []Query{{\"a\",\"b\"},{\"b\",\"a\"},{\"a\",\"c\"},{\"x\",\"y\"}}\nresult := CalcEquation(equations, values, queries)\nexpected := []float64{0.50000,2.00000,-1.00000,-1.00000}\nif !compareFloatArrays(result, expected) { t.Errorf(\"Test 3 Failed\") }"
      ],
      "compareHelper": "func compareFloatArrays(arr1, arr2 []float64) bool {}",
      "helpers": "type Equation struct { Ai string Bi string }\ntype Query struct { Cj string Dj string }\nfunc buildGraph(equations [][]string, values []float64) map[string]map[string]float64 {}\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}\nfunc treeToArray(root *TreeNode) []int\nfunc buildTree(arr []int) *TreeNode {}",
      "typeDefs": "type Equation struct { Ai string Bi string }\ntype Query struct { Cj string Dj string }",
      "builders": "func buildGraph(equations [][]string, values []float64) map[string]map[string]float64 {}\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}\nfunc treeToArray(root *TreeNode) []int\nfunc buildTree(arr []int) *TreeNode {}"
    },
    "rust": {
      "functionDeclaration": "fn EvaluateDivision(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> { }",
      "testCalls": [
        "let mut uf1 = UnionFind::new(2);\nuf1.union(0, 1, 2.0);\nlet result1 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"c\".to_string()]], vec![2.0, 3.0], vec![vec![\"a\".to_string(), \"c\".to_string()], vec![\"b\".to_string(), \"a\".to_string()], vec![\"a\".to_string(), \"e\".to_string()], vec![\"a\".to_string(), \"a\".to_string()], vec![\"x\".to_string(), \"x\".to_string()]);\nassert_eq!(result1, vec![6.0, 0.5, -1.0, 1.0, -1.0]);",
        "let mut uf2 = UnionFind::new(4);\nuf2.union(0, 1, 1.5);\nuf2.union(1, 2, 2.5);\nuf2.union(2, 3, 5.0);\nlet result2 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"c\".to_string()], vec![\"bc\".to_string(), \"cd\".to_string()]], vec![1.5, 2.5, 5.0], vec![vec![\"a\".to_string(), \"c\".to_string()], vec![\"c\".to_string(), \"b\".to_string()], vec![\"bc\".to_string(), \"cd\".to_string()], vec![\"cd\".to_string(), \"bc\".to_string()]]);\nassert_eq!(result2, vec![3.75, 0.4, 5.0, 0.2]);",
        "let mut uf3 = UnionFind::new(3);\nuf3.union(0, 1, 0.5);\nlet result3 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()]], vec![0.5], vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"a\".to_string()], vec![\"a\".to_string(), \"c\".to_string()], vec![\"x\".to_string(), \"y\".to_string()]]);\nassert_eq!(result3, vec![0.5, 2.0, -1.0, -1.0]);"
      ],
      "compareHelper": "",
      "helpers": "struct UnionFind { parent: Vec<usize>, weight: Vec<f64> }\nimpl UnionFind { fn new(n: usize) -> Self { Self { parent: (0..n).collect(), weight: vec![1.0; n] } }\nfn find(&mut self, mut x: usize) -> usize { let mut path = vec![]; while x != self.parent[x] { path.push(x); x = self.parent[x]; } for &p in path.iter() { self.weight[p] *= self.weight[x]; }\nself.parent[x] = x; x }\nfn union(&mut self, mut x: usize, mut y: usize, val: f64) { let root_x = self.find(x); let root_y = self.find(y); if root_x != root_y { self.parent[root_x] = root_y; self.weight[root_x] = val * self.weight[y] / self.weight[x]; } }\n}\n",
      "typeDefs": "struct UnionFind { parent: Vec<usize>, weight: Vec<f64> }\nimpl UnionFind { fn new(n: usize) -> Self { Self { parent: (0..n).collect(), weight: vec![1.0; n] } }\nfn find(&mut self, mut x: usize) -> usize { let mut path = vec![]; while x != self.parent[x] { path.push(x); x = self.parent[x]; } for &p in path.iter() { self.weight[p] *= self.weight[x]; }\nself.parent[x] = x; x }\nfn union(&mut self, mut x: usize, mut y: usize, val: f64) { let root_x = self.find(x); let root_y = self.find(y); if root_x != root_y { self.parent[root_x] = root_y; self.weight[root_x] = val * self.weight[y] / self.weight[x]; } }\n}",
      "builders": ""
    },
    "ruby": {
      "functionDeclaration": "def EvaluateDivision(equations, values, queries)\n  # Function body goes here\nend",
      "testCalls": [
        "result1 = EvaluateDivision([['a', 'b'], ['b', 'c']], [2.0, 3.0], [['a', 'c'], ['b', 'a'], ['a', 'e'], ['a', 'a'], ['x', 'x']]); raise 'Test Case 1 Failed' unless result1 == [6.0, 0.5, -1.0, 1.0, -1.0]",
        "result2 = EvaluateDivision([['a', 'b'], ['b', 'c'], ['bc', 'cd']], [1.5, 2.5, 5.0], [['a', 'c'], ['c', 'b'], ['bc', 'cd'], ['cd', 'bc']]); raise 'Test Case 2 Failed' unless result2 == [3.75, 0.4, 5.0, 0.2]",
        "result3 = EvaluateDivision([['a', 'b']], [0.5], [['a', 'b'], ['b', 'a'], ['a', 'c'], ['x', 'y']]); raise 'Test Case 3 Failed' unless result3 == [0.5, 2.0, -1.0, -1.0]"
      ],
      "compareHelper": "",
      "helpers": "class UnionFind\n  def initialize\n    @parent = {}\n    @weight = {}\n  end\n\n  def find(x)\n    @parent[x] = x unless @parent[x]\n    @weight[x] = 1 unless @weight[x]\n    return x if x == @parent[x]\n    px = find(@parent[x])\n    @weight[x] *= @weight[@parent[x]]\n    @parent[x] = px\n    px\n  end\n\n  def union(x, y, val)\n    px, py = find(x), find(y)\n    return false if px == py\n    @parent[px] = py\n    @weight[px] = @weight[y] * val / @weight[x]\n    true\n  end\n\n  def connected(x, y)\n    return false unless @parent[x] && @parent[y]\n    find(x) == find(y)\n  end\n\n  def query(x, y)\n    return -1 unless @parent[x] && @parent[y]\n    wx = @weight[x] || 1\n    wy = @weight[y] || 1\n    wx / wy\n  end\nend",
      "typeDefs": "class UnionFind\n  def initialize\n    @parent = {}\n    @weight = {}\n  end\n\n  def find(x)\n    @parent[x] = x unless @parent[x]\n    @weight[x] = 1 unless @weight[x]\n    return x if x == @parent[x]\n    px = find(@parent[x])\n    @weight[x] *= @weight[@parent[x]]\n    @parent[x] = px\n    px\n  end\n\n  def union(x, y, val)\n    px, py = find(x), find(y)\n    return false if px == py\n    @parent[px] = py\n    @weight[px] = @weight[y] * val / @weight[x]\n    true\n  end\n\n  def connected(x, y)\n    return false unless @parent[x] && @parent[y]\n    find(x) == find(y)\n  end\n\n  def query(x, y)\n    return -1 unless @parent[x] && @parent[y]\n    wx = @weight[x] || 1\n    wy = @weight[y] || 1\n    wx / wy\n  end\nend",
      "builders": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "equations": "[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]]",
          "values": "[2.0,3.0]",
          "queries": "[[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]"
        },
        "expected": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "equations": "[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]]",
          "values": "[1.5,2.5,5.0]",
          "queries": "[[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]"
        },
        "expected": "[3.75000,0.40000,5.00000,0.20000]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "equations": "[[&quot;a&quot;,&quot;b&quot;]]",
          "values": "[0.5]",
          "queries": "[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]"
        },
        "expected": "[0.50000,2.00000,-1.00000,-1.00000]"
      }
    ]
  },
  "evaluate-reverse-polish-notation": {
    "title": "Evaluate Reverse Polish Notation",
    "content": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\nThe valid operators are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, and &#39;/&#39;.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.\n\n\nExample 1:\n\nInput: tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\n\nInput: tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\n\nInput: tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n\nConstraints:\n\n1 <= tokens.length <= 104\ntokens[i] is either an operator: &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, or &quot;/&quot;, or an integer in the range [-200, 200].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math",
      "Stack"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EvaluateReversePolishNotation(tokens) {}",
      "testCalls": [
        "if (EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]) !== 9) { throw new Error('Test Case 1 Failed'); }",
        "if (EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]) !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function EvaluateReversePolishNotation(tokens: string[]): number {}",
      "testCalls": [
        "const result1 = EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]); if (result1 !== 9) { throw new Error('Test Case 1 Failed'); }",
        "const result2 = EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]); if (result2 !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int EvaluateReversePolishNotation(vector<string>& tokens)",
      "testCalls": [
        "assert(EvaluateReversePolishNotation({\"2\",\"1\",\"+\",\"3\",\"*\"}) == 9);",
        "assert(EvaluateReversePolishNotation({\"4\",\"13\",\"5\",\"/\",\"+\"}) == 6);",
        "assert(EvaluateReversePolishNotation({\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"}) == 22);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def EvaluateReversePolishNotation(tokens: List[str]) -> int:",
      "testCalls": [
        "assert EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]) == 9",
        "assert EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]) == 6",
        "assert EvaluateReversePolishNotation([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]) == 22"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int evaluateReversePolishNotation(String[] tokens) {}",
      "testCalls": [
        "int result1 = evaluateReversePolishNotation(new String[]{\"2\",\"1\",\"+\",\"3\",\"*\"});\nif (result1 != 9) throw new AssertionError();",
        "int result2 = evaluateReversePolishNotation(new String[]{\"4\",\"13\",\"5\",\"/\",\"+\"});\nif (result2 != 6) throw new AssertionError();",
        "int result3 = evaluateReversePolishNotation(new String[]{\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"});\nif (result3 != 22) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int EvaluateReversePolishNotation(char **tokens, int tokensSize)",
      "testCalls": [
        "if (EvaluateReversePolishNotation((char*[]) {\"2\",\"1\",\"+\",\"3\",\"*\"}, 5) != 9) { printf(\"Test case 1 failed\"); }",
        "if (EvaluateReversePolishNotation((char*[]) {\"4\",\"13\",\"5\",\"/\",\"+\"}, 5) != 6) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func EvaluateReversePolishNotation(tokens []string) int {}",
      "testCalls": [
        "if EvaluateReversePolishNotation([]string{\"2\",\"1\",\"+\",\"3\",\"*\"}) != 9 {panic(\"Test case 1 failed\")}",
        "if EvaluateReversePolishNotation([]string{\"4\",\"13\",\"5\",\"/\",\"+\"}) != 6 {panic(\"Test case 2 failed\")}",
        "if EvaluateReversePolishNotation([]string{\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"}) != 22 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn EvaluateReversePolishNotation(tokens: Vec<String>) -> i32 {}",
      "testCalls": [
        "assert_eq!(EvaluateReversePolishNotation(vec![\"2\".to_string(), \"1\".to_string(), \"+\".to_string(), \"3\".to_string(), \"*\".to_string()]), 9);",
        "assert_eq!(EvaluateReversePolishNotation(vec![\"4\".to_string(), \"13\".to_string(), \"5\".to_string(), \"/\".to_string(), \"+\".to_string()]), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EvaluateReversePolishNotation(tokens)\nend",
      "testCalls": [
        "result = EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"])\nraise 'Test Case 1 Failed' unless result == 9",
        "result = EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"])\nraise 'Test Case 2 Failed' unless result == 6"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "tokens": "[&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]"
        },
        "expected": "9"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "tokens": "[&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "tokens": "[&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]"
        },
        "expected": "22"
      }
    ]
  },
  "factorial-trailing-zeroes": {
    "title": "Factorial Trailing Zeroes",
    "content": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\nExample 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\n\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\n\nExample 3:\n\nInput: n = 0\nOutput: 0\n\n\nConstraints:\n\n0 <= n <= 104\n\n\nFollow up: Could you write a solution that works in logarithmic time complexity?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FactorialTrailingZeroes(n) {}",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if(FactorialTrailingZeroes(5) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FactorialTrailingZeroes(n: number): number {}",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) !== 0) throw new Error('Test Case 1 Failed');",
        "if(FactorialTrailingZeroes(5) !== 1) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FactorialTrailingZeroes(int n);",
      "testCalls": [
        "if (FactorialTrailingZeroes(3) != 0) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if (FactorialTrailingZeroes(5) != 1) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FactorialTrailingZeroes(n: int) -> int:",
      "testCalls": [
        "assert FactorialTrailingZeroes(3) == 0, 'Test Case 1 Failed'",
        "assert FactorialTrailingZeroes(5) == 1, 'Test Case 2 Failed'",
        "assert FactorialTrailingZeroes(0) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int FactorialTrailingZeroes(int n) { }",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) != 0) throw new AssertionError();",
        "if(FactorialTrailingZeroes(5) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FactorialTrailingZeroes(int n);",
      "testCalls": [
        "if (FactorialTrailingZeroes(3) != 0) { printf(\"Test Case 1 Failed\"); }",
        "if (FactorialTrailingZeroes(5) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FactorialTrailingZeroes(n int) int {}",
      "testCalls": [
        "if FactorialTrailingZeroes(3) != 0 { t.Errorf(\"Test case 1 failed\") }",
        "if FactorialTrailingZeroes(5) != 1 { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FactorialTrailingZeroes(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(FactorialTrailingZeroes(3), 0);",
        "assert_eq!(FactorialTrailingZeroes(5), 1);",
        "assert_eq!(FactorialTrailingZeroes(0), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FactorialTrailingZeroes(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless FactorialTrailingZeroes(3) == 0",
        "raise 'Test Case 2 Failed' unless FactorialTrailingZeroes(5) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "3"
        },
        "expected": "0"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "5"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "n": "0"
        },
        "expected": "0"
      }
    ]
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
    "title": "Find First and Last Position of Element in Sorted Array",
    "content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou mustwrite an algorithm withO(log n) runtime complexity.\n\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n\nConstraints:\n\n0 <= nums.length <= 105\n-109<= nums[i]<= 109\nnums is a non-decreasing array.\n-109<= target<= 109\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindFirstAndLastPositionOfElementInSortedArray(nums, target) {}",
      "testCalls": [
        "const test1 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8); if(JSON.stringify(test1) !== '[3,4]') throw new Error('Test Case 1 Failed');",
        "const test2 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6); if(JSON.stringify(test2) !== '[-1,-1]') throw new Error('Test Case 2 Failed');",
        "const test3 = FindFirstAndLastPositionOfElementInSortedArray([], 0); if(JSON.stringify(test3) !== '[-1,-1]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FindFirstAndLastPositionOfElementInSortedArray(nums: number[], target: number): number[]",
      "testCalls": [
        "const test1 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8); if (JSON.stringify(test1) !== JSON.stringify([3,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6); if (JSON.stringify(test2) !== JSON.stringify([-1,-1])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = FindFirstAndLastPositionOfElementInSortedArray([], 0); if (JSON.stringify(test3) !== JSON.stringify([-1,-1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<int> FindFirstAndLastPositionOfElementInSortedArray(vector<int>& nums, int target);",
      "testCalls": [
        "auto result1 = FindFirstAndLastPositionOfElementInSortedArray({5,7,7,8,8,10}, 8); assert(result1 == vector<int>({3,4}));",
        "auto result2 = FindFirstAndLastPositionOfElementInSortedArray({5,7,7,8,8,10}, 6); assert(result2 == vector<int>({-1,-1}));",
        "auto result3 = FindFirstAndLastPositionOfElementInSortedArray({}, 0); assert(result3 == vector<int>({-1,-1}));"
      ],
      "compareHelper": "bool CompareVectors(const vector<int>& v1, const vector<int>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def FindFirstAndLastPositionOfElementInSortedArray(nums: List[int], target: int) -> List[int]:",
      "testCalls": [
        "assert FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8) == [3, 4]",
        "assert FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6) == [-1, -1]",
        "assert FindFirstAndLastPositionOfElementInSortedArray([], 0) == [-1, -1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public int[] FindFirstAndLastPositionOfElementInSortedArray(int[] nums, int target) {}",
      "testCalls": [
        "assert Arrays.equals(FindFirstAndLastPositionOfElementInSortedArray(new int[]{5,7,7,8,8,10}, 8), new int[]{3,4});",
        "assert Arrays.equals(FindFirstAndLastPositionOfElementInSortedArray(new int[]{5,7,7,8,8,10}, 6), new int[]{-1,-1});",
        "assert Arrays.equals(FindFirstAndLastPositionOfElementInSortedArray(new int[]{}, 0), new int[]{-1,-1});"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) {return Arrays.equals(arr1, arr2);}"
    },
    "c": {
      "functionDeclaration": "int* FindFirstAndLastPositionOfElementInSortedArray(int* nums, int numsSize, int target)",
      "testCalls": [
        "int nums1[] = {5,7,7,8,8,10}; int target1 = 8; int* result1 = FindFirstAndLastPositionOfElementInSortedArray(nums1, 6, target1); if (result1[0] != 3 || result1[1] != 4) { printf(\"Test Case 1 Failed\"); }",
        "int nums2[] = {5,7,7,8,8,10}; int target2 = 6; int* result2 = FindFirstAndLastPositionOfElementInSortedArray(nums2, 6, target2); if (result2[0] != -1 || result2[1] != -1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func SearchRange(nums []int, target int) []int {}",
      "testCalls": [
        "if !compareArrays(SearchRange([]int{5,7,7,8,8,10}, 8), []int{3,4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(SearchRange([]int{5,7,7,8,8,10}, 6), []int{-1,-1}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(SearchRange([]int{}, 0), []int{-1,-1}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn FindFirstAndLastPositionOfElementInSortedArray(nums: Vec<i32>, target: i32) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![5,7,7,8,8,10], 8), vec![3, 4]);",
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![5,7,7,8,8,10], 6), vec![-1, -1]);",
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![], 0), vec![-1, -1]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def FindFirstAndLastPositionOfElementInSortedArray(nums, target)\nend",
      "testCalls": [
        "result = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8)\nraise 'Test Case 1 Failed' unless result == [3,4]",
        "result = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6)\nraise 'Test Case 2 Failed' unless result == [-1,-1]",
        "result = FindFirstAndLastPositionOfElementInSortedArray([], 0)\nraise 'Test Case 3 Failed' unless result == [-1,-1]"
      ],
      "compareHelper": "def arrays_equal(a, b)\na == b\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[5,7,7,8,8,10]",
          "target": "8"
        },
        "expected": "[3,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[5,7,7,8,8,10]",
          "target": "6"
        },
        "expected": "[-1,-1]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[]",
          "target": "0"
        },
        "expected": "[-1,-1]"
      }
    ]
  },
  "find-k-pairs-with-smallest-sums": {
    "title": "Find K Pairs with Smallest Sums",
    "content": "You are given two integer arrays nums1 and nums2 sorted in non-decreasingorder and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\n\nExample 1:\n\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\nExample 2:\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 105\n-109 <= nums1[i], nums2[i] <= 109\nnums1 and nums2 both are sorted in non-decreasing order.\n1 <= k <= 104\nk <=nums1.length *nums2.length\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindKPairsWithSmallestSums(nums1, nums2, k) { }",
      "testCalls": [
        "const test1 = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3); if(JSON.stringify(test1) !== '[[1,2],[1,4],[1,6]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2 = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2); if(JSON.stringify(test2) !== '[[1,1],[1,1]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FindKPairsWithSmallestSums(nums1: number[], nums2: number[], k: number): number[][] {}",
      "testCalls": [
        "const test1Result = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3); if(JSON.stringify(test1Result) !== '[[1,2],[1,4],[1,6]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2Result = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2); if(JSON.stringify(test2Result) !== '[[1,1],[1,1]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> FindKPairsWithSmallestSums(vector<int>& nums1, vector<int>& nums2, int k)",
      "testCalls": [
        "auto result1 = FindKPairsWithSmallestSums({1,7,11}, {2,4,6}, 3); assert(result1 == vector<vector<int>>{{1,2},{1,4},{1,6}});",
        "auto result2 = FindKPairsWithSmallestSums({1,1,2}, {1,2,3}, 2); assert(result2 == vector<vector<int>>{{1,1},{1,1}});"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def FindKPairsWithSmallestSums(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:",
      "testCalls": [
        "assert FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3) == [[1,2],[1,4],[1,6]], 'Test Case 1 Failed'",
        "assert FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2) == [[1,1],[1,1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> FindKPairsWithSmallestSums(int[] nums1, int[] nums2, int k) {}",
      "testCalls": [
        "List<List<Integer>> result1 = FindKPairsWithSmallestSums(new int[]{1, 7, 11}, new int[]{2, 4, 6}, 3); compareArrays(result1, new int[][]{{1, 2}, {1, 4}, {1, 6}});",
        "List<List<Integer>> result2 = FindKPairsWithSmallestSums(new int[]{1, 1, 2}, new int[]{1, 2, 3}, 2); compareArrays(result2, new int[][]{{1, 1}, {1, 1}});"
      ],
      "compareHelper": "private void compareArrays(List<List<Integer>> result, int[][] expected) {\n    for (int i = 0; i < result.size(); i++) {\n        List<Integer> pair = result.get(i);\n        if (pair.get(0) != expected[i][0] || pair.get(1) != expected[i][1]) {\n            throw new AssertionError(\"Test case failed\");\n        }\n    }\n}"
    },
    "c": {
      "functionDeclaration": "int** FindKPairsWithSmallestSums(int* nums1, int nums1Size, int* nums2, int nums2Size, int k)",
      "testCalls": [
        "int** result1 = FindKPairsWithSmallestSums((int[]){1,7,11}, 3, (int[]){2,4,6}, 3, 3); if (!CompareArrays(result1, (int*[]){(int[]){1,2}, (int[]){1,4}, (int[]){1,6}}, 3)) { printf(\"Test case 1 failed\"); }",
        "int** result2 = FindKPairsWithSmallestSums((int[]){1,1,2}, 3, (int[]){1,2,3}, 3, 2); if (!CompareArrays(result2, (int*[]){(int[]){1,1}, (int[]){1,1}}, 2)) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "int CompareArrays(int** arr1, int** arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i][0] != arr2[i][0] || arr1[i][1] != arr2[i][1]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func FindKPairsWithSmallestSums(nums1 []int, nums2 []int, k int) [][]int {}",
      "testCalls": [
        "if !reflect.DeepEqual(FindKPairsWithSmallestSums([]int{1,7,11}, []int{2,4,6}, 3), [][]int{{1,2},{1,4},{1,6}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !reflect.DeepEqual(FindKPairsWithSmallestSums([]int{1,1,2}, []int{1,2,3}, 2), [][]int{{1,1},{1,1}}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 [][]int, arr2 [][]int) bool { return reflect.DeepEqual(arr1, arr2) }"
    },
    "rust": {
      "functionDeclaration": "fn FindKPairsWithSmallestSums(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = FindKPairsWithSmallestSums(vec![1, 7, 11], vec![2, 4, 6], 3); assert_eq!(result1, vec![vec![1, 2], vec![1, 4], vec![1, 6]]);",
        "let result2 = FindKPairsWithSmallestSums(vec![1, 1, 2], vec![1, 2, 3], 2); assert_eq!(result2, vec![vec![1, 1], vec![1, 1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def FindKPairsWithSmallestSums(nums1, nums2, k)\n  # Function body goes here\nend",
      "testCalls": [
        "result1 = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3)\nraise 'Test Case 1 Failed' unless result1 == [[1,2],[1,4],[1,6]]",
        "result2 = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2)\nraise 'Test Case 2 Failed' unless result2 == [[1,1],[1,1]]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums1": "[1,7,11]",
          "nums2": "[2,4,6]",
          "k": "3"
        },
        "expected": "[[1,2],[1,4],[1,6]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums1": "[1,1,2]",
          "nums2": "[1,2,3]",
          "k": "2"
        },
        "expected": "[[1,1],[1,1]]"
      }
    ]
  },
  "find-minimum-in-rotated-sorted-array": {
    "title": "Find Minimum in Rotated Sorted Array",
    "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\n\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs inO(log n) time.\n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2].",
      "You can divide the search space into two and see which direction to go.\r\nCan you think of an algorithm which has O(logN) search complexity?",
      "<ol>\r\n<li>All the elements to the left of inflection point > first element of the array.</li>\r\n<li>All the elements to the right of inflection point < first element of the array.</li>\r\n<ol>"
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindMinimumInRotatedSortedArray(nums) {}",
      "testCalls": [
        "if(FindMinimumInRotatedSortedArray([3,4,5,1,2]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if(FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(FindMinimumInRotatedSortedArray([11,13,15,17]) !== 11) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindMinimumInRotatedSortedArray(nums: number[]): number {}",
      "testCalls": [
        "if (FindMinimumInRotatedSortedArray([3,4,5,1,2]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if (FindMinimumInRotatedSortedArray([11,13,15,17]) !== 11) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindMinimumInRotatedSortedArray(vector<int>& nums)",
      "testCalls": [
        "assert(FindMinimumInRotatedSortedArray({3,4,5,1,2}) == 1);",
        "assert(FindMinimumInRotatedSortedArray({4,5,6,7,0,1,2}) == 0);",
        "assert(FindMinimumInRotatedSortedArray({11,13,15,17}) == 11);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FindMinimumInRotatedSortedArray(nums: List[int]) -> int:",
      "testCalls": [
        "assert FindMinimumInRotatedSortedArray([3,4,5,1,2]) == 1",
        "assert FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) == 0",
        "assert FindMinimumInRotatedSortedArray([11,13,15,17]) == 11"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int findMinimumInRotatedSortedArray(int[] nums)",
      "testCalls": [
        "if (findMinimumInRotatedSortedArray(new int[]{3,4,5,1,2}) != 1) { throw new AssertionError(); }",
        "if (findMinimumInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}) != 0) { throw new AssertionError(); }",
        "if (findMinimumInRotatedSortedArray(new int[]{11,13,15,17}) != 11) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindMinimumInRotatedSortedArray(int* nums, int numsSize)",
      "testCalls": [
        "if (FindMinimumInRotatedSortedArray((int[]) {3,4,5,1,2}, 5) != 1) { printf(\"Test Case 1 Failed\"); }",
        "if (FindMinimumInRotatedSortedArray((int[]) {4,5,6,7,0,1,2}, 7) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindMinimumInRotatedSortedArray(nums []int) int {}",
      "testCalls": [
        "if FindMinimumInRotatedSortedArray([]int{3,4,5,1,2}) != 1 {panic(\"Test case 1 failed\")}",
        "if FindMinimumInRotatedSortedArray([]int{4,5,6,7,0,1,2}) != 0 {panic(\"Test case 2 failed\")}",
        "if FindMinimumInRotatedSortedArray([]int{11,13,15,17}) != 11 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindMinimumInRotatedSortedArray(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![3,4,5,1,2]), 1);",
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![4,5,6,7,0,1,2]), 0);",
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![11,13,15,17]), 11);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindMinimumInRotatedSortedArray(nums)\nend",
      "testCalls": [
        "nums1 = [3,4,5,1,2]\nputs FindMinimumInRotatedSortedArray(nums1) == 1 || raise('Test Case 1 Failed')",
        "nums2 = [4,5,6,7,0,1,2]\nputs FindMinimumInRotatedSortedArray(nums2) == 0 || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,4,5,1,2]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[4,5,6,7,0,1,2]"
        },
        "expected": "0"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[11,13,15,17]"
        },
        "expected": "11"
      }
    ]
  },
  "find-peak-element": {
    "title": "Find Peak Element",
    "content": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -&infin;. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\nConstraints:\n\n1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindPeakElement(nums) {}",
      "testCalls": [
        "let nums1 = [1,2,3,1]; if (FindPeakElement(buildArrayToLinkedList(nums1)) !== 2) throw new Error('Test Case 1 Failed');",
        "let nums2 = [1,2,1,3,5,6,4]; if (FindPeakElement(buildArrayToLinkedList(nums2)) !== 5) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "",
      "helpers": "function buildArrayToLinkedList(arr) { if (!arr.length) return null; let head = { val: arr[0], next: null }; let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = { val: arr[i], next: null }; curr = curr.next; } return head; }\nfunction arrayToLinkedList(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "",
      "builders": "function buildArrayToLinkedList(arr) { if (!arr.length) return null; let head = { val: arr[0], next: null }; let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = { val: arr[i], next: null }; curr = curr.next; } return head; }\nfunction arrayToLinkedList(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function FindPeakElement(nums: number[]): number {}",
      "testCalls": [
        "if (FindPeakElement(buildArray([1,2,3,1])) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (FindPeakElement(buildArray([1,2,1,3,5,6,4])) !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function buildArray(nums: number[]): number[] { return nums; }",
      "typeDefs": "",
      "builders": "function buildArray(nums: number[]): number[] { return nums; }"
    },
    "cpp": {
      "functionDeclaration": "int FindPeakElement(vector<int>& nums)",
      "testCalls": [
        "if(FindPeakElement(buildTree({1,2,3,1})) != 2) throw std::runtime_error(\"Test 1 failed!\");",
        "if(FindPeakElement(buildTree({1,2,1,3,5,6,4})) != 5) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; \nint FindPeakElement(vector<int>& nums) {}",
      "typeDefs": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} };",
      "builders": "int FindPeakElement(vector<int>& nums) {}"
    },
    "python": {
      "functionDeclaration": "def FindPeakElement(nums: List[int]) -> int",
      "testCalls": [
        "assert FindPeakElement([1,2,3,1]) == 2",
        "assert FindPeakElement([1,2,1,3,5,6,4]) == 5"
      ],
      "compareHelper": "",
      "helpers": "from typing import List",
      "typeDefs": "from typing import List",
      "builders": ""
    },
    "java": {
      "functionDeclaration": "public int FindPeakElement(int[] nums) { }",
      "testCalls": [
        "if (FindPeakElement(new int[]{1,2,3,1}) != 2) throw new AssertionError();",
        "if (FindPeakElement(new int[]{1,2,1,3,5,6,4}) != 5) throw new AssertionError();"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { result.add(null); } } while (result.get(result.size() - 1) == null) result.remove(result.size() - 1); return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { result.add(null); } } while (result.get(result.size() - 1) == null) result.remove(result.size() - 1); return result; }"
    },
    "c": {
      "functionDeclaration": "int FindPeakElement(int* nums, int numsSize)",
      "testCalls": [
        "assert(FindPeakElement(buildArray((int[]){1,2,3,1}, 4), 4) == 2);",
        "assert(FindPeakElement(buildArray((int[]){1,2,1,3,5,6,4}, 7), 7) == 5);"
      ],
      "compareHelper": "",
      "helpers": "function buildArray(int* arr, int size) { int* result = malloc(size * sizeof(int)); for (int i = 0; i < size; i++) result[i] = arr[i]; return result; }",
      "typeDefs": "",
      "builders": "function buildArray(int* arr, int size) { int* result = malloc(size * sizeof(int)); for (int i = 0; i < size; i++) result[i] = arr[i]; return result; }"
    },
    "go": {
      "functionDeclaration": "func FindPeakElement(nums []int) int {}",
      "testCalls": [
        "if FindPeakElement(buildTree([]int{1,2,3,1})) != 2 { panic(\"Test case 1 failed\") }",
        "if FindPeakElement(buildTree([]int{1,2,1,3,5,6,4})) != 5 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": "",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn FindPeakElement(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindPeakElement(vec![1,2,3,1]), 2);",
        "let result = FindPeakElement(vec![1,2,1,3,5,6,4]); assert!(result == 1 || result == 5);"
      ],
      "compareHelper": "",
      "helpers": "struct Solution;\nimpl Solution {\n    fn find_peak_element(nums: Vec<i32>) -> i32 {\n        0\n    }\n}\n",
      "typeDefs": "struct Solution;",
      "builders": "impl Solution {\n    fn find_peak_element(nums: Vec<i32>) -> i32 {\n        0\n    }\n}\n"
    },
    "ruby": {
      "functionDeclaration": "def FindPeakElement(nums)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,1]); raise 'Test Case 1 Failed' unless FindPeakElement(root) == 2",
        "root = buildTree([1,2,1,3,5,6,4]); raise 'Test Case 2 Failed' unless FindPeakElement(root) == 5"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\n\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  while result[-1].nil?\n    result.pop\n  end\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\n\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  while result[-1].nil?\n    result.pop\n  end\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,1]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,2,1,3,5,6,4]"
        },
        "expected": "5"
      }
    ]
  },
  "find-the-index-of-the-first-occurrence-in-a-string": {
    "title": "Find the Index of the First Occurrence in a String",
    "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\n\nInput: haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\nOutput: 0\nExplanation: &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\nExample 2:\n\nInput: haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\nOutput: -1\nExplanation: &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n\n\nConstraints:\n\n1 <= haystack.length, needle.length <= 104\nhaystack and needle consist of only lowercase English characters.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Two Pointers",
      "String",
      "String Matching"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "FindIndexOfTheFirstOccurrenceInAString(haystack, needle) {}",
      "testCalls": [
        "if (FindIndexOfTheFirstOccurrenceInAString('sadbutsad', 'sad') !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if (FindIndexOfTheFirstOccurrenceInAString('leetcode', 'leeto') !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindIndexOfFirstOccurrence(haystack: string, needle: string): number {}",
      "testCalls": [
        "if (FindIndexOfFirstOccurrence('sadbutsad', 'sad') !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if (FindIndexOfFirstOccurrence('leetcode', 'leeto') !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindIndexOfFirstOccurrenceInString(string haystack, string needle);",
      "testCalls": [
        "if (FindIndexOfFirstOccurrenceInString(\"sadbutsad\", \"sad\") != 0) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (FindIndexOfFirstOccurrenceInString(\"leetcode\", \"leeto\") != -1) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FindTheIndexOfTheFirstOccurrenceInAString(haystack: str, needle: str) -> int:",
      "testCalls": [
        "assert FindTheIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\") == 0, 'Test Case 1 Failed'",
        "assert FindTheIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\") == -1, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int FindIndexOfFirstOccurrence(String haystack, String needle) { }",
      "testCalls": [
        "if (FindIndexOfFirstOccurrence(\"sadbutsad\", \"sad\") != 0) throw new AssertionError();",
        "if (FindIndexOfFirstOccurrence(\"leetcode\", \"leeto\") != -1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindIndexOfFirstOccurrenceInString(char* haystack, char* needle)",
      "testCalls": [
        "if (FindIndexOfFirstOccurrenceInString(\"sadbutsad\", \"sad\") != 0) { printf(\"Test case 1 failed\"); }",
        "if (FindIndexOfFirstOccurrenceInString(\"leetcode\", \"leeto\") != -1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func StrStr(haystack string, needle string) int {}",
      "testCalls": [
        "if StrStr(\"sadbutsad\", \"sad\") != 0 { fmt.Println(\"Test case 1 failed\") }",
        "if StrStr(\"leetcode\", \"leeto\") != -1 { fmt.Println(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindIndexOfTheFirstOccurrenceInAString(haystack: &str, needle: &str) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\"), 0);",
        "assert_eq!(FindIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\"), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindTheIndexOfTheFirstOccurrenceInAString(haystack, needle)\nend",
      "testCalls": [
        "result = FindTheIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\")\nraise 'Test Case 1 Failed' unless result == 0",
        "result = FindTheIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\")\nraise 'Test Case 2 Failed' unless result == -1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "haystack": "&quot;sadbutsad&quot;",
          "needle": "&quot;sad&quot;"
        },
        "expected": "0"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "haystack": "&quot;leetcode&quot;",
          "needle": "&quot;leeto&quot;"
        },
        "expected": "-1"
      }
    ]
  },
  "flatten-binary-tree-to-linked-list": {
    "title": "Flatten Binary Tree to Linked List",
    "content": "Given the root of a binary tree, flatten the tree into a &quot;linked list&quot;:\n\nThe &quot;linked list&quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\nThe &quot;linked list&quot; should be in the same order as a pre-order traversal of the binary tree.\n\n\nExample 1:\n\n\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [0]\nOutput: [0]\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100\n\n\nFollow up: Can you flatten the tree in-place (with O(1) extra space)?",
    "difficulty": "Medium",
    "hints": [
      "If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal."
    ],
    "topicTags": [
      "Linked List",
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function FlattenBinaryTreeToLinkedList(root) {}",
      "testCalls": [
        "let root1 = buildTree([1,2,5,3,4,null,6]); if (JSON.stringify(treeToArray(FlattenBinaryTreeToLinkedList(root1))) !== JSON.stringify([1,null,2,null,3,null,4,null,5,null,6])) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([]); if (JSON.stringify(treeToArray(FlattenBinaryTreeToLinkedList(root2))) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function FlattenBinaryTreeToLinkedList(root: TreeNode | null): void",
      "testCalls": [
        "let root1 = buildTree([1,2,5,3,4,null,6]); FlattenBinaryTreeToLinkedList(root1); if(JSON.stringify(treeToArray(root1)) !== '[1,null,2,null,3,null,4,null,5,null,6]') throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([]); FlattenBinaryTreeToLinkedList(root2); if(JSON.stringify(treeToArray(root2)) !== '[]') throw new Error('Test Case 2 Failed');",
        "let root3 = buildTree([0]); FlattenBinaryTreeToLinkedList(root3); if(JSON.stringify(treeToArray(root3)) !== '[0]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }"
    },
    "cpp": {
      "functionDeclaration": "void FlattenBinaryTreeToLinkedList(TreeNode* root)",
      "testCalls": [
        "FlattenBinaryTreeToLinkedList(buildTree({1,2,5,3,4,null,6})); // compareArrays(root, {1,null,2,null,3,null,4,null,5,null,6});",
        "FlattenBinaryTreeToLinkedList(buildTree({})); // compareArrays(root, {});",
        "FlattenBinaryTreeToLinkedList(buildTree({0})); // compareArrays(root, {0});"
      ],
      "compareHelper": "void compareArrays(TreeNode* root, vector<int> expected) { /* Comparison logic here */ }",
      "helpers": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; \nvoid FlattenBinaryTreeToLinkedList(TreeNode* root) {}",
      "typeDefs": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} };",
      "builders": "void FlattenBinaryTreeToLinkedList(TreeNode* root) {}"
    },
    "python": {
      "functionDeclaration": "def FlattenBinaryTreeToLinkedList(root):",
      "testCalls": [
        "let root = buildTree([1,2,5,3,4,None,6]); FlattenBinaryTreeToLinkedList(root)",
        "let root = buildTree([]); FlattenBinaryTreeToLinkedList(root)",
        "let root = buildTree([0]); FlattenBinaryTreeToLinkedList(root)"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True",
      "helpers": "class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right\n\ndef buildTree(arr): pass\n\ndef treeToArray(root): pass",
      "typeDefs": "class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right",
      "builders": "def buildTree(arr): pass\n\ndef treeToArray(root): pass"
    },
    "java": {
      "functionDeclaration": "public void flattenBinaryTreeToLinkedList(TreeNode root) {}",
      "testCalls": [
        "flattenBinaryTreeToLinkedList(buildTree(new Integer[]{1,2,5,3,4,null,6})); // compare result with [1,null,2,null,3,null,4,null,5,null,6]",
        "flattenBinaryTreeToLinkedList(null); // compare result with []",
        "flattenBinaryTreeToLinkedList(buildTree(new Integer[]{0})); // compare result with [0]"
      ],
      "compareHelper": "Arrays.equals(expectedResult, actualResult)",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { result.add(null); } } while (result.get(result.size() - 1) == null) result.remove(result.size() - 1); return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { result.add(null); } } while (result.get(result.size() - 1) == null) result.remove(result.size() - 1); return result; }"
    },
    "c": {
      "functionDeclaration": "void FlattenBinaryTreeToLinkedList(struct TreeNode* root)",
      "testCalls": [
        "struct TreeNode* root1 = buildTree([1,2,5,3,4,null,6]); FlattenBinaryTreeToLinkedList(root1); // Compare result with expected for test case 1",
        "struct TreeNode* root2 = buildTree([]); FlattenBinaryTreeToLinkedList(root2); // Compare result with expected for test case 2"
      ],
      "compareHelper": "You can implement a helper function to compare arrays if needed, or use built-in functions for comparison",
      "helpers": "function TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "typeDefs": "function TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": ""
    },
    "go": {
      "functionDeclaration": "func FlattenBinaryTreeToLinkedList(root *TreeNode) { }",
      "testCalls": [
        "if result := FlattenBinaryTreeToLinkedList(buildTree([]int{1,2,5,3,4,-1,6})); !reflect.DeepEqual(treeToArray(result), []int{1,-1,2,-1,3,-1,4,-1,5,-1,6}) { t.Errorf(\"Test 1 Failed\") }",
        "if result := FlattenBinaryTreeToLinkedList(nil); !reflect.DeepEqual(treeToArray(result), nil) { t.Errorf(\"Test 2 Failed\") }",
        "if result := FlattenBinaryTreeToLinkedList(buildTree([]int{0})); !reflect.DeepEqual(treeToArray(result), []int{0}) { t.Errorf(\"Test 3 Failed\") }"
      ],
      "compareHelper": "func compareTrees(t1, t2 *TreeNode) bool { }",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn FlattenBinaryTreeToLinkedList(root: Option<Box<TreeNode>>) {}",
      "testCalls": [
        "let test1_root = Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 3, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })), right: Some(Box::new(TreeNode { val: 5, left: None, right: Some(Box::new(TreeNode { val: 6, left: None, right: None })) })) })); FlattenBinaryTreeToLinkedList(test1_root);",
        "let test2_root = None; FlattenBinaryTreeToLinkedList(test2_root);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<i32>, arr2: Vec<i32>) {\n    if arr1 != arr2 {\n        panic!(\"Arrays are not equal\");\n    }\n}",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n",
      "typeDefs": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n",
      "builders": ""
    },
    "ruby": {
      "functionDeclaration": "def FlattenBinaryTreeToLinkedList(root)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,5,3,4,nil,6]); test_case_1 = FlattenBinaryTreeToLinkedList(head); raise 'Test Case 1 Failed' unless linkedListToArray(test_case_1) == [1,nil,2,nil,3,nil,4,nil,5,nil,6]",
        "head = buildLinkedList([]); test_case_2 = FlattenBinaryTreeToLinkedList(head); raise 'Test Case 2 Failed' unless linkedListToArray(test_case_2) == []",
        "head = buildLinkedList([0]); test_case_3 = FlattenBinaryTreeToLinkedList(head); raise 'Test Case 3 Failed' unless linkedListToArray(test_case_3) == [0]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\n\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  for i in 1...arr.length\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\n",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  for i in 1...arr.length\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,5,3,4,null,6]"
        },
        "expected": "[1,null,2,null,3,null,4,null,5,null,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[0]"
        },
        "expected": "[0]"
      }
    ]
  },
  "game-of-life": {
    "title": "Game of Life",
    "content": "According to Wikipedia article: &quot;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.\n\nExample 1:\n\n\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\nExample 2:\n\n\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n\n\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1.\n\n\nFollow up:\n\nCould you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "GameOfLife(board)",
      "testCalls": [
        "GameOfLife(buildTree([0,1,0,null,0,0,1,null,1,1,1,0,0,0,null]))",
        "GameOfLife(buildTree([1,1,null,1,0,null]))"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "",
      "builders": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function GameOfLife(board: number[][]): void",
      "testCalls": [
        "let board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]; GameOfLife(board); if(JSON.stringify(board) !== JSON.stringify([[0,0,0],[1,0,1],[0,1,1],[0,1,0]])) throw new Error('Test Case 1 Failed');",
        "let board = [[1,1],[1,0]]; GameOfLife(board); if(JSON.stringify(board) !== JSON.stringify([[1,1],[1,1]])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: number[][], b: number[][]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function buildTree(arr) { if (!arr.length) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "",
      "builders": "function buildTree(arr) { if (!arr.length) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "void GameOfLife(vector<vector<int>>& board)",
      "testCalls": [
        "vector<vector<int>> board1 = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; GameOfLife(board1); // compareArrays(board1, {{0,0,0},{1,0,1},{0,1,1},{0,1,0}})",
        "vector<vector<int>> board2 = {{1,1},{1,0}}; GameOfLife(board2); // compareArrays(board2, {{1,1},{1,1}})"
      ],
      "compareHelper": "void compareArrays(vector<vector<int>>& arr1, vector<vector<int>> arr2) { for(int i=0; i<arr1.size(); i++) { for(int j=0; j<arr1[i].size(); j++) { if(arr1[i][j] != arr2[i][j]) { throw std::runtime_error(\"Test Failed\"); } } } }",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; \nListNode* buildLinkedList(vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nvector<int> linkedListToArray(ListNode* head) { vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nvector<int> linkedListToArray(ListNode* head) { vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def GameOfLife(board: List[List[int]]) -> None:",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])\nassert board == [[0,0,0],[1,0,1],[0,1,1],[0,1,0]], 'Test Case 1 Failed'",
        "GameOfLife([[1,1],[1,0]])\nassert board == [[1,1],[1,1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2) or any(arr1[i] != arr2[i] for i in range(len(arr1))):\n        raise AssertionError('Arrays are not equal')",
      "helpers": "from typing import List\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr\n",
      "typeDefs": "from typing import List\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr\n"
    },
    "java": {
      "functionDeclaration": "public void GameOfLife(int[][] board)",
      "testCalls": [
        "Cell[][] board1 = buildBoard(new int[][]{{0,1,0},{0,0,1},{1,1,1},{0,0,0}}); GameOfLife(board1); // Check board state after applying rules",
        "Cell[][] board2 = buildBoard(new int[][]{{1,1},{1,0}}); GameOfLife(board2); // Check board state after applying rules"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n        if (!Arrays.equals(arr1[i], arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "helpers": "class Cell {\n    int val;\n    boolean isAlive;\n\n    public Cell(int val) {\n        this.val = val;\n        this.isAlive = val == 1;\n    }\n}\n\npublic class GameOfLife {\n    public void gameOfLife(Cell[][] board) {\n        int rows = board.length;\n        int cols = board[0].length;\n        int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n        Cell[][] copyBoard = new Cell[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                copyBoard[i][j] = new Cell(board[i][j].val);\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                int liveNeighbors = 0;\n                for (int[] direction : directions) {\n                    int r = i + direction[0];\n                    int c = j + direction[1];\n                    if (r >= 0 && r < rows && c >= 0 && c < cols && copyBoard[r][c].isAlive) {\n                        liveNeighbors++;\n                    }\n                }\n                if (copyBoard[i][j].isAlive && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[i][j].isAlive = false;\n                }\n                if (!copyBoard[i][j].isAlive && liveNeighbors == 3) {\n                    board[i][j].isAlive = true;\n                }\n            }\n        }\n    }\n\n    public Cell[][] buildBoard(int[][] arr) {\n        Cell[][] board = new Cell[arr.length][arr[0].length];\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[0].length; j++) {\n                board[i][j] = new Cell(arr[i][j]);\n            }\n        }\n        return board;\n    }\n\n    public int[][] boardToArray(Cell[][] board) {\n        int[][] arr = new int[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                arr[i][j] = board[i][j].isAlive ? 1 : 0;\n            }\n        }\n        return arr;\n    }\n}",
      "typeDefs": "class Cell { int val; boolean isAlive; public Cell(int val) { this.val = val; this.isAlive = val == 1; } }",
      "builders": "public class GameOfLife {\n    public void gameOfLife(Cell[][] board) {\n        int rows = board.length;\n        int cols = board[0].length;\n        int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n        Cell[][] copyBoard = new Cell[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                copyBoard[i][j] = new Cell(board[i][j].val);\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                int liveNeighbors = 0;\n                for (int[] direction : directions) {\n                    int r = i + direction[0];\n                    int c = j + direction[1];\n                    if (r >= 0 && r < rows && c >= 0 && c < cols && copyBoard[r][c].isAlive) {\n                        liveNeighbors++;\n                    }\n                }\n                if (copyBoard[i][j].isAlive && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[i][j].isAlive = false;\n                }\n                if (!copyBoard[i][j].isAlive && liveNeighbors == 3) {\n                    board[i][j].isAlive = true;\n                }\n            }\n        }\n    }\n\n    public Cell[][] buildBoard(int[][] arr) {\n        Cell[][] board = new Cell[arr.length][arr[0].length];\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[0].length; j++) {\n                board[i][j] = new Cell(arr[i][j]);\n            }\n        }\n        return board;\n    }\n\n    public int[][] boardToArray(Cell[][] board) {\n        int[][] arr = new int[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                arr[i][j] = board[i][j].isAlive ? 1 : 0;\n            }\n        }\n        return arr;\n    }\n}"
    },
    "c": {
      "functionDeclaration": "void GameOfLife(int** board, int boardSize, int* boardColSize)",
      "testCalls": [
        "int row1[] = {0,1,0};\nint row2[] = {0,0,1};\nint row3[] = {1,1,1};\nint row4[] = {0,0,0};\nint* board[] = {row1, row2, row3, row4};\nint boardColSize[] = {3};\nint size = 4;\nGameOfLife(board, size, boardColSize);",
        "int row1[] = {1,1};\nint row2[] = {1,0};\nint* board[] = {row1, row2};\nint boardColSize[] = {2};\nint size = 2;\nGameOfLife(board, size, boardColSize);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) { return 0; } } return 1; }",
      "helpers": "typedef struct { int val; struct ListNode* next; } ListNode;\ntypedef struct { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;\nListNode* buildLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);\nTreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);",
      "typeDefs": "typedef struct { int val; struct ListNode* next; } ListNode;\ntypedef struct { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;",
      "builders": "ListNode* buildLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);\nTreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func GameOfLife(board [][]int)",
      "testCalls": [
        "let board1 = buildBoard([[0,1,0],[0,0,1],[1,1,1],[0,0,0]]); GameOfLife(board1)",
        "let board2 = buildBoard([[1,1],[1,0]]); GameOfLife(board2)"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) {\n  if !reflect.DeepEqual(arr1, arr2) {\n    panic(\"Test failed: Expected \" + fmt.Sprint(arr2) + \", but got \" + fmt.Sprint(arr1))\n  }\n}",
      "helpers": "type Cell struct { Row, Col int }\nfunc GameOfLife(board [][]int) {}\nfunc buildBoard(arr [][]int) [][]int { return arr }\nfunc boardToArray(board [][]int) [][]int { return board }",
      "typeDefs": "type Cell struct { Row, Col int }",
      "builders": "func GameOfLife(board [][]int) {}\nfunc buildBoard(arr [][]int) [][]int { return arr }\nfunc boardToArray(board [][]int) [][]int { return board }"
    },
    "rust": {
      "functionDeclaration": "fn GameOfLife(board: &mut Vec<Vec<i32>>) {}",
      "testCalls": [
        "let mut board1 = GameOfLife::buildBoard(vec![vec![0,1,0],vec![0,0,1],vec![1,1,1],vec![0,0,0]]); GameOfLife::GameOfLife(&mut board1); assert_eq!(board1, vec![vec![0,0,0],vec![1,0,1],vec![0,1,1],vec![0,1,0]]);",
        "let mut board2 = GameOfLife::buildBoard(vec![vec![1,1],vec![1,0]]); GameOfLife::GameOfLife(&mut board2); assert_eq!(board2, vec![vec![1,1],vec![1,1]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_equal(actual: &Vec<Vec<i32>>, expected: &Vec<Vec<i32>>) { for i in 0..actual.len() { assert_eq!(actual[i], expected[i]); }}",
      "helpers": "struct GameOfLife;\nimpl GameOfLife {\n    fn buildBoard(board: Vec<Vec<i32>>) -> Vec<Vec<i32>> { board }\n}\n",
      "typeDefs": "struct GameOfLife;",
      "builders": "impl GameOfLife {\n    fn buildBoard(board: Vec<Vec<i32>>) -> Vec<Vec<i32>> { board }\n}\n"
    },
    "ruby": {
      "functionDeclaration": "def GameOfLife(board)",
      "testCalls": [
        "GameOfLife(buildTree([[0,1,0],[0,0,1],[1,1,1],[0,0,0]]))",
        "GameOfLife(buildTree([[1,1],[1,0]]))"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  raise 'Test Failed' unless arr1 == arr2\nend",
      "helpers": "class Cell\n  attr_accessor :state\n  def initialize(state)\n    @state = state\n  end\nend\ndef GameOfLife(board)\n  # Your code here\nend",
      "typeDefs": "class Cell\n  attr_accessor :state\n  def initialize(state)\n    @state = state\n  end\nend",
      "builders": "def GameOfLife(board)\n  # Your code here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "board": "[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]"
        },
        "expected": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "board": "[[1,1],[1,0]]"
        },
        "expected": "[[1,1],[1,1]]"
      }
    ]
  },
  "gas-station": {
    "title": "Gas Station",
    "content": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.\n\nExample 1:\n\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\nExample 2:\n\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n\n\nConstraints:\n\nn == gas.length == cost.length\n1 <= n <= 105\n0 <= gas[i], cost[i] <= 104\nThe input is generated such that the answer is unique.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function GasStation(gas, cost) {}",
      "testCalls": [
        "if(GasStation([1,2,3,4,5], [3,4,5,1,2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(GasStation([2,3,4], [3,4,3]) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function GasStation(gas: number[], cost: number[]): number {}",
      "testCalls": [
        "if (GasStation([1,2,3,4,5], [3,4,5,1,2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (GasStation([2,3,4], [3,4,3]) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "const arraysEqual = (a: any[], b: any[]) => JSON.stringify(a) === JSON.stringify(b);"
    },
    "cpp": {
      "functionDeclaration": "int CanCompleteCircuit(vector<int>& gas, vector<int>& cost)",
      "testCalls": [
        "assert(CanCompleteCircuit({1,2,3,4,5}, {3,4,5,1,2}) == 3);",
        "assert(CanCompleteCircuit({2,3,4}, {3,4,3}) == -1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def GasStation(gas: List[int], cost: List[int]) -> int:",
      "testCalls": [
        "assert GasStation([1,2,3,4,5], [3,4,5,1,2]) == 3",
        "assert GasStation([2,3,4], [3,4,3]) == -1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int GasStation(int[] gas, int[] cost)",
      "testCalls": [
        "int result1 = GasStation(new int[]{1,2,3,4,5}, new int[]{3,4,5,1,2});\nif (result1 != 3) throw new AssertionError();",
        "int result2 = GasStation(new int[]{2,3,4}, new int[]{3,4,3});\nif (result2 != -1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int GasStation(int* gas, int gasSize, int* cost, int costSize)",
      "testCalls": [
        "if (GasStation((int[]) {1,2,3,4,5}, 5, (int[]) {3,4,5,1,2}, 5) != 3) { printf(\"Test case 1 failed\"); }",
        "if (GasStation((int[]) {2,3,4}, 3, (int[]) {3,4,3}, 3) != -1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GasStation(gas []int, cost []int) int {}",
      "testCalls": [
        "if result := GasStation([]int{1,2,3,4,5}, []int{3,4,5,1,2}); result != 3 {panic(result)}",
        "if result := GasStation([]int{2,3,4}, []int{3,4,3}); result != -1 {panic(result)}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn GasStation(gas: Vec<i32>, cost: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(GasStation(vec![1,2,3,4,5], vec![3,4,5,1,2]), 3);",
        "assert_eq!(GasStation(vec![2,3,4], vec![3,4,3]), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def GasStation(gas, cost)\nend",
      "testCalls": [
        "result = GasStation([1,2,3,4,5], [3,4,5,1,2])\nraise 'Test Case 1 Failed' unless result == 3",
        "result = GasStation([2,3,4], [3,4,3])\nraise 'Test Case 2 Failed' unless result == -1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "gas": "[1,2,3,4,5]",
          "cost": "[3,4,5,1,2]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "gas": "[2,3,4]",
          "cost": "[3,4,3]"
        },
        "expected": "-1"
      }
    ]
  },
  "group-anagrams": {
    "title": "Group Anagrams",
    "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nExample 1:\n\nInput: strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]\nOutput: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]\nExplanation:\n\nThere is no string in strs that can be rearranged to form &quot;bat&quot;.\nThe strings &quot;nat&quot; and &quot;tan&quot; are anagrams as they can be rearranged to form each other.\nThe strings &quot;ate&quot;, &quot;eat&quot;, and &quot;tea&quot; are anagrams as they can be rearranged to form each other.\n\n\nExample 2:\n\nInput: strs = [&quot;&quot;]\nOutput: [[&quot;&quot;]]\n\nExample 3:\n\nInput: strs = [&quot;a&quot;]\nOutput: [[&quot;a&quot;]]\n\n\nConstraints:\n\n1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function GroupAnagrams(strs) {}",
      "testCalls": [
        "GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]) === [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "GroupAnagrams([\"\"]) === [[\"\"]]",
        "GroupAnagrams([\"a\"]) === [[\"a\"]]"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function GroupAnagrams(strs: string[][]): string[][][] {}",
      "testCalls": [
        "const test1 = GroupAnagrams([['eat','tea','tan','ate','nat','bat']]); if(JSON.stringify(test1) !== '[[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]]') throw new Error('Test Case 1 Failed');",
        "const test2 = GroupAnagrams([['']]); if(JSON.stringify(test2) !== '[[[\"\"]]]') throw new Error('Test Case 2 Failed');",
        "const test3 = GroupAnagrams([['a']]); if(JSON.stringify(test3) !== '[[[\"a\"]]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<string>> GroupAnagrams(vector<string>& strs);",
      "testCalls": [
        "auto result1 = GroupAnagrams({\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"});\nif(result1 != vector<vector<string>>{{\"bat\"},{\"nat\",\"tan\"},{\"ate\",\"eat\",\"tea\"}}) { throw std::runtime_error(\"Test 1 Failed\"); }",
        "auto result2 = GroupAnagrams({\"\"});\nif(result2 != vector<vector<string>>{{\"\"}}) { throw std::runtime_error(\"Test 2 Failed\"); }",
        "auto result3 = GroupAnagrams({\"a\"});\nif(result3 != vector<vector<string>>{{\"a\"}}) { throw std::runtime_error(\"Test 3 Failed\"); }"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<string>>& arr1, vector<vector<string>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def GroupAnagrams(strs: List[str]) -> List[List[str]]",
      "testCalls": [
        "assert GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]) == [['bat'],['nat','tan'],['ate','eat','tea']]",
        "assert GroupAnagrams(['']) == [['']]",
        "assert GroupAnagrams(['a']) == [['a']]"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if sorted(list1) != sorted(list2):\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public List<List<String>> groupAnagrams(String[] strs) {}",
      "testCalls": [
        "List<List<String>> result1 = groupAnagrams(new String[]{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"});\nif (!Arrays.deepEquals(result1.toArray(), new String[][]{{\"bat\"},{\"nat\",\"tan\"},{\"ate\",\"eat\",\"tea\"}})) throw new AssertionError();",
        "List<List<String>> result2 = groupAnagrams(new String[]{\"\"});\nif (!Arrays.deepEquals(result2.toArray(), new String[][]{{\"\"}})) throw new AssertionError();",
        "List<List<String>> result3 = groupAnagrams(new String[]{\"a\"});\nif (!Arrays.deepEquals(result3.toArray(), new String[][]{{\"a\"}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<String>> arr1, List<List<String>> arr2) {\n    return Arrays.deepEquals(arr1.toArray(), arr2.toArray());\n}"
    },
    "c": {
      "functionDeclaration": "void GroupAnagrams(char** strs, int strsSize)",
      "testCalls": [
        "GroupAnagrams((char*[]) {\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}, 6);",
        "GroupAnagrams((char*[]) {\"\"}, 1);",
        "GroupAnagrams((char*[]) {\"a\"}, 1);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GroupAnagrams(strs []string) [][]string {}",
      "testCalls": [
        "if !reflect.DeepEqual(GroupAnagrams([]string{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}), [][]string{{\"bat\"},{\"nat\",\"tan\"},{\"ate\",\"eat\",\"tea\"}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !reflect.DeepEqual(GroupAnagrams([]string{\"\"}), [][]string{{\"\"}}) { t.Error(\"Test Case 2 Failed\") }",
        "if !reflect.DeepEqual(GroupAnagrams([]string{\"a\"}), [][]string{{\"a\"}}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]string) bool { return reflect.DeepEqual(arr1, arr2) }"
    },
    "rust": {
      "functionDeclaration": "fn GroupAnagrams(strs: Vec<String>) -> Vec<Vec<String>> { }",
      "testCalls": [
        "assert_eq!(GroupAnagrams(vec![\"eat\".to_string(), \"tea\".to_string(), \"tan\".to_string(), \"ate\".to_string(), \"nat\".to_string(), \"bat\".to_string()]), vec![vec![\"bat\".to_string()], vec![\"nat\".to_string(), \"tan\".to_string()], vec![\"ate\".to_string(), \"eat\".to_string(), \"tea\".to_string()]]);",
        "assert_eq!(GroupAnagrams(vec![\"\".to_string()]), vec![vec![\"\".to_string()]]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<Vec<String>>, b: Vec<Vec<String>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i].len(), b[i].len()); for j in 0..a[i].len() { assert_eq!(a[i][j], b[i][j]); } } }"
    },
    "ruby": {
      "functionDeclaration": "def GroupAnagrams(strs)\n  \nend",
      "testCalls": [
        "result1 = GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\nraise 'Test Case 1 Failed' unless result1 == [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "result2 = GroupAnagrams([\"\"])\nraise 'Test Case 2 Failed' unless result2 == [[\"\"]]",
        "result3 = GroupAnagrams([\"a\"])\nraise 'Test Case 3 Failed' unless result3 == [[\"a\"]]"
      ],
      "compareHelper": "def arrays_equal(a, b)\n  a.sort == b.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "strs": "[&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]"
        },
        "expected": "[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "strs": "[&quot;&quot;]"
        },
        "expected": "[[&quot;&quot;]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "strs": "[&quot;a&quot;]"
        },
        "expected": "[[&quot;a&quot;]]"
      }
    ]
  },
  "h-index": {
    "title": "H-Index",
    "content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n\n\nConstraints:\n\nn == citations.length\n1 <= n <= 5000\n0 <= citations[i] <= 1000\n\n",
    "difficulty": "Medium",
    "hints": [
      "An easy approach is to sort the array first.",
      "What are the possible values of h-index?",
      "A faster approach is to use extra space."
    ],
    "topicTags": [
      "Array",
      "Sorting",
      "Counting Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HIndex(citations) {}",
      "testCalls": [
        "if (HIndex([3,0,6,1,5]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (HIndex([1,3,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HIndex(citations: number[]): number { }",
      "testCalls": [
        "if (HIndex([3,0,6,1,5]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (HIndex([1,3,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "int HIndex(vector<int>& citations);",
      "testCalls": [
        "assert(HIndex({3,0,6,1,5}) == 3);",
        "assert(HIndex({1,3,1}) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def HIndex(citations: List[int]) -> int",
      "testCalls": [
        "assert HIndex([3,0,6,1,5]) == 3",
        "assert HIndex([1,3,1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int HIndex(int[] citations)",
      "testCalls": [
        "if (HIndex(new int[]{3,0,6,1,5}) != 3) throw new AssertionError();",
        "if (HIndex(new int[]{1,3,1}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int HIndex(int* citations, int citationsSize)",
      "testCalls": [
        "if (HIndex((int[]){3,0,6,1,5}, 5) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (HIndex((int[]){1,3,1}, 3) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HIndex(citations []int) int {}",
      "testCalls": [
        "if HIndex([]int{3,0,6,1,5}) != 3 { panic(\"Test case 1 failed\") }",
        "if HIndex([]int{1,3,1}) != 1 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HIndex(citations: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(HIndex(vec![3, 0, 6, 1, 5]), 3);",
        "assert_eq!(HIndex(vec![1, 3, 1]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HIndex(citations)\nend",
      "testCalls": [
        "result = HIndex([3,0,6,1,5])\nraise 'Test Case 1 Failed' unless result == 3",
        "result = HIndex([1,3,1])\nraise 'Test Case 2 Failed' unless result == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "citations": "[3,0,6,1,5]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "citations": "[1,3,1]"
        },
        "expected": "1"
      }
    ]
  },
  "happy-number": {
    "title": "Happy Number",
    "content": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\n\nReturn true if n is a happy number, and false if not.\n\nExample 1:\n\nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\nExample 2:\n\nInput: n = 2\nOutput: false\n\n\nConstraints:\n\n1 <= n <= 231 - 1\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HappyNumber(n) {}",
      "testCalls": [
        "if (HappyNumber(19) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (HappyNumber(2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HappyNumber(n: number): boolean {}",
      "testCalls": [
        "if (HappyNumber(19) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (HappyNumber(2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool HappyNumber(int n);",
      "testCalls": [
        "if (HappyNumber(19) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (HappyNumber(2) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def HappyNumber(n: int) -> bool:",
      "testCalls": [
        "assert HappyNumber(19) == True, 'Test Case 1 Failed'",
        "assert HappyNumber(2) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean HappyNumber(int n) {}",
      "testCalls": [
        "if (HappyNumber(19) != true) throw new AssertionError();",
        "if (HappyNumber(2) != false) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool HappyNumber(int n)",
      "testCalls": [
        "if (!HappyNumber(19)) { printf(\"Test Case 1 Failed\"); }",
        "if (HappyNumber(2)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HappyNumber(n int) bool {}",
      "testCalls": [
        "if HappyNumber(19) != true { t.Error(\"Test case 1 failed\") }",
        "if HappyNumber(2) != false { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HappyNumber(n: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(HappyNumber(19), true);",
        "assert_eq!(HappyNumber(2), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HappyNumber(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless HappyNumber(19) == true",
        "raise 'Test Case 2 Failed' unless HappyNumber(2) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "19"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "2"
        },
        "expected": "false"
      }
    ]
  },
  "house-robber": {
    "title": "House Robber",
    "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nExample 2:\n\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HouseRobber(nums) {}",
      "testCalls": [
        "if (HouseRobber(buildTree([1,2,3,1])) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (HouseRobber(buildTree([2,7,9,3,1])) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (arr[i] !== null) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "",
      "builders": "class TreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction buildTree(arr) {\n    if (!arr.length) return null;\n    const root = new TreeNode(arr[0]);\n    const queue = [root];\n    let i = 1;\n    while (i < arr.length) {\n        const current = queue.shift();\n        if (arr[i] !== null) {\n            current.left = new TreeNode(arr[i]);\n            queue.push(current.left);\n        }\n        i++;\n        if (i < arr.length && arr[i] !== null) {\n            current.right = new TreeNode(arr[i]);\n            queue.push(current.right);\n        }\n        i++;\n    }\n    return root;\n}\n\nfunction treeToArray(root) {\n    if (!root) return [];\n    const result = [];\n    const queue = [root];\n    while (queue.length) {\n        const node = queue.shift();\n        if (node) {\n            result.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            result.push(null);\n        }\n    }\n    while (result[result.length - 1] === null) {\n        result.pop();\n    }\n    return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function HouseRobber(nums: number[]): number {}",
      "testCalls": [
        "if (HouseRobber(buildTree([1,2,3,1])) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (HouseRobber(buildTree([2,7,9,3,1])) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (arr[i] !== null) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "",
      "builders": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (arr[i] !== null) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int HouseRobber(vector<int>& nums);",
      "testCalls": [
        "ListNode* head1 = buildLinkedList({1,2,3,1}); if (HouseRobber(head1) != 4) throw std::runtime_error(\"Test Case 1 Failed\");",
        "ListNode* head2 = buildLinkedList({2,7,9,3,1}); if (HouseRobber(head2) != 12) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; ListNode* buildLinkedList(vector<int>& arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int num : arr) { curr->next = new ListNode(num); curr = curr->next; } return dummy->next; } vector<int> linkedListToArray(ListNode* head) { vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(vector<int>& arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int num : arr) { curr->next = new ListNode(num); curr = curr->next; } return dummy->next; } vector<int> linkedListToArray(ListNode* head) { vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def HouseRobber(nums: List[int]) -> int",
      "testCalls": [
        "assert HouseRobber(buildTree([1,2,3,1])) == 4",
        "assert HouseRobber(buildTree([2,7,9,3,1])) == 12"
      ],
      "compareHelper": "",
      "helpers": "from typing import List",
      "typeDefs": "",
      "builders": "def build_tree(arr): ..."
    },
    "java": {
      "functionDeclaration": "public int HouseRobber(int[] nums) {}",
      "testCalls": [
        "int[] nums1 = {1,2,3,1}; ListNode head1 = buildLinkedList(nums1); if (HouseRobber(head1) != 4) throw new AssertionError();",
        "int[] nums2 = {2,7,9,3,1}; ListNode head2 = buildLinkedList(nums2); if (HouseRobber(head2) != 12) throw new AssertionError();"
      ],
      "compareHelper": "",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\nListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "ListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "int HouseRobber(int* nums, int numsSize)",
      "testCalls": [
        "if(HouseRobber(buildTree((int[]){1,2,3,1}, 4), 4) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(HouseRobber(buildTree((int[]){2,7,9,3,1}, 5), 5) != 12) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "helpers": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\nTreeNode* buildTree(int* arr, int size) { return NULL; }\nint* treeToArray(TreeNode* root, int* returnSize) { return NULL; }\n\ntypedef struct ListNode { int val; struct ListNode *next; } ListNode;\nListNode* buildLinkedList(int* arr, int size) { return NULL; }\nint* linkedListToArray(ListNode* head, int* returnSize) { return NULL; }",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\ntypedef struct ListNode { int val; struct ListNode *next; } ListNode;",
      "builders": "TreeNode* buildTree(int* arr, int size) { return NULL; }\nint* treeToArray(TreeNode* root, int* returnSize) { return NULL; }\nListNode* buildLinkedList(int* arr, int size) { return NULL; }\nint* linkedListToArray(ListNode* head, int* returnSize) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func HouseRobber(nums []int) int {}",
      "testCalls": [
        "let head = buildLinkedList([]int{1,2,3,1}); if HouseRobber(head) != 4 { panic(\"Test case 1 failed\") }",
        "let head = buildLinkedList([]int{2,7,9,3,1}); if HouseRobber(head) != 12 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": "",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn HouseRobber(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "let nums1 = vec![1,2,3,1]; let result1 = HouseRobber(nums1); assert_eq!(result1, 4);",
        "let nums2 = vec![2,7,9,3,1]; let result2 = HouseRobber(nums2); assert_eq!(result2, 12);"
      ],
      "compareHelper": "",
      "helpers": "struct ListNode { val: i32, next: Option<Box<ListNode>> }\n\nfn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {}",
      "typeDefs": "struct ListNode { val: i32, next: Option<Box<ListNode>> }",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def HouseRobber(nums)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,1]); raise 'Test Case 1 Failed' unless HouseRobber(head) == 4",
        "head = buildLinkedList([2,7,9,3,1]); raise 'Test Case 2 Failed' unless HouseRobber(head) == 12"
      ],
      "compareHelper": "",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,1]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[2,7,9,3,1]"
        },
        "expected": "12"
      }
    ]
  },
  "insert-interval": {
    "title": "Insert Interval",
    "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don&#39;t need to modify intervals in-place. You can make a new array and return it.\n\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n\nConstraints:\n\n0 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 105\nintervals is sorted by starti in ascending order.\nnewInterval.length == 2\n0 <= start <= end <= 105\n\n",
    "difficulty": "Medium",
    "hints": [
      "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
      "Can you try merging the overlapping intervals while inserting the new interval?",
      "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
    ],
    "topicTags": [
      "Array"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function InsertInterval(intervals, newInterval) {}",
      "testCalls": [
        "InsertInterval([[1,3],[6,9]], [2,5]) === [[1,5],[6,9]] || throwError()",
        "InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) === [[1,2],[3,10],[12,16]] || throwError()"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); } function throwError() { throw new Error('Test Failed!'); }"
    },
    "typescript": {
      "functionDeclaration": "function InsertInterval(intervals: number[][], newInterval: number[]): number[][] {}",
      "testCalls": [
        "if (JSON.stringify(InsertInterval([[1,3],[6,9]], [2,5])) !== '[[1,5],[6,9]]') { throw new Error('Test Case 1 Failed'); }",
        "if (JSON.stringify(InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])) !== '[[1,2],[3,10],[12,16]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> InsertInterval(vector<vector<int>>& intervals, vector<int>& newInterval)",
      "testCalls": [
        "auto result1 = InsertInterval({{1,3},{6,9}}, {2,5}); assert(result1 == vector<vector<int>>{{1,5},{6,9}});",
        "auto result2 = InsertInterval({{1,2},{3,5},{6,7},{8,10},{12,16}}, {4,8}); assert(result2 == vector<vector<int>>{{1,2},{3,10},{12,16}});"
      ],
      "compareHelper": "bool compareVectors(vector<vector<int>>& v1, vector<vector<int>>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def InsertInterval(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:",
      "testCalls": [
        "assert InsertInterval([[1,3],[6,9]], [2,5]) == [[1,5],[6,9]], 'Test Case 1 Failed'",
        "assert InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) == [[1,2],[3,10],[12,16]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public int[][] InsertInterval(int[][] intervals, int[] newInterval) {}",
      "testCalls": [
        "assert Arrays.deepEquals(InsertInterval(new int[][]{{1,3},{6,9}}, new int[]{2,5}), new int[][]{{1,5},{6,9}});",
        "assert Arrays.deepEquals(InsertInterval(new int[][]{{1,2},{3,5},{6,7},{8,10},{12,16}}, new int[]{4,8}), new int[][]{{1,2},{3,10},{12,16}});"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) {\n    return Arrays.deepEquals(arr1, arr2);\n}"
    },
    "c": {
      "functionDeclaration": "intervalsInsert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int** returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int** intervals1 = (int*[]){{1,3},{6,9}}; int intervalsSize1 = 2; int intervalsColSize1 = 2; int newInterval1[] = {2,5}; int newIntervalSize1 = 2; int* returnSize1; int* returnColumnSizes1; int** result1 = intervalsInsert(intervals1, intervalsSize1, &intervalsColSize1, newInterval1, newIntervalSize1, &returnSize1, &returnColumnSizes1); if (!compareArrays(result1, returnSize1, returnColumnSizes1, (int*[]{{1,5},{6,9}}), 2, 2)) { printf(\"Test Case 1 Failed\"); }",
        "int** intervals2 = (int*[]){{1,2},{3,5},{6,7},{8,10},{12,16}}; int intervalsSize2 = 5; int intervalsColSize2 = 2; int newInterval2[] = {4,8}; int newIntervalSize2 = 2; int* returnSize2; int* returnColumnSizes2; int** result2 = intervalsInsert(intervals2, intervalsSize2, &intervalsColSize2, newInterval2, newIntervalSize2, &returnSize2, &returnColumnSizes2); if (!compareArrays(result2, returnSize2, returnColumnSizes2, (int*[]{{1,2},{3,10},{12,16}}), 3, 2)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int** arr1, int* size1, int* colSize1, int** arr2, int size2, int colSize2) { if (*size1 != size2 || *colSize1 != colSize2) { return 0; } for (int i = 0; i < size2; i++) { for (int j = 0; j < colSize2; j++) { if (arr1[i][j] != arr2[i][j]) { return 0; } } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func InsertInterval(intervals [][]int, newInterval []int) [][]int {}",
      "testCalls": [
        "if !compareArrays(InsertInterval([][]int{{1,3},{6,9}}, []int{2,5}), [][]int{{1,5},{6,9}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(InsertInterval([][]int{{1,2},{3,5},{6,7},{8,10},{12,16}}, []int{4,8}), [][]int{{1,2},{3,10},{12,16}}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 [][]int, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn InsertInterval(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(InsertInterval(vec![vec![1,3], vec![6,9]], vec![2,5]), vec![vec![1,5], vec![6,9]]);",
        "assert_eq!(InsertInterval(vec![vec![1,2], vec![3,5], vec![6,7], vec![8,10], vec![12,16]], vec![4,8]), vec![vec![1,2], vec![3,10], vec![12,16]]);"
      ],
      "compareHelper": "fn assert_2d_vec_eq(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i], b[i]); } }"
    },
    "ruby": {
      "functionDeclaration": "def InsertInterval(intervals, newInterval)\nend",
      "testCalls": [
        "test_case_1 = InsertInterval([[1,3],[6,9]], [2,5])\nraise 'Test Case 1 Failed' unless test_case_1 == [[1,5],[6,9]]",
        "test_case_2 = InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\nraise 'Test Case 2 Failed' unless test_case_2 == [[1,2],[3,10],[12,16]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "intervals": "[[1,3],[6,9]]",
          "newInterval": "[2,5]"
        },
        "expected": "[[1,5],[6,9]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "intervals": "[[1,2],[3,5],[6,7],[8,10],[12,16]]",
          "newInterval": "[4,8]"
        },
        "expected": "[[1,2],[3,10],[12,16]]"
      }
    ]
  },
  "integer-to-roman": {
    "title": "Integer to Roman",
    "content": "Seven different symbols represent Roman numerals with the following values:\n\n\n\nSymbol\nValue\n\n\n\n\nI\n1\n\n\nV\n5\n\n\nX\n10\n\n\nL\n50\n\n\nC\n100\n\n\nD\n500\n\n\nM\n1000\n\n\n\nRoman numerals are formed by appendingthe conversions ofdecimal place valuesfrom highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\nIf the value does not start with 4 or9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\nIf the value starts with 4 or 9 use thesubtractive formrepresentingone symbol subtracted from the following symbol, for example,4 is 1 (I) less than 5 (V): IVand 9 is 1 (I) less than 10 (X): IX.Only the following subtractive forms are used: 4 (IV), 9 (IX),40 (XL), 90 (XC), 400 (CD) and 900 (CM).\nOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5(V), 50 (L), or 500 (D) multiple times. If you need to append a symbol4 timesuse the subtractive form.\n\nGiven an integer, convert it to a Roman numeral.\n\nExample 1:\n\nInput: num = 3749\nOutput: &quot;MMMDCCXLIX&quot;\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\nExample 2:\n\nInput: num = 58\nOutput: &quot;LVIII&quot;\nExplanation:\n\n50 = L\n 8 = VIII\n\n\nExample 3:\n\nInput: num = 1994\nOutput: &quot;MCMXCIV&quot;\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\nConstraints:\n\n1 <= num <= 3999\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "IntegerToRoman(num)",
      "testCalls": [
        "if (IntegerToRoman(3749) !== \"MMMDCCXLIX\") { throw new Error(\"Test Case 1 Failed\"); }",
        "if (IntegerToRoman(58) !== \"LVIII\") { throw new Error(\"Test Case 2 Failed\"); }",
        "if (IntegerToRoman(1994) !== \"MCMXCIV\") { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IntegerToRoman(num: number): string {}",
      "testCalls": [
        "if (IntegerToRoman(3749) !== 'MMMDCCXLIX') throw new Error('Test Case 1 Failed');",
        "if (IntegerToRoman(58) !== 'LVIII') throw new Error('Test Case 2 Failed');",
        "if (IntegerToRoman(1994) !== 'MCMXCIV') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string IntegerToRoman(int num)",
      "testCalls": [
        "if(IntegerToRoman(3749) != \"MMMDCCXLIX\") throw std::runtime_error(\"Test 1 failed\");",
        "if(IntegerToRoman(58) != \"LVIII\") throw std::runtime_error(\"Test 2 failed\");",
        "if(IntegerToRoman(1994) != \"MCMXCIV\") throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IntegerToRoman(num: int) -> str:",
      "testCalls": [
        "assert IntegerToRoman(3749) == 'MMMDCCXLIX', 'Test Case 1 Failed'",
        "assert IntegerToRoman(58) == 'LVIII', 'Test Case 2 Failed'",
        "assert IntegerToRoman(1994) == 'MCMXCIV', 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String IntegerToRoman(int num) {}",
      "testCalls": [
        "assertEquals(\"MMMDCCXLIX\", IntegerToRoman(3749));",
        "assertEquals(\"LVIII\", IntegerToRoman(58));",
        "assertEquals(\"MCMXCIV\", IntegerToRoman(1994));"
      ],
      "compareHelper": "private void assertEquals(String expected, String actual) { if (!expected.equals(actual)) { throw new AssertionError(\"Expected: \" + expected + \", but was: \" + actual); }}"
    },
    "c": {
      "functionDeclaration": "char* IntegerToRoman(int num)",
      "testCalls": [
        "IntegerToRoman(3749)",
        "IntegerToRoman(58)",
        "IntegerToRoman(1994)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IntegerToRoman(num int) string",
      "testCalls": [
        "if IntegerToRoman(3749) != \"MMMDCCXLIX\" { t.Error(\"Test Case 1 Failed\") }",
        "if IntegerToRoman(58) != \"LVIII\" { t.Error(\"Test Case 2 Failed\") }",
        "if IntegerToRoman(1994) != \"MCMXCIV\" { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn IntegerToRoman(num: i32) -> String { }",
      "testCalls": [
        "assert_eq!(IntegerToRoman(3749), \"MMMDCCXLIX\");",
        "assert_eq!(IntegerToRoman(58), \"LVIII\"); assert_eq!(IntegerToRoman(1994), \"MCMXCIV\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def IntegerToRoman(num)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless IntegerToRoman(3749) == 'MMMDCCXLIX'",
        "raise 'Test Case 2 Failed' unless IntegerToRoman(58) == 'LVIII'"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "num": "3749"
        },
        "expected": "&quot;MMMDCCXLIX&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "num": "58"
        },
        "expected": "&quot;LVIII&quot;"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "num": "1994"
        },
        "expected": "&quot;MCMXCIV&quot;"
      }
    ]
  },
  "interleaving-string": {
    "title": "Interleaving String",
    "content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| <= 1\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.\n\nExample 1:\n\n\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\nExample 2:\n\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\nExample 3:\n\nInput: s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\nOutput: true\n\n\nConstraints:\n\n0 <= s1.length, s2.length <= 100\n0 <= s3.length <= 200\ns1, s2, and s3 consist of lowercase English letters.\n\n\nFollow up: Could you solve it using only O(s2.length) additional memory space?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function InterleavingString(s1, s2, s3) {}",
      "testCalls": [
        "if(InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if(InterleavingString('', '', '') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function InterleavingString(s1: string, s2: string, s3: string): boolean {}",
      "testCalls": [
        "if (InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if (InterleavingString('', '', '') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool InterleavingString(string s1, string s2, string s3)",
      "testCalls": [
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if(InterleavingString(\"\", \"\", \"\") != true) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def InterleavingString(s1: str, s2: str, s3: str) -> bool:",
      "testCalls": [
        "assert InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") == True, 'Test Case 1 Failed'",
        "assert InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") == False, 'Test Case 2 Failed'",
        "assert InterleavingString(\"\", \"\", \"\") == True, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean InterleavingString(String s1, String s2, String s3) {}",
      "testCalls": [
        "if (!InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\")) throw new AssertionError();",
        "if (InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\")) throw new AssertionError();",
        "if (!InterleavingString(\"\", \"\", \"\")) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool InterleavingString(char *s1, char *s2, char *s3)",
      "testCalls": [
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true) { printf(\"Test Case 1 Failed\"); }",
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false) { printf(\"Test Case 2 Failed\"); }",
        "if(InterleavingString(\"\", \"\", \"\") != true) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsInterleave(s1 string, s2 string, s3 string) bool {}",
      "testCalls": [
        "if IsInterleave(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true { t.Error(\"Test case 1 failed\") }",
        "if IsInterleave(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false { t.Error(\"Test case 2 failed\") }",
        "if IsInterleave(\"\", \"\", \"\") != true { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn InterleavingString(s1: &str, s2: &str, s3: &str) -> bool {}",
      "testCalls": [
        "assert_eq!(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\"), true);",
        "assert_eq!(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\"), false);",
        "assert_eq!(InterleavingString(\"\", \"\", \"\"), true);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def InterleavingString(s1, s2, s3)\nend",
      "testCalls": [
        "result1 = InterleavingString('aabcc', 'dbbca', 'aadbbcbcac')\nraise 'Test Case 1 Failed' unless result1 == true",
        "result2 = InterleavingString('aabcc', 'dbbca', 'aadbbbaccc')\nraise 'Test Case 2 Failed' unless result2 == false",
        "result3 = InterleavingString('', '', '')\nraise 'Test Case 3 Failed' unless result3 == true"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s1": "&quot;aabcc&quot;",
          "s2": "&quot;dbbca&quot;",
          "s3": "&quot;aadbbcbcac&quot;"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s1": "&quot;aabcc&quot;",
          "s2": "&quot;dbbca&quot;",
          "s3": "&quot;aadbbbaccc&quot;"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s1": "&quot;&quot;",
          "s2": "&quot;&quot;",
          "s3": "&quot;&quot;"
        },
        "expected": "true"
      }
    ]
  },
  "invert-binary-tree": {
    "title": "Invert Binary Tree",
    "content": "Given the root of a binary tree, invert the tree, and return its root.\n\nExample 1:\n\n\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nExample 2:\n\n\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function InvertBinaryTree(root) {}",
      "testCalls": [
        "let root = buildTree([4,2,7,1,3,6,9]); InvertBinaryTree(root); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([4,7,2,9,6,3,1])) throw 'Test Case 1 Failed';",
        "let root = buildTree([2,1,3]); InvertBinaryTree(root); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([2,3,1])) throw 'Test Case 2 Failed';",
        "let root = buildTree([]); InvertBinaryTree(root); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([])) throw 'Test Case 3 Failed';"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function InvertBinaryTree(root: TreeNode | null): TreeNode | null",
      "testCalls": [
        "let root1 = buildTree([4,2,7,1,3,6,9]); if (JSON.stringify(treeToArray(InvertBinaryTree(root1))) !== JSON.stringify([4,7,2,9,6,3,1])) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([2,1,3]); if (JSON.stringify(treeToArray(InvertBinaryTree(root2))) !== JSON.stringify([2,3,1])) throw new Error('Test Case 2 Failed');",
        "let root3 = buildTree([]); if (JSON.stringify(treeToArray(InvertBinaryTree(root3))) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createBinaryTree(arr: number[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift()!; if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }",
      "helpers": "type TreeNode = { val: number; left: TreeNode | null; right: TreeNode | null; };\nfunction buildTree(arr: (number | null)[]): TreeNode | null { /* Builder function code */ }\nfunction treeToArray(root: TreeNode | null): (number | null)[] { /* Converter function code */ }",
      "typeDefs": "type TreeNode = { val: number; left: TreeNode | null; right: TreeNode | null; };",
      "builders": "function buildTree(arr: (number | null)[]): TreeNode | null { /* Builder function code */ }\nfunction treeToArray(root: TreeNode | null): (number | null)[] { /* Converter function code */ }"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* InvertBinaryTree(TreeNode* root)",
      "testCalls": [
        "TreeNode* root1 = buildTree({4,2,7,1,3,6,9}); assert(compareArrays(treeToArray(InvertBinaryTree(root1)), {4,7,2,9,6,3,1}));",
        "TreeNode* root2 = buildTree({2,1,3}); assert(compareArrays(treeToArray(InvertBinaryTree(root2)), {2,3,1}));",
        "TreeNode* root3 = buildTree({}); assert(compareArrays(treeToArray(InvertBinaryTree(root3)), {}));"
      ],
      "compareHelper": "bool compareArrays(std::vector<int>& arr1, std::vector<int>& arr2) { if (arr1.size() != arr2.size()) return false; for (int i = 0; i < arr1.size(); i++) { if (arr1[i] != arr2[i]) return false; } return true; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (result.back() == -1) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def InvertBinaryTree(root):",
      "testCalls": [
        "root = buildTree([4,2,7,1,3,6,9]); assert treeToArray(InvertBinaryTree(root)) == [4,7,2,9,6,3,1]",
        "root = buildTree([2,1,3]); assert treeToArray(InvertBinaryTree(root)) == [2,3,1]",
        "root = buildTree([]); assert treeToArray(InvertBinaryTree(root)) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode invertBinaryTree(TreeNode root) { }",
      "testCalls": [
        "TreeNode test1 = invertBinaryTree(buildTree(new Integer[]{4,2,7,1,3,6,9})); compareTrees(test1, buildTree(new Integer[]{4,7,2,9,6,3,1}));",
        "TreeNode test2 = invertBinaryTree(buildTree(new Integer[]{2,1,3})); compareTrees(test2, buildTree(new Integer[]{2,3,1}));",
        "TreeNode test3 = invertBinaryTree(buildTree(new Integer[]{})); compareTrees(test3, buildTree(new Integer[]{}));"
      ],
      "compareHelper": "public void compareTrees(TreeNode t1, TreeNode t2) { }",
      "helpers": "public class TreeNode {\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n\npublic TreeNode buildTree(Integer[] arr) {\n    if (arr == null || arr.length == 0) return null;\n    return buildTreeHelper(arr, 0);\n}\n\nprivate TreeNode buildTreeHelper(Integer[] arr, int index) {\n    if (index >= arr.length || arr[index] == null) return null;\n    TreeNode node = new TreeNode(arr[index]);\n    node.left = buildTreeHelper(arr, 2 * index + 1);\n    node.right = buildTreeHelper(arr, 2 * index + 2);\n    return node;\n}\n\npublic List<Integer> treeToArray(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        if (node != null) {\n            result.add(node.val);\n            queue.add(node.left);\n            queue.add(node.right);\n        } else {\n            result.add(null);\n        }\n    }\n    // Remove trailing nulls\n    for (int i = result.size() - 1; i >= 0; i--) {\n        if (result.get(i) == null) {\n            result.remove(i);\n        } else {\n            break;\n        }\n    }\n    return result;\n}",
      "typeDefs": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }",
      "builders": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode buildTree(Integer[] arr) {\n    if (arr.length == 0) return null;\n    return buildTreeHelper(arr, 0);\n}\n\nprivate TreeNode buildTreeHelper(Integer[] arr, int index) {\n    if (index >= arr.length || arr[index] == null) return null;\n    TreeNode node = new TreeNode(arr[index]);\n    node.left = buildTreeHelper(arr, 2 * index + 1);\n    node.right = buildTreeHelper(arr, 2 * index + 2);\n    return node;\n}\n\npublic List<Integer> treeToArray(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        if (node != null) {\n            result.add(node.val);\n            queue.add(node.left);\n            queue.add(node.right);\n        } else {\n            result.add(null);\n        }\n    }\n    // Remove trailing nulls\n    while (result.size() > 0 && result.get(result.size() - 1) == null) {\n        result.remove(result.size() - 1);\n    }\n    return result;\n}"
    },
    "c": {
      "functionDeclaration": "struct TreeNode* InvertBinaryTree(struct TreeNode* root);",
      "testCalls": [
        "struct TreeNode* root1 = buildTreeFromArray((int[]) {4, 2, 7, 1, 3, 6, 9}, 7); assert(compareArrays(InvertBinaryTree(root1), buildTreeFromArray((int[]) {4, 7, 2, 9, 6, 3, 1}, 7));",
        "struct TreeNode* root2 = buildTreeFromArray((int[]) {2, 1, 3}, 3); assert(compareArrays(InvertBinaryTree(root2), buildTreeFromArray((int[]) {2, 3, 1}, 3));",
        "assert(compareArrays(InvertBinaryTree(NULL), NULL);"
      ],
      "compareHelper": "bool compareArrays(struct TreeNode* root1, struct TreeNode* root2) { int size1 = 0, size2 = 0; int* arr1 = treeToArray(root1, &size1); int* arr2 = treeToArray(root2, &size2); if (size1 != size2) return false; for (int i = 0; i < size1; i++) { if (arr1[i] != arr2[i]) return false; } return true; }",
      "helpers": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\nstruct TreeNode* createTreeNode(int val) { struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node->val = val; node->left = NULL; node->right = NULL; return node; }\nstruct TreeNode* buildTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode** nodes = (struct TreeNode**)malloc(size * sizeof(struct TreeNode*)); for (int i = 0; i < size; i++) { if (arr[i] != -1) nodes[i] = createTreeNode(arr[i]); else nodes[i] = NULL; } for (int i = 0; i < size; i++) { if (nodes[i] != NULL) { int leftIndex = 2 * i + 1; int rightIndex = 2 * i + 2; if (leftIndex < size) nodes[i]->left = nodes[leftIndex]; if (rightIndex < size) nodes[i]->right = nodes[rightIndex]; } } struct TreeNode* root = nodes[0]; free(nodes); return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* arr = (int*)malloc(sizeof(int) * 1000); int index = 0; struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000); int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { arr[index++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { arr[index++] = -1; } } while (index > 0 && arr[index - 1] == -1) index--; *returnSize = index; free(queue); return arr; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* createTreeNode(int val) { struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node->val = val; node->left = NULL; node->right = NULL; return node; }\nstruct TreeNode* buildTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode** nodes = (struct TreeNode**)malloc(size * sizeof(struct TreeNode*)); for (int i = 0; i < size; i++) { if (arr[i] != -1) nodes[i] = createTreeNode(arr[i]); else nodes[i] = NULL; } for (int i = 0; i < size; i++) { if (nodes[i] != NULL) { int leftIndex = 2 * i + 1; int rightIndex = 2 * i + 2; if (leftIndex < size) nodes[i]->left = nodes[leftIndex]; if (rightIndex < size) nodes[i]->right = nodes[rightIndex]; } } struct TreeNode* root = nodes[0]; free(nodes); return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* arr = (int*)malloc(sizeof(int) * 1000); int index = 0; struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000); int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { arr[index++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { arr[index++] = -1; } } while (index > 0 && arr[index - 1] == -1) index--; *returnSize = index; free(queue); return arr; }"
    },
    "go": {
      "functionDeclaration": "func InvertBinaryTree(root *TreeNode) *TreeNode {}",
      "testCalls": [
        "root := buildTree([]int{4,2,7,1,3,6,9}); if !reflect.DeepEqual(treeToArray(InvertBinaryTree(root)), []int{4,7,2,9,6,3,1}) { t.Errorf(\"Test case 1 failed\") }",
        "root := buildTree([]int{2,1,3}); if !reflect.DeepEqual(treeToArray(InvertBinaryTree(root)), []int{2,3,1}) { t.Errorf(\"Test case 2 failed\") }",
        "root := buildTree([]int{}); if !reflect.DeepEqual(treeToArray(InvertBinaryTree(root)), []int{}) { t.Errorf(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareTrees(t1 *TreeNode, t2 *TreeNode) bool { if t1 == nil && t2 == nil { return true } if t1 == nil || t2 == nil { return false } return t1.Val == t2.Val && compareTrees(t1.Left, t2.Left) && compareTrees(t1.Right, t2.Right) }",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn InvertBinaryTree(root: Option<Box<TreeNode>>) -> Option<Box<TreeNode>> { }",
      "testCalls": [
        "let root = build_tree(vec![Some(4), Some(2), Some(7), Some(1), Some(3), Some(6), Some(9)]); assert_eq!(tree_to_array(InvertBinaryTree(root)), vec![Some(4), Some(7), Some(2), Some(9), Some(6), Some(3), Some(1)], \"Test case 1 failed\");",
        "let root = build_tree(vec![Some(2), Some(1), Some(3)]); assert_eq!(tree_to_array(InvertBinaryTree(root)), vec![Some(2), Some(3), Some(1)], \"Test case 2 failed\");"
      ],
      "compareHelper": "fn assert_tree_eq(tree1: Option<Box<TreeNode>>, tree2: Option<Box<TreeNode>>) { }",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let root = Box::new(TreeNode::new(arr[0].unwrap()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                node.left = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.left.clone().unwrap());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.right = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.right.clone().unwrap());\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.val));\n            if node.left.is_some() || node.right.is_some() {\n                queue.push_back(node.left.unwrap_or_else(|| Box::new(TreeNode::new(0))));\n                queue.push_back(node.right.unwrap_or_else(|| Box::new(TreeNode::new(0))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let root = Some(Box::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(Some(node)) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                node.left = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.left.clone());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.right = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.right.clone());\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    // Remove trailing None values\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def InvertBinaryTree(root)\nend",
      "testCalls": [
        "root = buildTree([4,2,7,1,3,6,9]); if treeToArray(InvertBinaryTree(root)) != [4,7,2,9,6,3,1]; raise 'Test Case 1 Failed'; end",
        "root = buildTree([2,1,3]); if treeToArray(InvertBinaryTree(root)) != [2,3,1]; raise 'Test Case 2 Failed'; end",
        "root = buildTree([]); if treeToArray(InvertBinaryTree(root)) != []; raise 'Test Case 3 Failed'; end"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[4,2,7,1,3,6,9]"
        },
        "expected": "[4,7,2,9,6,3,1]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[2,1,3]"
        },
        "expected": "[2,3,1]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "ipo": {
    "title": "IPO",
    "content": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\nExample 1:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\nExample 2:\n\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\n\n\nConstraints:\n\n1 <= k <= 105\n0 <= w <= 109\nn == profits.length\nn == capital.length\n1 <= n <= 105\n0 <= profits[i] <= 104\n0 <= capital[i] <= 109\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "IPO(k, w, profits, capital)",
      "testCalls": [
        "if (IPO(2, 0, [1,2,3], [0,1,1]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (IPO(3, 0, [1,2,3], [0,1,2]) !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IPO(k: number, w: number, profits: number[], capital: number[]): number {}",
      "testCalls": [
        "if (IPO(2, 0, [1,2,3], [0,1,1]) !== 4) throw new Error('Test Case 1 Failed');",
        "if (IPO(3, 0, [1,2,3], [0,1,2]) !== 6) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital)",
      "testCalls": [
        "assert(FindMaximizedCapital(2, 0, {1,2,3}, {0,1,1}) == 4);",
        "assert(FindMaximizedCapital(3, 0, {1,2,3}, {0,1,2}) == 6);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IPO(k: int, w: int, profits: List[int], capital: List[int]) -> int:",
      "testCalls": [
        "assert IPO(2, 0, [1,2,3], [0,1,1]) == 4",
        "assert IPO(3, 0, [1,2,3], [0,1,2]) == 6"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int IPO(int k, int w, int[] profits, int[] capital)",
      "testCalls": [
        "if (IPO(2, 0, new int[]{1,2,3}, new int[]{0,1,1}) != 4) throw new AssertionError();",
        "if (IPO(3, 0, new int[]{1,2,3}, new int[]{0,1,2}) != 6) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int IPO(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize)",
      "testCalls": [
        "if(IPO(2, 0, (int[]){1,2,3}, 3, (int[]){0,1,1}, 3) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(IPO(3, 0, (int[]){1,2,3}, 3, (int[]){0,1,2}, 3) != 6) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IPO(k int, w int, profits []int, capital []int) int { }",
      "testCalls": [
        "if IPO(2, 0, []int{1,2,3}, []int{0,1,1}) != 4 { panic(\"Test case 1 failed\") }",
        "if IPO(3, 0, []int{1,2,3}, []int{0,1,2}) != 6 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn Ipo(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(Ipo(2, 0, vec![1, 2, 3], vec![0, 1, 1]), 4);",
        "assert_eq!(Ipo(3, 0, vec![1, 2, 3], vec![0, 1, 2]), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def Ipo(k, w, profits, capital)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless Ipo(2, 0, [1,2,3], [0,1,1]) == 4",
        "raise 'Test Case 2 Failed' unless Ipo(3, 0, [1,2,3], [0,1,2]) == 6"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "k": "2",
          "w": "0",
          "profits": "[1,2,3]",
          "capital": "[0,1,1]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "k": "3",
          "w": "0",
          "profits": "[1,2,3]",
          "capital": "[0,1,2]"
        },
        "expected": "6"
      }
    ]
  },
  "isomorphic-strings": {
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\nExample 1:\n\nInput: s = &quot;egg&quot;, t = &quot;add&quot;\nOutput: true\nExplanation:\nThe strings s and t can be made identical by:\n\nMapping &#39;e&#39; to &#39;a&#39;.\nMapping &#39;g&#39; to &#39;d&#39;.\n\n\nExample 2:\n\nInput: s = &quot;foo&quot;, t = &quot;bar&quot;\nOutput: false\nExplanation:\nThe strings s and t can not be made identical as &#39;o&#39; needs to be mapped to both &#39;a&#39; and &#39;r&#39;.\n\nExample 3:\n\nInput: s = &quot;paper&quot;, t = &quot;title&quot;\nOutput: true\n\n\nConstraints:\n\n1 <= s.length <= 5 * 104\nt.length == s.length\ns and t consist of any valid ascii character.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function IsomorphicStrings(s, t) {}",
      "testCalls": [
        "if(IsomorphicStrings('egg', 'add') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(IsomorphicStrings('foo', 'bar') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if(IsomorphicStrings('paper', 'title') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IsomorphicStrings(s: string, t: string): boolean {}",
      "testCalls": [
        "if(IsomorphicStrings('egg', 'add') !== true) throw new Error('Test Case 1 Failed');",
        "if(IsomorphicStrings('foo', 'bar') !== false) throw new Error('Test Case 2 Failed');",
        "if(IsomorphicStrings('paper', 'title') !== true) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool IsomorphicStrings(string s, string t);",
      "testCalls": [
        "if(IsomorphicStrings(\"egg\", \"add\") != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(IsomorphicStrings(\"foo\", \"bar\") != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if(IsomorphicStrings(\"paper\", \"title\") != true) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IsomorphicStrings(s: str, t: str) -> bool:",
      "testCalls": [
        "assert IsomorphicStrings(\"egg\", \"add\") == True, 'Test Case 1 Failed'",
        "assert IsomorphicStrings(\"foo\", \"bar\") == False, 'Test Case 2 Failed'",
        "assert IsomorphicStrings(\"paper\", \"title\") == True, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean IsomorphicStrings(String s, String t) { }",
      "testCalls": [
        "if(!IsomorphicStrings(\"egg\", \"add\")) throw new AssertionError();",
        "if(IsomorphicStrings(\"foo\", \"bar\")) throw new AssertionError();",
        "if(!IsomorphicStrings(\"paper\", \"title\")) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool IsomorphicStrings(char* s, char* t)",
      "testCalls": [
        "if(IsomorphicStrings(\"egg\", \"add\") != true) { printf(\"Test Case 1 Failed\"); }",
        "if(IsomorphicStrings(\"foo\", \"bar\") != false) { printf(\"Test Case 2 Failed\"); }",
        "if(IsomorphicStrings(\"paper\", \"title\") != true) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsomorphicStrings(s string, t string) bool {}",
      "testCalls": [
        "if IsomorphicStrings(\"egg\", \"add\") != true {panic(\"Test case 1 failed\")}",
        "if IsomorphicStrings(\"foo\", \"bar\") != false {panic(\"Test case 2 failed\")}",
        "if IsomorphicStrings(\"paper\", \"title\") != true {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn IsomorphicStrings(s: String, t: String) -> bool {}",
      "testCalls": [
        "assert_eq!(IsomorphicStrings(String::from(\"egg\"), String::from(\"add\")), true);",
        "assert_eq!(IsomorphicStrings(String::from(\"foo\"), String::from(\"bar\")), false);",
        "assert_eq!(IsomorphicStrings(String::from(\"paper\"), String::from(\"title\")), true);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def IsomorphicStrings(s, t)\nend",
      "testCalls": [
        "puts(IsomorphicStrings('egg', 'add')) == true || raise('Test Case 1 Failed')",
        "puts(IsomorphicStrings('foo', 'bar')) == false || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;egg&quot;",
          "t": "&quot;add&quot;"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;foo&quot;",
          "t": "&quot;bar&quot;"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;paper&quot;",
          "t": "&quot;title&quot;"
        },
        "expected": "true"
      }
    ]
  },
  "jump-game-ii": {
    "title": "Jump Game II",
    "content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned atindex 0.\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j)where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach indexn - 1.\n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 1000\nIt guaranteed that you can reach nums[n - 1].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function JumpGameII(nums) {}",
      "testCalls": [
        "if(JumpGameII([2,3,1,1,4]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(JumpGameII([2,3,0,1,4]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function JumpGameII(nums: number[]): number {}",
      "testCalls": [
        "if (JumpGameII([2,3,1,1,4]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGameII([2,3,0,1,4]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int JumpGameII(std::vector<int>& nums);",
      "testCalls": [
        "assert(JumpGameII({2,3,1,1,4}) == 2);",
        "assert(JumpGameII({2,3,0,1,4}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def JumpGameII(nums: List[int]) -> int:",
      "testCalls": [
        "assert JumpGameII([2,3,1,1,4]) == 2",
        "assert JumpGameII([2,3,0,1,4]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int JumpGameII(int[] nums) {}",
      "testCalls": [
        "assert JumpGameII(new int[]{2, 3, 1, 1, 4}) == 2;",
        "assert JumpGameII(new int[]{2, 3, 0, 1, 4}) == 2;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int JumpGameII(int* nums, int numsSize)",
      "testCalls": [
        "if(JumpGameII((int[]){2,3,1,1,4}, 5) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(JumpGameII((int[]){2,3,0,1,4}, 5) != 2) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func JumpGameII(nums []int) int {}",
      "testCalls": [
        "if JumpGameII([]int{2,3,1,1,4}) != 2 {panic(\"Test case 1 failed\")}",
        "if JumpGameII([]int{2,3,0,1,4}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn JumpGameIi(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(JumpGameIi(vec![2,3,1,1,4]), 2);",
        "assert_eq!(JumpGameIi(vec![2,3,0,1,4]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def JumpGameII(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless JumpGameII([2,3,1,1,4]) == 2",
        "raise 'Test Case 2 Failed' unless JumpGameII([2,3,0,1,4]) == 2"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[2,3,1,1,4]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[2,3,0,1,4]"
        },
        "expected": "2"
      }
    ]
  },
  "jump-game": {
    "title": "Jump Game",
    "content": "You are given an integer array nums. You are initially positioned at the array first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 105\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function JumpGame(nums) {}",
      "testCalls": [
        "if (JumpGame([2,3,1,1,4]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGame([3,2,1,0,4]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function JumpGame(nums: number[]): boolean {}",
      "testCalls": [
        "if (JumpGame([2,3,1,1,4]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGame([3,2,1,0,4]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool JumpGame(std::vector<int>& nums);",
      "testCalls": [
        "if (JumpGame({2,3,1,1,4}) != true) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if (JumpGame({3,2,1,0,4}) != false) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def JumpGame(nums: List[int]) -> bool:",
      "testCalls": [
        "assert JumpGame([2,3,1,1,4]) == True, 'Test Case 1 Failed'",
        "assert JumpGame([3,2,1,0,4]) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean JumpGame(int[] nums) {}",
      "testCalls": [
        "if (JumpGame(new int[]{2,3,1,1,4}) != true) throw new AssertionError();",
        "if (JumpGame(new int[]{3,2,1,0,4}) != false) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool CanJump(int* nums, int numsSize)",
      "testCalls": [
        "if (CanJump((int[]){2,3,1,1,4}, 5) != true) { printf(\"Test Case 1 Failed\"); }",
        "if (CanJump((int[]){3,2,1,0,4}, 5) != false) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func JumpGame(nums []int) bool {}",
      "testCalls": [
        "if JumpGame([]int{2,3,1,1,4}) != true { panic(\"Test case 1 failed\") }",
        "if JumpGame([]int{3,2,1,0,4}) != false { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn JumpGame(nums: Vec<i32>) -> bool {}",
      "testCalls": [
        "assert_eq!(JumpGame(vec![2,3,1,1,4]), true);",
        "assert_eq!(JumpGame(vec![3,2,1,0,4]), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def JumpGame(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless JumpGame([2,3,1,1,4]) == true",
        "raise 'Test Case 2 Failed' unless JumpGame([3,2,1,0,4]) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[2,3,1,1,4]"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[3,2,1,0,4]"
        },
        "expected": "false"
      }
    ]
  },
  "kth-largest-element-in-an-array": {
    "title": "Kth Largest Element in an Array",
    "content": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n\n\nConstraints:\n\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function KthLargestElementInAnArray(nums, k) {}",
      "testCalls": [
        "if(KthLargestElementInAnArray([3,2,1,5,6,4], 2) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function KthLargestElementInAnArray(nums: number[], k: number): number {}",
      "testCalls": [
        "if (KthLargestElementInAnArray([3,2,1,5,6,4], 2) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if (KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "KthLargestElementInAnArray(std::vector<int>& nums, int k)",
      "testCalls": [
        "assert(KthLargestElementInAnArray({3, 2, 1, 5, 6, 4}, 2) == 5);",
        "assert(KthLargestElementInAnArray({3, 2, 3, 1, 2, 4, 5, 5, 6}, 4) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def KthLargestElementInArray(nums: List[int], k: int) -> int:",
      "testCalls": [
        "assert KthLargestElementInArray([3,2,1,5,6,4], 2) == 5",
        "assert KthLargestElementInArray([3,2,3,1,2,4,5,5,6], 4) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int KthLargestElementInArray(int[] nums, int k) { }",
      "testCalls": [
        "if (KthLargestElementInArray(new int[]{3,2,1,5,6,4}, 2) != 5) throw new AssertionError();",
        "if (KthLargestElementInArray(new int[]{3,2,3,1,2,4,5,5,6}, 4) != 4) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "KthLargestElementInAnArray(int* nums, int numsSize, int k)",
      "testCalls": [
        "KthLargestElementInAnArray((int[]){3,2,1,5,6,4}, 6, 2); // Expected: 5",
        "KthLargestElementInAnArray((int[]){3,2,3,1,2,4,5,5,6}, 9, 4); // Expected: 4"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindKthLargest(nums []int, k int) int {}",
      "testCalls": [
        "if FindKthLargest([]int{3,2,1,5,6,4}, 2) != 5 { panic(\"Test case 1 failed\") }",
        "if FindKthLargest([]int{3,2,3,1,2,4,5,5,6}, 4) != 4 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn KthLargestElementInAnArray(nums: Vec<i32>, k: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(KthLargestElementInAnArray(vec![3,2,1,5,6,4], 2), 5);",
        "assert_eq!(KthLargestElementInAnArray(vec![3,2,3,1,2,4,5,5,6], 4), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def KthLargestElementInAnArray(nums, k)\n  \nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless KthLargestElementInAnArray([3,2,1,5,6,4], 2) == 5",
        "raise 'Test Case 2 Failed' unless KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,2,1,5,6,4]",
          "k": "2"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[3,2,3,1,2,4,5,5,6]",
          "k": "4"
        },
        "expected": "4"
      }
    ]
  },
  "kth-smallest-element-in-a-bst": {
    "title": "Kth Smallest Element in a BST",
    "content": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\nExample 1:\n\n\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nExample 2:\n\n\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n\n\nConstraints:\n\nThe number of nodes in the tree is n.\n1 <= k <= n <= 104\n0 <= Node.val <= 104\n\n\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\n",
    "difficulty": "Medium",
    "hints": [
      "Try to utilize the property of a BST.",
      "Try in-order traversal. (Credits to @chan13)",
      "What if you could modify the BST node's structure?",
      "The optimal runtime complexity is O(height of BST)."
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function KthSmallestElementInABST(root, k) {}",
      "testCalls": [
        "let root1 = buildTree([3,1,4,null,2]); if (KthSmallestElementInABST(root1, 1) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "let root2 = buildTree([5,3,6,2,4,null,null,1]); if (KthSmallestElementInABST(root2, 3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function KthSmallestElementInBST(root: TreeNode | null, k: number): number { }",
      "testCalls": [
        "if (KthSmallestElementInBST(TreeNode.fromArray([3,1,4,null,2]), 1) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (KthSmallestElementInBST(TreeNode.fromArray([5,3,6,2,4,null,null,1]), 3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n  static fromArray(arr: Array<number | null>): TreeNode | null {\n    if (arr.length === 0 || arr[0] === null) return null;\n    const root = new TreeNode(arr[0]!);\n    const queue: (TreeNode | null)[] = [root];\n    let i = 1;\n    while (queue.length && i < arr.length) {\n      const node = queue.shift();\n      if (node !== null) {\n        if (i < arr.length && arr[i] !== null) {\n          node.left = new TreeNode(arr[i]!);\n          queue.push(node.left);\n        }\n        i++;\n        if (i < arr.length && arr[i] !== null) {\n          node.right = new TreeNode(arr[i]!);\n          queue.push(node.right);\n        }\n        i++;\n      }\n    }\n    return root;\n  }\n}\n\nfunction KthSmallestElementInBST(root: TreeNode | null, k: number): number {\n  const stack: TreeNode[] = [];\n  let current = root;\n  let count = 0;\n  while (current !== null || stack.length > 0) {\n    while (current !== null) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop()!;\n    count++;\n    if (count === k) return current.val;\n    current = current.right;\n  }\n  return -1; // This line should never be reached if k is valid\n}",
      "typeDefs": "class TreeNode { val: number; left: TreeNode | null; right: TreeNode | null; constructor(val = 0, left = null, right = null) { this.val = val; this.left = left; this.right = right; } }",
      "builders": "static fromArray(arr: Array<number | null>): TreeNode | null { if (arr.length === 0 || arr[0] === null) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (queue.length && i < arr.length) { const node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }"
    },
    "cpp": {
      "functionDeclaration": "int KthSmallestElementInABST(TreeNode* root, int k);",
      "testCalls": [
        "if (KthSmallestElementInABST(createTree({3,1,4,-1,2}), 1) != 1) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (KthSmallestElementInABST(createTree({5,3,6,2,4,-1,-1,1}), 3) != 3) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "std::vector<int> createTree(std::vector<int> values) { /* Helper function to create a binary tree from values */ }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } ++i; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } ++i; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; if (!root) return result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } ++i; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } ++i; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; if (!root) return result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (result.back() == -1) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def KthSmallestElementInABST(root, k):",
      "testCalls": [
        "root = buildTree([3,1,4,None,2]); assert KthSmallestElementInABST(root, 1) == 1, 'Test Case 1 Failed'",
        "root = buildTree([5,3,6,2,4,None,None,1]); assert KthSmallestElementInABST(root, 3) == 3, 'Test Case 2 Failed'"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public int KthSmallestElementInBST(TreeNode root, int k) { }",
      "testCalls": [
        "if(KthSmallestElementInBST(buildTree(new Integer[]{3,1,4,null,2}), 1) != 1) throw new AssertionError();",
        "if(KthSmallestElementInBST(buildTree(new Integer[]{5,3,6,2,4,null,null,1}), 3) != 3) throw new AssertionError();"
      ],
      "compareHelper": "public static class TreeNode { static TreeNode buildTree(Integer[] values) { } }",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic static TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public static TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }"
    },
    "c": {
      "functionDeclaration": "int KthSmallestElementInBST(struct TreeNode* root, int k)",
      "testCalls": [
        "if(KthSmallestElementInBST(buildTree((int[]){3,1,4,-1,2}, 5), 1) != 1) { printf(\"Test Case 1 Failed\"); }",
        "if(KthSmallestElementInBST(buildTree((int[]){5,3,6,2,4,-1,-1,1}, 8), 3) != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "struct TreeNode* createTreeFromString(char* str) { /* implementation to create tree from string */ }",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createNode(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = createNode(arr[0]); struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (front < rear && i < size) { struct TreeNode* node = queue[front++]; if (arr[i] != -1) { node->left = createNode(arr[i]); queue[rear++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = createNode(arr[i]); queue[rear++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 10000); int index = 0; struct TreeNode* queue[10000]; int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { result[index++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { result[index++] = -1; } } while (index > 0 && result[index - 1] == -1) index--; *returnSize = index; return result; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createNode(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = createNode(arr[0]); struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (front < rear && i < size) { struct TreeNode* node = queue[front++]; if (arr[i] != -1) { node->left = createNode(arr[i]); queue[rear++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = createNode(arr[i]); queue[rear++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 10000); int index = 0; struct TreeNode* queue[10000]; int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { result[index++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { result[index++] = -1; } } while (index > 0 && result[index - 1] == -1) index--; *returnSize = index; return result; }"
    },
    "go": {
      "functionDeclaration": "func KthSmallestElementInBST(root *TreeNode, k int) int {}",
      "testCalls": [
        "let root = buildTree([3,1,4,null,2]); if KthSmallestElementInBST(root, 1) != 1 {panic(\"Test case 1 failed\")}",
        "let root = buildTree([5,3,6,2,4,null,null,1]); if KthSmallestElementInBST(root, 3) != 3 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn KthSmallestElementInBST(root: Option<Box<TreeNode>>, k: i32) -> i32 { }",
      "testCalls": [
        "let root1 = build_tree(vec![Some(3), Some(1), Some(4), None, Some(2)]); assert_eq!(KthSmallestElementInBST(root1, 1), 1);",
        "let root2 = build_tree(vec![Some(5), Some(3), Some(6), Some(2), Some(4), None, None, Some(1)]); assert_eq!(KthSmallestElementInBST(root2, 3), 3);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() { return None; }\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(Some(val)) = arr.get(i) {\n                let left_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().left = Some(left_child.clone());\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if let Some(Some(val)) = arr.get(i) {\n                let right_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().right = Some(right_child.clone());\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.borrow().val));\n            if node.borrow().left.is_some() || node.borrow().right.is_some() {\n                queue.push_back(node.borrow().left.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(-1)))));\n                queue.push_back(node.borrow().right.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(-1)))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "use std::collections::VecDeque;\nuse std::collections::LinkedList;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                let left_child = Rc::new(RefCell::new(TreeNode::new(arr[i].unwrap())));\n                node.borrow_mut().left = Some(left_child.clone());\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                let right_child = Rc::new(RefCell::new(TreeNode::new(arr[i].unwrap())));\n                node.borrow_mut().right = Some(right_child.clone());\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            let node_borrowed = node.borrow();\n            result.push(Some(node_borrowed.val));\n            if node_borrowed.left.is_some() || node_borrowed.right.is_some() {\n                queue.push_back(node_borrowed.left.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(0)))));\n                queue.push_back(node_borrowed.right.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(0)))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def KthSmallestElementInABST(root, k)\nend",
      "testCalls": [
        "root = buildTree([3,1,4,nil,2]); raise 'Test Case 1 Failed' unless KthSmallestElementInABST(root, 1) == 1",
        "root = buildTree([5,3,6,2,4,nil,nil,1]); raise 'Test Case 2 Failed' unless KthSmallestElementInABST(root, 3) == 3"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,1,4,null,2]",
          "k": "1"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[5,3,6,2,4,null,null,1]",
          "k": "3"
        },
        "expected": "3"
      }
    ]
  },
  "length-of-last-word": {
    "title": "Length of Last Word",
    "content": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\n\nExample 1:\n\nInput: s = &quot;Hello World&quot;\nOutput: 5\nExplanation: The last word is &quot;World&quot; with length 5.\n\nExample 2:\n\nInput: s = &quot;   fly me   to   the moon  &quot;\nOutput: 4\nExplanation: The last word is &quot;moon&quot; with length 4.\n\nExample 3:\n\nInput: s = &quot;luffy is still joyboy&quot;\nOutput: 6\nExplanation: The last word is &quot;joyboy&quot; with length 6.\n\n\nConstraints:\n\n1 <= s.length <= 104\ns consists of only English letters and spaces &#39; &#39;.\nThere will be at least one word in s.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LengthOfLastWord(s) {}",
      "testCalls": [
        "if(LengthOfLastWord(&quot;Hello World&quot;) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(LengthOfLastWord(&quot;   fly me   to   the moon  &quot;) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LengthOfLastWord(s: string): number {}",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") !== 5) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") !== 4) { throw new Error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int LengthOfLastWord(string s);",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") != 5) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LengthOfLastWord(s: str) -> int:",
      "testCalls": [
        "assert LengthOfLastWord(\"Hello World\") == 5",
        "assert LengthOfLastWord(\"   fly me   to   the moon  \") == 4",
        "assert LengthOfLastWord(\"luffy is still joyboy\") == 6"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LengthOfLastWord(String s) { }",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") != 5) { throw new AssertionError(); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LengthOfLastWord(char *s)",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") != 5) { printf(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LengthOfLastWord(s string) int {}",
      "testCalls": [
        "if LengthOfLastWord(\"Hello World\") != 5 {panic(\"Test case 1 failed\")}",
        "if LengthOfLastWord(\"   fly me   to   the moon  \") != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LengthOfLastWord(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(LengthOfLastWord(String::from(\"Hello World\")), 5);",
        "assert_eq!(LengthOfLastWord(String::from(\"   fly me   to   the moon  \")), 4);",
        "assert_eq!(LengthOfLastWord(String::from(\"luffy is still joyboy\")), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LengthOfLastWord(s)",
      "testCalls": [
        "if LengthOfLastWord(\"Hello World\") != 5\n  raise 'Test Case 1 Failed'\nend",
        "if LengthOfLastWord(\"   fly me   to   the moon  \") != 4\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;HelloWorld&quot;"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;flymetothemoon&quot;"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;luffyisstilljoyboy&quot;"
        },
        "expected": "6"
      }
    ]
  },
  "letter-combinations-of-a-phone-number": {
    "title": "Letter Combinations of a Phone Number",
    "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\nExample 1:\n\nInput: digits = &quot;23&quot;\nOutput: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n\nExample 2:\n\nInput: digits = &quot;2&quot;\nOutput: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n\n\nConstraints:\n\n1 <= digits.length <= 4\ndigits[i] is a digit in the range [&#39;2&#39;, &#39;9&#39;].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LetterCombinationsOfAPhoneNumber(digits) {}",
      "testCalls": [
        "if(JSON.stringify(LetterCombinationsOfAPhoneNumber('23')) !== JSON.stringify(['ad','ae','af','bd','be','bf','cd','ce','cf'])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(LetterCombinationsOfAPhoneNumber('2')) !== JSON.stringify(['a','b','c'])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function LetterCombinations(digits: string): string[] {}",
      "testCalls": [
        "const test1 = LetterCombinations(\"23\"); if (JSON.stringify(test1) !== JSON.stringify([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])) { throw new Error(\"Test Case 1 Failed\"); }",
        "const test2 = LetterCombinations(\"2\"); if (JSON.stringify(test2) !== JSON.stringify([\"a\",\"b\",\"c\"])) { throw new Error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<string> LetterCombinationsOfAPhoneNumber(string digits)",
      "testCalls": [
        "auto result1 = LetterCombinationsOfAPhoneNumber(\"23\"); assert(result1 == vector<string>{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"});",
        "auto result2 = LetterCombinationsOfAPhoneNumber(\"2\"); assert(result2 == vector<string>{\"a\",\"b\",\"c\"});"
      ],
      "compareHelper": "bool compareVectors(const vector<string>& v1, const vector<string>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def LetterCombinations(digits: str) -> List[str]:",
      "testCalls": [
        "assert LetterCombinations(\"23\") == [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "assert LetterCombinations(\"2\") == [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if len(list1) != len(list2):\n        raise AssertionError\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            raise AssertionError"
    },
    "java": {
      "functionDeclaration": "public List<String> letterCombinations(String digits) {}",
      "testCalls": [
        "List<String> result1 = letterCombinations(\"23\");\nif (!Arrays.equals(result1.toArray(), new String[]{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"})) throw new AssertionError();",
        "List<String> result2 = letterCombinations(\"2\");\nif (!Arrays.equals(result2.toArray(), new String[]{\"a\",\"b\",\"c\"})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean arraysEqual(String[] arr1, String[] arr2) {\n    return Arrays.equals(arr1, arr2);\n}"
    },
    "c": {
      "functionDeclaration": "void LetterCombinationsOfAPhoneNumber(char* digits)",
      "testCalls": [
        "LetterCombinationsOfAPhoneNumber(\"23\"); // Expected output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "LetterCombinationsOfAPhoneNumber(\"2\"); // Expected output: [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LetterCombinations(digits string) []string {}",
      "testCalls": [
        "if !compareArrays(LetterCombinations(\"23\"), []string{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"}) { t.Error(\"Test case 1 failed\") }",
        "if !compareArrays(LetterCombinations(\"2\"), []string{\"a\",\"b\",\"c\"}) { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []string) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn LetterCombinations(digits: &str) -> Vec<String> {}",
      "testCalls": [
        "let result1 = LetterCombinations(\"23\"); assert_eq!(result1, vec![\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]);",
        "let result2 = LetterCombinations(\"2\"); assert_eq!(result2, vec![\"a\",\"b\",\"c\"]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<String>, arr2: Vec<String>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def LetterCombinations(digits)\n  # code here\nend",
      "testCalls": [
        "result1 = LetterCombinations(\"23\")\nraise 'Test Case 1 Failed' unless result1 == [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "result2 = LetterCombinations(\"2\")\nraise 'Test Case 2 Failed' unless result2 == [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "digits": "&quot;23&quot;"
        },
        "expected": "[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "digits": "&quot;2&quot;"
        },
        "expected": "[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]"
      }
    ]
  },
  "linked-list-cycle": {
    "title": "Linked List Cycle",
    "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following thenextpointer. Internally, posis used to denote the index of the node thattailnextpointer is connected to.Note thatposis not passed as a parameter.\nReturntrue if there is a cycle in the linked list. Otherwise, return false.\n\nExample 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\nExample 3:\n\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n\n\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\n\n\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LinkedListCycle(head, pos) {}",
      "testCalls": [
        "let head1 = buildLinkedList([3,2,0,-4]); head1.next.next.next.next = head1.next; if (LinkedListCycle(head1, 1) !== true) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1,2]); head2.next.next = head2; if (LinkedListCycle(head2, 0) !== true) { throw new Error('Test Case 2 Failed'); }",
        "let head3 = buildLinkedList([1]); if (LinkedListCycle(head3, -1) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function LinkedListCycle(head: ListNode | null): boolean {}",
      "testCalls": [
        "if (LinkedListCycle(createLinkedList([3,2,0,-4], 1)) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (LinkedListCycle(createLinkedList([1,2], 0)) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (LinkedListCycle(createLinkedList([1], -1)) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function createLinkedList(arr: number[], pos: number): ListNode | null {}",
      "helpers": "class ListNode { val: number; next: ListNode | null; constructor(val=0, next=null) { this.val = val; this.next = next; } }\nfunction createLinkedList(arr: number[], pos: number): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; let cycleNode: ListNode | null = null; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; if (i === pos) cycleNode = curr; } if (pos !== -1) curr.next = cycleNode; return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr: number[] = []; let curr = head; while (curr) { arr.push(curr.val); curr = curr.next; if (arr.length > 10) break; } return arr; }",
      "typeDefs": "class ListNode { val: number; next: ListNode | null; constructor(val=0, next=null) { this.val = val; this.next = next; } }",
      "builders": "function createLinkedList(arr: number[], pos: number): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; let cycleNode: ListNode | null = null; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; if (i === pos) cycleNode = curr; } if (pos !== -1) curr.next = cycleNode; return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr: number[] = []; let curr = head; while (curr) { arr.push(curr.val); curr = curr.next; if (arr.length > 10) break; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "bool HasCycle(ListNode* head)",
      "testCalls": [
        "assert(HasCycle(createLinkedList({3,2,0,-4}, 1)) == true);",
        "assert(HasCycle(createLinkedList({1,2}, 0)) == true);",
        "assert(HasCycle(createLinkedList({1}, -1)) == false);"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; \nListNode* createLinkedList(std::vector<int> values, int pos) { if (values.empty()) return nullptr; ListNode* head = new ListNode(values[0]); ListNode* curr = head; ListNode* cycleNode = nullptr; for (int i = 1; i < values.size(); ++i) { curr->next = new ListNode(values[i]); curr = curr->next; if (i == pos) cycleNode = curr; } if (pos != -1) curr->next = cycleNode; return head; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values, int pos) { if (values.empty()) return nullptr; ListNode* head = new ListNode(values[0]); ListNode* curr = head; ListNode* cycleNode = nullptr; for (int i = 1; i < values.size(); ++i) { curr->next = new ListNode(values[i]); curr = curr->next; if (i == pos) cycleNode = curr; } if (pos != -1) curr->next = cycleNode; return head; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }"
    },
    "python": {
      "functionDeclaration": "LinkedListCycle(head: ListNode) -> bool:",
      "testCalls": [
        "head = buildLinkedList([3,2,0,-4])\nhead.next.next.next.next = head.next\nassert LinkedListCycle(head) == True",
        "head = buildLinkedList([1,2])\nhead.next.next = head\nassert LinkedListCycle(head) == True",
        "head = buildLinkedList([1])\nassert LinkedListCycle(head) == False"
      ],
      "compareHelper": "",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public boolean LinkedListCycle(ListNode head)",
      "testCalls": [
        "assert LinkedListCycle(buildLinkedList(new int[]{3, 2, 0, -4, 1})) == true;",
        "assert LinkedListCycle(buildLinkedList(new int[]{1, 2, 0})) == true;"
      ],
      "compareHelper": "private boolean compareLinkedList(ListNode expected, ListNode actual) {\n    while (expected != null && actual != null) {\n        if (expected.val != actual.val) {\n            return false;\n        }\n        expected = expected.next;\n        actual = actual.next;\n    }\n    return expected == null && actual == null;\n}",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; this.next = null; } }\nListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; this.next = null; } }",
      "builders": "ListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "bool HasCycle(struct ListNode* head)",
      "testCalls": [
        "HasCycle(createLinkedListFromArray((int[]) {3, 2, 0, -4}, 4), 1)",
        "HasCycle(createLinkedListFromArray((int[]) {1, 2}, 2), 0)"
      ],
      "compareHelper": "",
      "helpers": "struct ListNode { int val; struct ListNode *next; }; \nstruct ListNode* createLinkedListFromArray(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (head == NULL) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head) { int size = 0; struct ListNode* curr = head; while (curr) { size++; curr = curr->next; } int* arr = (int*)malloc(sizeof(int) * size); curr = head; for (int i = 0; i < size; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode *next; };",
      "builders": "struct ListNode* createLinkedListFromArray(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (head == NULL) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head) { int size = 0; struct ListNode* curr = head; while (curr) { size++; curr = curr->next; } int* arr = (int*)malloc(sizeof(int) * size); curr = head; for (int i = 0; i < size; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func HasCycle(head *ListNode) bool",
      "testCalls": [
        "if result := HasCycle(NewLinkedList([]int{3, 2, 0, -4}, 1)); result != true { t.Errorf(\"Test 1 Failed: expected true, got %v\", result) }",
        "if result := HasCycle(NewLinkedList([]int{1, 2}, 0)); result != true { t.Errorf(\"Test 2 Failed: expected true, got %v\", result) }",
        "if result := HasCycle(NewLinkedList([]int{1}, -1)); result != false { t.Errorf(\"Test 3 Failed: expected false, got %v\", result) }"
      ],
      "compareHelper": "func NewLinkedList(values []int, pos int) *ListNode {\n\thead := &ListNode{Val: values[0]}\n\tprev := head\n\tposNode := &ListNode{}\n\tif pos == 0 {\n\t\tposNode = head\n\t}\n\tfor i := 1; i < len(values); i++ {\n\t\tnode := &ListNode{Val: values[i]}\n\t\tprev.Next = node\n\t\tprev = node\n\t\tif i == pos {\n\t\t\tposNode = node\n\t\t}\n\t}\n\tprev.Next = posNode\n\treturn head\n}\n\nfunc (l *ListNode) HasCycle() bool {\n\tslow, fast := l, l\n\tfor fast != nil && fast.Next != nil {\n\t\tslow = slow.Next\n\t\tfast = fast.Next.Next\n\t\tif slow == fast {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc NewLinkedList(arr []int, pos int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { node := &ListNode{Val: arr[i]} curr.Next = node curr = node } if pos != -1 { tail := head for pos > 0 { tail = tail.Next pos-- } curr.Next = tail } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := []int{} for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func NewLinkedList(arr []int, pos int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { node := &ListNode{Val: arr[i]} curr.Next = node curr = node } if pos != -1 { tail := head for pos > 0 { tail = tail.Next pos-- } curr.Next = tail } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := []int{} for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn LinkedListCycle(head: Option<Box<ListNode>>) -> bool {}",
      "testCalls": [
        "assert_eq!(LinkedListCycle(build_linked_list(vec![3, 2, 0, -4], 1)), true);",
        "assert_eq!(LinkedListCycle(build_linked_list(vec![1, 2], 0)), true);",
        "assert_eq!(LinkedListCycle(build_linked_list(vec![1], -1)), false);"
      ],
      "compareHelper": "impl Solution { pub fn create_linked_list_from_vec(values: Vec<i32>, pos: i32) -> Option<Box<ListNode>> { let mut head = None; let mut tail = &mut head; let mut cycle_node = None; for val in values { let new_node = Some(Box::new(ListNode { val, next: None })); if let Some(ref mut node) = tail { node.next = new_node.clone(); } if pos >= 0 && values.iter().position(|&x| x == val).unwrap() == pos as usize { cycle_node = tail; } tail = &mut tail.as_mut().unwrap().next; } if let Some(ref mut node) = tail { node.next = cycle_node; } head } }",
      "helpers": "use std::collections::HashSet;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>, pos: i32) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut tail = None;\n    let mut cycle_node = None;\n    let mut current = None;\n    let mut index = 0;\n\n    for val in arr {\n        let new_node = Some(Box::new(ListNode::new(val));\n        if index == pos {\n            cycle_node = new_node.clone();\n        }\n        if head.is_none() {\n            head = new_node.clone();\n        }\n        if let Some(ref mut node) = current {\n            node.next = new_node.clone();\n        }\n        current = new_node.clone();\n        index += 1;\n    }\n\n    if let Some(ref mut node) = current {\n        node.next = cycle_node;\n    }\n\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n\n    result\n}",
      "typeDefs": "use std::collections::HashSet;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: Vec<i32>, pos: i32) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut tail = None;\n    let mut cycle_node = None;\n    let mut current = None;\n    let mut index = 0;\n\n    for val in arr {\n        let new_node = Some(Box::new(ListNode::new(val));\n        if index == pos {\n            cycle_node = new_node.clone();\n        }\n        if head.is_none() {\n            head = new_node.clone();\n        }\n        if let Some(ref mut node) = current {\n            node.next = new_node.clone();\n        }\n        current = new_node.clone();\n        index += 1;\n    }\n\n    if let Some(ref mut node) = current {\n        node.next = cycle_node;\n    }\n\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def LinkedListCycle(head, pos)\nend",
      "testCalls": [
        "head1 = buildLinkedList([3,2,0,-4]); result1 = LinkedListCycle(head1, 1); raise 'Test Case 1 Failed' unless result1 == true",
        "head2 = buildLinkedList([1,2]); result2 = LinkedListCycle(head2, 0); raise 'Test Case 2 Failed' unless result2 == true",
        "head3 = buildLinkedList([1]); result3 = LinkedListCycle(head3, -1); raise 'Test Case 3 Failed' unless result3 == false"
      ],
      "compareHelper": "",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[3,2,0,-4]",
          "pos": "1"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1,2]",
          "pos": "0"
        },
        "expected": "true"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "head": "[1]",
          "pos": "-1"
        },
        "expected": "false"
      }
    ]
  },
  "longest-common-prefix": {
    "title": "Longest Common Prefix",
    "content": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.\n\nExample 1:\n\nInput: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\nOutput: &quot;fl&quot;\n\nExample 2:\n\nInput: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\nOutput: &quot;&quot;\nExplanation: There is no common prefix among the input strings.\n\n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "String",
      "Trie"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestCommonPrefix(strs) {}",
      "testCalls": [
        "if(LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) !== \"fl\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) !== \"\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestCommonPrefix(strs: string[]): string {}",
      "testCalls": [
        "if(LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) !== \"fl\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) !== \"\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string LongestCommonPrefix(vector<string>& strs)",
      "testCalls": [
        "assert(LongestCommonPrefix({\"flower\",\"flow\",\"flight\"}) == \"fl\");",
        "assert(LongestCommonPrefix({\"dog\",\"racecar\",\"car\"}) == \"\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestCommonPrefix(strs: List[str]) -> str:",
      "testCalls": [
        "assert LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"",
        "assert LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String LongestCommonPrefix(String[] strs) {}",
      "testCalls": [
        "assert LongestCommonPrefix(new String[]{\"flower\",\"flow\",\"flight\"}).equals(\"fl\");",
        "assert LongestCommonPrefix(new String[]{\"dog\",\"racecar\",\"car\"}).equals(\"\");"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* LongestCommonPrefix(char** strs, int strsSize)",
      "testCalls": [
        "LongestCommonPrefix((char*[]) {\"flower\",\"flow\",\"flight\"}, 3)",
        "LongestCommonPrefix((char*[]) {\"dog\",\"racecar\",\"car\"}, 3)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestCommonPrefix(strs []string) string {}",
      "testCalls": [
        "if LongestCommonPrefix([]string{\"flower\",\"flow\",\"flight\"}) != \"fl\" {panic(\"Test case 1 failed\")}",
        "if LongestCommonPrefix([]string{\"dog\",\"racecar\",\"car\"}) != \"\" {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestCommonPrefix(strs: Vec<String>) -> String {}",
      "testCalls": [
        "assert_eq!(LongestCommonPrefix(vec![String::from(\"flower\"), String::from(\"flow\"), String::from(\"flight\")]), \"fl\");",
        "assert_eq!(LongestCommonPrefix(vec![String::from(\"dog\"), String::from(\"racecar\"), String::from(\"car\")]), \"\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestCommonPrefix(strs)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"",
        "raise 'Test Case 2 Failed' unless LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\""
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "strs": "[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]"
        },
        "expected": "&quot;fl&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "strs": "[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]"
        },
        "expected": "&quot;&quot;"
      }
    ]
  },
  "longest-consecutive-sequence": {
    "title": "Longest Consecutive Sequence",
    "content": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs inO(n)time.\n\nExample 1:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\nExample 2:\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n\nExample 3:\n\nInput: nums = [1,0,1,2]\nOutput: 3\n\n\nConstraints:\n\n0 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestConsecutiveSequence(nums) {}",
      "testCalls": [
        "if(LongestConsecutiveSequence([100,4,200,1,3,2]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) !== 9) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestConsecutiveSequence([1,0,1,2]) !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function LongestConsecutiveSequence(nums: number[]): number {}",
      "testCalls": [
        "if(LongestConsecutiveSequence([100,4,200,1,3,2]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) !== 9) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestConsecutiveSequence([1,0,1,2]) !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "const arraysEqual = (a: number[], b: number[]) => JSON.stringify(a) === JSON.stringify(b);"
    },
    "cpp": {
      "functionDeclaration": "int LongestConsecutiveSequence(vector<int>& nums);",
      "testCalls": [
        "if(LongestConsecutiveSequence({100,4,200,1,3,2}) != 4) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(LongestConsecutiveSequence({0,3,7,2,5,8,4,6,0,1}) != 9) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "bool compareArrays(const vector<int>& arr1, const vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "LongestConsecutiveSequence(nums: List[int]) -> int",
      "testCalls": [
        "assert LongestConsecutiveSequence([100,4,200,1,3,2]) == 4",
        "assert LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) == 9",
        "assert LongestConsecutiveSequence([1,0,1,2]) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestConsecutiveSequence(int[] nums) { }",
      "testCalls": [
        "if(LongestConsecutiveSequence(new int[]{100,4,200,1,3,2}) != 4) throw new AssertionError();",
        "if(LongestConsecutiveSequence(new int[]{0,3,7,2,5,8,4,6,0,1}) != 9) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int LongestConsecutiveSequence(int* nums, int numsSize)",
      "testCalls": [
        "if(LongestConsecutiveSequence((int[]){100,4,200,1,3,2}, 6) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(LongestConsecutiveSequence((int[]){0,3,7,2,5,8,4,6,0,1}, 10) != 9) { printf(\"Test Case 2 Failed\"); }",
        "if(LongestConsecutiveSequence((int[]){1,0,1,2}, 4) != 3) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestConsecutiveSequence(nums []int) int {}",
      "testCalls": [
        "if LongestConsecutiveSequence([]int{100,4,200,1,3,2}) != 4 {panic(\"Test case 1 failed\")}",
        "if LongestConsecutiveSequence([]int{0,3,7,2,5,8,4,6,0,1}) != 9 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestConsecutiveSequence(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestConsecutiveSequence(vec![100, 4, 200, 1, 3, 2]), 4);",
        "assert_eq!(LongestConsecutiveSequence(vec![0, 3, 7, 2, 5, 8, 4, 6, 0, 1]), 9);",
        "assert_eq!(LongestConsecutiveSequence(vec![1, 0, 1, 2]), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestConsecutiveSequence(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestConsecutiveSequence([100,4,200,1,3,2]) == 4",
        "raise 'Test Case 2 Failed' unless LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) == 9",
        "raise 'Test Case 3 Failed' unless LongestConsecutiveSequence([1,0,1,2]) == 3"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[100,4,200,1,3,2]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,3,7,2,5,8,4,6,0,1]"
        },
        "expected": "9"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1,0,1,2]"
        },
        "expected": "3"
      }
    ]
  },
  "longest-increasing-subsequence": {
    "title": "Longest Increasing Subsequence",
    "content": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nExample 1:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\nExample 2:\n\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n\nExample 3:\n\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n\n\nConstraints:\n\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n\nFollow up:Can you come up with an algorithm that runs inO(n log(n)) time complexity?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestIncreasingSubsequence(nums) {}",
      "testCalls": [
        "if(LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestIncreasingSubsequence([0,1,0,3,2,3]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestIncreasingSubsequence([7,7,7,7,7,7,7]) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestIncreasingSubsequence(nums: number[]): number { }",
      "testCalls": [
        "if(LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(LongestIncreasingSubsequence([0,1,0,3,2,3]) !== 4) throw new Error('Test Case 2 Failed');",
        "if(LongestIncreasingSubsequence([7,7,7,7,7,7,7]) !== 1) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int LongestIncreasingSubsequence(vector<int>& nums);",
      "testCalls": [
        "if(LongestIncreasingSubsequence({10,9,2,5,3,7,101,18}) != 4) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(LongestIncreasingSubsequence({0,1,0,3,2,3}) != 4) throw std::runtime_error(\"Test Case 2 Failed\");",
        "if(LongestIncreasingSubsequence({7,7,7,7,7,7,7}) != 1) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestIncreasingSubsequence(nums: List[int]) -> int",
      "testCalls": [
        "assert LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) == 4",
        "assert LongestIncreasingSubsequence([0,1,0,3,2,3]) == 4",
        "assert LongestIncreasingSubsequence([7,7,7,7,7,7,7]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestIncreasingSubsequence(int[] nums) {}",
      "testCalls": [
        "if(LongestIncreasingSubsequence(new int[]{10,9,2,5,3,7,101,18}) != 4) throw new AssertionError();",
        "if(LongestIncreasingSubsequence(new int[]{0,1,0,3,2,3}) != 4) throw new AssertionError();",
        "if(LongestIncreasingSubsequence(new int[]{7,7,7,7,7,7,7}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LongestIncreasingSubsequence(int* nums, int numsSize)",
      "testCalls": [
        "if(LongestIncreasingSubsequence((int[]){10,9,2,5,3,7,101,18}, 8) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(LongestIncreasingSubsequence((int[]){0,1,0,3,2,3}, 6) != 4) { printf(\"Test Case 2 Failed\"); }",
        "if(LongestIncreasingSubsequence((int[]){7,7,7,7,7,7,7}, 7) != 1) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestIncreasingSubsequence(nums []int) int {}",
      "testCalls": [
        "if LongestIncreasingSubsequence([]int{10,9,2,5,3,7,101,18}) != 4 { panic(\"Test case 1 failed\") }",
        "if LongestIncreasingSubsequence([]int{0,1,0,3,2,3}) != 4 { panic(\"Test case 2 failed\") }",
        "if LongestIncreasingSubsequence([]int{7,7,7,7,7,7,7}) != 1 { panic(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestIncreasingSubsequence(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestIncreasingSubsequence(vec![10,9,2,5,3,7,101,18]), 4);",
        "assert_eq!(LongestIncreasingSubsequence(vec![0,1,0,3,2,3]), 4);",
        "assert_eq!(LongestIncreasingSubsequence(vec![7,7,7,7,7,7,7]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestIncreasingSubsequence(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) == 4",
        "raise 'Test Case 2 Failed' unless LongestIncreasingSubsequence([0,1,0,3,2,3]) == 4",
        "raise 'Test Case 3 Failed' unless LongestIncreasingSubsequence([7,7,7,7,7,7,7]) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[10,9,2,5,3,7,101,18]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1,0,3,2,3]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[7,7,7,7,7,7,7]"
        },
        "expected": "1"
      }
    ]
  },
  "longest-palindromic-substring": {
    "title": "Longest Palindromic Substring",
    "content": "Given a string s, return the longest palindromic substring in s.\n\nExample 1:\n\nInput: s = &quot;babad&quot;\nOutput: &quot;bab&quot;\nExplanation: &quot;aba&quot; is also a valid answer.\n\nExample 2:\n\nInput: s = &quot;cbbd&quot;\nOutput: &quot;bb&quot;\n\n\nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n\n",
    "difficulty": "Medium",
    "hints": [
      "How can we reuse a previously computed palindrome to compute a larger palindrome?",
      "If aba is a palindrome, is xabax a palindrome? Similarly is xabay a palindrome?",
      "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
    ],
    "topicTags": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestPalindromicSubstring(s) {}",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) !== &quot;bab&quot;) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) !== &quot;bb&quot;) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestPalindromicSubstring(s: string): string {}",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) !== &quot;bab&quot;) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) !== &quot;bb&quot;) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string LongestPalindromicSubstring(string s)",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) != &quot;bab&quot;) throw std::runtime_error(&quot;Test 1 failed&quot;);",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) != &quot;bb&quot;) throw std::runtime_error(&quot;Test 2 failed&quot;);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestPalindromicSubstring(s: str) -> str:",
      "testCalls": [
        "assert LongestPalindromicSubstring('babad') == 'bab', 'Test Case 1 Failed'",
        "assert LongestPalindromicSubstring('cbbd') == 'bb', 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String LongestPalindromicSubstring(String s) { }",
      "testCalls": [
        "if (!LongestPalindromicSubstring(\"babad\").equals(\"bab\")) { throw new AssertionError(); }",
        "if (!LongestPalindromicSubstring(\"cbbd\").equals(\"bb\")) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "LongestPalindromicSubstring(char* s)",
      "testCalls": [
        "LongestPalindromicSubstring(\"babad\")",
        "LongestPalindromicSubstring(\"cbbd\")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestPalindromicSubstring(s string) string {}",
      "testCalls": [
        "if LongestPalindromicSubstring(\"babad\") != \"bab\" {panic(\"Test case 1 failed\")}",
        "if LongestPalindromicSubstring(\"cbbd\") != \"bb\" {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestPalindromicSubstring(s: &str) -> String { }",
      "testCalls": [
        "assert_eq!(LongestPalindromicSubstring(\"babad\"), \"bab\");",
        "assert_eq!(LongestPalindromicSubstring(\"cbbd\"), \"bb\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestPalindromicSubstring(s)\nend",
      "testCalls": [
        "result = LongestPalindromicSubstring(&quot;babad&quot;)\nraise 'Test Case 1 Failed' unless result == &quot;bab&quot;",
        "result = LongestPalindromicSubstring(&quot;cbbd&quot;)\nraise 'Test Case 2 Failed' unless result == &quot;bb&quot;"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;babad&quot;"
        },
        "expected": "&quot;bab&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;cbbd&quot;"
        },
        "expected": "&quot;bb&quot;"
      }
    ]
  },
  "longest-substring-without-repeating-characters": {
    "title": "Longest Substring Without Repeating Characters",
    "content": "Given a string s, find the length of the longest substring without duplicate characters.\n\nExample 1:\n\nInput: s = &quot;abcabcbb&quot;\nOutput: 3\nExplanation: The answer is &quot;abc&quot;, with the length of 3. Note that &quot;bca&quot; and &quot;cab&quot; are also correct answers.\n\nExample 2:\n\nInput: s = &quot;bbbbb&quot;\nOutput: 1\nExplanation: The answer is &quot;b&quot;, with the length of 1.\n\nExample 3:\n\nInput: s = &quot;pwwkew&quot;\nOutput: 3\nExplanation: The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n\n\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestSubstringWithoutRepeatingCharacters(s) {}",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters('abcabcbb') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters('bbbbb') !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters('pwwkew') !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestSubstringWithoutRepeatingCharacters(s: string): number {}",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(&quot;abcabcbb&quot;) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters(&quot;bbbbb&quot;) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int LongestSubstringWithoutRepeatingCharacters(string s);",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestSubstringWithoutRepeatingCharacters(s: str) -> int:",
      "testCalls": [
        "assert LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") == 3",
        "assert LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") == 1",
        "assert LongestSubstringWithoutRepeatingCharacters(\"pwwkew\") == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestSubstringWithoutRepeatingCharacters(String s) { }",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) throw new AssertionError();",
        "if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LongestSubstringWithoutRepeatingCharacters(char* s)",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) { printf(\"Test Case 1 Failed\"); }",
        "if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestSubstringWithoutRepeatingCharacters(s string) int {}",
      "testCalls": [
        "if LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3 { t.Error(\"Test Case 1 Failed\") }",
        "if LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestSubstringWithoutRepeatingCharacters(s: &str) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestSubstringWithoutRepeatingCharacters(&\"abcabcbb\"), 3);",
        "assert_eq!(LongestSubstringWithoutRepeatingCharacters(&\"bbbbb\"), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestSubstringWithoutRepeatingCharacters(s)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestSubstringWithoutRepeatingCharacters(&quot;abcabcbb&quot;) == 3",
        "raise 'Test Case 2 Failed' unless LongestSubstringWithoutRepeatingCharacters(&quot;bbbbb&quot;) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;abcabcbb&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;bbbbb&quot;"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;pwwkew&quot;"
        },
        "expected": "3"
      }
    ]
  },
  "lowest-common-ancestor-of-a-binary-tree": {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;\n\nExample 1:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\nExample 2:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\n\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q will exist in the tree.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LowestCommonAncestor(root, p, q) {}",
      "testCalls": [
        "let root1 = buildTree([3,5,1,6,2,0,8,null,null,7,4]); if (LowestCommonAncestor(root1, 5, 1) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "let root2 = buildTree([3,5,1,6,2,0,8,null,null,7,4]); if (LowestCommonAncestor(root2, 5, 4) !== 5) { throw new Error('Test Case 2 Failed'); }",
        "let root3 = buildTree([1,2]); if (LowestCommonAncestor(root3, 1, 2) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function LowestCommonAncestor(root: TreeNode | null, p: number, q: number): TreeNode | null {}",
      "testCalls": [
        "if (LowestCommonAncestor(buildTree([3,5,1,6,2,0,8,null,null,7,4]), 5, 1)?.val !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (LowestCommonAncestor(buildTree([3,5,1,6,2,0,8,null,null,7,4]), 5, 4)?.val !== 5) { throw new Error('Test Case 2 Failed'); }",
        "if (LowestCommonAncestor(buildTree([1,2]), 1, 2)?.val !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }",
      "helpers": "class TreeNode { val: number; left: TreeNode | null; right: TreeNode | null; constructor(val = 0, left = null, right = null) { this.val = val; this.left = left; this.right = right; } static fromArray(arr: Array<number | null>): TreeNode | null { if (!arr.length || arr[0] === null) return null; const root = new TreeNode(arr[0] as number); const queue = [root]; let i = 1; while (queue.length && i < arr.length) { const node = queue.shift() as TreeNode; if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i] as number); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i] as number); queue.push(node.right); } i++; } return root; } }\nfunction buildTree(arr: Array<number | null>): TreeNode | null { return TreeNode.fromArray(arr); }\nfunction treeToArray(root: TreeNode | null): Array<number> { if (!root) return []; const result: Array<number | null> = []; const queue: Array<TreeNode | null> = [root]; while (queue.length) { const node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length - 1] === null) result.pop(); return result; }",
      "typeDefs": "class TreeNode { val: number; left: TreeNode | null; right: TreeNode | null; constructor(val = 0, left = null, right = null) { this.val = val; this.left = left; this.right = right; } }",
      "builders": "static fromArray(arr: Array<number | null>): TreeNode | null { if (!arr.length || arr[0] === null) return null; const root = new TreeNode(arr[0] as number); const queue = [root]; let i = 1; while (queue.length && i < arr.length) { const node = queue.shift() as TreeNode; if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i] as number); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i] as number); queue.push(node.right); } i++; } return root; }"
    },
    "cpp": {
      "functionDeclaration": "int LowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);",
      "testCalls": [
        "assert(LowestCommonAncestor(createTree({3,5,1,6,2,0,8,INT_MIN,INT_MIN,7,4}), new TreeNode(5), new TreeNode(1)) == 3);",
        "assert(LowestCommonAncestor(createTree({3,5,1,6,2,0,8,INT_MIN,INT_MIN,7,4}), new TreeNode(5), new TreeNode(4)) == 5);",
        "assert(LowestCommonAncestor(createTree({1,2}), new TreeNode(1), new TreeNode(2)) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); ++i) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def LowestCommonAncestor(root, p, q):",
      "testCalls": [
        "root = buildTree([3,5,1,6,2,0,8,None,None,7,4]); assert LowestCommonAncestor(root, 5, 1) == 3",
        "root = buildTree([3,5,1,6,2,0,8,None,None,7,4]); assert LowestCommonAncestor(root, 5, 4) == 5",
        "root = buildTree([1,2]); assert LowestCommonAncestor(root, 1, 2) == 1"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { }",
      "testCalls": [
        "TreeNode root1 = createTree(new Integer[]{3,5,1,6,2,0,8,null,null,7,4});\nTreeNode p1 = new TreeNode(5);\nTreeNode q1 = new TreeNode(1);\nassert lowestCommonAncestor(root1, p1, q1).val == 3 : \"Test Case 1 Failed\";",
        "TreeNode root2 = createTree(new Integer[]{3,5,1,6,2,0,8,null,null,7,4});\nTreeNode p2 = new TreeNode(5);\nTreeNode q2 = new TreeNode(4);\nassert lowestCommonAncestor(root2, p2, q2).val == 5 : \"Test Case 2 Failed\";",
        "TreeNode root3 = createTree(new Integer[]{1,2});\nTreeNode p3 = new TreeNode(1);\nTreeNode q3 = new TreeNode(2);\nassert lowestCommonAncestor(root3, p3, q3).val == 1 : \"Test Case 3 Failed\";"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}",
      "helpers": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }\npublic TreeNode createTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); List<TreeNode> queue = new ArrayList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.remove(0); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode createTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); List<TreeNode> queue = new ArrayList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.remove(0); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }"
    },
    "c": {
      "functionDeclaration": "int LowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)",
      "testCalls": [
        "int arr1[] = {3,5,1,6,2,0,8,-1,-1,7,4}; struct TreeNode* root1 = buildTree(arr1, 11); struct TreeNode* p1 = root1->left; struct TreeNode* q1 = root1->right; LowestCommonAncestor(root1, p1, q1); // Expected: 3",
        "int arr2[] = {3,5,1,6,2,0,-1,-1,-1,-1,7,4}; struct TreeNode* root2 = buildTree(arr2, 12); struct TreeNode* p2 = root2->left; struct TreeNode* q2 = root2->right->left; LowestCommonAncestor(root2, p2, q2); // Expected: 5",
        "int arr3[] = {3,5,1,6,2,0,-1,-1,-1,-1,7,4}; struct TreeNode* root3 = buildTree(arr3, 12); struct TreeNode* p3 = root3->left; struct TreeNode* q3 = root3->right; LowestCommonAncestor(root3, p3, q3); // Expected: 1"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; }; \nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == -1) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root->val = arr[0]; root->left = NULL; root->right = NULL; struct TreeNode* queue[size]; int i = 1, qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd && i < size) { struct TreeNode* node = queue[qStart++]; if (i < size && arr[i] != -1) { node->left = malloc(sizeof(struct TreeNode)); node->left->val = arr[i]; node->left->left = NULL; node->left->right = NULL; queue[qEnd++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = malloc(sizeof(struct TreeNode)); node->right->val = arr[i]; node->right->left = NULL; node->right->right = NULL; queue[qEnd++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = malloc(sizeof(int) * 1000); int resultIdx = 0; struct TreeNode* queue[1000]; int qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd) { struct TreeNode* node = queue[qStart++]; if (node) { result[resultIdx++] = node->val; if (node->left || node->right) { if (node->left) queue[qEnd++] = node->left; else queue[qEnd++] = NULL; if (node->right) queue[qEnd++] = node->right; else queue[qEnd++] = NULL; } } else { result[resultIdx++] = -1; } } while (result[resultIdx-1] == -1) resultIdx--; *returnSize = resultIdx; return result; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == -1) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root->val = arr[0]; root->left = NULL; root->right = NULL; struct TreeNode* queue[size]; int i = 1, qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd && i < size) { struct TreeNode* node = queue[qStart++]; if (i < size && arr[i] != -1) { node->left = malloc(sizeof(struct TreeNode)); node->left->val = arr[i]; node->left->left = NULL; node->left->right = NULL; queue[qEnd++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = malloc(sizeof(struct TreeNode)); node->right->val = arr[i]; node->right->left = NULL; node->right->right = NULL; queue[qEnd++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = malloc(sizeof(int) * 1000); int resultIdx = 0; struct TreeNode* queue[1000]; int qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd) { struct TreeNode* node = queue[qStart++]; if (node) { result[resultIdx++] = node->val; if (node->left || node->right) { if (node->left) queue[qEnd++] = node->left; else queue[qEnd++] = NULL; if (node->right) queue[qEnd++] = node->right; else queue[qEnd++] = NULL; } } else { result[resultIdx++] = -1; } } while (result[resultIdx-1] == -1) resultIdx--; *returnSize = resultIdx; return result; }"
    },
    "go": {
      "functionDeclaration": "func LowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode {}",
      "testCalls": [
        "if LowestCommonAncestor(BuildTree([]int{3,5,1,6,2,0,8,0,0,7,4}), &TreeNode{Val: 5}, &TreeNode{Val: 1}) != &TreeNode{Val: 3} { t.Error(\"Test Case 1 Failed\") }",
        "if LowestCommonAncestor(BuildTree([]int{3,5,1,6,2,0,8,0,0,7,4}), &TreeNode{Val: 5}, &TreeNode{Val: 4}) != &TreeNode{Val: 5} { t.Error(\"Test Case 2 Failed\") }",
        "if LowestCommonAncestor(BuildTree([]int{1,2}), &TreeNode{Val: 1}, &TreeNode{Val: 2}) != &TreeNode{Val: 1} { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func BuildTree(arr []int) *TreeNode {}",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc BuildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func BuildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn LowestCommonAncestor(root: Option<Box<TreeNode>>, p: i32, q: i32) -> Option<Box<TreeNode>> {}",
      "testCalls": [
        "let root = build_tree(vec![Some(3), Some(5), Some(1), Some(6), Some(2), Some(0), Some(8), None, None, Some(7), Some(4)]);\nassert_eq!(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) })), right: Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 0, left: None, right: None })), right: Some(Box::new(TreeNode { val: 8, left: None, right: None })) }))), LowestCommonAncestor(root, 5, 1));",
        "let root = build_tree(vec![Some(3), Some(5), Some(1), Some(6), Some(2), Some(0), Some(8), None, None, Some(7), Some(4)]);\nassert_eq!(Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) }), LowestCommonAncestor(root, 5, 4));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashMap;\nuse std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    let mut nodes: HashMap<i32, Box<TreeNode>> = HashMap::new();\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            nodes.insert(i as i32, Box::new(TreeNode::new(*v)));\n        }\n    }\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            if let Some(node) = nodes.get_mut(&(i as i32)) {\n                if let Some(left_val) = arr.get(2 * i + 1) {\n                    if let Some(left_node) = nodes.get(left_val) {\n                        node.left = Some(left_node.clone());\n                    }\n                }\n                if let Some(right_val) = arr.get(2 * i + 2) {\n                    if let Some(right_node) = nodes.get(right_val) {\n                        node.right = Some(right_node.clone());\n                    }\n                }\n            }\n        }\n    }\n    nodes.get(&0).cloned()\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(last) = result.last() {\n        if last.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}",
      "typeDefs": "use std::collections::HashMap;\nuse std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    let mut nodes: HashMap<i32, Box<TreeNode>> = HashMap::new();\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            nodes.insert(i as i32, Box::new(TreeNode::new(*v)));\n        }\n    }\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            if let Some(node) = nodes.get_mut(&(i as i32)) {\n                if let Some(left_val) = arr.get(2 * i + 1) {\n                    if let Some(left_node) = nodes.get(left_val) {\n                        node.left = Some(left_node.clone());\n                    }\n                }\n                if let Some(right_val) = arr.get(2 * i + 2) {\n                    if let Some(right_node) = nodes.get(right_val) {\n                        node.right = Some(right_node.clone());\n                    }\n                }\n            }\n        }\n    }\n    nodes.get(&0).cloned()\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(last) = result.last() {\n        if last.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def LowestCommonAncestor(root, p, q)\n  \nend",
      "testCalls": [
        "let root = buildTree([3,5,1,6,2,0,8,nil,nil,7,4]); LowestCommonAncestor(root, 5, 1)",
        "let root = buildTree([3,5,1,6,2,0,8,nil,nil,7,4]); LowestCommonAncestor(root, 5, 4)",
        "let root = buildTree([1,2]); LowestCommonAncestor(root, 1, 2)"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  # Implement buildTree function here\nend\ndef treeToArray(root)\n  # Implement treeToArray function here\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,5,1,6,2,0,8,null,null,7,4]",
          "p": "5",
          "q": "1"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[3,5,1,6,2,0,8,null,null,7,4]",
          "p": "5",
          "q": "4"
        },
        "expected": "5"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[1,2]",
          "p": "1",
          "q": "2"
        },
        "expected": "1"
      }
    ]
  },
  "majority-element": {
    "title": "Majority Element",
    "content": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than &lfloor;n / 2&rfloor; times. You may assume that the majority element always exists in the array.\n\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 104\n-109 <= nums[i] <= 109\nThe input is generated such that a majority element will exist in the array.\n\n\nFollow-up: Could you solve the problem in linear time and in O(1) space?",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Counting"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function MajorityElement(nums) {}",
      "testCalls": [
        "if (MajorityElement([3,2,3]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (MajorityElement([2,2,1,1,1,2,2]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MajorityElement(nums: number[]): number { }",
      "testCalls": [
        "const test1 = MajorityElement([3,2,3]); if (test1 !== 3) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MajorityElement([2,2,1,1,1,2,2]); if (test2 !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MajorityElement(vector<int>& nums);",
      "testCalls": [
        "assert(MajorityElement({3,2,3}) == 3);",
        "assert(MajorityElement({2,2,1,1,1,2,2}) == 2);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MajorityElement(nums: List[int]) -> int:",
      "testCalls": [
        "assert MajorityElement([3,2,3]) == 3",
        "assert MajorityElement([2,2,1,1,1,2,2]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MajorityElement(int[] nums) { }",
      "testCalls": [
        "assert MajorityElement(new int[]{3,2,3}) == 3;",
        "assert MajorityElement(new int[]{2,2,1,1,1,2,2}) == 2;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MajorityElement(int* nums, int numsSize)",
      "testCalls": [
        "if (MajorityElement((int[]){3,2,3}, 3) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (MajorityElement((int[]){2,2,1,1,1,2,2}, 7) != 2) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MajorityElement(nums []int) int {}",
      "testCalls": [
        "if MajorityElement([]int{3,2,3}) != 3 {panic(\"Test case 1 failed\")}",
        "if MajorityElement([]int{2,2,1,1,1,2,2}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MajorityElement(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MajorityElement(vec![3,2,3]), 3);",
        "assert_eq!(MajorityElement(vec![2,2,1,1,1,2,2]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MajorityElement(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MajorityElement([3,2,3]) == 3",
        "raise 'Test Case 2 Failed' unless MajorityElement([2,2,1,1,1,2,2]) == 2"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,2,3]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[2,2,1,1,1,2,2]"
        },
        "expected": "2"
      }
    ]
  },
  "max-points-on-a-line": {
    "title": "Max Points on a Line",
    "content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\nExample 1:\n\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\nExample 2:\n\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\n\n\nConstraints:\n\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaxPointsOnALine(points) {}",
      "testCalls": [
        "if(MaxPointsOnALine([[1,1],[2,2],[3,3]]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxPointsOnALine(points: number[][]): number { }",
      "testCalls": [
        "const test1 = MaxPointsOnALine([[1,1],[2,2],[3,3]]); if(test1 !== 3) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]); if(test2 !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxPointsOnALine(vector<vector<int>>& points)",
      "testCalls": [
        "assert(MaxPointsOnALine({{1,1},{2,2},{3,3}}) == 3);",
        "assert(MaxPointsOnALine({{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaxPointsOnALine(points: List[List[int]]) -> int",
      "testCalls": [
        "assert MaxPointsOnALine([[1,1],[2,2],[3,3]]) == 3",
        "assert MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public int MaxPointsOnALine(int[][] points) {}",
      "testCalls": [
        "int[][] test1 = {{1,1},{2,2},{3,3}}; int result1 = MaxPointsOnALine(test1); if (result1 != 3) { throw new AssertionError(); }",
        "int[][] test2 = {{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}; int result2 = MaxPointsOnALine(test2); if (result2 != 4) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxPointsOnALine(int** points, int pointsSize, int* pointsColSize)",
      "testCalls": [
        "if(MaxPointsOnALine((int*[]){{1,1},{2,2},{3,3}}, 3, (int[]){2, 2}) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxPointsOnALine((int*[]){{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}, 6, (int[]){2, 2}) != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxPointsOnALine(points [][]int) int {}",
      "testCalls": [
        "if MaxPointsOnALine([][]int{{1,1},{2,2},{3,3}}) != 3 {panic(\"Test case 1 failed\")}",
        "if MaxPointsOnALine([][]int{{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaxPointsOnALine(points: Vec<Vec<i32>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MaxPointsOnALine(vec![vec![1,1],vec![2,2],vec![3,3]]), 3);",
        "assert_eq!(MaxPointsOnALine(vec![vec![1,1],vec![3,2],vec![5,3],vec![4,1],vec![2,3],vec![1,4]]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaxPointsOnALine(points)\nend",
      "testCalls": [
        "test_case_1 = MaxPointsOnALine([[1,1],[2,2],[3,3]])\nraise 'Test Case 1 Failed' unless test_case_1 == 3",
        "test_case_2 = MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]])\nraise 'Test Case 2 Failed' unless test_case_2 == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "points": "[[1,1],[2,2],[3,3]]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "points": "[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]"
        },
        "expected": "4"
      }
    ]
  },
  "maximal-square": {
    "title": "Maximal Square",
    "content": "Given an m x n binary matrix filled with 0 and 1, find the largest square containing only 1 and return its area.\n\nExample 1:\n\n\nInput: matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\nOutput: 4\n\nExample 2:\n\n\nInput: matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]\nOutput: 1\n\nExample 3:\n\nInput: matrix = [[&quot;0&quot;]]\nOutput: 0\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 300\nmatrix[i][j] is &#39;0&#39; or &#39;1&#39;.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximalSquare(matrix) {}",
      "testCalls": [
        "if(MaximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(MaximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]]) !== 1) throw new Error('Test Case 2 Failed');",
        "if(MaximalSquare([[\"0\"]]) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximalSquare(matrix: string[][]): number { }",
      "testCalls": [
        "if(MaximalSquare([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(MaximalSquare([['0','1'],['1','0']]) !== 1) throw new Error('Test Case 2 Failed');",
        "if(MaximalSquare([['0']]) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaximalSquare(std::vector<std::vector<char>>& matrix)",
      "testCalls": [
        "if(MaximalSquare({{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}) != 4) throw std::runtime_error(\"Test 1 failed!\");",
        "if(MaximalSquare({{'0','1'},{'1','0'}}) != 1) throw std::runtime_error(\"Test 2 failed!\");",
        "if(MaximalSquare({{'0'}}) != 0) throw std::runtime_error(\"Test 3 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximalSquare(matrix: List[List[str]]) -> int",
      "testCalls": [
        "assert MaximalSquare([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) == 4",
        "assert MaximalSquare([['0','1'],['1','0']]) == 1",
        "assert MaximalSquare([['0']]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximalSquare(char[][] matrix) { }",
      "testCalls": [
        "int result1 = MaximalSquare(new char[][]{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}); if (result1 != 4) throw new AssertionError();",
        "int result2 = MaximalSquare(new char[][]{{'0','1'},{'1','0'}}); if (result2 != 1) throw new AssertionError();",
        "int result3 = MaximalSquare(new char[][]{{'0'}}); if (result3 != 0) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaximalSquare(char** matrix, int matrixSize, int* matrixColSize)",
      "testCalls": [
        "MaximalSquare((char*[]) {\"1\",\"0\",\"1\",\"0\",\"0\"}, 4, (int[]) {5}) == 4 ? printf(\"Test case 1 passed\\n\") : printf(\"Test case 1 failed\\n\");",
        "MaximalSquare((char*[]) {\"0\",\"1\",\"1\",\"0\"}, 2, (int[]) {2}) == 1 ? printf(\"Test case 2 passed\\n\") : printf(\"Test case 2 failed\\n\");",
        "MaximalSquare((char*[]) {\"0\"}, 1, (int[]) {1}) == 0 ? printf(\"Test case 3 passed\\n\") : printf(\"Test case 3 failed\\n\");"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaximalSquare(matrix [][]string) int {}",
      "testCalls": [
        "if MaximalSquare([][]string{{\"1\",\"0\",\"1\",\"0\",\"0\"},{\"1\",\"0\",\"1\",\"1\",\"1\"},{\"1\",\"1\",\"1\",\"1\",\"1\"},{\"1\",\"0\",\"0\",\"1\",\"0\"}}) != 4 { t.Error(\"Test Case 1 Failed\") }",
        "if MaximalSquare([][]string{{\"0\",\"1\"},{\"1\",\"0\"}}) != 1 { t.Error(\"Test Case 2 Failed\") }",
        "if MaximalSquare([][]string{{\"0\"}}) != 0 { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximalSquare(matrix: Vec<Vec<char>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaximalSquare(vec![vec![&'1', &'0', &'1', &'0', &'0'], vec![&'1', &'0', &'1', &'1', &'1'], vec![&'1', &'1', &'1', &'1', &'1'], vec![&'1', &'0', &'0', &'1', &'0']]), 4);",
        "assert_eq!(MaximalSquare(vec![vec![&'0', &'1'], vec![&'1', &'0']]), 1);",
        "assert_eq!(MaximalSquare(vec![vec![&'0']]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximalSquare(matrix)\nend",
      "testCalls": [
        "test1 = MaximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])\nraise 'Test Case 1 Failed' unless test1 == 4",
        "test2 = MaximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]])\nraise 'Test Case 2 Failed' unless test2 == 1",
        "test3 = MaximalSquare([[\"0\"]])\nraise 'Test Case 3 Failed' unless test3 == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "matrix": "[[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "matrix": "[[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "matrix": "[[&quot;0&quot;]]"
        },
        "expected": "0"
      }
    ]
  },
  "maximum-depth-of-binary-tree": {
    "title": "Maximum Depth of Binary Tree",
    "content": "Given the root of a binary tree, return its maximum depth.\nA binary tree maximum depthis the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\n\nInput: root = [1,null,2]\nOutput: 2\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaxDepthOfBinaryTree(root) {}",
      "testCalls": [
        "if(MaxDepthOfBinaryTree(buildTree([3,9,20,null,null,15,7])) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxDepthOfBinaryTree(buildTree([1,null,2])) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function MaxDepthOfBinaryTree(root: TreeNode | null): number { }",
      "testCalls": [
        "if(MaxDepthOfBinaryTree(buildTree([3,9,20,null,null,15,7])) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxDepthOfBinaryTree(buildTree([1,null,2])) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function createBinaryTree(arr: Array<number | null>): TreeNode | null { }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int MaxDepth(TreeNode* root)",
      "testCalls": [
        "assert(MaxDepth(createTree({3,9,20,INT_MIN,INT_MIN,15,7})) == 3);",
        "assert(MaxDepth(createTree({1,INT_MIN,2})) == 2);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } ++i; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } ++i; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } ++i; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } ++i; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def MaximumDepthOfBinaryTree(root: TreeNode) -> int",
      "testCalls": [
        "assert MaximumDepthOfBinaryTree(buildTree([3,9,20,None,None,15,7])) == 3",
        "assert MaximumDepthOfBinaryTree(buildTree([1,None,2])) == 2"
      ],
      "compareHelper": "def buildTree(nodes): pass",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public int maxDepth(TreeNode root) { }",
      "testCalls": [
        "if (maxDepth(buildTree(new Integer[]{3,9,20,null,null,15,7})) != 3) { throw new AssertionError(); }",
        "if (maxDepth(buildTree(new Integer[]{1,null,2})) != 2) { throw new AssertionError(); }"
      ],
      "compareHelper": "public static boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { if (root == null) return new int[0]; List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.add(node.left); queue.add(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { if (root == null) return new int[0]; List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.add(node.left); queue.add(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "int MaxDepth(struct TreeNode* root)",
      "testCalls": [
        "assert(MaxDepth(buildTreeFromArray((int[]) {3,9,20,-1,-1,15,7}, 7)) == 3);",
        "assert(MaxDepth(buildTreeFromArray((int[]) {1,-1,2}, 3)) == 2);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n    for (int i = 0; i < size; i++) {\n        if (arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createTreeNode(int val) { struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node->val = val; node->left = NULL; node->right = NULL; return node; }\nstruct TreeNode* buildTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = createTreeNode(arr[0]); struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (i < size) { struct TreeNode* current = queue[front++]; if (arr[i] != -1) { current->left = createTreeNode(arr[i]); queue[rear++] = current->left; } i++; if (i < size && arr[i] != -1) { current->right = createTreeNode(arr[i]); queue[rear++] = current->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int capacity = 1000, index = 0; int* result = (int*)malloc(sizeof(int) * capacity); struct TreeNode* queue[capacity]; int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* current = queue[front++]; if (current) { result[index++] = current->val; if (index == capacity) { capacity *= 2; result = (int*)realloc(result, sizeof(int) * capacity); } queue[rear++] = current->left; queue[rear++] = current->right; } else { result[index++] = -1; } } while (index > 0 && result[index - 1] == -1) index--; *returnSize = index; return result; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeNode(int val) { struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node->val = val; node->left = NULL; node->right = NULL; return node; }\nstruct TreeNode* buildTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = createTreeNode(arr[0]); struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (i < size) { struct TreeNode* current = queue[front++]; if (arr[i] != -1) { current->left = createTreeNode(arr[i]); queue[rear++] = current->left; } i++; if (i < size && arr[i] != -1) { current->right = createTreeNode(arr[i]); queue[rear++] = current->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int capacity = 1000, index = 0; int* result = (int*)malloc(sizeof(int) * capacity); struct TreeNode* queue[capacity]; int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* current = queue[front++]; if (current) { result[index++] = current->val; if (index == capacity) { capacity *= 2; result = (int*)realloc(result, sizeof(int) * capacity); } queue[rear++] = current->left; queue[rear++] = current->right; } else { result[index++] = -1; } } while (index > 0 && result[index - 1] == -1) index--; *returnSize = index; return result; }"
    },
    "go": {
      "functionDeclaration": "func MaxDepth(root *TreeNode) int {}",
      "testCalls": [
        "let root = buildTree([3,9,20,null,null,15,7]); if MaxDepth(root) != 3 { throw 'Test case 1 failed'; }",
        "let root = buildTree([1,null,2]); if MaxDepth(root) != 2 { throw 'Test case 2 failed'; }"
      ],
      "compareHelper": "",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn MaxDepth(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "let root1 = buildTree(vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]); assert_eq!(MaxDepth(root1), 3);",
        "let root2 = buildTree(vec![Some(1), None, Some(2)]); assert_eq!(MaxDepth(root2), 2);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() { return None; }\n    let root = Box::new(TreeNode::new(arr[0].unwrap()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(Some(val)) = arr.get(i) {\n                let left_child = Box::new(TreeNode::new(*val));\n                node.left = Some(left_child.clone());\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if let Some(Some(val)) = arr.get(i) {\n                let right_child = Box::new(TreeNode::new(*val));\n                node.right = Some(right_child.clone());\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.val));\n            if node.left.is_some() || node.right.is_some() {\n                queue.push_back(node.left.unwrap_or_else(|| Box::new(TreeNode::new(-1))));\n                queue.push_back(node.right.unwrap_or_else(|| Box::new(TreeNode::new(-1))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(Rc::clone(&root));\n    let mut i = 1;\n\n    while i < arr.len() {\n        if let Some(Some(val)) = arr.get(i) {\n            let left_node = Rc::new(RefCell::new(TreeNode::new(*val)));\n            if let Some(node) = queue.front() {\n                node.borrow_mut().left = Some(Rc::clone(&left_node));\n            }\n            queue.push_back(left_node);\n        }\n        i += 1;\n\n        if i < arr.len() {\n            if let Some(Some(val)) = arr.get(i) {\n                let right_node = Rc::new(RefCell::new(TreeNode::new(*val)));\n                if let Some(node) = queue.front() {\n                    node.borrow_mut().right = Some(Rc::clone(&right_node));\n                }\n                queue.push_back(right_node);\n            }\n            i += 1;\n        }\n\n        queue.pop_front();\n    }\n\n    Some(root)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n\n    if let Some(node) = root {\n        queue.push_back(Some(node));\n    }\n\n    while !queue.is_empty() {\n        if let Some(Some(node)) = queue.pop_front() {\n            result.push(Some(node.borrow().val));\n            if node.borrow().left.is_some() || node.borrow().right.is_some() {\n                queue.push_back(node.borrow().left.clone());\n                queue.push_back(node.borrow().right.clone());\n            }\n        } else {\n            result.push(None);\n        }\n    }\n\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def MaximumDepthOfBinaryTree(root)\nend",
      "testCalls": [
        "root = buildTree([3,9,20,nil,nil,15,7]); test_case_1 = MaximumDepthOfBinaryTree(root); raise 'Test Case 1 Failed' unless test_case_1 == 3",
        "root = buildTree([1,nil,2]); test_case_2 = MaximumDepthOfBinaryTree(root); raise 'Test Case 2 Failed' unless test_case_2 == 2"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,null,2]"
        },
        "expected": "2"
      }
    ]
  },
  "maximum-subarray": {
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximumSubarray(nums) {}",
      "testCalls": [
        "if(MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSubarray([1]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(MaximumSubarray([5,4,-1,7,8]) !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximumSubarray(nums: number[]): number {}",
      "testCalls": [
        "if (MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (MaximumSubarray([1]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if (MaximumSubarray([5,4,-1,7,8]) !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxSubarray(std::vector<int>& nums);",
      "testCalls": [
        "if(MaxSubarray({-2,1,-3,4,-1,2,1,-5,4}) != 6) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(MaxSubarray({1}) != 1) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximumSubarray(nums: List[int]) -> int",
      "testCalls": [
        "assert MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) == 6",
        "assert MaximumSubarray([1]) == 1",
        "assert MaximumSubarray([5,4,-1,7,8]) == 23"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximumSubarray(int[] nums) {}",
      "testCalls": [
        "if(MaximumSubarray(new int[]{-2,1,-3,4,-1,2,1,-5,4}) != 6) throw new AssertionError();",
        "if(MaximumSubarray(new int[]{1}) != 1) throw new AssertionError();",
        "if(MaximumSubarray(new int[]{5,4,-1,7,8}) != 23) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxSubarray(int* nums, int numsSize)",
      "testCalls": [
        "if(MaxSubarray((int[]){-2,1,-3,4,-1,2,1,-5,4}, 9) != 6) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxSubarray((int[]){1}, 1) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxSubarray(nums []int) int {}",
      "testCalls": [
        "if MaxSubarray([]int{-2,1,-3,4,-1,2,1,-5,4}) != 6 { panic(\"Test case 1 failed\") }",
        "if MaxSubarray([]int{1}) != 1 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximumSubarray(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaximumSubarray(vec![-2,1,-3,4,-1,2,1,-5,4]), 6);",
        "assert_eq!(MaximumSubarray(vec![1]), 1);",
        "assert_eq!(MaximumSubarray(vec![5,4,-1,7,8]), 23);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumSubarray(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) == 6",
        "raise 'Test Case 2 Failed' unless MaximumSubarray([1]) == 1",
        "raise 'Test Case 3 Failed' unless MaximumSubarray([5,4,-1,7,8]) == 23"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[-2,1,-3,4,-1,2,1,-5,4]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[5,4,-1,7,8]"
        },
        "expected": "23"
      }
    ]
  },
  "maximum-sum-circular-subarray": {
    "title": "Maximum Sum Circular Subarray",
    "content": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n\nExample 1:\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\n\nExample 2:\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\n\nExample 3:\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\n\n",
    "difficulty": "Medium",
    "hints": [
      "For those of you who are familiar with the Kadane's algorithm, think in terms of that. For the newbies, Kadane's algorithm is used to finding the maximum sum subarray from a given array. This problem is a twist on that idea and it is advisable to read up on that algorithm first before starting this problem. Unless you already have a great algorithm brewing up in your mind in which case, go right ahead!",
      "What is an alternate way of representing a circular array so that it appears to be a straight array?\r\nEssentially, there are two cases of this problem that we need to take care of. Let's look at the figure below to understand those two cases:\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/circular_subarray_hint_1.png\" width=\"700\"/>",
      "The first case can be handled by the good old Kadane's algorithm. However, is there a smarter way of going about handling the second case as well?"
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming",
      "Queue",
      "Monotonic Queue"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximumSumCircularSubarray(nums) {}",
      "testCalls": [
        "if(MaximumSumCircularSubarray([1,-2,3,-2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSumCircularSubarray([5,-3,5]) !== 10) { throw new Error('Test Case 2 Failed'); }",
        "if(MaximumSumCircularSubarray([-3,-2,-3]) !== -2) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximumSumCircularSubarray(nums: number[]): number {}",
      "testCalls": [
        "if(MaximumSumCircularSubarray([1,-2,3,-2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSumCircularSubarray([5,-3,5]) !== 10) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "MaximumSumCircularSubarray(vector<int>& nums)",
      "testCalls": [
        "if(MaximumSumCircularSubarray({1,-2,3,-2}) != 3) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(MaximumSumCircularSubarray({5,-3,5}) != 10) throw std::runtime_error(\"Test Case 2 Failed\");",
        "if(MaximumSumCircularSubarray({-3,-2,-3}) != -2) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximumSumCircularSubarray(nums: List[int]) -> int:",
      "testCalls": [
        "assert MaximumSumCircularSubarray([1,-2,3,-2]) == 3, 'Test Case 1 Failed'",
        "assert MaximumSumCircularSubarray([5,-3,5]) == 10, 'Test Case 2 Failed'",
        "assert MaximumSumCircularSubarray([-3,-2,-3]) == -2, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximumSumCircularSubarray(int[] nums) {}",
      "testCalls": [
        "if (MaximumSumCircularSubarray(new int[]{1,-2,3,-2}) != 3) throw new AssertionError();",
        "if (MaximumSumCircularSubarray(new int[]{5,-3,5}) != 10) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaximumSumCircularSubarray(int* nums, int numsSize)",
      "testCalls": [
        "if(MaximumSumCircularSubarray((int[]){1,-2,3,-2}, 4) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if(MaximumSumCircularSubarray((int[]){5,-3,5}, 3) != 10) { printf(\"Test Case 2 Failed\"); }",
        "if(MaximumSumCircularSubarray((int[]){-3,-2,-3}, 3) != -2) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaximumSumCircularSubarray(nums []int) int {}",
      "testCalls": [
        "if MaximumSumCircularSubarray([]int{1,-2,3,-2}) != 3 {panic(\"Test case 1 failed\")}",
        "if MaximumSumCircularSubarray([]int{5,-3,5}) != 10 {panic(\"Test case 2 failed\")}",
        "if MaximumSumCircularSubarray([]int{-3,-2,-3}) != -2 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximumSumCircularSubarray(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MaximumSumCircularSubarray(vec![1, -2, 3, -2]), 3);",
        "assert_eq!(MaximumSumCircularSubarray(vec![5, -3, 5]), 10);",
        "assert_eq!(MaximumSumCircularSubarray(vec![-3, -2, -3]), -2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumSumCircularSubarray(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MaximumSumCircularSubarray([1,-2,3,-2]) == 3",
        "raise 'Test Case 2 Failed' unless MaximumSumCircularSubarray([5,-3,5]) == 10"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,-2,3,-2]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[5,-3,5]"
        },
        "expected": "10"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[-3,-2,-3]"
        },
        "expected": "-2"
      }
    ]
  },
  "median-of-two-sorted-arrays": {
    "title": "Median of Two Sorted Arrays",
    "content": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MedianOfTwoSortedArrays(nums1, nums2) {}",
      "testCalls": [
        "if (MedianOfTwoSortedArrays([1,3], [2]) !== 2.00000) { throw new Error('Test Case 1 Failed'); }",
        "if (MedianOfTwoSortedArrays([1,2], [3,4]) !== 2.50000) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindMedianSortedArrays(nums1: number[], nums2: number[]): number[]",
      "testCalls": [
        "const test1Result = FindMedianSortedArrays([1,3], [2]); if (test1Result !== 2.00000) { throw new Error('Test Case 1 Failed'); }",
        "const test2Result = FindMedianSortedArrays([1,2], [3,4]); if (test2Result !== 2.50000) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "double FindMedianSortedArrays(vector<int>& nums1, vector<int>& nums2)",
      "testCalls": [
        "assert(FindMedianSortedArrays({1,3}, {2}) == 2.00000);",
        "assert(FindMedianSortedArrays({1,2}, {3,4}) == 2.50000);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MedianOfTwoSortedArrays(nums1, nums2):",
      "testCalls": [
        "result1 = MedianOfTwoSortedArrays([1,3], [2])\nif result1 != 2.00000:\n    raise AssertionError",
        "result2 = MedianOfTwoSortedArrays([1,2], [3,4])\nif result2 != 2.50000:\n    raise AssertionError"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public double FindMedianSortedArrays(int[] nums1, int[] nums2) {}",
      "testCalls": [
        "if (FindMedianSortedArrays(new int[]{1,3}, new int[]{2}) != 2.00000) throw new AssertionError();",
        "if (FindMedianSortedArrays(new int[]{1,2}, new int[]{3,4}) != 2.50000) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "double FindMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size)",
      "testCalls": [
        "if (FindMedianSortedArrays((int[]){1,3}, 2, (int[]){2}, 1) != 2.00000) { printf(\"Test case 1 failed\"); }",
        "if (FindMedianSortedArrays((int[]){1,2}, 2, (int[]){3,4}, 2) != 2.50000) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindMedianSortedArrays(nums1 []int, nums2 []int) float64 {}",
      "testCalls": [
        "if FindMedianSortedArrays([]int{1,3}, []int{2}) != 2.00000 { t.Error() }",
        "if FindMedianSortedArrays([]int{1,2}, []int{3,4}) != 2.50000 { t.Error() }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MedianOfTwoSortedArrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {}",
      "testCalls": [
        "assert_eq!(MedianOfTwoSortedArrays(vec![1, 3], vec![2]), 2.00000);",
        "assert_eq!(MedianOfTwoSortedArrays(vec![1, 2], vec![3, 4]), 2.50000);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MedianOfTwoSortedArrays(nums1, nums2)\nend",
      "testCalls": [
        "result1 = MedianOfTwoSortedArrays([1,3], [2])\nraise 'Test Case 1 Failed' unless result1 == 2.00000",
        "result2 = MedianOfTwoSortedArrays([1,2], [3,4])\nraise 'Test Case 2 Failed' unless result2 == 2.50000"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums1": "[1,3]",
          "nums2": "[2]"
        },
        "expected": "2.00000"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums1": "[1,2]",
          "nums2": "[3,4]"
        },
        "expected": "2.50000"
      }
    ]
  },
  "merge-intervals": {
    "title": "Merge Intervals",
    "content": "Given an arrayof intervalswhere intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\nExample 3:\n\nInput: intervals = [[4,7],[1,4]]\nOutput: [[1,7]]\nExplanation: Intervals [1,4] and [4,7] are considered overlapping.\n\n\nConstraints:\n\n1 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeIntervals(intervals) {}",
      "testCalls": [
        "const test1 = MergeIntervals([[1,3],[2,6],[8,10],[15,18]]); if(JSON.stringify(test1) !== '[[1,6],[8,10],[15,18]]') throw new Error('Test Case 1 Failed');",
        "const test2 = MergeIntervals([[1,4],[4,5]]); if(JSON.stringify(test2) !== '[[1,5]]') throw new Error('Test Case 2 Failed');",
        "const test3 = MergeIntervals([[4,7],[1,4]]); if(JSON.stringify(test3) !== '[[1,7]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeIntervals(intervals: number[][]): number[][] {}",
      "testCalls": [
        "const test1 = MergeIntervals([[1,3],[2,6],[8,10],[15,18]]); if (JSON.stringify(test1) !== '[[1,6],[8,10],[15,18]]') throw new Error('Test Case 1 Failed');",
        "const test2 = MergeIntervals([[1,4],[4,5]]); if (JSON.stringify(test2) !== '[[1,5]]') throw new Error('Test Case 2 Failed');",
        "const test3 = MergeIntervals([[4,7],[1,4]]); if (JSON.stringify(test3) !== '[[1,7]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> MergeIntervals(vector<vector<int>>& intervals);",
      "testCalls": [
        "auto res1 = MergeIntervals({{1,3},{2,6},{8,10},{15,18}}); assert(res1 == vector<vector<int>>{{1,6},{8,10},{15,18}});",
        "auto res2 = MergeIntervals({{1,4},{4,5}}); assert(res2 == vector<vector<int>>{{1,5}});",
        "auto res3 = MergeIntervals({{4,7},{1,4}}); assert(res3 == vector<vector<int>>{{1,7}});"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MergeIntervals(intervals: List[List[int]]) -> List[List[int]]",
      "testCalls": [
        "assert MergeIntervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]",
        "assert MergeIntervals([[1,4],[4,5]]) == [[1,5]]",
        "assert MergeIntervals([[4,7],[1,4]]) == [[1,7]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public int[][] MergeIntervals(int[][] intervals) { }",
      "testCalls": [
        "int[][] test1 = MergeIntervals(new int[][]{{1,3},{2,6},{8,10},{15,18}}); if (!Arrays.deepEquals(test1, new int[][]{{1,6},{8,10},{15,18}})) throw new AssertionError();",
        "int[][] test2 = MergeIntervals(new int[][]{{1,4},{4,5}}); if (!Arrays.deepEquals(test2, new int[][]{{1,5}})) throw new AssertionError();",
        "int[][] test3 = MergeIntervals(new int[][]{{4,7},{1,4}}); if (!Arrays.deepEquals(test3, new int[][]{{1,7}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) { return Arrays.deepEquals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int** MergeIntervals(int** intervals, int intervalsSize, int* intervalsColSize)",
      "testCalls": [
        "MergeIntervals((int*[]){{1,3},{2,6},{8,10},{15,18}}, 4, (int[]){2, 2}); // Expected: [[1,6],[8,10],[15,18]]",
        "MergeIntervals((int*[]){{1,4},{4,5}}, 2, (int[]){2, 2}); // Expected: [[1,5]]",
        "MergeIntervals((int*[]){{4,7},{1,4}}, 2, (int[]){2, 2}); // Expected: [[1,7]]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n    if(size1 != size2) return 0;\n    for(int i = 0; i < size1; i++) {\n        if(arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MergeIntervals(intervals [][]int) [][]int {}",
      "testCalls": [
        "result1 := MergeIntervals([][]int{{1,3},{2,6},{8,10},{15,18}}); if !compareArrays(result1, [][]int{{1,6},{8,10},{15,18}}) { t.Error(\"Test case 1 failed\") }",
        "result2 := MergeIntervals([][]int{{1,4},{4,5}}); if !compareArrays(result2, [][]int{{1,5}}) { t.Error(\"Test case 2 failed\") }",
        "result3 := MergeIntervals([][]int{{4,7},{1,4}}); if !compareArrays(result3, [][]int{{1,7}}) { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i][0] != arr2[i][0] || arr1[i][1] != arr2[i][1] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeIntervals(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = MergeIntervals(vec![vec![1,3], vec![2,6], vec![8,10], vec![15,18]]); assert_eq!(result1, vec![vec![1,6], vec![8,10], vec![15,18]]);",
        "let result2 = MergeIntervals(vec![vec![1,4], vec![4,5]]); assert_eq!(result2, vec![vec![1,5]]);",
        "let result3 = MergeIntervals(vec![vec![4,7], vec![1,4]]); assert_eq!(result3, vec![vec![1,7]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_eq(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i], b[i]); } }"
    },
    "ruby": {
      "functionDeclaration": "def MergeIntervals(intervals)\n  \nend",
      "testCalls": [
        "intervals1 = [[1,3],[2,6],[8,10],[15,18]]\nexpected_result1 = [[1,6],[8,10],[15,18]]\nresult1 = MergeIntervals(intervals1)\nraise 'Test Case 1 Failed' unless result1 == expected_result1",
        "intervals2 = [[1,4],[4,5]]\nexpected_result2 = [[1,5]]\nresult2 = MergeIntervals(intervals2)\nraise 'Test Case 2 Failed' unless result2 == expected_result2"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "intervals": "[[1,3],[2,6],[8,10],[15,18]]"
        },
        "expected": "[[1,6],[8,10],[15,18]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "intervals": "[[1,4],[4,5]]"
        },
        "expected": "[[1,5]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "intervals": "[[4,7],[1,4]]"
        },
        "expected": "[[1,7]]"
      }
    ]
  },
  "merge-k-sorted-lists": {
    "title": "Merge k Sorted Lists",
    "content": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\nExample 2:\n\nInput: lists = []\nOutput: []\n\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n\n\nConstraints:\n\nk == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeKSortedLists(lists) {}",
      "testCalls": [
        "let test1 = MergeKSortedLists([buildLinkedList([1,4,5]), buildLinkedList([1,3,4]), buildLinkedList([2,6])]); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,1,2,3,4,4,5,6])) throw new Error('Test Case 1 Failed');",
        "let test2 = MergeKSortedLists([]); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');",
        "let test3 = MergeKSortedLists([buildLinkedList([])]); if(JSON.stringify(linkedListToArray(test3)) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function MergeKSortedLists(lists: number[][]): number[] | null {}",
      "testCalls": [
        "const test1 = MergeKSortedLists([buildLinkedList([1,4,5]), buildLinkedList([1,3,4]), buildLinkedList([2,6])]); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,1,2,3,4,4,5,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = MergeKSortedLists([]); if(JSON.stringify(test2) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');",
        "const test3 = MergeKSortedLists([null]); if(JSON.stringify(test3) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "",
      "builders": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* MergeKSortedLists(vector<ListNode*>& lists)",
      "testCalls": [
        "assert(compareLinkedLists(MergeKSortedLists({buildLinkedList({1,4,5}), buildLinkedList({1,3,4}), buildLinkedList({2,6})}), buildLinkedList({1,1,2,3,4,4,5,6})));",
        "assert(compareLinkedLists(MergeKSortedLists({})), nullptr);",
        "assert(compareLinkedLists(MergeKSortedLists({nullptr})), nullptr);"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; \nListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def MergeKSortedLists(lists: List[List[int]]) -> List[int]:",
      "testCalls": [
        "l1 = buildLinkedList([1,4,5]); l2 = buildLinkedList([1,3,4]); l3 = buildLinkedList([2,6]); result = MergeKSortedLists([l1, l2, l3]); assert linkedListToArray(result) == [1,1,2,3,4,4,5,6], 'Test Case 1 Failed'",
        "result = MergeKSortedLists([]); assert linkedListToArray(result) == [], 'Test Case 2 Failed'",
        "result = MergeKSortedLists([None]); assert linkedListToArray(result) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode mergeKSortedLists(ListNode[] lists)",
      "testCalls": [
        "ListNode[] testInput1 = {buildLinkedList(new int[]{1,4,5}), buildLinkedList(new int[]{1,3,4}), buildLinkedList(new int[]{2,6})};\nListNode expectedResult1 = buildLinkedList(new int[]{1,1,2,3,4,4,5,6});\ncompareLinkedLists(expectedResult1, mergeKSortedLists(testInput1));",
        "ListNode[] testInput2 = {};\nListNode expectedResult2 = null;\ncompareLinkedLists(expectedResult2, mergeKSortedLists(testInput2));",
        "ListNode[] testInput3 = {buildLinkedList(new int[]{})};\nListNode expectedResult3 = null;\ncompareLinkedLists(expectedResult3, mergeKSortedLists(testInput3));"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode expected, ListNode actual) {\n    while (expected != null && actual != null) {\n        if (expected.val != actual.val) {\n            throw new AssertionError(\"Mismatch in linked list values\");\n        }\n        expected = expected.next;\n        actual = actual.next;\n    }\n    if (expected != null || actual != null) {\n        throw new AssertionError(\"Linked lists are of different lengths\");\n    }\n}",
      "helpers": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "MergeKSortedLists(int** lists, int listsSize, int* listsColSize)",
      "testCalls": [
        "struct ListNode* l1 = buildLinkedList((int[]){1,4,5}, 3); struct ListNode* l2 = buildLinkedList((int[]){1,3,4}, 3); struct ListNode* l3 = buildLinkedList((int[]){2,6}, 2); struct ListNode* lists[3] = {l1, l2, l3}; int listsColSize[3] = {3, 3, 2}; MergeKSortedLists(lists, 3, listsColSize);",
        "MergeKSortedLists(NULL, 0, NULL);"
      ],
      "compareHelper": "",
      "helpers": "struct ListNode { int val; struct ListNode* next; }; \nstruct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func MergeKSortedLists(lists [][]int) []int {}",
      "testCalls": [
        "result1 := MergeKSortedLists([][]int{{1,4,5},{1,3,4},{2,6}}); if !compareArrays(result1, []int{1,1,2,3,4,4,5,6}) { t.Error(\"Test case 1 failed\") }",
        "result2 := MergeKSortedLists([][]int{}); if !compareArrays(result2, []int{}) { t.Error(\"Test case 2 failed\") }",
        "result3 := MergeKSortedLists([][]int{{}}); if !compareArrays(result3, []int{}) { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeKSortedLists(lists: Vec<Vec<i32>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode::from(vec![1, 1, 2, 3, 4, 4, 5, 6]))), MergeKSortedLists(vec![vec![1, 4, 5], vec![1, 3, 4], vec![2, 6]]));",
        "assert_eq!(None, MergeKSortedLists(vec![]));",
        "assert_eq!(None, MergeKSortedLists(vec![vec![]]));"
      ],
      "compareHelper": "fn compare_linked_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) { }",
      "helpers": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}",
      "typeDefs": "#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}",
      "builders": "impl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeKSortedLists(lists)\nend",
      "testCalls": [
        "l1 = buildLinkedList([1,4,5]); l2 = buildLinkedList([1,3,4]); l3 = buildLinkedList([2,6]); result1 = MergeKSortedLists([l1, l2, l3]); raise 'Test Case 1 Failed' unless linkedListToArray(result1) == [1,1,2,3,4,4,5,6]",
        "result2 = MergeKSortedLists([]); raise 'Test Case 2 Failed' unless linkedListToArray(result2) == []",
        "result3 = MergeKSortedLists([nil]); raise 'Test Case 3 Failed' unless linkedListToArray(result3) == []"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "lists": "[[1,4,5],[1,3,4],[2,6]]"
        },
        "expected": "[1,1,2,3,4,4,5,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "lists": "[]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "lists": "[[]]"
        },
        "expected": "[]"
      }
    ]
  },
  "merge-sorted-array": {
    "title": "Merge Sorted Array",
    "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\nExample 1:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n\nExample 2:\n\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\nExample 3:\n\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\nConstraints:\n\nnums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-109 <= nums1[i], nums2[j] <= 109\n\n\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?\n",
    "difficulty": "Easy",
    "hints": [
      "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
      "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeSortedArray(nums1, m, nums2, n) {}",
      "testCalls": [
        "MergeSortedArray([1,2,3,0,0,0], 3, [2,5,6], 3);",
        "MergeSortedArray([1], 1, [], 0);",
        "MergeSortedArray([0], 0, [1], 1);"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeSortedArray(nums1: number[], m: number, nums2: number[], n: number): void {}",
      "testCalls": [
        "MergeSortedArray([1,2,3,0,0,0], 3, [2,5,6], 3); if (JSON.stringify(nums1) !== JSON.stringify([1,2,2,3,5,6])) throw new Error('Test Case 1 Failed');",
        "MergeSortedArray([1], 1, [], 0); if (JSON.stringify(nums1) !== JSON.stringify([1])) throw new Error('Test Case 2 Failed');",
        "MergeSortedArray([0], 0, [1], 1); if (JSON.stringify(nums1) !== JSON.stringify([1])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "void MergeSortedArray(vector<int>& nums1, int m, vector<int>& nums2, int n)",
      "testCalls": [
        "MergeSortedArray({1,2,3,0,0,0}, 3, {2,5,6}, 3);",
        "MergeSortedArray({1}, 1, {}, 0);",
        "MergeSortedArray({0}, 0, {1}, 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def MergeSortedArray(nums1, m, nums2, n):",
      "testCalls": [
        "result1 = [1,2,3,0,0,0]\nMergeSortedArray(result1, 3, [2,5,6], 3)\nassert result1 == [1,2,2,3,5,6]",
        "result2 = [1]\nMergeSortedArray(result2, 1, [], 0)\nassert result2 == [1]",
        "result3 = [0]\nMergeSortedArray(result3, 0, [1], 1)\nassert result3 == [1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public void MergeSortedArray(int[] nums1, int m, int[] nums2, int n) {}",
      "testCalls": [
        "MergeSortedArray(new int[]{1,2,3,0,0,0}, 3, new int[]{2,5,6}, 3); // compareArrays(nums1, new int[]{1,2,2,3,5,6});",
        "MergeSortedArray(new int[]{1}, 1, new int[]{}, 0); // compareArrays(nums1, new int[]{1});",
        "MergeSortedArray(new int[]{0}, 0, new int[]{1}, 1); // compareArrays(nums1, new int[]{1});"
      ],
      "compareHelper": "private void compareArrays(int[] arr1, int[] arr2) { for (int i = 0; i < arr1.length; i++) { if (arr1[i] != arr2[i]) { throw new AssertionError(\"Arrays differ at index \" + i); } } }"
    },
    "c": {
      "functionDeclaration": "void MergeSortedArray(int* nums1, int m, int* nums2, int n)",
      "testCalls": [
        "MergeSortedArray((int[]){1,2,3,0,0,0}, 3, (int[]){2,5,6}, 3);",
        "MergeSortedArray((int[]){1}, 1, (int[]){}, 0);",
        "MergeSortedArray((int[]){0}, 0, (int[]){1}, 1);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n  for (int i = 0; i < size; i++) {\n    if (arr1[i] != arr2[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MergeSortedArray(nums1 []int, m int, nums2 []int, n int) {}",
      "testCalls": [
        "if !compareArrays(MergeSortedArray([]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3), []int{1, 2, 2, 3, 5, 6}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(MergeSortedArray([]int{1}, 1, []int{}, 0), []int{1}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(MergeSortedArray([]int{0}, 0, []int{1}, 1), []int{1}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeSortedArray(nums1: &mut Vec<i32>, m: i32, nums2: &Vec<i32>, n: i32) {}",
      "testCalls": [
        "let mut test1_nums1 = vec![1, 2, 3, 0, 0, 0];\nlet test1_nums2 = vec![2, 5, 6];\nMergeSortedArray(&mut test1_nums1, 3, &test1_nums2, 3);\nassert_eq!(test1_nums1, vec![1, 2, 2, 3, 5, 6]);",
        "let mut test2_nums1 = vec![1];\nlet test2_nums2 = vec![];\nMergeSortedArray(&mut test2_nums1, 1, &test2_nums2, 0);\nassert_eq!(test2_nums1, vec![1]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: &Vec<i32>, b: &Vec<i32>) {\n    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert_eq!(a[i], b[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeSortedArray(nums1, m, nums2, n)\nend",
      "testCalls": [
        "nums1 = [1,2,3,0,0,0]\nm = 3\nnums2 = [2,5,6]\nn = 3\nMergeSortedArray(nums1, m, nums2, n)\nraise 'Test Case 1 Failed' unless nums1 == [1,2,2,3,5,6]",
        "nums1 = [1]\nm = 1\nnums2 = []\nn = 0\nMergeSortedArray(nums1, m, nums2, n)\nraise 'Test Case 2 Failed' unless nums1 == [1]"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums1": "[1,2,3,0,0,0]",
          "m": "3",
          "nums2": "[2,5,6]",
          "n": "3"
        },
        "expected": "[1,2,2,3,5,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums1": "[1]",
          "m": "1",
          "nums2": "[]",
          "n": "0"
        },
        "expected": "[1]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums1": "[0]",
          "m": "0",
          "nums2": "[1]",
          "n": "1"
        },
        "expected": "[1]"
      }
    ]
  },
  "merge-two-sorted-lists": {
    "title": "Merge Two Sorted Lists",
    "content": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\n\nExample 1:\n\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n\nConstraints:\n\nThe number of nodes in both lists is in the range [0, 50].\n-100 <= Node.val <= 100\nBoth list1 and list2 are sorted in non-decreasing order.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeTwoSortedLists(list1, list2) {}",
      "testCalls": [
        "let test1 = MergeTwoSortedLists(buildLinkedList([1,2,4]), buildLinkedList([1,3,4])); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,1,2,3,4,4])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = MergeTwoSortedLists(null, null); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "let test3 = MergeTwoSortedLists(null, buildLinkedList([0])); if(JSON.stringify(linkedListToArray(test3)) !== JSON.stringify([0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function MergeTwoSortedLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {}",
      "testCalls": [
        "const test1Result = MergeTwoSortedLists(buildLinkedList([1,2,4]), buildLinkedList([1,3,4])); compareLinkedLists(test1Result, buildLinkedList([1,1,2,3,4,4]));",
        "const test2Result = MergeTwoSortedLists(null, null); compareLinkedLists(test2Result, null);",
        "const test3Result = MergeTwoSortedLists(null, buildLinkedList([0])); compareLinkedLists(test3Result, buildLinkedList([0]));"
      ],
      "compareHelper": "function compareLinkedLists(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); } }",
      "helpers": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "",
      "builders": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* MergeTwoSortedLists(ListNode* list1, ListNode* list2)",
      "testCalls": [
        "assert(compareLinkedLists(MergeTwoSortedLists(buildLinkedList({1,2,4}), buildLinkedList({1,3,4})), buildLinkedList({1,1,2,3,4,4}));",
        "assert(compareLinkedLists(MergeTwoSortedLists(buildLinkedList({}), buildLinkedList({})), buildLinkedList({}));",
        "assert(compareLinkedLists(MergeTwoSortedLists(buildLinkedList({}), buildLinkedList({0})), buildLinkedList({0}));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; \nListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def MergeTwoSortedLists(list1, list2):",
      "testCalls": [
        "l1 = buildLinkedList([1,2,4]); l2 = buildLinkedList([1,3,4]); result = MergeTwoSortedLists(l1, l2); assert linkedListToArray(result) == [1,1,2,3,4,4], 'Test Case 1 Failed'",
        "result = MergeTwoSortedLists(None, None); assert linkedListToArray(result) == [], 'Test Case 2 Failed'",
        "l = buildLinkedList([0]); result = MergeTwoSortedLists(None, l); assert linkedListToArray(result) == [0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode mergeTwoSortedLists(ListNode list1, ListNode list2) { }",
      "testCalls": [
        "ListNode expected1 = buildLinkedList(new int[]{1, 1, 2, 3, 4, 4}); ListNode result1 = mergeTwoSortedLists(buildLinkedList(new int[]{1, 2, 4}), buildLinkedList(new int[]{1, 3, 4})); assertLinkedListEquals(expected1, result1);",
        "ListNode expected2 = buildLinkedList(new int[]{}); ListNode result2 = mergeTwoSortedLists(buildLinkedList(new int[]{}), buildLinkedList(new int[]{})); assertLinkedListEquals(expected2, result2);",
        "ListNode expected3 = buildLinkedList(new int[]{0}); ListNode result3 = mergeTwoSortedLists(buildLinkedList(new int[]{}), buildLinkedList(new int[]{0})); assertLinkedListEquals(expected3, result3);"
      ],
      "compareHelper": "private void assertLinkedListEquals(ListNode expected, ListNode actual) { while (expected != null && actual != null) { if (expected.val != actual.val) { throw new AssertionError(\"Value mismatch: expected=\" + expected.val + \", actual=\" + actual.val); } expected = expected.next; actual = actual.next; } if (expected != null || actual != null) { throw new AssertionError(\"Length mismatch\"); } }",
      "helpers": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "struct ListNode* MergeTwoSortedLists(struct ListNode* list1, struct ListNode* list2)",
      "testCalls": [
        "struct ListNode* list1 = buildLinkedList((int[]){1,2,4}, 3); struct ListNode* list2 = buildLinkedList((int[]){1,3,4}, 3); MergeTwoSortedLists(list1, list2);",
        "MergeTwoSortedLists(NULL, NULL);",
        "struct ListNode* list2 = buildLinkedList((int[]){0}, 1); MergeTwoSortedLists(NULL, list2);"
      ],
      "compareHelper": "int compareArrays(struct ListNode* l1, struct ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return 0; l1 = l1->next; l2 = l2->next; } return l1 == NULL && l2 == NULL; }",
      "helpers": "struct ListNode { int val; struct ListNode* next; }; \nstruct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func MergeTwoSortedLists(list1 *ListNode, list2 *ListNode) *ListNode {}",
      "testCalls": [
        "if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{1, 2, 4}), sliceToListNode([]int{1, 3, 4})), sliceToListNode([]int{1, 1, 2, 3, 4, 4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{}), sliceToListNode([]int{})), sliceToListNode([]int{})) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{}), sliceToListNode([]int{0})), sliceToListNode([]int{0})) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }"
    },
    "rust": {
      "functionDeclaration": "fn MergeTwoSortedLists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 4, next: None) } } } } } } } } } } } } } })), MergeTwoSortedLists(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 4, next: None) } } } })), Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: None) } } } })))).unwrap());",
        "assert_eq!(None, MergeTwoSortedLists(None, None));",
        "assert_eq!(Some(Box::new(ListNode { val: 0, next: None })), MergeTwoSortedLists(None, Some(Box::new(ListNode { val: 0, next: None })));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}",
      "typeDefs": "#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}",
      "builders": "impl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeTwoSortedLists(list1, list2)\nend",
      "testCalls": [
        "l1 = buildLinkedList([1,2,4]); l2 = buildLinkedList([1,3,4]); result1 = MergeTwoSortedLists(l1, l2); raise 'Test Case 1 Failed' unless linkedListToArray(result1) == [1,1,2,3,4,4]",
        "result2 = MergeTwoSortedLists(nil, nil); raise 'Test Case 2 Failed' unless linkedListToArray(result2) == []",
        "result3 = MergeTwoSortedLists(nil, buildLinkedList([0])); raise 'Test Case 3 Failed' unless linkedListToArray(result3) == [0]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "list1": "[1,2,4]",
          "list2": "[1,3,4]"
        },
        "expected": "[1,1,2,3,4,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "list1": "[]",
          "list2": "[]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "list1": "[]",
          "list2": "[0]"
        },
        "expected": "[0]"
      }
    ]
  },
  "minimum-absolute-difference-in-bst": {
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\n\nExample 1:\n\n\nInput: root = [4,2,6,1,3]\nOutput: 1\n\nExample 2:\n\n\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 104].\n0 <= Node.val <= 105\n\n\nNote: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumAbsoluteDifferenceInBST(root) {}",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(buildTree([4,2,6,1,3])) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumAbsoluteDifferenceInBST(buildTree([1,0,48,null,null,12,49])) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function MinimumAbsoluteDifferenceInBST(root: TreeNode | null): number {}",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(createTreeNode([4,2,6,1,3])) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumAbsoluteDifferenceInBST(createTreeNode([1,0,48,null,null,12,49])) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function createTreeNode(arr: Array<number | null>): TreeNode | null {}",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int MinDiffInBST(TreeNode* root)",
      "testCalls": [
        "assert(MinDiffInBST(buildTree({4,2,6,1,3})) == 1);",
        "assert(MinDiffInBST(buildTree({1,0,48,INT_MIN,INT_MIN,12,49})) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def MinimumAbsoluteDifferenceInBST(root):",
      "testCalls": [
        "root = buildTree([4,2,6,1,3]); assert MinimumAbsoluteDifferenceInBST(root) == 1",
        "root = buildTree([1,0,48,None,None,12,49]); assert MinimumAbsoluteDifferenceInBST(root) == 1"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public int MinimumAbsoluteDifferenceInBST(TreeNode root) { }",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(buildTree(new Integer[]{4,2,6,1,3})) != 1) { throw new AssertionError(); }",
        "if (MinimumAbsoluteDifferenceInBST(buildTree(new Integer[]{1,0,48,null,null,12,49})) != 1) { throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }",
      "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "int GetMinimumDifference(struct TreeNode* root)",
      "testCalls": [
        "if(GetMinimumDifference(buildTree((int[]){4,2,6,1,3}, 5)) != 1) { printf(\"Test Case 1 Failed\"); }",
        "if(GetMinimumDifference(buildTree((int[]){1,0,48,INT_MIN,INT_MIN,12,49}, 7)) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; \nstruct TreeNode* createNode(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == INT_MIN) return NULL; struct TreeNode* root = createNode(arr[0]); struct TreeNode* queue[size]; int i = 1, qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd && i < size) { struct TreeNode* node = queue[qStart++]; if (i < size && arr[i] != INT_MIN) { node->left = createNode(arr[i]); queue[qEnd++] = node->left; } i++; if (i < size && arr[i] != INT_MIN) { node->right = createNode(arr[i]); queue[qEnd++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 10000); int index = 0; struct TreeNode* queue[10000]; int qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd) { struct TreeNode* node = queue[qStart++]; if (node) { result[index++] = node->val; queue[qEnd++] = node->left; queue[qEnd++] = node->right; } else { result[index++] = INT_MIN; } } while (result[index-1] == INT_MIN) index--; *returnSize = index; return result; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createNode(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == INT_MIN) return NULL; struct TreeNode* root = createNode(arr[0]); struct TreeNode* queue[size]; int i = 1, qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd && i < size) { struct TreeNode* node = queue[qStart++]; if (i < size && arr[i] != INT_MIN) { node->left = createNode(arr[i]); queue[qEnd++] = node->left; } i++; if (i < size && arr[i] != INT_MIN) { node->right = createNode(arr[i]); queue[qEnd++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 10000); int index = 0; struct TreeNode* queue[10000]; int qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd) { struct TreeNode* node = queue[qStart++]; if (node) { result[index++] = node->val; queue[qEnd++] = node->left; queue[qEnd++] = node->right; } else { result[index++] = INT_MIN; } } while (result[index-1] == INT_MIN) index--; *returnSize = index; return result; }"
    },
    "go": {
      "functionDeclaration": "func GetMinimumDifference(root *TreeNode) int {}",
      "testCalls": [
        "let root = buildTree([4,2,6,1,3]); if GetMinimumDifference(root) != 1 { throw 'Test case 1 failed'; }",
        "let root = buildTree([1,0,48,null,null,12,49]); if GetMinimumDifference(root) != 1 { throw 'Test case 2 failed'; }"
      ],
      "compareHelper": "",
      "helpers": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn MinimumAbsoluteDifferenceInBST(root: Option<Rc<RefCell<TreeNode>>) -> i32 {}",
      "testCalls": [
        "let root1 = buildTree(vec![Some(4), Some(2), Some(6), Some(1), Some(3)]); assert_eq!(MinimumAbsoluteDifferenceInBST(root1), 1);",
        "let root2 = buildTree(vec![Some(1), Some(0), Some(48), None, None, Some(12), Some(49)]); assert_eq!(MinimumAbsoluteDifferenceInBST(root2), 1);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}",
      "builders": "impl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {}"
    },
    "ruby": {
      "functionDeclaration": "def MinimumAbsoluteDifferenceInBst(root)\nend",
      "testCalls": [
        "root = buildTree([4,2,6,1,3]); raise 'Test Case 1 Failed' unless MinimumAbsoluteDifferenceInBst(root) == 1",
        "root = buildTree([1,0,48,nil,nil,12,49]); raise 'Test Case 2 Failed' unless MinimumAbsoluteDifferenceInBst(root) == 1"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[4,2,6,1,3]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,0,48,null,null,12,49]"
        },
        "expected": "1"
      }
    ]
  },
  "minimum-genetic-mutation": {
    "title": "Minimum Genetic Mutation",
    "content": "A gene string can be represented by an 8-character long string, with choices from &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\nFor example, &quot;AACCGGTT&quot; --> &quot;AACCGGTA&quot; is one mutation.\n\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\n\nExample 1:\n\nInput: startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]\nOutput: 1\n\nExample 2:\n\nInput: startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]\nOutput: 2\n\n\nConstraints:\n\n0 <= bank.length <= 10\nstartGene.length == endGene.length == bank[i].length == 8\nstartGene, endGene, and bank[i] consist of only the characters [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Breadth-First Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumGeneticMutation(startGene, endGene, bank) {}",
      "testCalls": [
        "const test1 = MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA']);\nif (test1 !== 1) { throw new Error('Test case 1 failed'); }",
        "const test2 = MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA']);\nif (test2 !== 2) { throw new Error('Test case 2 failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumGeneticMutation(startGene: string, endGene: string, bank: string[]): number {}",
      "testCalls": [
        "if (MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA']) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA']) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MinGeneticMutation(string startGene, string endGene, vector<string>& bank)",
      "testCalls": [
        "assert(MinGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", {\"AACCGGTA\"}) == 1);",
        "assert(MinGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", {\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumGeneticMutation(startGene: str, endGene: str, bank: List[str]) -> int:",
      "testCalls": [
        "assert MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", [\"AACCGGTA\"]) == 1",
        "assert MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int minMutation(String startGene, String endGene, String[] bank)",
      "testCalls": [
        "if (minMutation(\"AACCGGTT\", \"AACCGGTA\", new String[]{\"AACCGGTA\"}) != 1) { throw new AssertionError(); }",
        "if (minMutation(\"AACCGGTT\", \"AAACGGTA\", new String[]{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) != 2) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinimumGeneticMutation(char *startGene, char *endGene, char **bank, int bankSize)",
      "testCalls": [
        "TEST_CASE(\"Example 1\") { REQUIRE(MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", (char*[]){\"AACCGGTA\"}, 1) == 1); }",
        "TEST_CASE(\"Example 2\") { REQUIRE(MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", (char*[]){\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"}, 3) == 2); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumGeneticMutation(startGene string, endGene string, bank []string) int {}",
      "testCalls": [
        "if MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", []string{\"AACCGGTA\"}) != 1 {panic(\"Test case 1 failed\")}",
        "if MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", []string{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumGeneticMutation(start_gene: &str, end_gene: &str, bank: Vec<&str>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", vec![\"AACCGGTA\"]), 1);",
        "assert_eq!(MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", vec![\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumGeneticMutation(start_gene, end_gene, bank)\n  \nend",
      "testCalls": [
        "result1 = MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA'])\nraise 'Test Case 1 Failed' unless result1 == 1",
        "result2 = MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA'])\nraise 'Test Case 2 Failed' unless result2 == 2"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "startGene": "&quot;AACCGGTT&quot;",
          "endGene": "&quot;AACCGGTA&quot;",
          "bank": "[&quot;AACCGGTA&quot;]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "startGene": "&quot;AACCGGTT&quot;",
          "endGene": "&quot;AAACGGTA&quot;",
          "bank": "[&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]"
        },
        "expected": "2"
      }
    ]
  },
  "minimum-number-of-arrows-to-burst-balloons": {
    "title": "Minimum Number of Arrows to Burst Balloons",
    "content": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\n\nExample 1:\n\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n\nExample 2:\n\nInput: points = [[1,2],[3,4],[5,6],[7,8]]\nOutput: 4\nExplanation: One arrow needs to be shot for each balloon for a total of 4 arrows.\n\nExample 3:\n\nInput: points = [[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n\n\nConstraints:\n\n1 <= points.length <= 105\npoints[i].length == 2\n-231 <= xstart < xend <= 231 - 1\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumNumberOfArrowsToBurstBalloons(points) {}",
      "testCalls": [
        "const test1 = MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]); if(test1 !== 2) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]); if(test2 !== 4) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = MinimumNumberOfArrowsToBurstBalloons([[1,2],[2,3],[3,4],[4,5]]); if(test3 !== 2) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function MinimumNumberOfArrowsToBurstBalloons(points: number[][]): number {}",
      "testCalls": [
        "if (MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindMinArrowShots(vector<vector<int>>& points)",
      "testCalls": [
        "assert(FindMinArrowShots({{10,16},{2,8},{1,6},{7,12}}) == 2);",
        "assert(FindMinArrowShots({{1,2},{3,4},{5,6},{7,8}}) == 4);",
        "assert(FindMinArrowShots({{1,2},{2,3},{3,4},{4,5}}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumNumberOfArrowsToBurstBalloons(points: List[List[int]]) -> int:",
      "testCalls": [
        "assert MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]) == 2",
        "assert MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]) == 4",
        "assert MinimumNumberOfArrowsToBurstBalloons([[1,2],[2,3],[3,4],[4,5]]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int findMinArrowShots(int[][] points)",
      "testCalls": [
        "int[][] points1 = {{10,16},{2,8},{1,6},{7,12}};\nint expected1 = 2;\nint result1 = findMinArrowShots(points1);\nif(result1 != expected1) throw new AssertionError();",
        "int[][] points2 = {{1,2},{3,4},{5,6},{7,8}};\nint expected2 = 4;\nint result2 = findMinArrowShots(points2);\nif(result2 != expected2) throw new AssertionError();",
        "int[][] points3 = {{1,2},{2,3},{3,4},{4,5}};\nint expected3 = 2;\nint result3 = findMinArrowShots(points3);\nif(result3 != expected3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinimumNumberOfArrowsToBurstBalloons(int** points, int pointsSize, int* pointsColSize)",
      "testCalls": [
        "int** points1 = (int*[]){{10,16},{2,8},{1,6},{7,12}}; int pointsSize1 = 4; int pointsColSize1 = 2; int result1 = MinimumNumberOfArrowsToBurstBalloons(points1, pointsSize1, &pointsColSize1); if(result1 != 2) { printf(\"Test Case 1 Failed\"); }",
        "int** points2 = (int*[]){{1,2},{3,4},{5,6},{7,8}}; int pointsSize2 = 4; int pointsColSize2 = 2; int result2 = MinimumNumberOfArrowsToBurstBalloons(points2, pointsSize2, &pointsColSize2); if(result2 != 4) { printf(\"Test Case 2 Failed\"); }",
        "int** points3 = (int*[]){{1,2},{2,3},{3,4},{4,5}}; int pointsSize3 = 4; int pointsColSize3 = 2; int result3 = MinimumNumberOfArrowsToBurstBalloons(points3, pointsSize3, &pointsColSize3); if(result3 != 2) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumNumberOfArrowsToBurstBalloons(points [][]int) int {}",
      "testCalls": [
        "if MinimumNumberOfArrowsToBurstBalloons([][]int{{10,16},{2,8},{1,6},{7,12}}) != 2 {panic(\"Test case 1 failed\")}",
        "if MinimumNumberOfArrowsToBurstBalloons([][]int{{1,2},{3,4},{5,6},{7,8}}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumNumberOfArrowsToBurstBalloons(points: Vec<Vec<i32>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![10,16],vec![2,8],vec![1,6],vec![7,12]]), 2);",
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![1,2],vec![3,4],vec![5,6],vec![7,8]]), 4);",
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![1,2],vec![2,3],vec![3,4],vec![4,5]]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumNumberOfArrowsToBurstBalloons(points)\nend",
      "testCalls": [
        "points1 = [[10,16],[2,8],[1,6],[7,12]]\nputs(MinimumNumberOfArrowsToBurstBalloons(points1) == 2)",
        "points2 = [[1,2],[3,4],[5,6],[7,8]]\nputs(MinimumNumberOfArrowsToBurstBalloons(points2) == 4)"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "points": "[[10,16],[2,8],[1,6],[7,12]]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "points": "[[1,2],[3,4],[5,6],[7,8]]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "points": "[[1,2],[2,3],[3,4],[4,5]]"
        },
        "expected": "2"
      }
    ]
  },
  "minimum-path-sum": {
    "title": "Minimum Path Sum",
    "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n\nExample 1:\n\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 200\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumPathSum(grid) {}",
      "testCalls": [
        "if (MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumPathSum([[1,2,3],[4,5,6]]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumPathSum(grid: number[][]): number {}",
      "testCalls": [
        "if (MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumPathSum([[1,2,3],[4,5,6]]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MinPathSum(vector<vector<int>>& grid)",
      "testCalls": [
        "assert(MinPathSum({{1,3,1},{1,5,1},{4,2,1}}) == 7);",
        "assert(MinPathSum({{1,2,3},{4,5,6}}) == 12);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumPathSum(grid: List[List[int]]) -> int:",
      "testCalls": [
        "assert MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7",
        "assert MinimumPathSum([[1,2,3],[4,5,6]]) == 12"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minPathSum(int[][] grid)",
      "testCalls": [
        "if (minPathSum(new int[][]{{1,3,1},{1,5,1},{4,2,1}}) != 7) throw new AssertionError();",
        "if (minPathSum(new int[][]{{1,2,3},{4,5,6}}) != 12) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinPathSum(int** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "assert(MinPathSum((int*[]){(int[]){1,3,1}, (int[]){1,5,1}, (int[]){4,2,1}}, 3, (int[]){3, 3}) == 7)",
        "assert(MinPathSum((int*[]){(int[]){1,2,3}, (int[]){4,5,6}}, 2, (int[]){3, 3}) == 12)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinPathSum(grid [][]int) int {}",
      "testCalls": [
        "if MinPathSum([][]int{{1,3,1},{1,5,1},{4,2,1}}) != 7 { t.Error(\"Test case 1 failed\") }",
        "if MinPathSum([][]int{{1,2,3},{4,5,6}}) != 12 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumPathSum(grid: Vec<Vec<i32>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MinimumPathSum(vec![vec![1,3,1], vec![1,5,1], vec![4,2,1]]), 7);",
        "assert_eq!(MinimumPathSum(vec![vec![1,2,3], vec![4,5,6]]), 12);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumPathSum(grid)\nend",
      "testCalls": [
        "test1 = MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]])\nraise 'Test Case 1 Failed' unless test1 == 7",
        "test2 = MinimumPathSum([[1,2,3],[4,5,6]])\nraise 'Test Case 2 Failed' unless test2 == 12"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "grid": "[[1,3,1],[1,5,1],[4,2,1]]"
        },
        "expected": "7"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "grid": "[[1,2,3],[4,5,6]]"
        },
        "expected": "12"
      }
    ]
  },
  "minimum-size-subarray-sum": {
    "title": "Minimum Size Subarray Sum",
    "content": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\nExample 1:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n\nExample 2:\n\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n\nExample 3:\n\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n\n\nConstraints:\n\n1 <= target <= 109\n1 <= nums.length <= 105\n1 <= nums[i] <= 104\n\n\nFollow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Sliding Window",
      "Prefix Sum"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumSizeSubarraySum(target, nums) {}",
      "testCalls": [
        "if(MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(MinimumSizeSubarraySum(4, [1,4,4]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinSizeSubarraySum(target: number, nums: number[]): number {}",
      "testCalls": [
        "if (MinSizeSubarraySum(7, [2,3,1,2,4,3]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (MinSizeSubarraySum(4, [1,4,4]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if (MinSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MinSizeSubarraySum(int target, vector<int>& nums);",
      "testCalls": [
        "assert(MinSizeSubarraySum(7, {2,3,1,2,4,3}) == 2);",
        "assert(MinSizeSubarraySum(4, {1,4,4}) == 1);",
        "assert(MinSizeSubarraySum(11, {1,1,1,1,1,1,1,1}) == 0);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MinimumSizeSubarraySum(target: int, nums: List[int]) -> int:",
      "testCalls": [
        "assert MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) == 2",
        "assert MinimumSizeSubarraySum(4, [1,4,4]) == 1",
        "assert MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minSubArrayLen(int target, int[] nums) { }",
      "testCalls": [
        "if (minSubArrayLen(7, new int[]{2,3,1,2,4,3}) != 2) { throw new AssertionError(); }",
        "if (minSubArrayLen(4, new int[]{1,4,4}) != 1) { throw new AssertionError(); }",
        "if (minSubArrayLen(11, new int[]{1,1,1,1,1,1,1,1}) != 0) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinSubarraySum(int target, int* nums, int numsSize)",
      "testCalls": [
        "if(MinSubarraySum(7, (int[]){2,3,1,2,4,3}, 6) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(MinSubarraySum(4, (int[]){1,4,4}, 3) != 1) { printf(\"Test Case 2 Failed\"); }",
        "if(MinSubarraySum(11, (int[]){1,1,1,1,1,1,1,1}, 8) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinSubArrayLen(target int, nums []int) int {}",
      "testCalls": [
        "if got := MinSubArrayLen(7, []int{2,3,1,2,4,3}); got != 2 { t.Errorf(\"Expected: %v, Got: %v\", 2, got) }",
        "if got := MinSubArrayLen(4, []int{1,4,4}); got != 1 { t.Errorf(\"Expected: %v, Got: %v\", 1, got) }",
        "if got := MinSubArrayLen(11, []int{1,1,1,1,1,1,1,1}); got != 0 { t.Errorf(\"Expected: %v, Got: %v\", 0, got) }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumSizeSubarraySum(target: i32, nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumSizeSubarraySum(7, vec![2,3,1,2,4,3]), 2);",
        "assert_eq!(MinimumSizeSubarraySum(4, vec![1,4,4]), 1);",
        "assert_eq!(MinimumSizeSubarraySum(11, vec![1,1,1,1,1,1,1,1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumSizeSubarraySum(target, nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) == 2",
        "raise 'Test Case 2 Failed' unless MinimumSizeSubarraySum(4, [1,4,4]) == 1",
        "raise 'Test Case 3 Failed' unless MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "target": "7",
          "nums": "[2,3,1,2,4,3]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "target": "4",
          "nums": "[1,4,4]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "target": "11",
          "nums": "[1,1,1,1,1,1,1,1]"
        },
        "expected": "0"
      }
    ]
  },
  "minimum-window-substring": {
    "title": "Minimum Window Substring",
    "content": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &quot;&quot;.\nThe testcases will be generated such that the answer is unique.\n\nExample 1:\n\nInput: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\nOutput: &quot;BANC&quot;\nExplanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n\nExample 2:\n\nInput: s = &quot;a&quot;, t = &quot;a&quot;\nOutput: &quot;a&quot;\nExplanation: The entire string s is the minimum window.\n\nExample 3:\n\nInput: s = &quot;a&quot;, t = &quot;aa&quot;\nOutput: &quot;&quot;\nExplanation: Both &#39;a from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n\n\nConstraints:\n\nm == s.length\nn == t.length\n1 <= m, n <= 105\ns and t consist of uppercase and lowercase English letters.\n\n\nFollow up: Could you find an algorithm that runs in O(m + n) time?\n",
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to create a window of letters in s, which would have all the characters from t.",
      "Expand the right pointer until all the characters of t are covered.",
      "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
      "Continue expanding the right and left pointers until you reach the end of s."
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumWindowSubstring(s, t) {}",
      "testCalls": [
        "if (MinimumWindowSubstring('ADOBECODEBANC', 'ABC') !== 'BANC') { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumWindowSubstring('a', 'a') !== 'a') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumWindowSubstring(s: string, t: string): string {}",
      "testCalls": [
        "if (MinimumWindowSubstring('ADOBECODEBANC', 'ABC') !== 'BANC') { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumWindowSubstring('a', 'a') !== 'a') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string MinimumWindowSubstring(string s, string t)",
      "testCalls": [
        "assert(MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\");",
        "assert(MinimumWindowSubstring(\"a\", \"a\") == \"a\"); assert(MinimumWindowSubstring(\"a\", \"aa\") == \"\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumWindowSubstring(s: str, t: str) -> str:",
      "testCalls": [
        "assert MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"",
        "assert MinimumWindowSubstring(\"a\", \"a\") == \"a\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String MinimumWindowSubstring(String s, String t) { }",
      "testCalls": [
        "assert MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\").equals(\"BANC\");",
        "assert MinimumWindowSubstring(\"a\", \"a\").equals(\"a\");"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* MinimumWindowSubstring(char* s, char* t)",
      "testCalls": [
        "MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\")",
        "MinimumWindowSubstring(\"a\", \"a\")",
        "MinimumWindowSubstring(\"a\", \"aa\")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumWindowSubstring(s string, t string) string {}",
      "testCalls": [
        "if MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") != \"BANC\" { panic(\"Test case 1 failed\") }",
        "if MinimumWindowSubstring(\"a\", \"a\") != \"a\" { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumWindowSubstring(s: String, t: String) -> String {}",
      "testCalls": [
        "assert_eq!(MinimumWindowSubstring(String::from(\"ADOBECODEBANC\"), String::from(\"ABC\")), String::from(\"BANC\"));",
        "assert_eq!(MinimumWindowSubstring(String::from(\"a\"), String::from(\"a\")), String::from(\"a\")); assert_eq!(MinimumWindowSubstring(String::from(\"a\"), String::from(\"aa\")), String::from(\"\"));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumWindowSubstring(s, t)\nend",
      "testCalls": [
        "assert_equal(\"BANC\", MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\"))",
        "assert_equal(\"a\", MinimumWindowSubstring(\"a\", \"a\"))",
        "assert_equal(\"\", MinimumWindowSubstring(\"a\", \"aa\"))"
      ],
      "compareHelper": "def assert_equal(expected, result)\n  raise 'Test Case Failed' unless expected == result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;ADOBECODEBANC&quot;",
          "t": "&quot;ABC&quot;"
        },
        "expected": "&quot;BANC&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;a&quot;",
          "t": "&quot;a&quot;"
        },
        "expected": "&quot;a&quot;"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;a&quot;",
          "t": "&quot;aa&quot;"
        },
        "expected": "&quot;&quot;"
      }
    ]
  },
  "n-queens-ii": {
    "title": "N-Queens II",
    "content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to then-queens puzzle.\n\nExample 1:\n\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\nConstraints:\n\n1 <= n <= 9\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NQueensII(n) {}",
      "testCalls": [
        "if(NQueensII(4) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(NQueensII(1) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function TotalNQueens(n: number): number {}",
      "testCalls": [
        "if (TotalNQueens(4) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (TotalNQueens(1) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int TotalNQueens(int n);",
      "testCalls": [
        "if(TotalNQueens(4) != 2) throw std::runtime_error(\"Test 1 failed!\");",
        "if(TotalNQueens(1) != 1) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NQueensII(n: int) -> int:",
      "testCalls": [
        "assert NQueensII(4) == 2",
        "assert NQueensII(1) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int TotalNQueens(int n)",
      "testCalls": [
        "if(TotalNQueens(4) != 2) throw new AssertionError();",
        "if(TotalNQueens(1) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int TotalNQueens(int n);",
      "testCalls": [
        "if (TotalNQueens(4) != 2) { printf(\"Test case 1 failed\"); }",
        "if (TotalNQueens(1) != 1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func TotalNQueens(n int) int {}",
      "testCalls": [
        "if TotalNQueens(4) != 2 { t.Error(\"Test case 1 failed\") }",
        "if TotalNQueens(1) != 1 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NQueensII(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(NQueensII(4), 2);",
        "assert_eq!(NQueensII(1), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NQueensII(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless NQueensII(4) == 2",
        "raise 'Test Case 2 Failed' unless NQueensII(1) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "4"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "1"
        },
        "expected": "1"
      }
    ]
  },
  "number-of-1-bits": {
    "title": "Number of 1 Bits",
    "content": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).\n\nExample 1:\n\nInput: n = 11\nOutput: 3\nExplanation:\nThe input binary string 1011 has a total of three set bits.\n\nExample 2:\n\nInput: n = 128\nOutput: 1\nExplanation:\nThe input binary string 10000000 has a total of one set bit.\n\nExample 3:\n\nInput: n = 2147483645\nOutput: 30\nExplanation:\nThe input binary string 1111111111111111111111111111101 has a total of thirty set bits.\n\n\nConstraints:\n\n1 <= n <= 231 - 1\n\n\nFollow up: If this function is called many times, how would you optimize it?",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NumberOf1Bits(n) {}",
      "testCalls": [
        "if(NumberOf1Bits(11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(NumberOf1Bits(128) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(NumberOf1Bits(2147483645) !== 30) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function NumberOf1Bits(n: number): number {}",
      "testCalls": [
        "if(NumberOf1Bits(11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(NumberOf1Bits(128) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(NumberOf1Bits(2147483645) !== 30) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int NumberOf1Bits(int n);",
      "testCalls": [
        "if (NumberOf1Bits(11) != 3) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (NumberOf1Bits(128) != 1) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if (NumberOf1Bits(2147483645) != 30) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NumberOf1Bits(n: int) -> int",
      "testCalls": [
        "assert NumberOf1Bits(11) == 3",
        "assert NumberOf1Bits(128) == 1",
        "assert NumberOf1Bits(2147483645) == 30"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int NumberOf1Bits(int n) {}",
      "testCalls": [
        "if(NumberOf1Bits(11) != 3) throw new AssertionError();",
        "if(NumberOf1Bits(128) != 1) throw new AssertionError();",
        "if(NumberOf1Bits(2147483645) != 30) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int NumberOf1Bits(int n);",
      "testCalls": [
        "if (NumberOf1Bits(11) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (NumberOf1Bits(128) != 1) { printf(\"Test Case 2 Failed\"); }",
        "if (NumberOf1Bits(2147483645) != 30) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func NumberOf1Bits(n uint32) int { }",
      "testCalls": [
        "if NumberOf1Bits(11) != 3 { t.Errorf(\"Test case 1 failed\") }",
        "if NumberOf1Bits(128) != 1 { t.Errorf(\"Test case 2 failed\") }",
        "if NumberOf1Bits(2147483645) != 30 { t.Errorf(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NumberOf1Bits(n: u32) -> i32 {}",
      "testCalls": [
        "assert_eq!(NumberOf1Bits(11), 3);",
        "assert_eq!(NumberOf1Bits(128), 1);",
        "assert_eq!(NumberOf1Bits(2147483645), 30);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NumberOf1Bits(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless NumberOf1Bits(11) == 3",
        "raise 'Test Case 2 Failed' unless NumberOf1Bits(128) == 1",
        "raise 'Test Case 3 Failed' unless NumberOf1Bits(2147483645) == 30"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "11"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "128"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "n": "2147483645"
        },
        "expected": "30"
      }
    ]
  },
  "number-of-islands": {
    "title": "Number of Islands",
    "content": "Given an m x n 2D binary grid grid which represents a map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n\nInput: grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\nOutput: 1\n\nExample 2:\n\nInput: grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\nOutput: 3\n\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] is &#39;0&#39; or &#39;1&#39;.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NumberOfIslands(grid) {}",
      "testCalls": [
        "const test1 = NumberOfIslands([['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]); if(test1 !== 1) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = NumberOfIslands([['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]); if(test2 !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function NumberOfIslands(grid: string[][]): number {}",
      "testCalls": [
        "if(NumberOfIslands([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]) !== 1) throw new Error('Test Case 1 Failed');",
        "if(NumberOfIslands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]) !== 3) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int NumIslands(vector<vector<char>>& grid)",
      "testCalls": [
        "assert(NumIslands({{'1','1','1','1','0'},{'1','1','0','1','0'},{'1','1','0','0','0'},{'0','0','0','0','0'}}) == 1);",
        "assert(NumIslands({{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}}) == 3);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NumberOfIslands(grid: List[List[str]]) -> int:",
      "testCalls": [
        "assert NumberOfIslands([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]) == 1",
        "assert NumberOfIslands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int NumberOfIslands(char[][] grid) {}",
      "testCalls": [
        "int result1 = NumberOfIslands(new char[][]{{'1','1','1','1','0'},{'1','1','0','1','0'},{'1','1','0','0','0'},{'0','0','0','0','0'}}); if(result1 != 1) throw new AssertionError();",
        "int result2 = NumberOfIslands(new char[][]{{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}}); if(result2 != 3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int NumberOfIslands(char** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "int result1 = NumberOfIslands(grid1, 4, gridColSize1); if(result1 != 1) { printf(\"Test Case 1 Failed\"); }",
        "int result2 = NumberOfIslands(grid2, 4, gridColSize2); if(result2 != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func NumIslands(grid [][]string) int {}",
      "testCalls": [
        "if NumIslands([][]string{{\"1\",\"1\",\"1\",\"1\",\"0\"},{\"1\",\"1\",\"0\",\"1\",\"0\"},{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"0\",\"0\",\"0\",\"0\",\"0\"}}) != 1 { t.Error(\"Test case 1 failed\") }",
        "if NumIslands([][]string{{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"0\",\"0\",\"1\",\"0\",\"0\"},{\"0\",\"0\",\"0\",\"1\",\"1\"}}) != 3 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NumberOfIslands(grid: Vec<Vec<char>>) -> i32 { }",
      "testCalls": [
        "let result1 = NumberOfIslands(vec![vec!['1', '1', '1', '1', '0'], vec!['1', '1', '0', '1', '0'], vec!['1', '1', '0', '0', '0'], vec!['0', '0', '0', '0', '0']]);\nassert_eq!(result1, 1);",
        "let result2 = NumberOfIslands(vec![vec!['1', '1', '0', '0', '0'], vec!['1', '1', '0', '0', '0'], vec!['0', '0', '1', '0', '0'], vec!['0', '0', '0', '1', '1']]);\nassert_eq!(result2, 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NumberOfIslands(grid)\nend",
      "testCalls": [
        "grid1 = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]\nputs NumberOfIslands(grid1) == 1 || raise('Test Case 1 Failed')",
        "grid2 = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]\nputs NumberOfIslands(grid2) == 3 || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "grid": "[[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "grid": "[[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]"
        },
        "expected": "3"
      }
    ]
  },
  "palindrome-number": {
    "title": "Palindrome Number",
    "content": "Given an integer x, return true if x is a palindrome, and false otherwise.\n\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\nConstraints:\n\n-231<= x <= 231- 1\n\n\nFollow up: Could you solve it without converting the integer to a string?",
    "difficulty": "Easy",
    "hints": [
      "Beware of overflow when you reverse the integer."
    ],
    "topicTags": [
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PalindromeNumber(x) {}",
      "testCalls": [
        "if (PalindromeNumber(121) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PalindromeNumber(-121) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IsPalindrome(x: number): boolean {}",
      "testCalls": [
        "if (IsPalindrome(121) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (IsPalindrome(-121) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool PalindromeNumber(int x);",
      "testCalls": [
        "if (PalindromeNumber(121) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (PalindromeNumber(-121) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def PalindromeNumber(x: int) -> bool:",
      "testCalls": [
        "assert PalindromeNumber(121) == True, 'Test Case 1 Failed'",
        "assert PalindromeNumber(-121) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean PalindromeNumber(int x) {}",
      "testCalls": [
        "if (!PalindromeNumber(121)) throw new AssertionError();",
        "if (PalindromeNumber(-121)) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool IsPalindrome(int x)",
      "testCalls": [
        "if(IsPalindrome(121) != true) { printf(\"Test Case 1 Failed\"); }",
        "if(IsPalindrome(-121) != false) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsPalindrome(x int) bool {}",
      "testCalls": [
        "if IsPalindrome(121) != true { t.Error(\"Test case 1 failed\") }",
        "if IsPalindrome(-121) != false { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn PalindromeNumber(x: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(PalindromeNumber(121), true);",
        "assert_eq!(PalindromeNumber(-121), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def PalindromeNumber(x)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless PalindromeNumber(121) == true",
        "raise 'Test Case 2 Failed' unless PalindromeNumber(-121) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "x": "121"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "x": "-121"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "x": "10"
        },
        "expected": "false"
      }
    ]
  },
  "partition-list": {
    "title": "Partition List",
    "content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\nExample 1:\n\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\nExample 2:\n\nInput: head = [2,1], x = 2\nOutput: [1,2]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 200].\n-100 <= Node.val <= 100\n-200 <= x <= 200\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PartitionList(head, x) {}",
      "testCalls": [
        "const test1 = PartitionList(buildLinkedList([1,4,3,2,5,2]), 3); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,2,2,4,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = PartitionList(buildLinkedList([2,1]), 2); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([1,2])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function PartitionList(head: ListNode | null, x: number): ListNode | null {}",
      "testCalls": [
        "if(JSON.stringify(PartitionList(arrayToLinkedList([1,4,3,2,5,2]), 3)) !== JSON.stringify(arrayToLinkedList([1,2,2,4,3,5]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(PartitionList(arrayToLinkedList([2,1]), 2)) !== JSON.stringify(arrayToLinkedList([1,2]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToLinkedList(arr: number[]): ListNode | null { if(arr.length === 0) return null; const head = new ListNode(arr[0]); let current = head; for(let i = 1; i < arr.length; i++) { current.next = new ListNode(arr[i]); current = current.next; } return head; }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction arrayToLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function arrayToLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "void PartitionList(ListNode* head, int x);",
      "testCalls": [
        "PartitionList(createLinkedList({1,4,3,2,5,2}), 3); // Expected: [1,2,2,4,3,5]",
        "PartitionList(createLinkedList({2,1}), 2); // Expected: [1,2]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} }; ListNode* createLinkedList(std::vector<int> values) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : values) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : values) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }"
    },
    "python": {
      "functionDeclaration": "def PartitionList(head, x):",
      "testCalls": [
        "head = buildLinkedList([1,4,3,2,5,2])\nassert linkedListToArray(PartitionList(head, 3)) == [1,2,2,4,3,5], 'Test Case 1 Failed'",
        "head = buildLinkedList([2,1])\nassert linkedListToArray(PartitionList(head, 2)) == [1,2], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode partition(ListNode head, int x) {}",
      "testCalls": [
        "ListNode head1 = createLinkedList(new int[]{1,4,3,2,5,2}); ListNode expected1 = createLinkedList(new int[]{1,2,2,4,3,5}); partition(head1, 3); compareLinkedLists(head1, expected1);",
        "ListNode head2 = createLinkedList(new int[]{2,1}); ListNode expected2 = createLinkedList(new int[]{1,2}); partition(head2, 2); compareLinkedLists(head2, expected2);"
      ],
      "compareHelper": "public void compareLinkedLists(ListNode l1, ListNode l2) { while (l1 != null && l2 != null) { if (l1.val != l2.val) throw new AssertionError(); l1 = l1.next; l2 = l2.next; } if (l1 != null || l2 != null) throw new AssertionError(); }",
      "helpers": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic ListNode createLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode createLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "void PartitionList(struct ListNode* head, int x);",
      "testCalls": [
        "PartitionList(createLinkedList((int[]){1,4,3,2,5,2}, 6), 3); // Expected: [1,2,2,4,3,5]",
        "PartitionList(createLinkedList((int[]){2,1}, 2), 2); // Expected: [1,2]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }",
      "helpers": "struct ListNode { int val; struct ListNode* next; }; \nstruct ListNode* createLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head) { int size = 0; struct ListNode* curr = head; while (curr) { size++; curr = curr->next; } int* arr = (int*)malloc(size * sizeof(int)); curr = head; int i = 0; while (curr) { arr[i++] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* createLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head) { int size = 0; struct ListNode* curr = head; while (curr) { size++; curr = curr->next; } int* arr = (int*)malloc(size * sizeof(int)); curr = head; int i = 0; while (curr) { arr[i++] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func PartitionList(head *ListNode, x int) *ListNode {}",
      "testCalls": [
        "if result := PartitionList(buildLinkedList([]int{1,4,3,2,5,2}), 3); !compareLinkedLists(result, buildLinkedList([]int{1,2,2,4,3,5})) { t.Errorf(\"Test case 1 failed\") }",
        "if result := PartitionList(buildLinkedList([]int{2,1}), 2); !compareLinkedLists(result, buildLinkedList([]int{1,2})) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareLinkedLists(l1 *ListNode, l2 *ListNode) bool {}",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn PartitionList(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = build_linked_list(vec![1, 4, 3, 2, 5, 2]);\nassert_eq!(linked_list_to_vec(PartitionList(head1, 3)), vec![1, 2, 2, 4, 3, 5]);",
        "let head2 = build_linked_list(vec![2, 1]);\nassert_eq!(linked_list_to_vec(PartitionList(head2, 2)), vec![1, 2]);"
      ],
      "compareHelper": "fn compare_linked_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) { }",
      "helpers": "use std::collections::LinkedList;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}",
      "builders": "impl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def PartitionList(head, x)\nend",
      "testCalls": [
        "head = buildLinkedList([1,4,3,2,5,2])\nresult1 = PartitionList(head, 3)\nraise 'Test Case 1 Failed' unless linkedListToArray(result1) == [1,2,2,4,3,5]",
        "head = buildLinkedList([2,1])\nresult2 = PartitionList(head, 2)\nraise 'Test Case 2 Failed' unless linkedListToArray(result2) == [1,2]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,4,3,2,5,2]",
          "x": "3"
        },
        "expected": "[1,2,2,4,3,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[2,1]",
          "x": "2"
        },
        "expected": "[1,2]"
      }
    ]
  },
  "path-sum": {
    "title": "Path Sum",
    "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\n\nExample 1:\n\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is shown.\n\nExample 2:\n\n\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There are two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\nExample 3:\n\nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since the tree is empty, there are no root-to-leaf paths.\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PathSum(root, targetSum) {}",
      "testCalls": [
        "if (PathSum(buildTree([5,4,8,11,null,13,4,7,2,null,null,null,1]), 22) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PathSum(buildTree([1,2,3]), 5) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function PathSum(root: TreeNode | null, targetSum: number): boolean {}",
      "testCalls": [
        "if (PathSum(buildTree([5,4,8,11,null,13,4,7,2,null,null,null,1]), 22) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PathSum(buildTree([1,2,3]), 5) !== false) { throw new Error('Test Case 2 Failed'); }",
        "if (PathSum(null, 0) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "bool HasPathSum(TreeNode* root, int targetSum);",
      "testCalls": [
        "if (HasPathSum(createTree({5,4,8,11,-1,13,4,7,2,-1,-1,-1,1}), 22) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (HasPathSum(createTree({1,2,3}), 5) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "std::vector<int> createTree(const std::vector<int>& values) {\n    // Implementation to create a binary tree from values\n}",
      "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} }; TreeNode* createTree(std::vector<int> values) { if (values.empty()) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (i < values.size() && !q.empty()) { TreeNode* node = q.front(); q.pop(); if (values[i] != -1) { node->left = new TreeNode(values[i]); q.push(node->left); } ++i; if (i < values.size() && values[i] != -1) { node->right = new TreeNode(values[i]); q.push(node->right); } ++i; } return root; } std::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (!result.empty() && result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} };",
      "builders": "TreeNode* createTree(std::vector<int> values) { if (values.empty()) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (i < values.size() && !q.empty()) { TreeNode* node = q.front(); q.pop(); if (values[i] != -1) { node->left = new TreeNode(values[i]); q.push(node->left); } ++i; if (i < values.size() && values[i] != -1) { node->right = new TreeNode(values[i]); q.push(node->right); } ++i; } return root; } std::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (!result.empty() && result.back() == -1) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def PathSum(root, targetSum):",
      "testCalls": [
        "root = buildTree([5,4,8,11,None,13,4,7,2,None,None,None,1])\nassert PathSum(root, 22) == True",
        "root = buildTree([1,2,3])\nassert PathSum(root, 5) == False",
        "root = buildTree([])\nassert PathSum(root, 0) == False"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None): ...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public boolean PathSum(TreeNode root, int targetSum)",
      "testCalls": [
        "if (PathSum(TreeNode.buildTree(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1}), 22) != true) throw new AssertionError();",
        "if (PathSum(TreeNode.buildTree(new Integer[]{1,2,3}), 5) != false) throw new AssertionError();",
        "if (PathSum(null, 0) != false) throw new AssertionError();"
      ],
      "compareHelper": "private static boolean compareArrays(int[] arr1, int[] arr2) {\n        return Arrays.equals(arr1, arr2);\n    }",
      "helpers": "public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.add(node.left); queue.add(node.right); } else { list.add(null); } } while (list.get(list.size()-1) == null) list.remove(list.size()-1); return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.add(node.left); queue.add(node.right); } else { list.add(null); } } while (list.get(list.size()-1) == null) list.remove(list.size()-1); return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "bool HasPathSum(struct TreeNode* root, int targetSum)",
      "testCalls": [
        "assert(HasPathSum(createTreeFromArray((int[]) {5,4,8,11,NULL,13,4,7,2,NULL,NULL,NULL,1}, 13), 22) == true);",
        "assert(HasPathSum(createTreeFromArray((int[]) {1,2,3}, 3), 5) == false);",
        "assert(HasPathSum(NULL, 0) == false);"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; }; \nstruct TreeNode* createTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode** nodes = (struct TreeNode**)malloc(size * sizeof(struct TreeNode*)); for (int i = 0; i < size; i++) { if (arr[i] == NULL) nodes[i] = NULL; else { nodes[i] = (struct TreeNode*)malloc(sizeof(struct TreeNode)); nodes[i]->val = arr[i]; nodes[i]->left = NULL; nodes[i]->right = NULL; } } struct TreeNode* root = nodes[0]; int pos = 1; for (int i = 0; i < size && pos < size; i++) { if (nodes[i]) { nodes[i]->left = nodes[pos++]; if (pos < size) nodes[i]->right = nodes[pos++]; } } free(nodes); return root; } \nint* treeToArray(struct TreeNode* root) { int* arr = (int*)malloc(1000 * sizeof(int)); int size = 0; struct TreeNode** queue = (struct TreeNode**)malloc(1000 * sizeof(struct TreeNode*)); int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { arr[size++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { arr[size++] = NULL; } } while (size > 0 && arr[size-1] == NULL) size--; int* result = (int*)malloc(size * sizeof(int)); for (int i = 0; i < size; i++) result[i] = arr[i]; free(arr); free(queue); return result; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* createTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode** nodes = (struct TreeNode**)malloc(size * sizeof(struct TreeNode*)); for (int i = 0; i < size; i++) { if (arr[i] == NULL) nodes[i] = NULL; else { nodes[i] = (struct TreeNode*)malloc(sizeof(struct TreeNode)); nodes[i]->val = arr[i]; nodes[i]->left = NULL; nodes[i]->right = NULL; } } struct TreeNode* root = nodes[0]; int pos = 1; for (int i = 0; i < size && pos < size; i++) { if (nodes[i]) { nodes[i]->left = nodes[pos++]; if (pos < size) nodes[i]->right = nodes[pos++]; } } free(nodes); return root; } \nint* treeToArray(struct TreeNode* root) { int* arr = (int*)malloc(1000 * sizeof(int)); int size = 0; struct TreeNode** queue = (struct TreeNode**)malloc(1000 * sizeof(struct TreeNode*)); int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { arr[size++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { arr[size++] = NULL; } } while (size > 0 && arr[size-1] == NULL) size--; int* result = (int*)malloc(size * sizeof(int)); for (int i = 0; i < size; i++) result[i] = arr[i]; free(arr); free(queue); return result; }"
    },
    "go": {
      "functionDeclaration": "func PathSum(root *TreeNode, targetSum int) bool {}",
      "testCalls": [
        "if PathSum(buildTree([]int{5,4,8,11,-1,13,4,7,2,-1,-1,-1,-1,1}, 0), 22) != true { t.Error(\"Test Case 1 Failed\") }",
        "if PathSum(buildTree([]int{1,2,3}, 0), 5) != false { t.Error(\"Test Case 2 Failed\") }",
        "if PathSum(nil, 0) != false { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func buildTree(arr []int, idx int) *TreeNode {\n    if idx >= len(arr) || arr[idx] == -1 {\n        return nil\n    }\n    root := &TreeNode{Val: arr[idx]}\n    root.Left = buildTree(arr, 2*idx+1)\n    root.Right = buildTree(arr, 2*idx+2)\n    return root\n}",
      "helpers": "type TreeNode struct { Val int Left *TreeNode Right *TreeNode }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
      "typeDefs": "type TreeNode struct { Val int Left *TreeNode Right *TreeNode }",
      "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn PathSum(root: Option<Box<TreeNode>>, target_sum: i32) -> bool {}",
      "testCalls": [
        "let root1 = build_tree(vec![Some(5), Some(4), Some(8), Some(11), None, Some(13), Some(4), Some(7), Some(2), None, None, None, Some(1)]);\nassert_eq!(PathSum(root1, 22), true);",
        "let root2 = build_tree(vec![Some(1), Some(2), Some(3)]);\nassert_eq!(PathSum(root2, 5), false);",
        "assert_eq!(PathSum(None, 0), false);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let mut nodes = arr.iter().map(|&val| val.map(TreeNode::new)).collect::<Vec<_>>();\n    let root = Some(Box::new(nodes[0].as_ref().unwrap().clone()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(val) = arr[i] {\n                node.borrow_mut().left = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().left.as_ref().unwrap().clone());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.borrow_mut().right = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().right.as_ref().unwrap().clone());\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_vec(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    while let Some(node) = queue.pop_front() {\n        result.push(Some(node.val));\n        if let Some(left) = &node.left {\n            queue.push_back(left.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n        if let Some(right) = &node.right {\n            queue.push_back(right.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(val) = result.last() {\n        if val.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let mut nodes = arr.iter().map(|&val| val.map(TreeNode::new)).collect::<Vec<_>>();\n    let root = Some(Box::new(nodes[0].as_ref().unwrap().clone()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(val) = arr[i] {\n                node.borrow_mut().left = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().left.as_ref().unwrap().clone());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.borrow_mut().right = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().right.as_ref().unwrap().clone());\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_vec(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    while let Some(node) = queue.pop_front() {\n        result.push(Some(node.val));\n        if let Some(left) = &node.left {\n            queue.push_back(left.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n        if let Some(right) = &node.right {\n            queue.push_back(right.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(val) = result.last() {\n        if val.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def PathSum(root, targetSum)\nend",
      "testCalls": [
        "root = buildTree([5,4,8,11,nil,13,4,7,2,nil,nil,nil,1])\nassert_equal(true, PathSum(root, 22))",
        "root = buildTree([1,2,3])\nassert_equal(false, PathSum(root, 5))",
        "root = buildTree([])\nassert_equal(false, PathSum(root, 0))"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test Case Failed' unless expected == actual\nend",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result << node.val\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result << nil\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result << node.val\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result << nil\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[5,4,8,11,null,13,4,7,2,null,null,null,1]",
          "targetSum": "22"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,2,3]",
          "targetSum": "5"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]",
          "targetSum": "0"
        },
        "expected": "false"
      }
    ]
  },
  "permutations": {
    "title": "Permutations",
    "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n\n\nConstraints:\n\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Permutations(nums) {}",
      "testCalls": [
        "const test1 = Permutations([1,2,3]); if(JSON.stringify(test1) !== '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Permutations([0,1]); if(JSON.stringify(test2) !== '[[0,1],[1,0]]') throw new Error('Test Case 2 Failed');",
        "const test3 = Permutations([1]); if(JSON.stringify(test3) !== '[[1]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function Permutations(nums: number[]): number[][] { }",
      "testCalls": [
        "const test1 = Permutations([1,2,3]); if(JSON.stringify(test1) !== '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Permutations([0,1]); if(JSON.stringify(test2) !== '[[0,1],[1,0]]') throw new Error('Test Case 2 Failed');",
        "const test3 = Permutations([1]); if(JSON.stringify(test3) !== '[[1]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> Permutations(vector<int>& nums);",
      "testCalls": [
        "auto result1 = Permutations({1,2,3});\nif (result1 != vector<vector<int>>{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = Permutations({0,1});\nif (result2 != vector<vector<int>>{{0,1},{1,0}}) throw std::runtime_error(\"Test Case 2 Failed\");",
        "auto result3 = Permutations({1});\nif (result3 != vector<vector<int>>{{1}}) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def Permutations(nums: List[int]) -> List[List[int]]:",
      "testCalls": [
        "assert Permutations([1,2,3]) == [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "assert Permutations([0,1]) == [[0,1],[1,0]]",
        "assert Permutations([1]) == [[1]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> Permutations(int[] nums) {}",
      "testCalls": [
        "List<List<Integer>> result1 = Permutations(new int[]{1,2,3});\nif (!compareArrays(result1, new int[][]{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}})) throw new AssertionError();",
        "List<List<Integer>> result2 = Permutations(new int[]{0,1});\nif (!compareArrays(result2, new int[][]{{0,1},{1,0}})) throw new AssertionError();",
        "List<List<Integer>> result3 = Permutations(new int[]{1});\nif (!compareArrays(result3, new int[][]{{1}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, int[][] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n        List<Integer> list1 = arr1.get(i);\n        int[] list2 = arr2[i];\n        if (list1.size() != list2.length) return false;\n        for (int j = 0; j < list1.size(); j++) {\n            if (list1.get(j) != list2[j]) return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int** Permutations(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int* nums1 = (int[]){1, 2, 3}; int returnSize1; int* returnColumnSizes1; int** result1 = Permutations(nums1, 3, &returnSize1, &returnColumnSizes1); if (compareArrays(result1, returnSize1, returnColumnSizes1, 6, \"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\") == 0) { printf(\"Test case 1 failed\"); }",
        "int* nums2 = (int[]){0, 1}; int returnSize2; int* returnColumnSizes2; int** result2 = Permutations(nums2, 2, &returnSize2, &returnColumnSizes2); if (compareArrays(result2, returnSize2, returnColumnSizes2, 2, \"[[0,1],[1,0]]\") == 0) { printf(\"Test case 2 failed\"); }",
        "int* nums3 = (int[]){1}; int returnSize3; int* returnColumnSizes3; int** result3 = Permutations(nums3, 1, &returnSize3, &returnColumnSizes3); if (compareArrays(result3, returnSize3, returnColumnSizes3, 1, \"[[1]]\") == 0) { printf(\"Test case 3 failed\"); }"
      ],
      "compareHelper": "int compareArrays(int** result, int returnSize, int* returnColumnSizes, int expectedSize, char* expected) { /* Compare logic here, return 0 if arrays are not equal */ }"
    },
    "go": {
      "functionDeclaration": "func Permutations(nums []int) [][]int {}",
      "testCalls": [
        "if !compareArrays(Permutations([]int{1,2,3}), [][]int{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(Permutations([]int{0,1}), [][]int{{0,1},{1,0}}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(Permutations([]int{1}), [][]int{{1}}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn Permutations(nums: Vec<i32>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(Permutations(vec![1,2,3]), vec![vec![1,2,3],vec![1,3,2],vec![2,1,3],vec![2,3,1],vec![3,1,2],vec![3,2,1]]);",
        "assert_eq!(Permutations(vec![0,1]), vec![vec![0,1],vec![1,0]]); assert_eq!(Permutations(vec![1]), vec![vec![1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) { for (a, b) in arr1.iter().zip(arr2.iter()) { assert_eq!(a, b); }}"
    },
    "ruby": {
      "functionDeclaration": "def Permutations(nums)\nend",
      "testCalls": [
        "test_input = [1,2,3]\nexpected_output = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nresult = Permutations(test_input)\nraise 'Test Case 1 Failed' unless result == expected_output",
        "test_input = [0,1]\nexpected_output = [[0,1],[1,0]]\nresult = Permutations(test_input)\nraise 'Test Case 2 Failed' unless result == expected_output",
        "test_input = [1]\nexpected_output = [[1]]\nresult = Permutations(test_input)\nraise 'Test Case 3 Failed' unless result == expected_output"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3]"
        },
        "expected": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1]"
        },
        "expected": "[[0,1],[1,0]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1]"
        },
        "expected": "[[1]]"
      }
    ]
  },
  "plus-one": {
    "title": "Plus One",
    "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0.\nIncrement the large integer by one and return the resulting array of digits.\n\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n\nConstraints:\n\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PlusOne(digits) {}",
      "testCalls": [
        "const test1 = PlusOne([1,2,3]); if(JSON.stringify(test1) !== JSON.stringify([1,2,4])) throw new Error('Test Case 1 Failed');",
        "const test2 = PlusOne([4,3,2,1]); if(JSON.stringify(test2) !== JSON.stringify([4,3,2,2])) throw new Error('Test Case 2 Failed');",
        "const test3 = PlusOne([9]); if(JSON.stringify(test3) !== JSON.stringify([1,0])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function PlusOne(digits: number[]): number[]",
      "testCalls": [
        "const test1 = PlusOne([1,2,3]); if (JSON.stringify(test1) !== JSON.stringify([1,2,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = PlusOne([4,3,2,1]); if (JSON.stringify(test2) !== JSON.stringify([4,3,2,2])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = PlusOne([9]); if (JSON.stringify(test3) !== JSON.stringify([1,0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<int> PlusOne(vector<int>& digits);",
      "testCalls": [
        "auto result1 = PlusOne({1,2,3});\nif (result1 != vector<int>({1,2,4})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = PlusOne({4,3,2,1});\nif (result2 != vector<int>({4,3,2,2})) throw std::runtime_error(\"Test Case 2 Failed\");",
        "auto result3 = PlusOne({9});\nif (result3 != vector<int>({1,0})) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool compareArrays(const vector<int>& arr1, const vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def PlusOne(digits: List[int]) -> List[int]:",
      "testCalls": [
        "result1 = PlusOne([1,2,3]); assert result1 == [1,2,4], 'Test Case 1 Failed'",
        "result2 = PlusOne([4,3,2,1]); assert result2 == [4,3,2,2], 'Test Case 2 Failed'",
        "result3 = PlusOne([9]); assert result3 == [1,0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2) or any(arr1[i] != arr2[i] for i in range(len(arr1))):\n        return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int[] PlusOne(int[] digits) {}",
      "testCalls": [
        "assert Arrays.equals(PlusOne(new int[]{1,2,3}), new int[]{1,2,4}) : \"Test Case 1 Failed\";",
        "assert Arrays.equals(PlusOne(new int[]{4,3,2,1}), new int[]{4,3,2,2}) : \"Test Case 2 Failed\";"
      ],
      "compareHelper": "Arrays.equals method for comparing arrays"
    },
    "c": {
      "functionDeclaration": "int* PlusOne(int* digits, int digitsSize)",
      "testCalls": [
        "int digits1[] = {1, 2, 3}; int* result1 = PlusOne(digits1, 3); if (compareArrays(result1, (int[]){1, 2, 4}, 3) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int digits2[] = {4, 3, 2, 1}; int* result2 = PlusOne(digits2, 4); if (compareArrays(result2, (int[]){4, 3, 2, 2}, 4) != 0) { printf(\"Test Case 2 Failed\"); }",
        "int digits3[] = {9}; int* result3 = PlusOne(digits3, 1); if (compareArrays(result3, (int[]){1, 0}, 2) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return -1; } return 0; }"
    },
    "go": {
      "functionDeclaration": "func PlusOne(digits []int) []int",
      "testCalls": [
        "if !compareArrays(PlusOne([]int{1,2,3}), []int{1,2,4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(PlusOne([]int{4,3,2,1}), []int{4,3,2,2}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(PlusOne([]int{9}), []int{1,0}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn PlusOne(digits: Vec<i32>) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(PlusOne(vec![1,2,3]), vec![1,2,4]);",
        "assert_eq!(PlusOne(vec![4,3,2,1]), vec![4,3,2,2]);",
        "assert_eq!(PlusOne(vec![9]), vec![1,0]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def PlusOne(digits)\n  \nend",
      "testCalls": [
        "result = PlusOne([1,2,3])\nraise 'Test Case 1 Failed' unless result == [1,2,4]",
        "result = PlusOne([4,3,2,1])\nraise 'Test Case 2 Failed' unless result == [4,3,2,2]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "digits": "[1,2,3]"
        },
        "expected": "[1,2,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "digits": "[4,3,2,1]"
        },
        "expected": "[4,3,2,2]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "digits": "[9]"
        },
        "expected": "[1,0]"
      }
    ]
  },
  "populating-next-right-pointers-in-each-node-ii": {
    "title": "Populating Next Right Pointers in Each Node II",
    "content": "Given a binary tree\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n\nExample 1:\n\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n\nExample 2:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 6000].\n-100 <= Node.val <= 100\n\n\nFollow-up:\n\nYou may only use constant extra space.\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PopulatingNextRightPointersInEachNodeII(root) {}",
      "testCalls": [
        "let root = buildTree([1,2,3,4,5,null,7]); PopulatingNextRightPointersInEachNodeII(root);",
        "let emptyRoot = buildTree([]); PopulatingNextRightPointersInEachNodeII(emptyRoot);"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function Node(val, left, right, next) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; this.next = next === undefined ? null : next; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new Node(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new Node(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new Node(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function Node(val, left, right, next) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; this.next = next === undefined ? null : next; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new Node(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new Node(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new Node(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function ConnectNextRight(root: Node | null): Node | null {}",
      "testCalls": [
        "if(JSON.stringify(ConnectNextRight(buildTree([1,2,3,4,5,null,7]))) !== JSON.stringify(buildTree([1,null,2,3,null,4,5,7,null]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(ConnectNextRight(buildTree([]))) !== JSON.stringify(buildTree([]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function parseTree(arr: (number | null)[]): Node | null { if(arr.length === 0) return null; const root = { val: arr[0], left: null, right: null, next: null }; const queue = [root]; let i = 1; while(i < arr.length) { const current = queue.shift(); if(arr[i] !== null) { current.left = { val: arr[i], left: null, right: null, next: null }; queue.push(current.left); } i++; if(i < arr.length && arr[i] !== null) { current.right = { val: arr[i], left: null, right: null, next: null }; queue.push(current.right); } i++; } return root; }",
      "helpers": "class Node { val: number; left: Node | null; right: Node | null; next: Node | null; constructor(val?: number, left?: Node | null, right?: Node | null, next?: Node | null) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; this.next = next === undefined ? null : next; } }\nfunction buildTree(arr: (number | null)[]): Node | null { if (!arr.length || arr[0] === null) return null; let root = new Node(arr[0] as number); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift() as Node; if (i < arr.length && arr[i] !== null) { node.left = new Node(arr[i] as number); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new Node(arr[i] as number); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root: Node | null): (number | null)[] { if (!root) return []; let result: (number | null)[] = []; let queue = [root]; while (queue.length) { let node = queue.shift() as Node; if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "class Node { val: number; left: Node | null; right: Node | null; next: Node | null; constructor(val?: number, left?: Node | null, right?: Node | null, next?: Node | null) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; this.next = next === undefined ? null : next; } }",
      "builders": "function buildTree(arr: (number | null)[]): Node | null { if (!arr.length || arr[0] === null) return null; let root = new Node(arr[0] as number); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift() as Node; if (i < arr.length && arr[i] !== null) { node.left = new Node(arr[i] as number); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new Node(arr[i] as number); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root: Node | null): (number | null)[] { if (!root) return []; let result: (number | null)[] = []; let queue = [root]; while (queue.length) { let node = queue.shift() as Node; if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "void PopulatingNextRightPointersInEachNodeII(Node* root)",
      "testCalls": [
        "std::vector<int> input1 = {1,2,3,4,5,INT_MIN,7}; Node* root = buildTree(input1); PopulatingNextRightPointersInEachNodeII(root); // Test Case 1",
        "PopulatingNextRightPointersInEachNodeII(nullptr); // Test Case 2"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "helpers": "struct Node { int val; Node* left; Node* right; Node* next; }; \nNode* buildTree(std::vector<int>& arr) { if (arr.empty()) return nullptr; Node* root = new Node{arr[0]}; std::queue<Node*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { Node* curr = q.front(); q.pop(); if (arr[i] != INT_MIN) { curr->left = new Node{arr[i]}; q.push(curr->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { curr->right = new Node{arr[i]}; q.push(curr->right); } i++; } return root; }\nstd::vector<int> treeToArray(Node* root) { std::vector<int> result; if (!root) return result; std::queue<Node*> q; q.push(root); while (!q.empty()) { Node* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "struct Node { int val; Node* left; Node* right; Node* next; };",
      "builders": "Node* buildTree(std::vector<int>& arr) { if (arr.empty()) return nullptr; Node* root = new Node{arr[0]}; std::queue<Node*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { Node* curr = q.front(); q.pop(); if (arr[i] != INT_MIN) { curr->left = new Node{arr[i]}; q.push(curr->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { curr->right = new Node{arr[i]}; q.push(curr->right); } i++; } return root; }\nstd::vector<int> treeToArray(Node* root) { std::vector<int> result; if (!root) return result; std::queue<Node*> q; q.push(root); while (!q.empty()) { Node* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def PopulatingNextRightPointersInEachNodeII(root: 'Node') -> 'Node':",
      "testCalls": [
        "let root = buildTree([1,2,3,4,5,null,7]); if (JSON.stringify(treeToArray(PopulatingNextRightPointersInEachNodeII(root))) !== JSON.stringify([1,null,2,3,null,4,5,7,null])) throw 'Test 1 Failed';",
        "let emptyRoot = buildTree([]); if (JSON.stringify(treeToArray(PopulatingNextRightPointersInEachNodeII(emptyRoot))) !== JSON.stringify([])) throw 'Test 2 Failed';"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        raise AssertionError('Arrays have different lengths')\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            raise AssertionError(f'Arrays differ at index {i}')",
      "helpers": "class Node:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\ndef buildTree(arr):\n    if not arr:\n        return None\n    nodes = [Node(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class Node:\n    def __init__(self, val=0, left=None, right=None, next=None): ...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "void connect(Node root)",
      "testCalls": [
        "Node root1 = buildTree(new Integer[]{1,2,3,4,5,null,7});\nconnect(root1);\nif (!compareTree(root1, new Integer[]{1,null,2,3,null,4,5,7,null})) throw new AssertionError();",
        "Node root2 = buildTree(new Integer[]{});\nconnect(root2);\nif (!compareTree(root2, new Integer[]{})) throw new AssertionError();"
      ],
      "compareHelper": "boolean compareTree(Node root, Integer[] expected) { List<Integer> actual = treeToArray(root); List<Integer> expList = Arrays.asList(expected); return actual.equals(expList); }",
      "helpers": "class Node { int val; Node left; Node right; Node next; }\nNode buildTree(Integer[] arr) { if (arr.length == 0) return null; Node root = new Node(); Queue<Node> queue = new LinkedList<>(); root.val = arr[0]; queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { Node node = queue.poll(); if (arr[i] != null) { node.left = new Node(); node.left.val = arr[i]; queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new Node(); node.right.val = arr[i]; queue.add(node.right); } i++; } return root; }\nList<Integer> treeToArray(Node root) { List<Integer> result = new ArrayList<>(); Queue<Node> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { Node node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }",
      "typeDefs": "class Node { int val; Node left; Node right; Node next; }",
      "builders": "Node buildTree(Integer[] arr) { if (arr.length == 0) return null; Node root = new Node(); Queue<Node> queue = new LinkedList<>(); root.val = arr[0]; queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { Node node = queue.poll(); if (arr[i] != null) { node.left = new Node(); node.left.val = arr[i]; queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new Node(); node.right.val = arr[i]; queue.add(node.right); } i++; } return root; }\nList<Integer> treeToArray(Node root) { List<Integer> result = new ArrayList<>(); Queue<Node> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { Node node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "void PopulatingNextRightPointersInEachNodeII(struct Node* root)",
      "testCalls": [
        "struct Node* root = buildTree([1,2,3,4,5,0,7], 7); PopulatingNextRightPointersInEachNodeII(root); // Expected: [1,#,2,3,#,4,5,7,#]",
        "struct Node* root = buildTree([], 0); PopulatingNextRightPointersInEachNodeII(root); // Expected: []"
      ],
      "compareHelper": "",
      "helpers": "struct Node { int val; struct Node *left; struct Node *right; struct Node *next; }; \nstruct Node* buildTree(int* arr, int size) { return NULL; } \nint* treeToArray(struct Node* root, int* returnSize) { return NULL; }",
      "typeDefs": "struct Node { int val; struct Node *left; struct Node *right; struct Node *next; };",
      "builders": "struct Node* buildTree(int* arr, int size) { return NULL; } \nint* treeToArray(struct Node* root, int* returnSize) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func Connect(root *Node) *Node",
      "testCalls": [
        "let root = buildTree([1,2,3,4,5,null,7]); if JSON.stringify(treeToArray(Connect(root))) !== JSON.stringify([1,null,2,3,null,4,5,7,null]) throw 'Test 1 Failed';",
        "let root = buildTree([]); if JSON.stringify(treeToArray(Connect(root))) !== JSON.stringify([]) throw 'Test 2 Failed';"
      ],
      "compareHelper": "func (n *Node) String() string { if n == nil { return \"[]\" } return fmt.Sprintf(\"[%d,%s,%s]\", n.Val, n.Left.String(), n.Right.String()) }",
      "helpers": "type Node struct {\n    Val   int\n    Left  *Node\n    Right *Node\n    Next  *Node\n}\n\nfunc buildTree(arr []int) *Node {\n    if len(arr) == 0 {\n        return nil\n    }\n    root := &Node{Val: arr[0]}\n    queue := []*Node{root}\n    i := 1\n    for i < len(arr) {\n        current := queue[0]\n        queue = queue[1:]\n        if i < len(arr) && arr[i] != -1 {\n            current.Left = &Node{Val: arr[i]}\n            queue = append(queue, current.Left)\n        }\n        i++\n        if i < len(arr) && arr[i] != -1 {\n            current.Right = &Node{Val: arr[i]}\n            queue = append(queue, current.Right)\n        }\n        i++\n    }\n    return root\n}\n\nfunc treeToArray(root *Node) []int {\n    if root == nil {\n        return []int{}\n    }\n    result := []int{}\n    queue := []*Node{root}\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n        if current != nil {\n            result = append(result, current.Val)\n            queue = append(queue, current.Left)\n            queue = append(queue, current.Right)\n        } else {\n            result = append(result, -1)\n        }\n    }\n    // Trim trailing -1s\n    for len(result) > 0 && result[len(result)-1] == -1 {\n        result = result[:len(result)-1]\n    }\n    return result\n}",
      "typeDefs": "type Node struct { Val int; Left *Node; Right *Node; Next *Node }",
      "builders": "type Node struct { Val int; Left *Node; Right *Node; Next *Node }\n\nfunc buildTree(arr []int) *Node {\n    if len(arr) == 0 {\n        return nil\n    }\n    root := &Node{Val: arr[0]}\n    queue := []*Node{root}\n    i := 1\n    for len(queue) > 0 && i < len(arr) {\n        current := queue[0]\n        queue = queue[1:]\n        if i < len(arr) && arr[i] != -1 {\n            current.Left = &Node{Val: arr[i]}\n            queue = append(queue, current.Left)\n        }\n        i++\n        if i < len(arr) && arr[i] != -1 {\n            current.Right = &Node{Val: arr[i]}\n            queue = append(queue, current.Right)\n        }\n        i++\n    }\n    return root\n}\n\nfunc treeToArray(root *Node) []int {\n    if root == nil {\n        return []int{}\n    }\n    result := []int{}\n    queue := []*Node{root}\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n        if current != nil {\n            result = append(result, current.Val)\n            queue = append(queue, current.Left)\n            queue = append(queue, current.Right)\n        } else {\n            result = append(result, -1)\n        }\n    }\n    // Trim trailing -1s\n    for len(result) > 0 && result[len(result)-1] == -1 {\n        result = result[:len(result)-1]\n    }\n    return result\n}"
    },
    "rust": {
      "functionDeclaration": "fn PopulatingNextRightPointersInEachNodeII(root: Option<Box<Node>>) -> Option<Box<Node>> { }",
      "testCalls": [
        "let root = buildTree(vec![Some(1), Some(2), Some(3), Some(4), Some(5), None, Some(7)]); assert_eq!(treeToArray(PopulatingNextRightPointersInEachNodeII(root.clone())), vec![Some(1), None, Some(2), Some(3), None, Some(4), Some(5), Some(7), None]);",
        "assert_eq!(PopulatingNextRightPointersInEachNodeII(None), None)"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: i32,\n    pub left: Option<Box<Node>>, \n    pub right: Option<Box<Node>>, \n    pub next: Option<Box<Node>>,\n}\n\nimpl Node {\n    pub fn new(val: i32) -> Self {\n        Node {\n            val,\n            left: None,\n            right: None,\n            next: None,\n        }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Box<Node>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n\n    let mut root = Box::new(Node::new(arr[0].unwrap()));\n    let mut queue = VecDeque::new();\n    queue.push_back(&mut root);\n\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                node.left = Some(Box::new(Node::new(arr[i].unwrap())));\n                queue.push_back(node.left.as_mut().unwrap());\n            }\n            i += 1;\n\n            if i < arr.len() && arr[i].is_some() {\n                node.right = Some(Box::new(Node::new(arr[i].unwrap())));\n                queue.push_back(node.right.as_mut().unwrap());\n            }\n            i += 1;\n        }\n    }\n\n    Some(root)\n}\n\nfn treeToArray(root: Option<Box<Node>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.val));\n\n            if let Some(left) = node.left {\n                queue.push_back(left);\n            } else {\n                result.push(None);\n            }\n\n            if let Some(right) = node.right {\n                queue.push_back(right);\n            } else {\n                result.push(None);\n            }\n        }\n    }\n\n    // Remove trailing None values\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: i32,\n    pub left: Option<Box<Node>>, \n    pub right: Option<Box<Node>>, \n    pub next: Option<Box<Node>>,\n}",
      "builders": "#[derive(Debug)]\nstruct Node {\n    val: i32,\n    left: Option<Box<Node>>,\n    right: Option<Box<Node>>,\n    next: Option<*mut Node>,\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<Node>> {\n    if arr.is_empty() {\n        return None;\n    }\n    let root = Some(Box::new(Node { val: arr[0].unwrap(), left: None, right: None, next: None }));\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root.as_ref().map(|node| node as *const _ as *mut _));\n    let mut i = 1;\n    while let Some(current) = queue.pop_front() {\n        unsafe {\n            if i < arr.len() && arr[i].is_some() {\n                let left_node = Box::new(Node { val: arr[i].unwrap(), left: None, right: None, next: None });\n                (*current).left = Some(left_node);\n                queue.push_back((*current).left.as_ref().map(|node| node as *const _ as *mut _));\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                let right_node = Box::new(Node { val: arr[i].unwrap(), left: None, right: None, next: None });\n                (*current).right = Some(right_node);\n                queue.push_back((*current).right.as_ref().map(|node| node as *const _ as *mut _));\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<Node>>) -> Vec<Option<i32>> {\n    let mut result = vec![];\n    let mut queue = std::collections::VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(Some(node));\n    }\n    while let Some(current) = queue.pop_front() {\n        if let Some(node) = current {\n            result.push(Some(node.val));\n            queue.push_back(node.left);\n            queue.push_back(node.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def PopulatingNextRightPointersInEachNodeII(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,4,5,nil,7])\nPopulatingNextRightPointersInEachNodeII(root)",
        "root_empty = buildTree([])\nPopulatingNextRightPointersInEachNodeII(root_empty)"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class Node\n  attr_accessor :val, :left, :right, :next\n  def initialize(val = 0, left = nil, right = nil, next_node = nil)\n    @val = val\n    @left = left\n    @right = right\n    @next = next_node\n  end\nend\n\ndef buildTree(arr)\n  # Implementation for building a binary tree from an array\nend\n\ndef treeToArray(root)\n  # Implementation for converting a binary tree to an array\nend\n\ndef buildLinkedList(arr)\n  # Implementation for building a linked list from an array\nend\n\ndef linkedListToArray(head)\n  # Implementation for converting a linked list to an array\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :left, :right, :next\n  def initialize(val = 0, left = nil, right = nil, next_node = nil)\n    @val = val\n    @left = left\n    @right = right\n    @next = next_node\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implementation for building a binary tree from an array\nend\n\ndef treeToArray(root)\n  # Implementation for converting a binary tree to an array\nend\n\ndef buildLinkedList(arr)\n  # Implementation for building a linked list from an array\nend\n\ndef linkedListToArray(head)\n  # Implementation for converting a linked list to an array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3,4,5,null,7]"
        },
        "expected": "[1,#,2,3,#,4,5,7,#]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "product-of-array-except-self": {
    "title": "Product of Array Except Self",
    "content": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs inO(n)time and without using the division operation.\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\n\nConstraints:\n\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.\n\n\nFollow up:Can you solve the problem in O(1)extraspace complexity? (The output array does not count as extra space for space complexity analysis.)\n",
    "difficulty": "Medium",
    "hints": [
      "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
      "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
    ],
    "topicTags": [
      "Array",
      "Prefix Sum"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ProductOfArrayExceptSelf(nums) {}",
      "testCalls": [
        "const test1 = ProductOfArrayExceptSelf([1,2,3,4]); if(JSON.stringify(test1) !== JSON.stringify([24,12,8,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = ProductOfArrayExceptSelf([-1,1,0,-3,3]); if(JSON.stringify(test2) !== JSON.stringify([0,0,9,0,0])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function ProductOfArrayExceptSelf(nums: number[]): number[]",
      "testCalls": [
        "const test1 = ProductOfArrayExceptSelf([1,2,3,4]); if (JSON.stringify(test1) !== JSON.stringify([24,12,8,6])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ProductOfArrayExceptSelf([-1,1,0,-3,3]); if (JSON.stringify(test2) !== JSON.stringify([0,0,9,0,0])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<int> ProductOfArrayExceptSelf(vector<int>& nums)",
      "testCalls": [
        "auto result1 = ProductOfArrayExceptSelf({1,2,3,4});\nif(result1 != vector<int>({24,12,8,6})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = ProductOfArrayExceptSelf({-1,1,0,-3,3});\nif(result2 != vector<int>({0,0,9,0,0})) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def ProductOfArrayExceptSelf(nums: List[int]) -> List[int]",
      "testCalls": [
        "assert ProductOfArrayExceptSelf([1,2,3,4]) == [24,12,8,6]",
        "assert ProductOfArrayExceptSelf([-1,1,0,-3,3]) == [0,0,9,0,0]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int[] ProductOfArrayExceptSelf(int[] nums) {}",
      "testCalls": [
        "assert Arrays.equals(ProductOfArrayExceptSelf(new int[]{1,2,3,4}), new int[]{24,12,8,6});",
        "assert Arrays.equals(ProductOfArrayExceptSelf(new int[]{-1,1,0,-3,3}), new int[]{0,0,9,0,0});"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int* ProductOfArrayExceptSelf(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1,2,3,4}; int expected1[] = {24,12,8,6}; int* result1 = ProductOfArrayExceptSelf(nums1, 4); if(memcmp(result1, expected1, 4*sizeof(int)) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int nums2[] = {-1,1,0,-3,3}; int expected2[] = {0,0,9,0,0}; int* result2 = ProductOfArrayExceptSelf(nums2, 5); if(memcmp(result2, expected2, 5*sizeof(int)) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func ProductOfArrayExceptSelf(nums []int) []int {}",
      "testCalls": [
        "if !compareArrays(ProductOfArrayExceptSelf([]int{1,2,3,4}), []int{24,12,8,6}) { t.Error(\"Test case 1 failed\") }",
        "if !compareArrays(ProductOfArrayExceptSelf([]int{-1,1,0,-3,3}), []int{0,0,9,0,0}) { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn ProductOfArrayExceptSelf(nums: Vec<i32>) -> Vec<i32> {}",
      "testCalls": [
        "let result1 = ProductOfArrayExceptSelf(vec![1,2,3,4]); assert_eq!(result1, vec![24,12,8,6]);",
        "let result2 = ProductOfArrayExceptSelf(vec![-1,1,0,-3,3]); assert_eq!(result2, vec![0,0,9,0,0]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def ProductOfArrayExceptSelf(nums)\nend",
      "testCalls": [
        "nums = [1,2,3,4]\nexpected_result = [24,12,8,6]\nresult = ProductOfArrayExceptSelf(nums)\nraise 'Test Case 1 Failed' unless result == expected_result",
        "nums = [-1,1,0,-3,3]\nexpected_result = [0,0,9,0,0]\nresult = ProductOfArrayExceptSelf(nums)\nraise 'Test Case 2 Failed' unless result == expected_result"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,4]"
        },
        "expected": "[24,12,8,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[-1,1,0,-3,3]"
        },
        "expected": "[0,0,9,0,0]"
      }
    ]
  },
  "remove-duplicates-from-sorted-array-ii": {
    "title": "Remove Duplicates from Sorted Array II",
    "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of numsshould hold the final result. It does not matter what you leave beyond the firstkelements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArrayII(nums) {}",
      "testCalls": [
        "let nums1 = [1,1,1,2,2,3]; let expectedResult1 = [1,1,2,2,3]; let expectedLength1 = 5; let result1 = RemoveDuplicatesFromSortedArrayII(nums1); if (result1 !== expectedLength1 || !arraysEqual(nums1.slice(0, expectedLength1), expectedResult1)) { throw new Error('Test Case 1 Failed'); }",
        "let nums2 = [0,0,1,1,1,1,2,3,3]; let expectedResult2 = [0,0,1,1,2,3,3]; let expectedLength2 = 7; let result2 = RemoveDuplicatesFromSortedArrayII(nums2); if (result2 !== expectedLength2 || !arraysEqual(nums2.slice(0, expectedLength2), expectedResult2)) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0; i < arr1.length; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArrayII(nums: number[]): number {}",
      "testCalls": [
        "const test1Nums = [1,1,1,2,2,3];\nconst expectedNums1 = [1,1,2,2,3,null];\nconst k1 = RemoveDuplicatesFromSortedArrayII(test1Nums);\nif (k1 !== expectedNums1.length || !arraysEqual(test1Nums.slice(0, k1), expectedNums1.slice(0, k1))) {\n  throw new Error('Test Case 1 Failed');\n}",
        "const test2Nums = [0,0,1,1,1,1,2,3,3];\nconst expectedNums2 = [0,0,1,1,2,3,3,null,null];\nconst k2 = RemoveDuplicatesFromSortedArrayII(test2Nums);\nif (k2 !== expectedNums2.length || !arraysEqual(test2Nums.slice(0, k2), expectedNums2.slice(0, k2))) {\n  throw new Error('Test Case 2 Failed');\n}"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}"
    },
    "cpp": {
      "functionDeclaration": "int RemoveDuplicatesFromSortedArrayII(vector<int>& nums)",
      "testCalls": [
        "vector<int> nums1 = {1, 1, 1, 2, 2, 3}; int k1 = RemoveDuplicatesFromSortedArrayII(nums1); vector<int> expectedNums1 = {1, 1, 2, 2, 3}; assert(k1 == expectedNums1.size()); for(int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "vector<int> nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3}; int k2 = RemoveDuplicatesFromSortedArrayII(nums2); vector<int> expectedNums2 = {0, 0, 1, 1, 2, 3, 3}; assert(k2 == expectedNums2.size()); for(int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "empty string"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArrayII(nums: List[int]) -> int:",
      "testCalls": [
        "nums1 = [1,1,1,2,2,3]\nexpectedNums1 = [1,1,2,2,3]\nexpectedResult1 = 5\nk1 = RemoveDuplicatesFromSortedArrayII(nums1)\nassert k1 == expectedResult1\nassert nums1[:k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,1,2,3,3]\nexpectedNums2 = [0,0,1,1,2,3,3]\nexpectedResult2 = 7\nk2 = RemoveDuplicatesFromSortedArrayII(nums2)\nassert k2 == expectedResult2\nassert nums2[:k2] == expectedNums2"
      ],
      "compareHelper": "def assertArraysEqual(arr1, arr2):\n    assert len(arr1) == len(arr2)\n    for i in range(len(arr1)):\n        assert arr1[i] == arr2[i]"
    },
    "java": {
      "functionDeclaration": "public int RemoveDuplicatesFromSortedArrayII(int[] nums)",
      "testCalls": [
        "int[] nums1 = {1, 1, 1, 2, 2, 3};\nint expectedLength1 = 5;\nint[] expectedNums1 = {1, 1, 2, 2, 3};\nint k1 = RemoveDuplicatesFromSortedArrayII(nums1);\nif (k1 != expectedLength1) throw new AssertionError();\nfor (int i = 0; i < k1; i++) {\n    if (nums1[i] != expectedNums1[i]) throw new AssertionError();\n}",
        "int[] nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3};\nint expectedLength2 = 7;\nint[] expectedNums2 = {0, 0, 1, 1, 2, 3, 3};\nint k2 = RemoveDuplicatesFromSortedArrayII(nums2);\nif (k2 != expectedLength2) throw new AssertionError();\nfor (int i = 0; i < k2; i++) {\n    if (nums2[i] != expectedNums2[i]) throw new AssertionError();\n}"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int RemoveDuplicatesFromSortedArrayII(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1, 1, 1, 2, 2, 3};\nint expectedNums1[] = {1, 1, 2, 2, 3};\nint k1 = RemoveDuplicatesFromSortedArrayII(nums1, 6);\nif (k1 != 5) { printf(\"Test Case 1 Failed\"); }\nfor (int i = 0; i < k1; i++) { if (nums1[i] != expectedNums1[i]) { printf(\"Test Case 1 Failed\"); }}",
        "int nums2[] = {0, 0, 1, 1, 1, 1, 2, 3, 3};\nint expectedNums2[] = {0, 0, 1, 1, 2, 3, 3};\nint k2 = RemoveDuplicatesFromSortedArrayII(nums2, 9);\nif (k2 != 7) { printf(\"Test Case 2 Failed\"); }\nfor (int i = 0; i < k2; i++) { if (nums2[i] != expectedNums2[i]) { printf(\"Test Case 2 Failed\"); }}"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; }} return 1; }"
    },
    "go": {
      "functionDeclaration": "func RemoveDuplicatesFromSortedArrayII(nums []int) int {}",
      "testCalls": [
        "k1 := RemoveDuplicatesFromSortedArrayII([]int{1,1,1,2,2,3}); if k1 != 5 {panic(\"Test case 1 failed\")}",
        "k2 := RemoveDuplicatesFromSortedArrayII([]int{0,0,1,1,1,1,2,3,3}); if k2 != 7 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicatesFromSortedArrayII(nums: &mut Vec<i32>) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![1, 1, 1, 2, 2, 3];\nlet expected_nums1 = vec![1, 1, 2, 2, 3];\nlet k1 = RemoveDuplicatesFromSortedArrayII(&mut nums1);\nassert_eq!(k1, expected_nums1.len() as i32);\nassert_eq!(&nums1[0..expected_nums1.len()], &expected_nums1[..]);",
        "let mut nums2 = vec![0, 0, 1, 1, 1, 1, 2, 3, 3];\nlet expected_nums2 = vec![0, 0, 1, 1, 2, 3, 3];\nlet k2 = RemoveDuplicatesFromSortedArrayII(&mut nums2);\nassert_eq!(k2, expected_nums2.len() as i32);\nassert_eq!(&nums2[0..expected_nums2.len()], &expected_nums2[..]);"
      ],
      "compareHelper": "fn assert_arrays_equal(arr1: &[i32], arr2: &[i32]) {\n    assert_eq!(arr1, arr2);\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArrayII(nums)",
      "testCalls": [
        "nums1 = [1,1,1,2,2,3]; expectedNums1 = [1,1,2,2,3]; k1 = RemoveDuplicatesFromSortedArrayII(nums1); raise 'Test Case 1 Failed' unless k1 == expectedNums1.length && nums1[0...k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,1,2,3,3]; expectedNums2 = [0,0,1,1,2,3,3]; k2 = RemoveDuplicatesFromSortedArrayII(nums2); raise 'Test Case 2 Failed' unless k2 == expectedNums2.length && nums2[0...k2] == expectedNums2"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,1,1,2,2,3]"
        },
        "expected": "5,nums=[1,1,2,2,3,_]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,0,1,1,1,1,2,3,3]"
        },
        "expected": "7,nums=[0,0,1,1,2,3,3,_,_]"
      }
    ]
  },
  "remove-duplicates-from-sorted-array": {
    "title": "Remove Duplicates from Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nConsider the number of unique elements innums to be k. After removing duplicates, return the number of unique elementsk.\nThe firstkelements ofnumsshould contain the unique numbers in sorted order. The remaining elements beyond indexk - 1can be ignored.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.\n\n",
    "difficulty": "Easy",
    "hints": [
      "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n\r\n",
      "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
      "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArray(nums) {}",
      "testCalls": [
        "RemoveDuplicatesFromSortedArray([1,1,2])",
        "RemoveDuplicatesFromSortedArray([0,0,1,1,1,2,2,3,3,4])"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArray(nums: number[]): number {}",
      "testCalls": [
        "const nums1: number[] = [1,1,2];\nconst expectedNums1: number[] = [1,2];\nconst k1: number = RemoveDuplicatesFromSortedArray(nums1);\nif (k1 !== expectedNums1.length || !arraysEqual(nums1.slice(0, k1), expectedNums1)) {\n  throw new Error('Test Case 1 Failed');\n}",
        "const nums2: number[] = [0,0,1,1,1,2,2,3,3,4];\nconst expectedNums2: number[] = [0,1,2,3,4];\nconst k2: number = RemoveDuplicatesFromSortedArray(nums2);\nif (k2 !== expectedNums2.length || !arraysEqual(nums2.slice(0, k2), expectedNums2)) {\n  throw new Error('Test Case 2 Failed');\n}"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}"
    },
    "cpp": {
      "functionDeclaration": "int RemoveDuplicates(vector<int>& nums)",
      "testCalls": [
        "vector<int> nums1 = {1, 1, 2}; int k1 = RemoveDuplicates(nums1); assert(k1 == 2); vector<int> expectedNums1 = {1, 2}; for (int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "vector<int> nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int k2 = RemoveDuplicates(nums2); assert(k2 == 5); vector<int> expectedNums2 = {0, 1, 2, 3, 4}; for (int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "std::equal(nums.begin(), nums.begin() + k, expectedNums.begin())"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArray(nums: List[int]) -> int:",
      "testCalls": [
        "nums1 = [1,1,2]; expectedResult1 = 2; expectedNums1 = [1,2]; k1 = RemoveDuplicatesFromSortedArray(nums1); assert k1 == expectedResult1; assert nums1[:k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,2,2,3,3,4]; expectedResult2 = 5; expectedNums2 = [0,1,2,3,4]; k2 = RemoveDuplicatesFromSortedArray(nums2); assert k2 == expectedResult2; assert nums2[:k2] == expectedNums2"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return all(x == y for x, y in zip(arr1, arr2))"
    },
    "java": {
      "functionDeclaration": "public int RemoveDuplicates(int[] nums) {}",
      "testCalls": [
        "int[] nums1 = {1, 1, 2}; int[] expectedNums1 = {1, 2}; int k1 = RemoveDuplicates(nums1); assert k1 == expectedNums1.length; for (int i = 0; i < k1; i++) { assert nums1[i] == expectedNums1[i]; }",
        "int[] nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int[] expectedNums2 = {0, 1, 2, 3, 4}; int k2 = RemoveDuplicates(nums2); assert k2 == expectedNums2.length; for (int i = 0; i < k2; i++) { assert nums2[i] == expectedNums2[i]; }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { if (arr1.length != arr2.length) { return false; } for (int i = 0; i < arr1.length; i++) { if (arr1[i] != arr2[i]) { return false; } } return true; }"
    },
    "c": {
      "functionDeclaration": "int RemoveDuplicates(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1, 1, 2}; int expectedNums1[] = {1, 2}; int k1 = RemoveDuplicates(nums1, 3); assert(k1 == 2); for (int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "int nums2[] = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int expectedNums2[] = {0, 1, 2, 3, 4}; int k2 = RemoveDuplicates(nums2, 10); assert(k2 == 5); for (int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RemoveDuplicates(nums []int) int {}",
      "testCalls": [
        "if RemoveDuplicates([]int{1, 1, 2}) != 2 {panic(\"Test case 1 failed\")}",
        "if RemoveDuplicates([]int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}) != 5 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n    if len(arr1) != len(arr2) { return false }\n    for i := range arr1 {\n        if arr1[i] != arr2[i] { return false }\n    }\n    return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicates(nums: &mut Vec<i32>) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![1, 1, 2];\nlet expected_nums1 = vec![1, 2];\nlet k1 = RemoveDuplicates(&mut nums1);\nassert_eq!(k1, expected_nums1.len() as i32);\nassert_eq!(&nums1[0..k1 as usize], &expected_nums1[..]);",
        "let mut nums2 = vec![0, 0, 1, 1, 1, 2, 2, 3, 3, 4];\nlet expected_nums2 = vec![0, 1, 2, 3, 4];\nlet k2 = RemoveDuplicates(&mut nums2);\nassert_eq!(k2, expected_nums2.len() as i32);\nassert_eq!(&nums2[0..k2 as usize], &expected_nums2[..]);"
      ],
      "compareHelper": "fn assert_arrays_equal(arr1: &[i32], arr2: &[i32]) {\n    assert_eq!(arr1, arr2);\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArray(nums)\nend",
      "testCalls": [
        "nums1 = [1,1,2]\nexpected_nums1 = [1,2]\nexpected_result1 = 2\nresult1 = RemoveDuplicatesFromSortedArray(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected_result1 && nums1[0...result1] == expected_nums1",
        "nums2 = [0,0,1,1,1,2,2,3,3,4]\nexpected_nums2 = [0,1,2,3,4]\nexpected_result2 = 5\nresult2 = RemoveDuplicatesFromSortedArray(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected_result2 && nums2[0...result2] == expected_nums2"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,1,2]"
        },
        "expected": "2,nums=[1,2,_]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,0,1,1,1,2,2,3,3,4]"
        },
        "expected": "5,nums=[0,1,2,3,4,_,_,_,_,_]"
      }
    ]
  },
  "remove-duplicates-from-sorted-list-ii": {
    "title": "Remove Duplicates from Sorted List II",
    "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n\nExample 1:\n\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 300].\n-100 <= Node.val <= 100\nThe list is guaranteed to be sorted in ascending order.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedListII(head) {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,3,4,4,5]); if(JSON.stringify(RemoveDuplicatesFromSortedListII(head1)) !== JSON.stringify([1,2,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1,1,1,2,3]); if(JSON.stringify(RemoveDuplicatesFromSortedListII(head2)) !== JSON.stringify([2,3])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function DeleteDuplicatesFromSortedListII(head: ListNode | null): ListNode | null",
      "testCalls": [
        "if (JSON.stringify(DeleteDuplicatesFromSortedListII(arrayToLinkedList([1,2,3,3,4,4,5]))) !== JSON.stringify(arrayToLinkedList([1,2,5]))) throw new Error('Test Case 1 Failed');",
        "if (JSON.stringify(DeleteDuplicatesFromSortedListII(arrayToLinkedList([1,1,1,2,3]))) !== JSON.stringify(arrayToLinkedList([2,3]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  const head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction arrayToLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function arrayToLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* DeleteDuplicates(ListNode* head)",
      "testCalls": [
        "assert(compareLinkedList(DeleteDuplicates(buildLinkedList({1,2,3,3,4,4,5})), buildLinkedList({1,2,5}));",
        "assert(compareLinkedList(DeleteDuplicates(buildLinkedList({1,1,1,2,3})), buildLinkedList({2,3}));"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} }; ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedListII(head):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,3,4,4,5])\nresult = RemoveDuplicatesFromSortedListII(head)\nassert linkedListToArray(result) == [1,2,5]",
        "head = buildLinkedList([1,1,1,2,3])\nresult = RemoveDuplicatesFromSortedListII(head)\nassert linkedListToArray(result) == [2,3]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None): ...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode deleteDuplicates(ListNode head) { }",
      "testCalls": [
        "ListNode test1 = deleteDuplicates(buildLinkedList(new int[]{1,2,3,3,4,4,5})); if (!Arrays.equals(linkedListToArray(test1), new int[]{1,2,5})) throw new AssertionError();",
        "ListNode test2 = deleteDuplicates(buildLinkedList(new int[]{1,1,1,2,3})); if (!Arrays.equals(linkedListToArray(test2), new int[]{2,3})) throw new AssertionError();"
      ],
      "compareHelper": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n    public static ListNode fromArray(int[] arr) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        for (int val : arr) {\n            current.next = new ListNode(val);\n            current = current.next;\n        }\n        return dummy.next;\n    }\n    public static boolean equalsArray(ListNode head, int[] arr) {\n        ListNode current = head;\n        for (int val : arr) {\n            if (current == null || current.val != val) {\n                return false;\n            }\n            current = current.next;\n        }\n        return current == null;\n    }\n}",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "void DeleteDuplicatesFromSortedListII(struct ListNode* head)",
      "testCalls": [
        "int arr1[] = {1,2,3,3,4,4,5}; struct ListNode* head1 = buildLinkedList(arr1, 7); DeleteDuplicatesFromSortedListII(head1); // Compare result with expected for input [1,2,3,3,4,4,5]",
        "int arr2[] = {1,1,1,2,3}; struct ListNode* head2 = buildLinkedList(arr2, 5); DeleteDuplicatesFromSortedListII(head2); // Compare result with expected for input [1,1,1,2,3]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n    if (size1 != size2) return 0;\n    for (int i = 0; i < size1; i++) {\n        if (arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}",
      "helpers": "struct ListNode { int val; struct ListNode* next; }; \nstruct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func DeleteDuplicates(head *ListNode) *ListNode",
      "testCalls": [
        "if result := DeleteDuplicates(buildLinkedList([]int{1,2,3,3,4,4,5})); !compareLinkedList(result, buildLinkedList([]int{1,2,5})) { t.Errorf(\"Test 1 Failed\") }",
        "if result := DeleteDuplicates(buildLinkedList([]int{1,1,1,2,3})); !compareLinkedList(result, buildLinkedList([]int{2,3})) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicatesFromSortedListII(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = build_linked_list(vec![1, 2, 5]); assert_eq!(Some(Box::new(ListNode::new(1))), RemoveDuplicatesFromSortedListII(head1));",
        "let head2 = build_linked_list(vec![1, 1, 1, 2, 3]); assert_eq!(Some(Box::new(ListNode::new(2))), RemoveDuplicatesFromSortedListII(head2));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashSet;\nuse std::iter::FromIterator;\nuse std::mem;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedListII(head)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,3,4,4,5])\nresult = RemoveDuplicatesFromSortedListII(head)\nraise 'Test Case 1 Failed' unless linkedListToArray(result) == [1,2,5]",
        "head = buildLinkedList([1,1,1,2,3])\nresult = RemoveDuplicatesFromSortedListII(head)\nraise 'Test Case 2 Failed' unless linkedListToArray(result) == [2,3]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\n\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,3,4,4,5]"
        },
        "expected": "[1,2,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1,1,1,2,3]"
        },
        "expected": "[2,3]"
      }
    ]
  },
  "remove-element": {
    "title": "Remove Element",
    "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\n\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n\n",
    "difficulty": "Easy",
    "hints": [
      "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to remove that element per se, right?",
      "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
      "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveElement(nums, val) {}",
      "testCalls": [
        "const test1Nums = [3,2,2,3]; const test1Val = 3; const test1Expected = 2; const test1Result = RemoveElement(test1Nums, test1Val); if (test1Result !== test1Expected) { throw new Error(`Test case 1 failed: Expected ${test1Expected}, got ${test1Result}`); }",
        "const test2Nums = [0,1,2,2,3,0,4,2]; const test2Val = 2; const test2Expected = 5; const test2Result = RemoveElement(test2Nums, test2Val); if (test2Result !== test2Expected) { throw new Error(`Test case 2 failed: Expected ${test2Expected}, got ${test2Result}`); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveElement(nums: number[], val: number): number {}",
      "testCalls": [
        "const test1Nums = [3,2,2,3]; const test1Val = 3; const test1Expected = 2; const test1Result = RemoveElement(test1Nums, test1Val); if (test1Result !== test1Expected) { throw new Error(`Test case 1 failed: Expected ${test1Expected}, got ${test1Result}`); }",
        "const test2Nums = [0,1,2,2,3,0,4,2]; const test2Val = 2; const test2Expected = 5; const test2Result = RemoveElement(test2Nums, test2Val); if (test2Result !== test2Expected) { throw new Error(`Test case 2 failed: Expected ${test2Expected}, got ${test2Result}`); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "int RemoveElement(vector<int>& nums, int val);",
      "testCalls": [
        "vector<int> nums1 = {3, 2, 2, 3}; int val1 = 3; int k1 = RemoveElement(nums1, val1); assert(k1 == 2); vector<int> expectedNums1 = {2, 2}; sort(nums1.begin(), nums1.begin() + k1); assert(nums1 == expectedNums1);",
        "vector<int> nums2 = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int k2 = RemoveElement(nums2, val2); assert(k2 == 5); vector<int> expectedNums2 = {0, 1, 4, 0, 3}; sort(nums2.begin(), nums2.begin() + k2); assert(nums2 == expectedNums2);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def RemoveElement(nums: List[int], val: int) -> int:",
      "testCalls": [
        "assert RemoveElement([3,2,2,3], 3) == 2",
        "assert RemoveElement([0,1,2,2,3,0,4,2], 2) == 5"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        raise AssertionError('Arrays have different lengths')\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            raise AssertionError(f'Arrays differ at index {i}')"
    },
    "java": {
      "functionDeclaration": "public int RemoveElement(int[] nums, int val) {}",
      "testCalls": [
        "int[] nums1 = {3, 2, 2, 3};\nint val1 = 3;\nint expected1 = 2;\nint k1 = RemoveElement(nums1, val1);\nassert k1 == expected1;",
        "int[] nums2 = {0, 1, 2, 2, 3, 0, 4, 2};\nint val2 = 2;\nint expected2 = 5;\nint k2 = RemoveElement(nums2, val2);\nassert k2 == expected2;"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2, int length) {\n    for (int i = 0; i < length; i++) {\n        if (arr1[i] != arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int RemoveElement(int* nums, int numsSize, int val);",
      "testCalls": [
        "int nums1[] = {3, 2, 2, 3}; int val1 = 3; int expected1 = 2; int k1 = RemoveElement(nums1, 4, val1); assert(k1 == expected1);",
        "int nums2[] = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int expected2 = 5; int k2 = RemoveElement(nums2, 8, val2); assert(k2 == expected2);"
      ],
      "compareHelper": "void assertArrayEquals(int* arr1, int* arr2, int size) { for(int i = 0; i < size; i++) { assert(arr1[i] == arr2[i]); } }"
    },
    "go": {
      "functionDeclaration": "func RemoveElement(nums []int, val int) int {}",
      "testCalls": [
        "if RemoveElement([]int{3,2,2,3}, 3) != 2 {panic(\"Test case 1 failed\")}",
        "if RemoveElement([]int{0,1,2,2,3,0,4,2}, 2) != 5 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n  if len(arr1) != len(arr2) { return false }\n  for i := range arr1 {\n    if arr1[i] != arr2[i] { return false }\n  }\n  return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn RemoveElement(nums: &mut Vec<i32>, val: i32) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![3, 2, 2, 3];\nlet val1 = 3;\nlet result1 = RemoveElement(&mut nums1, val1);\nassert_eq!(result1, 2);\nassert_eq!(nums1, vec![2, 2]);",
        "let mut nums2 = vec![0, 1, 2, 2, 3, 0, 4, 2];\nlet val2 = 2;\nlet result2 = RemoveElement(&mut nums2, val2);\nassert_eq!(result2, 5);\nassert_eq!(nums2, vec![0, 1, 4, 0, 3]);"
      ],
      "compareHelper": "fn assert_vec_eq(actual: Vec<i32>, expected: Vec<i32>) {\n    assert_eq!(actual.len(), expected.len());\n    for i in 0..actual.len() {\n        assert_eq!(actual[i], expected[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveElement(nums, val)\nend",
      "testCalls": [
        "nums1 = [3,2,2,3]\nval1 = 3\nexpected_result1 = 2\nRemoveElement(nums1, val1) # Call function\nif nums1[0...expected_result1] != [2, 2]\n  raise 'Test Case 1 Failed'\nend",
        "nums2 = [0,1,2,2,3,0,4,2]\nval2 = 2\nexpected_result2 = 5\nRemoveElement(nums2, val2) # Call function\nif nums2[0...expected_result2].sort != [0, 0, 1, 3, 4]\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,2,2,3]",
          "val": "3"
        },
        "expected": "2,nums=[2,2,_,_]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1,2,2,3,0,4,2]",
          "val": "2"
        },
        "expected": "5,nums=[0,1,4,0,3,_,_,_]"
      }
    ]
  },
  "remove-nth-node-from-end-of-list": {
    "title": "Remove Nth Node From End of List",
    "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n\nConstraints:\n\nThe number of nodes in the list is sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz\n\n\nFollow up: Could you do this in one pass?\n",
    "difficulty": "Medium",
    "hints": [
      "Maintain two pointers and update one with a delay of n steps."
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RemoveNthNodeFromEndOfList(head, n) {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); let test1 = RemoveNthNodeFromEndOfList(head1, 2); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,2,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1]); let test2 = RemoveNthNodeFromEndOfList(head2, 1); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "let head3 = buildLinkedList([1,2]); let test3 = RemoveNthNodeFromEndOfList(head3, 1); if(JSON.stringify(linkedListToArray(test3)) !== JSON.stringify([1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveNthNodeFromEndOfList(head: ListNode | null, n: number): ListNode | null {}",
      "testCalls": [
        "const test1 = RemoveNthNodeFromEndOfList(createLinkedList([1,2,3,4,5]), 2); compareLinkedList(test1, createLinkedList([1,2,3,5]));",
        "const test2 = RemoveNthNodeFromEndOfList(createLinkedList([1]), 1); compareLinkedList(test2, createLinkedList([]));",
        "const test3 = RemoveNthNodeFromEndOfList(createLinkedList([1,2]), 1); compareLinkedList(test3, createLinkedList([1]));"
      ],
      "compareHelper": "function compareLinkedList(head1, head2) { let arr1 = []; let arr2 = []; while (head1) { arr1.push(head1.val); head1 = head1.next; } while (head2) { arr2.push(head2.val); head2 = head2.next; } if (JSON.stringify(arr1) !== JSON.stringify(arr2)) throw new Error('Test Failed'); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction createLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1, head2) { let arr1 = []; let arr2 = []; while (head1) { arr1.push(head1.val); head1 = head1.next; } while (head2) { arr2.push(head2.val); head2 = head2.next; } if (JSON.stringify(arr1) !== JSON.stringify(arr2)) throw new Error('Test Failed'); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function createLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1, head2) { let arr1 = []; let arr2 = []; while (head1) { arr1.push(head1.val); head1 = head1.next; } while (head2) { arr2.push(head2.val); head2 = head2.next; } if (JSON.stringify(arr1) !== JSON.stringify(arr2)) throw new Error('Test Failed'); }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* RemoveNthNodeFromEndOfList(ListNode* head, int n)",
      "testCalls": [
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(buildLinkedList({1,2,3,4,5}), 2), buildLinkedList({1,2,3,5}));",
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(buildLinkedList({1}), 1), buildLinkedList({}));",
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(buildLinkedList({1,2}), 1), buildLinkedList({1}));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} }; ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def RemoveNthNodeFromEndOfList(head, n):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nresult = RemoveNthNodeFromEndOfList(head, 2)\nassert linkedListToArray(result) == [1,2,3,5]",
        "head = buildLinkedList([1])\nresult = RemoveNthNodeFromEndOfList(head, 1)\nassert linkedListToArray(result) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None): ...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode removeNthFromEnd(ListNode head, int n) { }",
      "testCalls": [
        "ListNode test1 = removeNthFromEnd(buildLinkedList(new int[]{1,2,3,4,5}), 2); if (!Arrays.equals(linkedListToArray(test1), new int[]{1,2,3,5})) throw new AssertionError();",
        "ListNode test2 = removeNthFromEnd(buildLinkedList(new int[]{1}), 1); if (!Arrays.equals(linkedListToArray(test2), new int[]{})) throw new AssertionError();",
        "ListNode test3 = removeNthFromEnd(buildLinkedList(new int[]{1,2}), 1); if (!Arrays.equals(linkedListToArray(test3), new int[]{1})) throw new AssertionError();"
      ],
      "compareHelper": "public static boolean equalsArray(ListNode node, int[] expected) { }",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* RemoveNthFromEnd(ListNode* head, int n)",
      "testCalls": [
        "int arr1[] = {1,2,3,4,5}; struct ListNode* head1 = buildLinkedList(arr1, 5); assert(compareArrays(RemoveNthFromEnd(head1, 2), createLinkedListFromArray((int[]) {1,2,3,5}, 4));",
        "int arr2[] = {1}; struct ListNode* head2 = buildLinkedList(arr2, 1); assert(compareArrays(RemoveNthFromEnd(head2, 1), createLinkedListFromArray((int[]) {}, 0));",
        "int arr3[] = {1,2}; struct ListNode* head3 = buildLinkedList(arr3, 2); assert(compareArrays(RemoveNthFromEnd(head3, 1), createLinkedListFromArray((int[]) {1}, 1));"
      ],
      "compareHelper": "bool compareArrays(struct ListNode* head1, struct ListNode* head2) { while (head1 && head2) { if (head1->val != head2->val) return false; head1 = head1->next; head2 = head2->next; } return !head1 && !head2; }",
      "helpers": "struct ListNode { int val; struct ListNode* next; }; \nstruct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func RemoveNthFromEnd(head *ListNode, n int) *ListNode {}",
      "testCalls": [
        "if result := RemoveNthFromEnd(buildLinkedList([]int{1, 2, 3, 4, 5}), 2); !compareLinkedList(result, buildLinkedList([]int{1, 2, 3, 5})) { t.Errorf(\"Test 1 failed\") }",
        "if result := RemoveNthFromEnd(buildLinkedList([]int{1}), 1); !compareLinkedList(result, buildLinkedList([]int{})) { t.Errorf(\"Test 2 failed\") }",
        "if result := RemoveNthFromEnd(buildLinkedList([]int{1, 2}), 1); !compareLinkedList(result, buildLinkedList([]int{1})) { t.Errorf(\"Test 3 failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]} curr = curr.Next } return head }\nfunc linkedListToArray(head *ListNode) []int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveNthNodeFromEndOfList(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = build_linked_list(vec![1, 2, 3, 5]); assert_eq!(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })), RemoveNthNodeFromEndOfList(head1, 2));",
        "let head2 = build_linked_list(vec![1]); assert_eq!(None, RemoveNthNodeFromEndOfList(head2, 1));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashSet;\nuse std::iter::FromIterator;\nuse std::mem;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveNthNodeFromEndOfList(head, n)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nresult = RemoveNthNodeFromEndOfList(head, 2)\nraise 'Test Case 1 Failed' unless linkedListToArray(result) == [1,2,3,5]",
        "head = buildLinkedList([1])\nresult = RemoveNthNodeFromEndOfList(head, 1)\nraise 'Test Case 2 Failed' unless linkedListToArray(result) == []",
        "head = buildLinkedList([1,2])\nresult = RemoveNthNodeFromEndOfList(head, 1)\nraise 'Test Case 3 Failed' unless linkedListToArray(result) == [1]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\n\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "n": "2"
        },
        "expected": "[1,2,3,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1]",
          "n": "1"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "head": "[1,2]",
          "n": "1"
        },
        "expected": "[1]"
      }
    ]
  },
  "reverse-bits": {
    "title": "Reverse Bits",
    "content": "Reverse bits of a given 32 bits signed integer.\n\nExample 1:\n\nInput: n = 43261596\nOutput: 964176192\nExplanation:\n\n\n\nInteger\nBinary\n\n\n43261596\n00000010100101000001111010011100\n\n\n964176192\n00111001011110000010100101000000\n\n\n\n\nExample 2:\n\nInput: n = 2147483644\nOutput: 1073741822\nExplanation:\n\n\n\nInteger\nBinary\n\n\n2147483644\n01111111111111111111111111111100\n\n\n1073741822\n00111111111111111111111111111110\n\n\n\n\n\nConstraints:\n\n0 <= n <= 231 - 2\nn is even.\n\n\nFollow up: If this function is called many times, how would you optimize it?\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "ReverseBits(n)",
      "testCalls": [
        "if (ReverseBits(43261596) !== 964176192) { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseBits(2147483644) !== 1073741822) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ReverseBits(n: number): number {}",
      "testCalls": [
        "if (ReverseBits(43261596) !== 964176192) { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseBits(2147483644) !== 1073741822) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int ReverseBits(int n);",
      "testCalls": [
        "if(ReverseBits(43261596) != 964176192) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(ReverseBits(2147483644) != 1073741822) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ReverseBits(n: int) -> int",
      "testCalls": [
        "assert ReverseBits(43261596) == 964176192",
        "assert ReverseBits(2147483644) == 1073741822"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int ReverseBits(int n) {}",
      "testCalls": [
        "if (ReverseBits(43261596) != 964176192) throw new AssertionError();",
        "if (ReverseBits(2147483644) != 1073741822) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int ReverseBits(int n)",
      "testCalls": [
        "if (ReverseBits(43261596) != 964176192) { printf(\"Test Case 1 Failed\"); }",
        "if (ReverseBits(2147483644) != 1073741822) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ReverseBits(n uint32) uint32 {}",
      "testCalls": [
        "if ReverseBits(43261596) != 964176192 { t.Error(\"Test Case 1 Failed\") }",
        "if ReverseBits(2147483644) != 1073741822 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ReverseBits(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(ReverseBits(43261596), 964176192);",
        "assert_eq!(ReverseBits(2147483644), 1073741822);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseBits(n)",
      "testCalls": [
        "test_case_1 = ReverseBits(43261596); raise 'Test Case 1 Failed' unless test_case_1 == 964176192",
        "test_case_2 = ReverseBits(2147483644); raise 'Test Case 2 Failed' unless test_case_2 == 1073741822"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "43261596"
        },
        "expected": "964176192"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "2147483644"
        },
        "expected": "1073741822"
      }
    ]
  },
  "reverse-linked-list-ii": {
    "title": "Reverse Linked List II",
    "content": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n\n\nFollow up: Could you do it in one pass?",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseLinkedListII(head, left, right) {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); const test1 = ReverseLinkedListII(head1, 2, 4); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,4,3,2,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([5]); const test2 = ReverseLinkedListII(head2, 1, 1); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([5])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function ReverseLinkedListII(head: ListNode | null, left: number, right: number): ListNode | null {}",
      "testCalls": [
        "const test1 = ReverseLinkedListII(createLinkedList([1,2,3,4,5]), 2, 4); compareLinkedList(test1, createLinkedList([1,4,3,2,5]));",
        "const test2 = ReverseLinkedListII(createLinkedList([5]), 1, 1); compareLinkedList(test2, createLinkedList([5]));"
      ],
      "compareHelper": "function compareLinkedList(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); }}",
      "helpers": "class ListNode { val: number; next: ListNode | null; constructor(val = 0, next: ListNode | null = null) { this.val = val; this.next = next; } }\nfunction createLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1: ListNode | null, head2: ListNode | null): boolean { while (head1 && head2) { if (head1.val !== head2.val) return false; head1 = head1.next; head2 = head2.next; } return !head1 && !head2; }",
      "typeDefs": "class ListNode { val: number; next: ListNode | null; constructor(val = 0, next: ListNode | null = null) { this.val = val; this.next = next; } }",
      "builders": "function createLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1: ListNode | null, head2: ListNode | null): boolean { while (head1 && head2) { if (head1.val !== head2.val) return false; head1 = head1.next; head2 = head2.next; } return !head1 && !head2; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* ReverseLinkedListII(ListNode* head, int left, int right);",
      "testCalls": [
        "assert(linkedListToString(ReverseLinkedListII(buildLinkedList({1,2,3,4,5}), 2, 4)) == \"1,4,3,2,5\";",
        "assert(linkedListToString(ReverseLinkedListII(buildLinkedList({5}), 1, 1)) == \"5\";"
      ],
      "compareHelper": "std::string ListNodeToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + ','; head = head->next; } if (!res.empty()) res.pop_back(); return '[' + res + ']'; }",
      "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::string linkedListToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + \",\"; head = head->next; } return res; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::string linkedListToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + \",\"; head = head->next; } return res; }"
    },
    "python": {
      "functionDeclaration": "def ReverseLinkedListII(head, left, right):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(ReverseLinkedListII(head, 2, 4)) == [1,4,3,2,5]",
        "head = buildLinkedList([5])\nassert linkedListToArray(ReverseLinkedListII(head, 1, 1)) == [5]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None): ...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode reverseBetween(ListNode head, int left, int right) { }",
      "testCalls": [
        "ListNode test1 = reverseBetween(buildLinkedList(new int[]{1,2,3,4,5}), 2, 4); if (!Arrays.equals(linkedListToArray(test1), new int[]{1,4,3,2,5})) throw new AssertionError();",
        "ListNode test2 = reverseBetween(buildLinkedList(new int[]{5}), 1, 1); if (!Arrays.equals(linkedListToArray(test2), new int[]{5})) throw new AssertionError();"
      ],
      "compareHelper": "private static boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* ReverseLinkedListII(ListNode* head, int left, int right);",
      "testCalls": [
        "ListNode* test1 = ReverseLinkedListII(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2, 4); assert(compareLinkedListToArray(test1, (int[]) {1,4,3,2,5}, 5));",
        "ListNode* test2 = ReverseLinkedListII(createLinkedListFromArray((int[]) {5}, 1), 1, 1); assert(compareLinkedListToArray(test2, (int[]) {5}, 1));"
      ],
      "compareHelper": "int compareLinkedListToArray(ListNode* head, int* arr, int size);",
      "helpers": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;\nListNode* createLinkedListFromArray(int* arr, int size);\nint* linkedListToArray(ListNode* head);",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* createLinkedListFromArray(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
    },
    "go": {
      "functionDeclaration": "func ReverseLinkedListII(head *ListNode, left int, right int) *ListNode {}",
      "testCalls": [
        "if result := ReverseLinkedListII(buildLinkedList([]int{1,2,3,4,5}), 2, 4); !compareLinkedList(result, buildLinkedList([]int{1,4,3,2,5})) { t.Errorf(\"Test 1 Failed\") }",
        "if result := ReverseLinkedListII(buildLinkedList([]int{5}), 1, 1); !compareLinkedList(result, buildLinkedList([]int{5})) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool {}",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn ReverseLinkedListII(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {}",
      "testCalls": [
        "let head = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(ReverseLinkedListII(head, 2, 4)), vec![1,4,3,2,5]);",
        "let head = buildLinkedList(vec![5]); assert_eq!(linkedListToArray(ReverseLinkedListII(head, 1, 1)), vec![5]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::LinkedList;\nuse std::iter::FromIterator;\n\n#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def ReverseLinkedListII(head, left, right)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5]); test_case_1 = ReverseLinkedListII(head, 2, 4); raise 'Test Case 1 Failed' unless linkedListToArray(test_case_1) == [1,4,3,2,5]",
        "head = buildLinkedList([5]); test_case_2 = ReverseLinkedListII(head, 1, 1); raise 'Test Case 2 Failed' unless linkedListToArray(test_case_2) == [5]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "left": "2",
          "right": "4"
        },
        "expected": "[1,4,3,2,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[5]",
          "left": "1",
          "right": "1"
        },
        "expected": "[5]"
      }
    ]
  },
  "reverse-nodes-in-k-group": {
    "title": "Reverse Nodes in k-Group",
    "content": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list nodes, only nodes themselves may be changed.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\n\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\nFollow-up: Can you solve the problem in O(1) extra memory space?\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseNodesInKGroup(head, k) {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); const test1 = ReverseNodesInKGroup(head1, 2); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([2,1,4,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1,2,3,4,5]); const test2 = ReverseNodesInKGroup(head2, 3); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([3,2,1,4,5])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function ReverseNodesInKGroup(head: ListNode | null, k: number): ListNode | null {}",
      "testCalls": [
        "if (JSON.stringify(ReverseNodesInKGroup(createLinkedList([1,2,3,4,5]), 2)?.toArray()) !== JSON.stringify([2,1,4,3,5])) throw new Error('Test Case 1 Failed');",
        "if (JSON.stringify(ReverseNodesInKGroup(createLinkedList([1,2,3,4,5]), 3)?.toArray()) !== JSON.stringify([3,2,1,4,5])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "class ListNode { val: number; next: ListNode | null; constructor(val = 0, next: ListNode | null = null) { this.val = val; this.next = next; } }\nfunction createLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1: ListNode | null, head2: ListNode | null): boolean { while (head1 && head2) { if (head1.val !== head2.val) return false; head1 = head1.next; head2 = head2.next; } return !head1 && !head2; }",
      "typeDefs": "class ListNode { val: number; next: ListNode | null; constructor(val = 0, next: ListNode | null = null) { this.val = val; this.next = next; } }",
      "builders": "function createLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1: ListNode | null, head2: ListNode | null): boolean { while (head1 && head2) { if (head1.val !== head2.val) return false; head1 = head1.next; head2 = head2.next; } return !head1 && !head2; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* ReverseNodesInKGroup(ListNode* head, int k)",
      "testCalls": [
        "assert(linkedListToString(ReverseNodesInKGroup(buildLinkedList({1,2,3,4,5}), 2)) == \"2,1,4,3,5\";",
        "assert(linkedListToString(ReverseNodesInKGroup(buildLinkedList({1,2,3,4,5}), 3)) == \"3,2,1,4,5\";"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::string linkedListToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + \",\"; head = head->next; } return res; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::string linkedListToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + \",\"; head = head->next; } return res; }"
    },
    "python": {
      "functionDeclaration": "def ReverseNodesInKGroup(head, k):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(ReverseNodesInKGroup(head, 2)) == [2,1,4,3,5]",
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(ReverseNodesInKGroup(head, 3)) == [3,2,1,4,5]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode reverseKGroup(ListNode head, int k) { }",
      "testCalls": [
        "ListNode test1Head = new ListNode(1); test1Head.next = new ListNode(2); test1Head.next.next = new ListNode(3); test1Head.next.next.next = new ListNode(4); test1Head.next.next.next.next = new ListNode(5); ListNode expected1 = new ListNode(2); expected1.next = new ListNode(1); expected1.next.next = new ListNode(4); expected1.next.next.next = new ListNode(3); expected1.next.next.next.next = new ListNode(5); ListNode result1 = reverseKGroup(test1Head, 2); if (!compareLinkedLists(result1, expected1)) { throw new AssertionError(); }",
        "ListNode test2Head = new ListNode(1); test2Head.next = new ListNode(2); test2Head.next.next = new ListNode(3); test2Head.next.next.next = new ListNode(4); test2Head.next.next.next.next = new ListNode(5); ListNode expected2 = new ListNode(3); expected2.next = new ListNode(2); expected2.next.next = new ListNode(1); expected2.next.next.next = new ListNode(4); expected2.next.next.next.next = new ListNode(5); ListNode result2 = reverseKGroup(test2Head, 3); if (!compareLinkedLists(result2, expected2)) { throw new AssertionError(); }"
      ],
      "compareHelper": "public static boolean compareLinkedLists(ListNode l1, ListNode l2) { while (l1 != null && l2 != null) { if (l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; } return l1 == null && l2 == null; }",
      "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* ReverseNodesInKGroup(ListNode* head, int k)",
      "testCalls": [
        "testReverseNodesInKGroup(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2, createLinkedListFromArray((int[]) {2,1,4,3,5}, 5))",
        "testReverseNodesInKGroup(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 3, createLinkedListFromArray((int[]) {3,2,1,4,5}, 5))"
      ],
      "compareHelper": "int compareLinkedListToArray(ListNode* head, int* arr, int size);",
      "helpers": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;\nListNode* createLinkedListFromArray(int* arr, int size);\nint* linkedListToArray(ListNode* head);",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* createLinkedListFromArray(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
    },
    "go": {
      "functionDeclaration": "func ReverseNodesInKGroup(head *ListNode, k int) *ListNode",
      "testCalls": [
        "if !compareLinkedList(ReverseNodesInKGroup(buildLinkedList([]int{1,2,3,4,5}), 2), buildLinkedList([]int{2,1,4,3,5})) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareLinkedList(ReverseNodesInKGroup(buildLinkedList([]int{1,2,3,4,5}), 3), buildLinkedList([]int{3,2,1,4,5})) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool {}",
      "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}",
      "typeDefs": "type ListNode struct { Val int Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn ReverseNodesInKGroup(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(ReverseNodesInKGroup(head, 2)), vec![2,1,4,3,5]);",
        "let head = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(ReverseNodesInKGroup(head, 3)), vec![3,2,1,4,5]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::LinkedList;\nuse std::iter::FromIterator;\n\n#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def ReverseNodesInKGroup(head, k)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5]); test_case_1 = ReverseNodesInKGroup(head, 2); raise 'Test Case 1 Failed' unless linkedListToArray(test_case_1) == [2,1,4,3,5]",
        "head = buildLinkedList([1,2,3,4,5]); test_case_2 = ReverseNodesInKGroup(head, 3); raise 'Test Case 2 Failed' unless linkedListToArray(test_case_2) == [3,2,1,4,5]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "k": "2"
        },
        "expected": "[2,1,4,3,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "k": "3"
        },
        "expected": "[3,2,1,4,5]"
      }
    ]
  },
  "reverse-words-in-a-string": {
    "title": "Reverse Words in a String",
    "content": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\nExample 1:\n\nInput: s = &quot;the sky is blue&quot;\nOutput: &quot;blue is sky the&quot;\n\nExample 2:\n\nInput: s = &quot;  hello world  &quot;\nOutput: &quot;world hello&quot;\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nExample 3:\n\nInput: s = &quot;a good   example&quot;\nOutput: &quot;example good a&quot;\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\nConstraints:\n\n1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces &#39; &#39;.\nThere is at least one word in s.\n\n\nFollow-up:If the string data type is mutable in your language, canyou solve itin-placewithO(1)extra space?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Two Pointers",
      "String"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function ReverseWordsInAString(s) {}",
      "testCalls": [
        "if (ReverseWordsInAString('the sky is blue') !== 'blue is sky the') { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseWordsInAString('  hello world  ') !== 'world hello') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ReverseWordsInAString(s: string): string {}",
      "testCalls": [
        "if (ReverseWordsInAString('the sky is blue') !== 'blue is sky the') { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseWordsInAString('hello world') !== 'world hello') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string ReverseWordsInAString(string s)",
      "testCalls": [
        "assert(ReverseWordsInAString(\"the sky is blue\") == \"blue is sky the\");",
        "assert(ReverseWordsInAString(\"  hello world  \") == \"world hello\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ReverseWordsInAString(s: str) -> str:",
      "testCalls": [
        "assert ReverseWordsInAString(\"the sky is blue\") == \"blue is sky the\"",
        "assert ReverseWordsInAString(\"  hello world  \") == \"world hello\"",
        "assert ReverseWordsInAString(\"a good   example\") == \"example good a\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String ReverseWordsInAString(String s) {}",
      "testCalls": [
        "if (!ReverseWordsInAString(\"the sky is blue\").equals(\"blue is sky the\")) { throw new AssertionError(); }",
        "if (!ReverseWordsInAString(\"hello world\").equals(\"world hello\")) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* ReverseWordsInAString(char* s)",
      "testCalls": [
        "ReverseWordsInAString(\"the sky is blue\")",
        "ReverseWordsInAString(\"  hello world  \")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ReverseWordsInAString(s string) string {}",
      "testCalls": [
        "if ReverseWordsInAString(\"the sky is blue\") != \"blue is sky the\" {panic(\"Test 1 failed\")}",
        "if ReverseWordsInAString(\"  hello world  \") != \"world hello\" {panic(\"Test 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ReverseWordsInAString(s: String) -> String {}",
      "testCalls": [
        "assert_eq!(ReverseWordsInAString(String::from(\"theskyisblue\")), \"blueisskythe\");",
        "assert_eq!(ReverseWordsInAString(String::from(\"helloworld\")), \"worldhello\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseWordsInAString(s)",
      "testCalls": [
        "puts ReverseWordsInAString(\"theskyisblue\") == \"blueisskythe\" || raise(\"Test Case 1 Failed\")",
        "puts ReverseWordsInAString(\"helloworld\") == \"worldhello\" || raise(\"Test Case 2 Failed\")"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;theskyisblue&quot;"
        },
        "expected": "&quot;blueisskythe&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;helloworld&quot;"
        },
        "expected": "&quot;worldhello&quot;"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;agoodexample&quot;"
        },
        "expected": "&quot;examplegooda&quot;"
      }
    ]
  },
  "roman-to-integer": {
    "title": "Roman to Integer",
    "content": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,2 is written as IIin Roman numeral, just two ones added together. 12 is written asXII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\nExample 1:\n\nInput: s = &quot;III&quot;\nOutput: 3\nExplanation: III = 3.\n\nExample 2:\n\nInput: s = &quot;LVIII&quot;\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 3:\n\nInput: s = &quot;MCMXCIV&quot;\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n\n1 <= s.length <= 15\ns contains onlythe characters (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;).\nIt is guaranteedthat s is a valid roman numeral in the range [1, 3999].\n\n",
    "difficulty": "Easy",
    "hints": [
      "Problem is simpler to solve by working the string from back to front and using a map."
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RomanToInteger(s) {}",
      "testCalls": [
        "if (RomanToInteger(\"III\") !== 3) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") !== 58) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (RomanToInteger(\"MCMXCIV\") !== 1994) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function RomanToInteger(s: string): number {}",
      "testCalls": [
        "if (RomanToInteger(\"III\") !== 3) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") !== 58) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (RomanToInteger(\"MCMXCIV\") !== 1994) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int RomanToInteger(string s)",
      "testCalls": [
        "if (RomanToInteger(\"III\") != 3) { throw \"Test 1 failed\"; }",
        "if (RomanToInteger(\"LVIII\") != 58) { throw \"Test 2 failed\"; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def RomanToInteger(s: str) -> int:",
      "testCalls": [
        "assert RomanToInteger(\"III\") == 3",
        "assert RomanToInteger(\"LVIII\") == 58"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int RomanToInteger(String s) { }",
      "testCalls": [
        "if (RomanToInteger(\"III\") != 3) { throw new AssertionError(); }",
        "if (RomanToInteger(\"LVIII\") != 58) { throw new AssertionError(); }",
        "if (RomanToInteger(\"MCMXCIV\") != 1994) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int RomanToInteger(char *s)",
      "testCalls": [
        "if (RomanToInteger(\"III\") != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") != 58) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func RomanToInteger(s string) int {\n\t// Function body will be implemented here\n}",
      "testCalls": [
        "if RomanToInteger(\"III\") != 3 {\n\tt.Errorf(\"Test case 1 failed\")\n}",
        "if RomanToInteger(\"LVIII\") != 58 {\n\tt.Errorf(\"Test case 2 failed\")\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn RomanToInteger(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(RomanToInteger(String::from(\"III\")), 3);",
        "assert_eq!(RomanToInteger(String::from(\"LVIII\")), 58);",
        "assert_eq!(RomanToInteger(String::from(\"MCMXCIV\")), 1994);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def RomanToInteger(s)",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless RomanToInteger('III') == 3",
        "raise 'Test Case 2 Failed' unless RomanToInteger('LVIII') == 58",
        "raise 'Test Case 3 Failed' unless RomanToInteger('MCMXCIV') == 1994"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;III&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;LVIII&quot;"
        },
        "expected": "58"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;MCMXCIV&quot;"
        },
        "expected": "1994"
      }
    ]
  },
  "rotate-array": {
    "title": "Rotate Array",
    "content": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n\n\nFollow up:\n\nTry to come up with as many solutions as you can. There are at least three different ways to solve this problem.\nCould you do it in-place with O(1) extra space?\n\n",
    "difficulty": "Medium",
    "hints": [
      "The easiest solution would use additional memory and that is perfectly fine.",
      "The actual trick comes when trying to solve this problem without using any additional memory. This means you need to use the original array somehow to move the elements around. Now, we can place each element in its original location and shift all the elements around it to adjust as that would be too costly and most likely will time out on larger input arrays.",
      "One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example.",
      "The other line of thought is a tad bit complicated but essentially it builds on the idea of placing each element in its original position while keeping track of the element originally in that position. Basically, at every step, we place an element in its rightful position and keep track of the element already there or the one being overwritten in an additional variable. We can't do this in one linear pass and the idea here is based on <b>cyclic-dependencies</b> between elements."
    ],
    "topicTags": [
      "Array",
      "Math",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RotateArray(nums, k) {}",
      "testCalls": [
        "let test1 = RotateArray([1,2,3,4,5,6,7], 3); if(JSON.stringify(test1) !== JSON.stringify([5,6,7,1,2,3,4])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RotateArray([-1,-100,3,99], 2); if(JSON.stringify(test2) !== JSON.stringify([3,99,-1,-100])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateArray(nums: number[], k: number): void {}",
      "testCalls": [
        "RotateArray([1,2,3,4,5,6,7], 3); // should output [5,6,7,1,2,3,4]",
        "RotateArray([-1,-100,3,99], 2); // should output [3,99,-1,-100]"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "void RotateArray(vector<int>& nums, int k);",
      "testCalls": [
        "RotateArray({1,2,3,4,5,6,7}, 3); // Expected output: [5,6,7,1,2,3,4]",
        "RotateArray({-1,-100,3,99}, 2); // Expected output: [3,99,-1,-100]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def RotateArray(nums: List[int], k: int) -> None:",
      "testCalls": [
        "RotateArray([1,2,3,4,5,6,7], 3)  # Expected: [5,6,7,1,2,3,4]",
        "RotateArray([-1,-100,3,99], 2)  # Expected: [3,99,-1,-100]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError(f'Arrays do not match. Expected: {arr2}, Got: {arr1}')"
    },
    "java": {
      "functionDeclaration": "public void RotateArray(int[] nums, int k) {}",
      "testCalls": [
        "RotateArray(new int[]{1,2,3,4,5,6,7}, 3); // should return [5,6,7,1,2,3,4]",
        "RotateArray(new int[]{-1,-100,3,99}, 2); // should return [3,99,-1,-100]"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "void RotateArray(int* nums, int numsSize, int k);",
      "testCalls": [
        "RotateArray((int[]){1,2,3,4,5,6,7}, 7, 3); // compareArrays(nums, (int[]){5,6,7,1,2,3,4}, 7);",
        "RotateArray((int[]){-1,-100,3,99}, 4, 2); // compareArrays(nums, (int[]){3,99,-1,-100}, 4);"
      ],
      "compareHelper": "void compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) { printf(\"Test Failed\"); exit(1); } } }"
    },
    "go": {
      "functionDeclaration": "func RotateArray(nums []int, k int) []int {}",
      "testCalls": [
        "if !compareArrays(RotateArray([]int{1,2,3,4,5,6,7}, 3), []int{5,6,7,1,2,3,4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(RotateArray([]int{-1,-100,3,99}, 2), []int{3,99,-1,-100}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn RotateArray(nums: &mut Vec<i32>, k: i32) {}",
      "testCalls": [
        "let mut test_input1 = vec![1,2,3,4,5,6,7];\nRotateArray(&mut test_input1, 3);\nassert_eq!(test_input1, vec![5,6,7,1,2,3,4]);",
        "let mut test_input2 = vec![-1,-100,3,99];\nRotateArray(&mut test_input2, 2);\nassert_eq!(test_input2, vec![3,99,-1,-100]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) {\n    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert_eq!(a[i], b[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def RotateArray(nums, k)\nend",
      "testCalls": [
        "result = RotateArray([1,2,3,4,5,6,7], 3)\nraise 'Test Case 1 Failed' unless result == [5,6,7,1,2,3,4]",
        "result = RotateArray([-1,-100,3,99], 2)\nraise 'Test Case 2 Failed' unless result == [3,99,-1,-100]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,4,5,6,7]",
          "k": "3"
        },
        "expected": "[5,6,7,1,2,3,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[-1,-100,3,99]",
          "k": "2"
        },
        "expected": "[3,99,-1,-100]"
      }
    ]
  },
  "rotate-image": {
    "title": "Rotate Image",
    "content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math",
      "Matrix"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RotateImage(matrix) {}",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]])",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateImage(matrix: number[][]): void",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]]); // Expected: [[7,4,1],[8,5,2],[9,6,3]]",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]); // Expected: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "function arraysEqual(a: number[][], b: number[][]): void {\n  if (JSON.stringify(a) !== JSON.stringify(b)) {\n    throw new Error('Test Failed');\n  }\n}"
    },
    "cpp": {
      "functionDeclaration": "void RotateImage(vector<vector<int>>& matrix)",
      "testCalls": [
        "RotateImage(matrix); assert(matrix == vector<vector<int>>{{7,4,1},{8,5,2},{9,6,3}});",
        "RotateImage(matrix); assert(matrix == vector<vector<int>>{{15,13,2,5},{14,3,4,1},{12,6,8,9},{16,7,10,11}});"
      ],
      "compareHelper": "bool compareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def RotateImage(matrix: List[List[int]]) -> None:",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]])",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public void rotateImage(int[][] matrix)",
      "testCalls": [
        "rotateImage(new int[][]{{1,2,3},{4,5,6},{7,8,9}}); // compareArrays(matrix, new int[][]{{7,4,1},{8,5,2},{9,6,3}})",
        "rotateImage(new int[][]{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}); // compareArrays(matrix, new int[][]{{15,13,2,5},{14,3,4,1},{12,6,8,9},{16,7,10,11}})"
      ],
      "compareHelper": "private void compareArrays(int[][] arr1, int[][] arr2) {\n    if (!Arrays.deepEquals(arr1, arr2)) {\n        throw new AssertionError(\"Arrays not equal: \" + Arrays.deepToString(arr1) + \" != \" + Arrays.deepToString(arr2));\n    }\n}"
    },
    "c": {
      "functionDeclaration": "void RotateImage(int** matrix, int matrixSize, int* matrixColSize)",
      "testCalls": [
        "RotateImage((int*[]){{1,2,3},{4,5,6},{7,8,9}}, 3, (int[]){3}); // Expected output: [[7,4,1],[8,5,2],[9,6,3]]",
        "RotateImage((int*[]){{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}, 4, (int[]){4}); // Expected output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RotateImage(matrix [][]int) { }",
      "testCalls": [
        "RotateImage([][]int{{1,2,3},{4,5,6},{7,8,9}})",
        "RotateImage([][]int{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}})"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) { }"
    },
    "rust": {
      "functionDeclaration": "fn RotateImage(matrix: &mut Vec<Vec<i32>>) {}",
      "testCalls": [
        "let mut matrix1 = vec![vec![1,2,3],vec![4,5,6],vec![7,8,9]]; RotateImage(&mut matrix1); assert_eq!(matrix1, vec![vec![7,4,1],vec![8,5,2],vec![9,6,3]]);",
        "let mut matrix2 = vec![vec![5,1,9,11],vec![2,4,8,10],vec![13,3,6,7],vec![15,14,12,16]]; RotateImage(&mut matrix2); assert_eq!(matrix2, vec![vec![15,13,2,5],vec![14,3,4,1],vec![12,6,8,9],vec![16,7,10,11]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_equal(actual: Vec<Vec<i32>>, expected: Vec<Vec<i32>>) { for (a, e) in actual.iter().zip(expected.iter()) { assert_eq!(a, e); }}"
    },
    "ruby": {
      "functionDeclaration": "def RotateImage(matrix)\nend",
      "testCalls": [
        "test_case_1 = [[1,2,3],[4,5,6],[7,8,9]]\nRotateImage(test_case_1)\nraise 'Test Case 1 Failed' unless test_case_1 == [[7,4,1],[8,5,2],[9,6,3]]",
        "test_case_2 = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nRotateImage(test_case_2)\nraise 'Test Case 2 Failed' unless test_case_2 == [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "matrix": "[[1,2,3],[4,5,6],[7,8,9]]"
        },
        "expected": "[[7,4,1],[8,5,2],[9,6,3]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "matrix": "[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]"
        },
        "expected": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      }
    ]
  },
  "rotate-list": {
    "title": "Rotate List",
    "content": "Given the head of a linkedlist, rotate the list to the right by k places.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\n\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RotateList(head, k) {}",
      "testCalls": [
        "let test1 = RotateList(buildLinkedList([1,2,3,4,5]), 2); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([4,5,1,2,3])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RotateList(buildLinkedList([0,1,2]), 4); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([2,0,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function RotateList(head: number[], k: number): number[] {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); const test1 = RotateList(head1, 2); if (JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([4,5,1,2,3])) throw new Error('Test Case 1 Failed');",
        "let head2 = buildLinkedList([0,1,2]); const test2 = RotateList(head2, 4); if (JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([2,0,1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "void RotateList(ListNode* head, int k);",
      "testCalls": [
        "RotateList(createLinkedList({1,2,3,4,5}), 2); // Expected: [4,5,1,2,3]",
        "RotateList(createLinkedList({0,1,2}), 4); // Expected: [2,0,1]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "helpers": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(nullptr) {} }; \nListNode* createLinkedList(std::vector<int> values) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : values) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(nullptr) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : values) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }"
    },
    "python": {
      "functionDeclaration": "def RotateList(head, k):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(RotateList(head, 2)) == [4,5,1,2,3]",
        "head = buildLinkedList([0,1,2])\nassert linkedListToArray(RotateList(head, 4)) == [2,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 == arr2:\n        return True\n    else:\n        raise AssertionError(f'Arrays do not match. Expected: {arr2}, Got: {arr1}')",
      "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode rotateRight(ListNode head, int k) { }",
      "testCalls": [
        "ListNode test1 = rotateRight(createLinkedList(new int[]{1,2,3,4,5}), 2); compareLinkedList(test1, new int[]{4,5,1,2,3});",
        "ListNode test2 = rotateRight(createLinkedList(new int[]{0,1,2}), 4); compareLinkedList(test2, new int[]{2,0,1});"
      ],
      "compareHelper": "public void compareLinkedList(ListNode l1, int[] arr) { int[] l1Arr = linkedListToArray(l1); if (!Arrays.equals(l1Arr, arr)) throw new AssertionError(); }",
      "helpers": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\npublic ListNode createLinkedList(int[] arr) { if (arr == null || arr.length == 0) return null; ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode createLinkedList(int[] arr) { if (arr == null || arr.length == 0) return null; ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "void RotateList(struct ListNode* head, int k);",
      "testCalls": [
        "RotateList(createListFromArray((int[]) {1,2,3,4,5}, 5), 2); // Expected output: [4,5,1,2,3]",
        "RotateList(createListFromArray((int[]) {0,1,2}, 3), 4); // Expected output: [2,0,1]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return 0; } return 1; }",
      "helpers": "struct ListNode { int val; struct ListNode* next; }; \nstruct ListNode* createListFromArray(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* listToArray(struct ListNode* head, int* size) { struct ListNode* curr = head; int count = 0; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* createListFromArray(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* listToArray(struct ListNode* head, int* size) { struct ListNode* curr = head; int count = 0; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func RotateList(head *ListNode, k int) *ListNode {}",
      "testCalls": [
        "if result := RotateList(buildLinkedList([]int{1, 2, 3, 4, 5}), 2); !compareLinkedList(result, buildLinkedList([]int{4, 5, 1, 2, 3})) { t.Errorf(\"Test 1 failed\") }",
        "if result := RotateList(buildLinkedList([]int{0, 1, 2}), 4); !compareLinkedList(result, buildLinkedList([]int{2, 0, 1})) { t.Errorf(\"Test 2 failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }",
      "helpers": "type ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc buildLinkedList(arr []int) *ListNode {\n    if len(arr) == 0 {\n        return nil\n    }\n    head := &ListNode{Val: arr[0]}\n    curr := head\n    for i := 1; i < len(arr); i++ {\n        curr.Next = &ListNode{Val: arr[i]}\n        curr = curr.Next\n    }\n    return head\n}\n\nfunc linkedListToArray(head *ListNode) []int {\n    arr := make([]int, 0)\n    for head != nil {\n        arr = append(arr, head.Val)\n        head = head.Next\n    }\n    return arr\n}",
      "typeDefs": "type ListNode struct {\n    Val  int\n    Next *ListNode\n}",
      "builders": "func buildLinkedList(arr []int) *ListNode {\n    if len(arr) == 0 {\n        return nil\n    }\n    head := &ListNode{Val: arr[0]}\n    curr := head\n    for i := 1; i < len(arr); i++ {\n        curr.Next = &ListNode{Val: arr[i]}\n        curr = curr.Next\n    }\n    return head\n}\n\nfunc linkedListToArray(head *ListNode) []int {\n    arr := make([]int, 0)\n    for head != nil {\n        arr = append(arr, head.Val)\n        head = head.Next\n    }\n    return arr\n}"
    },
    "rust": {
      "functionDeclaration": "fn RotateList(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(RotateList(head1, 2)), vec![4,5,1,2,3]);",
        "let head2 = buildLinkedList(vec![0,1,2]); assert_eq!(linkedListToArray(RotateList(head2, 4)), vec![2,0,1]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::LinkedList; use std::iter::FromIterator; #[derive(Debug, PartialEq, Eq)] pub struct ListNode { pub val: i32, pub next: Option<Box<ListNode>>, } impl ListNode { pub fn new(val: i32) -> Self { ListNode { val, next: None } } } fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> { let mut list = LinkedList::new(); for &val in arr.iter().rev() { list.push_front(ListNode::new(val)); } let mut head = None; for node in list.into_iter() { head = Some(Box::new(node)); } head } fn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> { let mut arr = Vec::new(); let mut curr = &head; while let Some(node) = curr { arr.push(node.val); curr = &node.next; } arr }",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)] pub struct ListNode { pub val: i32, pub next: Option<Box<ListNode>>, } impl ListNode { pub fn new(val: i32) -> Self { ListNode { val, next: None } } }",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> { let mut list = LinkedList::new(); for &val in arr.iter().rev() { list.push_front(ListNode::new(val)); } let mut head = None; for node in list.into_iter() { head = Some(Box::new(node)); } head } fn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> { let mut arr = Vec::new(); let mut curr = &head; while let Some(node) = curr { arr.push(node.val); curr = &node.next; } arr }"
    },
    "ruby": {
      "functionDeclaration": "def RotateList(head, k)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5]); result = RotateList(head, 2); raise 'Test Case 1 Failed' unless linkedListToArray(result) == [4,5,1,2,3]",
        "head = buildLinkedList([0,1,2]); result = RotateList(head, 4); raise 'Test Case 2 Failed' unless linkedListToArray(result) == [2,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend",
      "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "k": "2"
        },
        "expected": "[4,5,1,2,3]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[0,1,2]",
          "k": "4"
        },
        "expected": "[2,0,1]"
      }
    ]
  },
  "same-tree": {
    "title": "Same Tree",
    "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nExample 1:\n\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SameTree(p, q) {}",
      "testCalls": [
        "if (SameTree(buildTree([1,2,3]), buildTree([1,2,3])) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (SameTree(buildTree([1,2]), buildTree([1,null,2])) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {}",
      "testCalls": [
        "const test1 = isSameTree(buildTree([1,2,3]), buildTree([1,2,3])); if (test1 !== true) throw new Error('Test Case 1 Failed');",
        "const test2 = isSameTree(buildTree([1,2]), buildTree([1,null,2])); if (test2 !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToBinaryTree(arr: (number | null)[]): TreeNode | null {}",
      "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "bool IsSameTree(TreeNode* p, TreeNode* q)",
      "testCalls": [
        "if(IsSameTree(buildTree({1,2,3}), buildTree({1,2,3})) != true) throw std::runtime_error(\"Test 1 failed\");",
        "if(IsSameTree(buildTree({1,2}), buildTree({1,INT_MIN,2})) != false) throw std::runtime_error(\"Test 2 failed\");",
        "if(IsSameTree(buildTree({1,2,1}), buildTree({1,1,2})) != false) throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": "std::vector<int> BuildTree(const std::vector<int>& values) { TreeNode* root = new TreeNode(values[0]); std::vector<TreeNode*> nodes = {root}; for(int i = 1; i < values.size(); ++i) { if(values[i] != INT_MIN) { TreeNode* node = new TreeNode(values[i]); nodes.push_back(node); if(i % 2 == 1) nodes[(i-1)/2]->left = node; else nodes[(i-1)/2]->right = node; } } return root; }",
      "helpers": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; \nTreeNode* buildTree(std::vector<int> values) { if (values.empty() || values[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (values[i] != INT_MIN) { node->left = new TreeNode(values[i]); q.push(node->left); } ++i; if (i < values.size() && values[i] != INT_MIN) { node->right = new TreeNode(values[i]); q.push(node->right); } ++i; } return root; } \nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }",
      "typeDefs": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(std::vector<int> values) { if (values.empty() || values[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (values[i] != INT_MIN) { node->left = new TreeNode(values[i]); q.push(node->left); } ++i; if (i < values.size() && values[i] != INT_MIN) { node->right = new TreeNode(values[i]); q.push(node->right); } ++i; } return root; } \nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def SameTree(p, q):",
      "testCalls": [
        "root_p = buildTree([1,2,3])\nroot_q = buildTree([1,2,3])\nassert SameTree(root_p, root_q) == True, 'Test Case 1 Failed'",
        "root_p = buildTree([1,2])\nroot_q = buildTree([1,None,2])\nassert SameTree(root_p, root_q) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public boolean SameTree(TreeNode p, TreeNode q)",
      "testCalls": [
        "if (!SameTree(createTree(new Integer[]{1,2,3}), createTree(new Integer[]{1,2,3}))) throw new AssertionError();",
        "if (SameTree(createTree(new Integer[]{1,2}), createTree(new Integer[]{1,null,2}))) throw new AssertionError();",
        "if (SameTree(createTree(new Integer[]{1,2,1}), createTree(new Integer[]{1,1,2}))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    return p.val == q.val && compareTrees(p.left, q.left) && compareTrees(p.right, q.right);\n}",
      "helpers": "public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }\npublic TreeNode createTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode curr = queue.poll(); if (arr[i] != null) { curr.left = new TreeNode(arr[i]); queue.offer(curr.left); } i++; if (i < arr.length && arr[i] != null) { curr.right = new TreeNode(arr[i]); queue.offer(curr.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode curr = queue.poll(); if (curr != null) { list.add(curr.val); queue.offer(curr.left); queue.offer(curr.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(Integer::intValue).toArray(); }",
      "typeDefs": "public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode createTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode curr = queue.poll(); if (arr[i] != null) { curr.left = new TreeNode(arr[i]); queue.offer(curr.left); } i++; if (i < arr.length && arr[i] != null) { curr.right = new TreeNode(arr[i]); queue.offer(curr.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode curr = queue.poll(); if (curr != null) { list.add(curr.val); queue.offer(curr.left); queue.offer(curr.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "bool IsSameTree(struct TreeNode* p, struct TreeNode* q)",
      "testCalls": [
        "IsSameTree(buildTree((int[]) {1,2,3}, 3), buildTree((int[]) {1,2,3}, 3)); // Expected: true",
        "IsSameTree(buildTree((int[]) {1,2}, 2), buildTree((int[]) {1,-1,2}, 3)); // Expected: false",
        "IsSameTree(buildTree((int[]) {1,2,1}, 3), buildTree((int[]) {1,1,2}, 3)); // Expected: false"
      ],
      "compareHelper": "",
      "helpers": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; }; \nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root->val = arr[0]; root->left = NULL; root->right = NULL; struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (i < size && rear < size) { struct TreeNode* current = queue[front++]; if (arr[i] != -1) { struct TreeNode* leftNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); leftNode->val = arr[i]; leftNode->left = NULL; leftNode->right = NULL; current->left = leftNode; queue[rear++] = leftNode; } i++; if (i < size && arr[i] != -1) { struct TreeNode* rightNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); rightNode->val = arr[i]; rightNode->left = NULL; rightNode->right = NULL; current->right = rightNode; queue[rear++] = rightNode; } i++; } return root; } \nint* treeToArray(struct TreeNode* root, int* size) { if (!root) return NULL; int* arr = (int*)malloc(sizeof(int) * 100); struct TreeNode* queue[100]; int front = 0, rear = 0; queue[rear++] = root; int index = 0; while (front < rear) { struct TreeNode* current = queue[front++]; if (current) { arr[index++] = current->val; if (current->left) queue[rear++] = current->left; else queue[rear++] = NULL; if (current->right) queue[rear++] = current->right; else queue[rear++] = NULL; } else { arr[index++] = -1; } } *size = index; return arr; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* buildTree(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root->val = arr[0]; root->left = NULL; root->right = NULL; struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (i < size && rear < size) { struct TreeNode* current = queue[front++]; if (arr[i] != -1) { struct TreeNode* leftNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); leftNode->val = arr[i]; leftNode->left = NULL; leftNode->right = NULL; current->left = leftNode; queue[rear++] = leftNode; } i++; if (i < size && arr[i] != -1) { struct TreeNode* rightNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); rightNode->val = arr[i]; rightNode->left = NULL; rightNode->right = NULL; current->right = rightNode; queue[rear++] = rightNode; } i++; } return root; } \nint* treeToArray(struct TreeNode* root, int* size) { if (!root) return NULL; int* arr = (int*)malloc(sizeof(int) * 100); struct TreeNode* queue[100]; int front = 0, rear = 0; queue[rear++] = root; int index = 0; while (front < rear) { struct TreeNode* current = queue[front++]; if (current) { arr[index++] = current->val; if (current->left) queue[rear++] = current->left; else queue[rear++] = NULL; if (current->right) queue[rear++] = current->right; else queue[rear++] = NULL; } else { arr[index++] = -1; } } *size = index; return arr; }"
    },
    "go": {
      "functionDeclaration": "func IsSameTree(p *TreeNode, q *TreeNode) bool",
      "testCalls": [
        "if !IsSameTree(buildTree([]int{1, 2, 3}), buildTree([]int{1, 2, 3})) { t.Error(\"Test Case 1 Failed\") }",
        "if IsSameTree(buildTree([]int{1, 2}), buildTree([]int{1, 0, 2})) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func sliceToTreeNode(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n    root := &TreeNode{Val: nums[0]}\n    queue := []*TreeNode{root}\n    i := 1\n    for i < len(nums) {\n        node := queue[0]\n        queue = queue[1:]\n        if nums[i] != -1 {\n            node.Left = &TreeNode{Val: nums[i]}\n            queue = append(queue, node.Left)\n        }\n        i++\n        if i < len(nums) && nums[i] != -1 {\n            node.Right = &TreeNode{Val: nums[i]}\n            queue = append(queue, node.Right)\n        }\n        i++\n    }\n    return root\n}",
      "helpers": "type TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc buildTree(arr []int) *TreeNode {\n    if len(arr) == 0 || arr[0] == -1 {\n        return nil\n    }\n    root := &TreeNode{Val: arr[0]}\n    queue := []*TreeNode{root}\n    i := 1\n    for len(queue) > 0 && i < len(arr) {\n        node := queue[0]\n        queue = queue[1:]\n        if i < len(arr) && arr[i] != -1 {\n            node.Left = &TreeNode{Val: arr[i]}\n            queue = append(queue, node.Left)\n        }\n        i++\n        if i < len(arr) && arr[i] != -1 {\n            node.Right = &TreeNode{Val: arr[i]}\n            queue = append(queue, node.Right)\n        }\n        i++\n    }\n    return root\n}\n\nfunc treeToArray(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n    result := make([]int, 0)\n    queue := []*TreeNode{root}\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        if node != nil {\n            result = append(result, node.Val)\n            queue = append(queue, node.Left, node.Right)\n        } else {\n            result = append(result, -1)\n        }\n    }\n    for result[len(result)-1] == -1 {\n        result = result[:len(result)-1]\n    }\n    return result\n}",
      "typeDefs": "type TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}",
      "builders": "func buildTree(arr []int) *TreeNode {\n    if len(arr) == 0 || arr[0] == -1 {\n        return nil\n    }\n    root := &TreeNode{Val: arr[0]}\n    queue := []*TreeNode{root}\n    i := 1\n    for len(queue) > 0 && i < len(arr) {\n        node := queue[0]\n        queue = queue[1:]\n        if i < len(arr) && arr[i] != -1 {\n            node.Left = &TreeNode{Val: arr[i]}\n            queue = append(queue, node.Left)\n        }\n        i++\n        if i < len(arr) && arr[i] != -1 {\n            node.Right = &TreeNode{Val: arr[i]}\n            queue = append(queue, node.Right)\n        }\n        i++\n    }\n    return root\n}\n\nfunc treeToArray(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n    result := make([]int, 0)\n    queue := []*TreeNode{root}\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        if node != nil {\n            result = append(result, node.Val)\n            queue = append(queue, node.Left, node.Right)\n        } else {\n            result = append(result, -1)\n        }\n    }\n    for result[len(result)-1] == -1 {\n        result = result[:len(result)-1]\n    }\n    return result\n}"
    },
    "rust": {
      "functionDeclaration": "fn SameTree(p: Option<Box<TreeNode>>, q: Option<Box<TreeNode>>) -> bool {}",
      "testCalls": [
        "let root1 = buildTree(vec![Some(1), Some(2), Some(3)]); let root2 = buildTree(vec![Some(1), Some(2), Some(3)]); assert_eq!(SameTree(root1, root2), true);",
        "let root3 = buildTree(vec![Some(1), Some(2), None]); let root4 = buildTree(vec![Some(1), None, Some(2)]); assert_eq!(SameTree(root3, root4), false);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque; #[derive(Debug, PartialEq, Eq)] pub struct TreeNode { pub val: i32, pub left: Option<Box<TreeNode>>, pub right: Option<Box<TreeNode>>, } impl TreeNode { pub fn new(val: i32) -> Self { TreeNode { val, left: None, right: None } } } fn buildTree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> { if arr.is_empty() { return None; } let root = Some(Box::new(TreeNode::new(arr[0].unwrap())); let mut queue = VecDeque::new(); queue.push_back(root.as_ref().unwrap().clone()); let mut i = 1; while i < arr.len() && !queue.is_empty() { let node = queue.pop_front().unwrap(); if let Some(val) = arr[i] { node.borrow_mut().left = Some(Box::new(TreeNode::new(val))); queue.push_back(node.borrow().left.as_ref().unwrap().clone()); } i += 1; if i < arr.len() && arr[i].is_some() { node.borrow_mut().right = Some(Box::new(TreeNode::new(arr[i].unwrap()))); queue.push_back(node.borrow().right.as_ref().unwrap().clone()); } i += 1; } root } fn treeToArray(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> { let mut result = Vec::new(); let mut queue = VecDeque::new(); queue.push_back(root); while let Some(node) = queue.pop_front() { if let Some(n) = node { result.push(Some(n.val)); queue.push_back(n.left.clone()); queue.push_back(n.right.clone()); } else { result.push(None); } } while let Some(last) = result.last() { if last.is_none() { result.pop(); } else { break; } } result }",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)] pub struct TreeNode { pub val: i32, pub left: Option<Box<TreeNode>>, pub right: Option<Box<TreeNode>>, } impl TreeNode { pub fn new(val: i32) -> Self { TreeNode { val, left: None, right: None } } }",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> { if arr.is_empty() { return None; } let root = Some(Box::new(TreeNode::new(arr[0].unwrap())); let mut queue = VecDeque::new(); queue.push_back(root.as_ref().unwrap().clone()); let mut i = 1; while i < arr.len() && !queue.is_empty() { let node = queue.pop_front().unwrap(); if let Some(val) = arr[i] { node.borrow_mut().left = Some(Box::new(TreeNode::new(val))); queue.push_back(node.borrow().left.as_ref().unwrap().clone()); } i += 1; if i < arr.len() && arr[i].is_some() { node.borrow_mut().right = Some(Box::new(TreeNode::new(arr[i].unwrap()))); queue.push_back(node.borrow().right.as_ref().unwrap().clone()); } i += 1; } root } fn treeToArray(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> { let mut result = Vec::new(); let mut queue = VecDeque::new(); queue.push_back(root); while let Some(node) = queue.pop_front() { if let Some(n) = node { result.push(Some(n.val)); queue.push_back(n.left.clone()); queue.push_back(n.right.clone()); } else { result.push(None); } } while let Some(last) = result.last() { if last.is_none() { result.pop(); } else { break; } } result }"
    },
    "ruby": {
      "functionDeclaration": "def SameTree(p, q)\nend",
      "testCalls": [
        "root = buildTree([1,2,3]); SameTree(root, buildTree([1,2,3])) == true || raise('Test Case 1 Failed')",
        "root = buildTree([1,2]); SameTree(root, buildTree([1,nil,2])) == false || raise('Test Case 2 Failed')"
      ],
      "compareHelper": "",
      "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result << node.val\n      queue.push(node.left)\n      queue.push(node.right\n    else\n      result << nil\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result << node.val\n      queue.push(node.left)\n      queue.push(node.right\n    else\n      result << nil\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "p": "[1,2,3]",
          "q": "[1,2,3]"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "p": "[1,2]",
          "q": "[1,null,2]"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "p": "[1,2,1]",
          "q": "[1,1,2]"
        },
        "expected": "false"
      }
    ]
  },
  "search-a-2d-matrix": {
    "title": "Search a 2D Matrix",
    "content": "You are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\n\nExample 1:\n\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n\nExample 2:\n\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-104 <= matrix[i][j], target <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchA2DMatrix(matrix, target) {}",
      "testCalls": [
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchA2DMatrix(matrix: number[][], target: number): boolean {}",
      "testCalls": [
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) !== true) throw new Error('Test Case 1 Failed');",
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool SearchA2DMatrix(vector<vector<int>>& matrix, int target);",
      "testCalls": [
        "if(SearchA2DMatrix({{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(SearchA2DMatrix({{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchA2DMatrix(matrix: List[List[int]], target: int) -> bool:",
      "testCalls": [
        "assert SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) == True",
        "assert SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) == False"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean SearchA2DMatrix(int[][] matrix, int target) { }",
      "testCalls": [
        "if (!SearchA2DMatrix(new int[][]{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3)) throw new AssertionError();",
        "if (SearchA2DMatrix(new int[][]{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13)) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool SearchA2DMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)",
      "testCalls": [
        "if (!SearchA2DMatrix((int*[]){(int[]){1,3,5,7}, (int[]){10,11,16,20}, (int[]){23,30,34,60}}, 3, (int[]){4,4}, 3)) { printf(\"Test 1 Failed\"); }",
        "if (SearchA2DMatrix((int*[]){(int[]){1,3,5,7}, (int[]){10,11,16,20}, (int[]){23,30,34,60}}, 3, (int[]){4,4}, 13)) { printf(\"Test 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchA2DMatrix(matrix [][]int, target int) bool {}",
      "testCalls": [
        "if SearchA2DMatrix([][]int{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3) != true {panic(\"Test case 1 failed\")}",
        "if SearchA2DMatrix([][]int{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13) != false {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchA2DMatrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(SearchA2DMatrix(vec![vec![1,3,5,7], vec![10,11,16,20], vec![23,30,34,60]], 3), true);",
        "assert_eq!(SearchA2DMatrix(vec![vec![1,3,5,7], vec![10,11,16,20], vec![23,30,34,60]], 13), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchA2DMatrix(matrix, target)\nend",
      "testCalls": [
        "result = SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3)\nraise 'Test Case 1 Failed' unless result == true",
        "result = SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13)\nraise 'Test Case 2 Failed' unless result == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "matrix": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]]",
          "target": "3"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "matrix": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]]",
          "target": "13"
        },
        "expected": "false"
      }
    ]
  },
  "search-in-rotated-sorted-array": {
    "title": "Search in Rotated Sorted Array",
    "content": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by3indices and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n\n\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-104 <= target <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchInRotatedSortedArray(nums, target) {}",
      "testCalls": [
        "if(SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchInRotatedSortedArray(nums: number[], target: number): number {}",
      "testCalls": [
        "if (SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int SearchInRotatedSortedArray(vector<int>& nums, int target);",
      "testCalls": [
        "assert(SearchInRotatedSortedArray({4,5,6,7,0,1,2}, 0) == 4);",
        "assert(SearchInRotatedSortedArray({4,5,6,7,0,1,2}, 3) == -1);",
        "assert(SearchInRotatedSortedArray({1}, 0) == -1);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchInRotatedSortedArray(nums: List[int], target: int) -> int:",
      "testCalls": [
        "assert SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) == 4",
        "assert SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) == -1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int SearchInRotatedSortedArray(int[] nums, int target) {}",
      "testCalls": [
        "assert SearchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 0) == 4;",
        "assert SearchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 3) == -1;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int SearchInRotatedSortedArray(int* nums, int numsSize, int target)",
      "testCalls": [
        "assert(SearchInRotatedSortedArray((int[]){4,5,6,7,0,1,2}, 7, 0) == 4);",
        "assert(SearchInRotatedSortedArray((int[]){4,5,6,7,0,1,2}, 7, 3) == -1);",
        "assert(SearchInRotatedSortedArray((int[]){1}, 1, 0) == -1);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchInRotatedSortedArray(nums []int, target int) int {}",
      "testCalls": [
        "if SearchInRotatedSortedArray([]int{4,5,6,7,0,1,2}, 0) != 4 {panic(\"Test case 1 failed\")}",
        "if SearchInRotatedSortedArray([]int{4,5,6,7,0,1,2}, 3) != -1 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchInRotatedSortedArray(nums: Vec<i32>, target: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(SearchInRotatedSortedArray(vec![4,5,6,7,0,1,2], 0), 4);",
        "assert_eq!(SearchInRotatedSortedArray(vec![4,5,6,7,0,1,2], 3), -1);",
        "assert_eq!(SearchInRotatedSortedArray(vec![1], 0), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchInRotatedSortedArray(nums, target)\n  \nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) == 4",
        "raise 'Test Case 2 Failed' unless SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) == -1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[4,5,6,7,0,1,2]",
          "target": "0"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[4,5,6,7,0,1,2]",
          "target": "3"
        },
        "expected": "-1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1]",
          "target": "0"
        },
        "expected": "-1"
      }
    ]
  },
  "search-insert-position": {
    "title": "Search Insert Position",
    "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou mustwrite an algorithm withO(log n) runtime complexity.\n\nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\n\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchInsertPosition(nums, target) {}",
      "testCalls": [
        "if(SearchInsertPosition([1,3,5,6], 5) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInsertPosition([1,3,5,6], 2) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchInsertPosition(nums: number[], target: number): number {}",
      "testCalls": [
        "if(SearchInsertPosition([1,3,5,6], 5) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInsertPosition([1,3,5,6], 2) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int SearchInsertPosition(vector<int>& nums, int target);",
      "testCalls": [
        "assert(SearchInsertPosition({1, 3, 5, 6}, 5) == 2);",
        "assert(SearchInsertPosition({1, 3, 5, 6}, 2) == 1);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchInsertPosition(nums: List[int], target: int) -> int:",
      "testCalls": [
        "assert SearchInsertPosition([1,3,5,6], 5) == 2",
        "assert SearchInsertPosition([1,3,5,6], 2) == 1",
        "assert SearchInsertPosition([1,3,5,6], 7) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int searchInsert(int[] nums, int target) {}",
      "testCalls": [
        "if (searchInsert(new int[]{1,3,5,6}, 5) != 2) throw new AssertionError();",
        "if (searchInsert(new int[]{1,3,5,6}, 2) != 1) throw new AssertionError();",
        "if (searchInsert(new int[]{1,3,5,6}, 7) != 4) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int SearchInsertPosition(int* nums, int numsSize, int target)",
      "testCalls": [
        "if(SearchInsertPosition((int[]){1,3,5,6}, 4, 5) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(SearchInsertPosition((int[]){1,3,5,6}, 4, 2) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchInsertPosition(nums []int, target int) int {}",
      "testCalls": [
        "if SearchInsertPosition([]int{1,3,5,6}, 5) != 2 { panic(\"Test case 1 failed\") }",
        "if SearchInsertPosition([]int{1,3,5,6}, 2) != 1 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchInsertPosition(nums: Vec<i32>, target: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(SearchInsertPosition(vec![1,3,5,6], 5), 2);",
        "assert_eq!(SearchInsertPosition(vec![1,3,5,6], 2), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchInsertPosition(nums, target)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless SearchInsertPosition([1,3,5,6], 5) == 2",
        "raise 'Test Case 2 Failed' unless SearchInsertPosition([1,3,5,6], 2) == 1",
        "raise 'Test Case 3 Failed' unless SearchInsertPosition([1,3,5,6], 7) == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,3,5,6]",
          "target": "5"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,3,5,6]",
          "target": "2"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1,3,5,6]",
          "target": "7"
        },
        "expected": "4"
      }
    ]
  }
}