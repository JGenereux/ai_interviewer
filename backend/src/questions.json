{
  "3sum": {
    "title": "3Sum",
    "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.",
    "difficulty": "Medium",
    "hints": [
      "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
      "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ThreeSum(nums) {}",
      "testCalls": [
        "if(JSON.stringify(ThreeSum([-1,0,1,2,-1,-4])) !== JSON.stringify([[-1,-1,2],[-1,0,1]])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(ThreeSum([0,1,1])) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "if(JSON.stringify(ThreeSum([0,0,0])) !== JSON.stringify([[0,0,0]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ThreeSum(nums: number[]): number[][] { return []; }",
      "testCalls": [
        "const test1 = ThreeSum([-1,0,1,2,-1,-4]); if (JSON.stringify(test1) !== JSON.stringify([[-1,-1,2],[-1,0,1]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ThreeSum([0,1,1]); if (JSON.stringify(test2) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = ThreeSum([0,0,0]); if (JSON.stringify(test3) !== JSON.stringify([[0,0,0]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> ThreeSum(const std::vector<int>& nums) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> result1 = ThreeSum(std::vector<int>{-1,0,1,2,-1,-4}); if (result1 != std::vector<std::vector<int>>{{-1,-1,2},{-1,0,1}}) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> result2 = ThreeSum(std::vector<int>{0,1,1}); if (result2 != std::vector<std::vector<int>>{}) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> result3 = ThreeSum(std::vector<int>{0,0,0}); if (result3 != std::vector<std::vector<int>>{{0,0,0}}) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def ThreeSum(nums):\n return []",
      "testCalls": [
        "assert ThreeSum([-1,0,1,2,-1,-4]) == [[-1,-1,2],[-1,0,1]]",
        "assert ThreeSum([0,1,1]) == []",
        "assert ThreeSum([0,0,0]) == [[0,0,0]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> threeSum(int[] nums) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result1 = m.threeSum(new int[]{-1,0,1,2,-1,-4}); if (!m.compareLists(result1, Arrays.asList(Arrays.asList(-1,-1,2), Arrays.asList(-1,0,1)))) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result2 = m.threeSum(new int[]{0,1,1}); if (!m.compareLists(result2, Collections.emptyList())) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result3 = m.threeSum(new int[]{0,0,0}); if (!m.compareLists(result3, Collections.singletonList(Arrays.asList(0,0,0)))) throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) {\n    if (list1.size() != list2.size()) return false;\n    for (List<Integer> l : list1) {\n        if (!list2.contains(l)) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int** ThreeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int main() { int returnSize1; int* returnColumnSizes1; int** result1 = ThreeSum((int[]){-1,0,1,2,-1,-4}, 6, &returnSize1, &returnColumnSizes1); if (returnSize1 == 2 && compareArrays(result1, returnSize1, 3, (int*[]){(int[]){-1,-1,2}, (int[]){-1,0,1}})) { printf(\"Test case 1 passed.\\n\"); } else { printf(\"Test case 1 failed.\\n\"); } return 0; }",
        "int main() { int returnSize2; int* returnColumnSizes2; int** result2 = ThreeSum((int[]){0,1,1}, 3, &returnSize2, &returnColumnSizes2); if (returnSize2 == 0) { printf(\"Test case 2 passed.\\n\"); } else { printf(\"Test case 2 failed.\\n\"); } return 0; }"
      ],
      "compareHelper": "int compareArrays(int** arr1, int size1, int size2, int** arr2) { if (size1 != size2) { return 0; } for (int i = 0; i < size1; i++) { if (memcmp(arr1[i], arr2[i], sizeof(int) * 3) != 0) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func ThreeSum(nums []int) [][]int { return [][]int{} }",
      "testCalls": [
        "func TestThreeSum(t *testing.T) { if !compareArrays(ThreeSum([]int{-1,0,1,2,-1,-4}), [][]int{{-1,-1,2},{-1,0,1}}) { t.Error(\"Test Case 1 Failed\") } if !compareArrays(ThreeSum([]int{0,1,1}), [][]int{}) { t.Error(\"Test Case 2 Failed\") } if !compareArrays(ThreeSum([]int{0,0,0}), [][]int{{0,0,0}}) { t.Error(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if !compareArray(arr1[i], arr2[i]) { return false } } return true } func compareArray(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "ruby": {
      "functionDeclaration": "def ThreeSum(nums)\n  \nend",
      "testCalls": [
        "nums1 = [-1,0,1,2,-1,-4]\nexpected1 = [[-1,-1,2],[-1,0,1]]\nresult1 = ThreeSum(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected1",
        "nums2 = [0,1,1]\nexpected2 = []\nresult2 = ThreeSum(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected2"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[-1,0,1,2,-1,-4]"
        },
        "expected": "[[-1,-1,2],[-1,0,1]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1,1]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[0,0,0]"
        },
        "expected": "[[0,0,0]]"
      }
    ]
  },
  "add-two-numbers": {
    "title": "Add Two Numbers",
    "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sumas a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function AddTwoNumbers(l1, l2) {}",
      "testCalls": [
        "let l1 = buildLinkedList([2,4,3]); let l2 = buildLinkedList([5,6,4]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l1, l2))) !== JSON.stringify([7,0,8])) throw 'Test 1 Failed';",
        "let l3 = buildLinkedList([0]); let l4 = buildLinkedList([0]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l3, l4))) !== JSON.stringify([0])) throw 'Test 2 Failed';",
        "let l5 = buildLinkedList([9,9,9,9,9,9]); let l6 = buildLinkedList([9,9,9,9]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l5, l6))) !== JSON.stringify([8,9,9,9,0,0,0,1])) throw 'Test 3 Failed';"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function AddTwoNumbers(l1: number[], l2: number[]): number[] { }",
      "testCalls": [
        "let l1 = buildLinkedList([2,4,3]); let l2 = buildLinkedList([5,6,4]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l1, l2))) !== JSON.stringify([7,0,8])) throw 'Test 1 Failed';"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}",
      "builders": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2) { return nullptr; }",
      "testCalls": [
        "int main() { ListNode* result1 = AddTwoNumbers(createLinkedList({2,4,3}), createLinkedList({5,6,4})); if (!compareLinkedLists(result1, createLinkedList({7,0,8}))) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { ListNode* result2 = AddTwoNumbers(createLinkedList({0}), createLinkedList({0})); if (!compareLinkedLists(result2, createLinkedList({0}))) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }",
        "int main() { ListNode* result3 = AddTwoNumbers(createLinkedList({9,9,9,9,9,9,9}), createLinkedList({9,9,9,9})); if (!compareLinkedLists(result3, createLinkedList({8,9,9,9,0,0,0,1}))) throw std::runtime_error(\"Test Case 3 Failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>\n\nclass ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };\n\nListNode* createLinkedList(std::vector<int> values) { if (values.empty()) return nullptr; ListNode* head = new ListNode(values[0]); ListNode* curr = head; for (size_t i = 1; i < values.size(); i++) { curr->next = new ListNode(values[i]); curr = curr->next; } return head; }\n\nbool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def AddTwoNumbers(l1, l2):\n  return []",
      "testCalls": [
        "l1 = buildLinkedList([2,4,3])\nl2 = buildLinkedList([5,6,4])\nif linkedListToArray(AddTwoNumbers(l1, l2)) != [7,0,8]: raise Exception('Test 1 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode l1 = buildLinkedList(new int[]{2,4,3}); ListNode l2 = buildLinkedList(new int[]{5,6,4}); ListNode result1 = addTwoNumbers(l1, l2); if (!Arrays.equals(linkedListToArray(result1), new int[]{7,0,8})) throw new AssertionError(); }",
        "public static void main(String[] args) { ListNode l3 = buildLinkedList(new int[]{0}); ListNode l4 = buildLinkedList(new int[]{0}); ListNode result2 = addTwoNumbers(l3, l4); if (!Arrays.equals(linkedListToArray(result2), new int[]{0})) throw new AssertionError(); }",
        "public static void main(String[] args) { ListNode l5 = buildLinkedList(new int[]{9,9,9,9,9,9,9}); ListNode l6 = buildLinkedList(new int[]{9,9,9,9}); ListNode result3 = addTwoNumbers(l5, l6); if (!Arrays.equals(linkedListToArray(result3), new int[]{8,9,9,9,0,0,0,1})) throw new AssertionError(); }"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode l1, ListNode l2) {\n    while (l1 != null && l2 != null) {\n        if (l1.val != l2.val) {\n            throw new AssertionError(\"Test case failed\");\n        }\n        l1 = l1.next;\n        l2 = l2.next;\n    }\n    if (l1 != null || l2 != null) {\n        throw new AssertionError(\"Test case failed\");\n    }\n}",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "ListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
      "testCalls": [
        "int main() { ListNode* result1 = AddTwoNumbers(createLinkedList((int[]){2,4,3}, 3), createLinkedList((int[]){5,6,4}, 3)); if (!compareLinkedLists(result1, createLinkedList((int[]){7,0,8}, 3))) { printf(\"Test Case 1 Failed\\n\"); } return 0; }",
        "int main() { ListNode* result2 = AddTwoNumbers(createLinkedList((int[]){0}, 1), createLinkedList((int[]){0}, 1)); if (!compareLinkedLists(result2, createLinkedList((int[]){0}, 1))) { printf(\"Test Case 2 Failed\\n\"); } return 0; }",
        "int main() { ListNode* result3 = AddTwoNumbers(createLinkedList((int[]){9,9,9,9,9,9,9}, 7), createLinkedList((int[]){9,9,9,9}, 4)); if (!compareLinkedLists(result3, createLinkedList((int[]){8,9,9,9,0,0,0,1}, 8))) { printf(\"Test Case 3 Failed\\n\"); } return 0; }"
      ],
      "compareHelper": "int compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return 0; l1 = l1->next; l2 = l2->next; } return l1 == NULL && l2 == NULL; }",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* createLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
    },
    "go": {
      "functionDeclaration": "func AddTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { return nil }",
      "testCalls": [
        "func main() { l1 := buildLinkedList([]int{2, 4, 3}); l2 := buildLinkedList([]int{5, 6, 4}); if !compareArrays(linkedListToArray(AddTwoNumbers(l1, l2)), []int{7, 0, 8}) { panic(\"Test 1 Failed\") } }",
        "func main() { l1 := buildLinkedList([]int{0}); l2 := buildLinkedList([]int{0}); if !compareArrays(linkedListToArray(AddTwoNumbers(l1, l2)), []int{0}) { panic(\"Test 2 Failed\") } }",
        "func main() { l1 := buildLinkedList([]int{9,9,9,9,9,9,9}); l2 := buildLinkedList([]int{9,9,9,9}); if !compareArrays(linkedListToArray(AddTwoNumbers(l1, l2)), []int{8,9,9,9,0,0,0,1}) { panic(\"Test 3 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if arr1[i] != arr2[i] { return false } }; return true }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil }; head := &ListNode{Val: arr[0]}; curr := head; for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]}; curr = curr.Next }; return head }\nfunc linkedListToArray(head *ListNode) []int { var arr []int; for head != nil { arr = append(arr, head.Val); head = head.Next }; return arr }"
    },
    "rust": {
      "functionDeclaration": "fn AddTwoNumbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let l1 = build_linked_list(&[2, 4, 3]);\nlet l2 = build_linked_list(&[5, 6, 4]);\nassert_eq!(linked_list_to_array(AddTwoNumbers(l1, l2)), vec![7, 0, 8]);"
      ],
      "compareHelper": "fn compare_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> bool { if list1.is_none() && list2.is_none() { return true; } let mut current1 = list1; let mut current2 = list2; while let (Some(node1), Some(node2)) = (current1, current2) { if node1.val != node2.val { return false; } current1 = node1.next.clone(); current2 = node2.next.clone(); } current1.is_none() && current2.is_none() }",
      "helpers": "use std::collections::LinkedList;\n\n#[derive(Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: &[i32]) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr {\n        *curr = Some(Box::new(ListNode::new(val)));\n        curr = &mut (*curr).as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: &[i32]) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr {\n        *curr = Some(Box::new(ListNode::new(val)));\n        curr = &mut (*curr).as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def AddTwoNumbers(l1, l2)\nend",
      "testCalls": [
        "l1 = build_linked_list([2,4,3])\nl2 = build_linked_list([5,6,4])\nif linked_list_to_array(AddTwoNumbers(l1, l2)) != [7,0,8]\n  raise 'Test 1 Failed'\nend"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def build_linked_list(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linked_list_to_array(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "l1": "[2,4,3]",
          "l2": "[5,6,4]"
        },
        "expected": "[7,0,8]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "l1": "[0]",
          "l2": "[0]"
        },
        "expected": "[0]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "l1": "[9,9,9,9,9,9,9]",
          "l2": "[9,9,9,9]"
        },
        "expected": "[8,9,9,9,0,0,0,1]"
      }
    ]
  },
  "average-of-levels-in-binary-tree": {
    "title": "Average of Levels in Binary Tree",
    "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function AverageOfLevelsInBinaryTree(root) {}",
      "testCalls": [
        "let root1 = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root1))) !== JSON.stringify([3,14.5,11])) throw 'Test 1 Failed';",
        "let root2 = buildTree([3,9,20,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root2))) !== JSON.stringify([3,14.5,11])) throw 'Test 2 Failed';"
      ],
      "compareHelper": "function arraysAreEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function AverageOfLevelsInBinaryTree(root: TreeNode | null): number[]",
      "testCalls": [
        "let root = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root))) !== JSON.stringify([3.00000,14.50000,11.00000])) throw 'Test 1 Failed';"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}",
      "builders": "function buildTree(arr: (number | null)[]): TreeNode | null {\n  if (!arr.length || arr[0] === null) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (queue.length && i < arr.length) {\n    const node = queue.shift()!;\n    if (i < arr.length && arr[i] !== null) {\n      node.left = new TreeNode(arr[i] as number);\n      queue.push(node.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      node.right = new TreeNode(arr[i] as number);\n      queue.push(node.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) result.pop();\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "std::vector<double> AverageOfLevelsInBinaryTree(TreeNode* root) { return {}; }",
      "testCalls": [
        "int main() { std::vector<double> result1 = AverageOfLevelsInBinaryTree(createTree({3,9,20,-1,-1,15,7})); std::vector<double> expected1 = {3.0, 14.5, 11.0}; if (!compareArrays(result1, expected1)) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { std::vector<double> result2 = AverageOfLevelsInBinaryTree(createTree({3,9,20,15,7})); std::vector<double> expected2 = {3.0, 14.5, 11.0}; if (!compareArrays(result2, expected2)) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <cmath>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} };\n\nTreeNode* createTree(std::vector<int> values) { if (values.empty() || values[0] == -1) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (i < values.size() && values[i] != -1) { node->left = new TreeNode(values[i]); q.push(node->left); } i++; if (i < values.size() && values[i] != -1) { node->right = new TreeNode(values[i]); q.push(node->right); } i++; } return root; }\n\nbool compareArrays(std::vector<double>& arr1, std::vector<double>& arr2) { if (arr1.size() != arr2.size()) return false; for (size_t i = 0; i < arr1.size(); ++i) { if (std::abs(arr1[i] - arr2[i]) > 1e-5) return false; } return true; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def AverageOfLevelsInBinaryTree(root: TreeNode) -> list[float]:\n return []",
      "testCalls": [
        "root = buildTree([3,9,20,None,None,15,7])\nif treeToArray(AverageOfLevelsInBinaryTree(root)) != [3.00000,14.50000,11.00000]: raise Exception('Test 1 Failed')"
      ],
      "compareHelper": "def assertArrayEquals(arr1, arr2): assert len(arr1) == len(arr2) and all(a == b for a, b in zip(arr1, arr2)), 'Arrays not equal'",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public double[] AverageOfLevels(TreeNode root) { return new double[0]; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode root1 = m.buildTree(new Integer[]{3, 9, 20, null, null, 15, 7}); double[] result1 = m.AverageOfLevels(root1); if (!Arrays.equals(result1, new double[]{3.0, 14.5, 11.0})) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode root2 = m.buildTree(new Integer[]{3, 9, 20, 15, 7}); double[] result2 = m.AverageOfLevels(root2); if (!Arrays.equals(result2, new double[]{3.0, 14.5, 11.0})) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }\n\nTreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "double* AverageOfLevelsInBinaryTree(struct TreeNode* root, int* returnSize)",
      "testCalls": [
        "int returnSize; double* result1 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]){3,9,20,0,0,15,7}, 7), &returnSize); assert(compareDoubleArrays(result1, 3, (double[]){3.00000,14.50000,11.00000}, 3));",
        "int returnSize; double* result2 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]){3,9,20,15,7}, 5), &returnSize); assert(compareDoubleArrays(result2, 3, (double[]){3.00000,14.50000,11.00000}, 3));"
      ],
      "compareHelper": "int compareDoubleArrays(double* arr1, int size1, double* arr2, int size2) { if (size1 != size2) return 0; for (int i = 0; i < size1; i++) { if (fabs(arr1[i] - arr2[i]) > 0.00001) return 0; } return 1; }",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;",
      "builders": "TreeNode* createTreeFromArray(int* arr, int size);\ndouble* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func AverageOfLevels(root *TreeNode) []float64 { return nil }",
      "testCalls": [
        "func main() { root := buildTree([]interface{}{3, 9, 20, nil, nil, 15, 7}); if !compareFloatArrays(AverageOfLevels(root), []float64{3.00000, 14.50000, 11.00000}) { panic(\"Test Case 1 Failed\") } }",
        "func main() { root := buildTree([]interface{}{3, 9, 20, 15, 7}); if !compareFloatArrays(AverageOfLevels(root), []float64{3.00000, 14.50000, 11.00000}) { panic(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": "func compareFloatArrays(arr1, arr2 []float64) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if arr1[i] != arr2[i] { return false } }; return true }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []interface{}) *TreeNode { if len(arr) == 0 || arr[0] == nil { return nil }; root := &TreeNode{Val: arr[0].(int)}; queue := []*TreeNode{root}; i := 1; for len(queue) > 0 && i < len(arr) { node := queue[0]; queue = queue[1:]; if i < len(arr) && arr[i] != nil { node.Left = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Left) }; i++; if i < len(arr) && arr[i] != nil { node.Right = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Right) }; i++ }; return root }"
    },
    "rust": {
      "functionDeclaration": "fn AverageOfLevelsInBinaryTree(root: Option<Box<TreeNode>>) -> Vec<f64> { }",
      "testCalls": [
        "let root = build_tree(&[Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);\nassert_eq!(tree_to_array(AverageOfLevelsInBinaryTree(root)), vec![Some(3), Some(14), Some(11)]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Clone, Debug)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}\n\nfn build_tree(arr: &[Option<i32>]) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() { return None; }\n    let mut root = Some(Box::new(TreeNode { val: arr[0].unwrap(), left: None, right: None }));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_mut().unwrap());\n    let mut i = 1;\n    while !queue.is_empty() && i < arr.len() {\n        let node = queue.pop_front().unwrap();\n        if let Some(val) = arr[i] {\n            node.left = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.left.as_mut().unwrap());\n        }\n        i += 1;\n        if let Some(val) = arr[i] {\n            node.right = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.right.as_mut().unwrap());\n        }\n        i += 1;\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Clone, Debug)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}",
      "builders": "fn build_tree(arr: &[Option<i32>]) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() { return None; }\n    let mut root = Some(Box::new(TreeNode { val: arr[0].unwrap(), left: None, right: None }));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_mut().unwrap());\n    let mut i = 1;\n    while !queue.is_empty() && i < arr.len() {\n        let node = queue.pop_front().unwrap();\n        if let Some(val) = arr[i] {\n            node.left = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.left.as_mut().unwrap());\n        }\n        i += 1;\n        if let Some(val) = arr[i] {\n            node.right = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.right.as_mut().unwrap());\n        }\n        i += 1;\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def AverageOfLevelsInBinaryTree(root)\nend",
      "testCalls": [
        "root = build_tree([3,9,20,nil,nil,15,7])\nif tree_to_array(AverageOfLevelsInBinaryTree(root)) != [3.00000,14.50000,11.00000]\n  raise 'Test Case 1 Failed'\nend"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def build_tree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef tree_to_array(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "[3.00000,14.50000,11.00000]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[3,9,20,15,7]"
        },
        "expected": "[3.00000,14.50000,11.00000]"
      }
    ]
  },
  "basic-calculator": {
    "title": "Basic Calculator",
    "content": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Math",
      "String",
      "Stack",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BasicCalculator(s) { return 0; }",
      "testCalls": [
        "if(BasicCalculator(\"1+1\") !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BasicCalculator(\"2-1+2\") !== 3) { throw new Error('Test Case 2 Failed'); }",
        "if(BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BasicCalculator(s: string): number { return 0; }",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") !== 2) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (BasicCalculator(\"2-1+2\") !== 3) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") !== 23) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int BasicCalculator(string s);",
      "testCalls": [
        "int main() { if (BasicCalculator(\"1+1\") != 2) { throw std::runtime_error(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (BasicCalculator(\"2-1+2\") != 3) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BasicCalculator(s: str) -> int:\n return 0",
      "testCalls": [
        "assert BasicCalculator(\"1+1\") == 2",
        "assert BasicCalculator(\"2-1+2\") == 3",
        "assert BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") == 23"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BasicCalculator(String s) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.BasicCalculator(\"1+1\") != 2) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.BasicCalculator(\"2-1+2\") != 3) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BasicCalculator(char* s)",
      "testCalls": [
        "int main() { if(BasicCalculator(\"1+1\") != 2) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(BasicCalculator(\"2-1+2\") != 3) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BasicCalculator(s string) int { return 0 }",
      "testCalls": [
        "func main() { if BasicCalculator(\"1+1\") != 2 { panic(\"Test case 1 failed\") } }",
        "func main() { if BasicCalculator(\"2-1+2\") != 3 { panic(\"Test case 2 failed\") } }",
        "func main() { if BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") != 23 { panic(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BasicCalculator(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(BasicCalculator(String::from(\"1+1\")), 2);",
        "assert_eq!(BasicCalculator(String::from(\"2-1+2\")), 3);",
        "assert_eq!(BasicCalculator(String::from(\"(1+(4+5+2)-3)+(6+8)\")), 23);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BasicCalculator(s)\n  return 0\nend",
      "testCalls": [
        "result1 = BasicCalculator(\"1+1\"); raise 'Test Case 1 Failed' unless result1 == 2",
        "result2 = BasicCalculator(\"2-1+2\"); raise 'Test Case 2 Failed' unless result2 == 3",
        "result3 = BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\"); raise 'Test Case 3 Failed' unless result3 == 23"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;1+1&quot;"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;2-1+2&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;(1+(4+5+2)-3)+(6+8)&quot;"
        },
        "expected": "23"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock-ii": {
    "title": "Best Time to Buy and Sell Stock II",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.\nFind and return the maximum profit you can achieve.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockII(prices) { return 0; }",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(BestTimeToBuyAndSellStockII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockII(prices: number[]): number { return 0; }",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (BestTimeToBuyAndSellStockII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfit(std::vector<int> prices) { return 0; }",
      "testCalls": [
        "int main() { if (MaxProfit({7,1,5,3,6,4}) != 7) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { if (MaxProfit({1,2,3,4,5}) != 4) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockII(prices: list[int]) -> int:\n  return 0",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) == 7",
        "assert BestTimeToBuyAndSellStockII([1,2,3,4,5]) == 4",
        "assert BestTimeToBuyAndSellStockII([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockII(int[] prices) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.BestTimeToBuyAndSellStockII(new int[]{7,1,5,3,6,4}) != 7) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.BestTimeToBuyAndSellStockII(new int[]{1,2,3,4,5}) != 4) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int* prices, int pricesSize)",
      "testCalls": [
        "int main() {",
        "    if(MaxProfit((int[]){7,1,5,3,6,4}, 6) != 7) { printf(\"Test Case 1 Failed\\n\"); }",
        "    if(MaxProfit((int[]){1,2,3,4,5}, 5) != 4) { printf(\"Test Case 2 Failed\\n\"); }",
        "    if(MaxProfit((int[]){7,6,4,3,1}, 5) != 0) { printf(\"Test Case 3 Failed\\n\"); }",
        "    return 0;",
        "}"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxProfit(prices []int) int { return 0 }",
      "testCalls": [
        "func main() { if MaxProfit([]int{7,1,5,3,6,4}) != 7 { panic(\"Test case 1 failed\") } }",
        "func main() { if MaxProfit([]int{1,2,3,4,5}) != 4 { panic(\"Test case 2 failed\") } }",
        "func main() { if MaxProfit([]int{7,6,4,3,1}) != 0 { panic(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockII(prices: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![7,1,5,3,6,4]), 7);",
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![1,2,3,4,5]), 4);",
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![7,6,4,3,1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockII(prices)\nend",
      "testCalls": [
        "test_case_1 = BestTimeToBuyAndSellStockII([7,1,5,3,6,4])\nraise 'Test Case 1 Failed' unless test_case_1 == 7",
        "test_case_2 = BestTimeToBuyAndSellStockII([1,2,3,4,5])\nraise 'Test Case 2 Failed' unless test_case_2 == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "prices": "[7,1,5,3,6,4]"
        },
        "expected": "7"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "prices": "[1,2,3,4,5]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "prices": "[7,6,4,3,1]"
        },
        "expected": "0"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock-iii": {
    "title": "Best Time to Buy and Sell Stock III",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIII(prices) { return 0; }",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(BestTimeToBuyAndSellStockIII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIII(prices: number[]): number { return 0; }",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BestTimeToBuyAndSellStockIII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if (BestTimeToBuyAndSellStockIII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfitIII(std::vector<int> prices) { return 0; }",
      "testCalls": [
        "int main() { if (MaxProfitIII({3,3,5,0,0,3,1,4}) != 6) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (MaxProfitIII({1,2,3,4,5}) != 4) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIII(prices: list[int]) -> int:\n  return 0",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) == 6",
        "assert BestTimeToBuyAndSellStockIII([1,2,3,4,5]) == 4",
        "assert BestTimeToBuyAndSellStockIII([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockIII(int[] prices) { return 0; }",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockIII(new int[]{3,3,5,0,0,3,1,4}) != 6) throw new AssertionError();",
        "if (BestTimeToBuyAndSellStockIII(new int[]{1,2,3,4,5}) != 4) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfitIII(int* prices, int pricesSize)",
      "testCalls": [
        "int main() { if(MaxProfitIII((int[]){3,3,5,0,0,3,1,4}, 8) != 6) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(MaxProfitIII((int[]){1,2,3,4,5}, 5) != 4) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BestTimeToBuyAndSellStockIII(prices []int) int { return 0 }",
      "testCalls": [
        "func main() { if BestTimeToBuyAndSellStockIII([]int{3,3,5,0,0,3,1,4}) != 6 { panic(\"Test case 1 failed\") } }",
        "func main() { if BestTimeToBuyAndSellStockIII([]int{1,2,3,4,5}) != 4 { panic(\"Test case 2 failed\") } }",
        "func main() { if BestTimeToBuyAndSellStockIII([]int{7,6,4,3,1}) != 0 { panic(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockIII(prices: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockIII(vec![3,3,5,0,0,3,1,4]), 6);",
        "assert_eq!(BestTimeToBuyAndSellStockIII(vec![1,2,3,4,5]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIII(prices)\nend",
      "testCalls": [
        "result1 = BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4])\nraise 'Test Case 1 Failed' unless result1 == 6",
        "result2 = BestTimeToBuyAndSellStockIII([1,2,3,4,5])\nraise 'Test Case 2 Failed' unless result2 == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "prices": "[3,3,5,0,0,3,1,4]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "prices": "[1,2,3,4,5]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "prices": "[7,6,4,3,1]"
        },
        "expected": "0"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock-iv": {
    "title": "Best Time to Buy and Sell Stock IV",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIV(k, prices) { return 0; }",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIV(2, [2,4,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) !== 7) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIV(k: number, prices: number[]): number { return 0; }",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIV(2, [2,4,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) !== 7) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfit(int k, std::vector<int> prices) { return 0; }",
      "testCalls": [
        "int main() { if (MaxProfit(2, {2,4,1}) != 2) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (MaxProfit(2, {3,2,6,5,0,3}) != 7) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIV(k: int, prices: list[int]) -> int:\n  return 0",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIV(2, [2,4,1]) == 2",
        "assert BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) == 7"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockIV(int k, int[] prices) { return 0; }",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockIV(2, new int[]{2,4,1}) != 2) throw new AssertionError();",
        "if (BestTimeToBuyAndSellStockIV(2, new int[]{3,2,6,5,0,3}) != 7) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int k, int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit(2, (int[]){2,4,1}, 3) != 2) { printf(\"Test Case 1 Failed\"); }",
        "int main() { if(MaxProfit(2, (int[]){3,2,6,5,0,3}, 6) != 7) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BestTimeToBuyAndSellStockIV(k int, prices []int) int { return 0 }",
      "testCalls": [
        "func main() { if BestTimeToBuyAndSellStockIV(2, []int{2,4,1}) != 2 { panic(\"Test 1 failed\") } }",
        "func main() { if BestTimeToBuyAndSellStockIV(2, []int{3,2,6,5,0,3}) != 7 { panic(\"Test 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockIV(k: i32, prices: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockIV(2, vec![2, 4, 1]), 2);",
        "assert_eq!(BestTimeToBuyAndSellStockIV(2, vec![3, 2, 6, 5, 0, 3]), 7);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIV(k, prices)\nend",
      "testCalls": [
        "result1 = BestTimeToBuyAndSellStockIV(2, [2,4,1])\nraise 'Test Case 1 Failed' unless result1 == 2",
        "result2 = BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3])\nraise 'Test Case 2 Failed' unless result2 == 7"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "k": "2",
          "prices": "[2,4,1]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "k": "2",
          "prices": "[3,2,6,5,0,3]"
        },
        "expected": "7"
      }
    ]
  },
  "best-time-to-buy-and-sell-stock": {
    "title": "Best Time to Buy and Sell Stock",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStock(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStock([7,1,5,3,6,4]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStock([7,6,4,3,1]) !== 0) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxProfit(prices: number[]): number { return 0; }",
      "testCalls": [
        "if(MaxProfit([7,1,5,3,6,4]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxProfit([7,6,4,3,1]) !== 0) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxProfit(std::vector<int> prices) { return 0; }",
      "testCalls": [
        "int main() { if (MaxProfit({7,1,5,3,6,4}) != 5) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (MaxProfit({7,6,4,3,1}) != 0) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStock(prices: list[int]) -> int:\n  return 0",
      "testCalls": [
        "assert BestTimeToBuyAndSellStock([7,1,5,3,6,4]) == 5",
        "assert BestTimeToBuyAndSellStock([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaxProfit(int[] prices) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if(m.MaxProfit(new int[]{7,1,5,3,6,4}) != 5) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.MaxProfit(new int[]{7,6,4,3,1}) != 0) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int* prices, int pricesSize)",
      "testCalls": [
        "int main() { if(MaxProfit((int[]) {7,1,5,3,6,4}, 6) != 5) { printf(\"Test Case 1 Failed\\n\"); }",
        "if(MaxProfit((int[]) {7,6,4,3,1}, 5) != 0) { printf(\"Test Case 2 Failed\\n\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxProfit(prices []int) int { return 0 }",
      "testCalls": [
        "func main() { if MaxProfit([]int{7,1,5,3,6,4}) != 5 { panic(\"Test case 1 failed\") } }",
        "func main() { if MaxProfit([]int{7,6,4,3,1}) != 0 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStock(prices: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStock(vec![7, 1, 5, 3, 6, 4]), 5);",
        "assert_eq!(BestTimeToBuyAndSellStock(vec![7, 6, 4, 3, 1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStock(prices)\nend",
      "testCalls": [
        "test 'Example 1' do\n  expect(BestTimeToBuyAndSellStock([7,1,5,3,6,4])).to eq(5)\nend",
        "test 'Example 2' do\n  expect(BestTimeToBuyAndSellStock([7,6,4,3,1])).to eq(0)\nend"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "prices": "[7,1,5,3,6,4]"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "prices": "[7,6,4,3,1]"
        },
        "expected": "0"
      }
    ]
  },
  "binary-tree-level-order-traversal": {
    "title": "Binary Tree Level Order Traversal",
    "content": "Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).",
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS."
    ],
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeLevelOrderTraversal(root) {}",
      "testCalls": [
        "let root1 = buildTree([3,9,20,null,null,15,7]); BinaryTreeLevelOrderTraversal(root1);",
        "let root2 = buildTree([1]); BinaryTreeLevelOrderTraversal(root2);",
        "let root3 = buildTree([]); BinaryTreeLevelOrderTraversal(root3);"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeLevelOrderTraversal(root: TreeNode | null): number[][] {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(buildTree([3,9,20,null,null,15,7]))) !== '[[3],[9,20],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(buildTree([1]))) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(null)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null {\n  // implementation here\n}\n",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> BinaryTreeLevelOrderTraversal(TreeNode* root) { return {}; }",
      "testCalls": [
        "int main() { if (BinaryTreeLevelOrderTraversal(nullptr) != std::vector<std::vector<int>>{}) throw std::runtime_error(\"Test 1 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def BinaryTreeLevelOrderTraversal(root) -> list[list[int]]:\n  return []",
      "testCalls": [
        "root = buildTree([3,9,20,None,None,15,7])\nassert BinaryTreeLevelOrderTraversal(root) == [[3],[9,20],[15,7]], 'Test Case 1 Failed'",
        "root = buildTree([1])\nassert BinaryTreeLevelOrderTraversal(root) == [[1]], 'Test Case 2 Failed'",
        "root = buildTree([])\nassert BinaryTreeLevelOrderTraversal(root) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i] if i < len(arr) else None\n            node.right = nodes[i + 1] if i + 1 < len(arr) else None\n            queue.append(node.left)\n            queue.append(node.right)\n        i += 2\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result\n"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> BinaryTreeLevelOrderTraversal(TreeNode root) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result1 = m.BinaryTreeLevelOrderTraversal(m.buildTree(new Integer[]{3, 9, 20, null, null, 15, 7})); if (result1.size() != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result2 = m.BinaryTreeLevelOrderTraversal(m.buildTree(new Integer[]{1})); if (result2.size() != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result3 = m.BinaryTreeLevelOrderTraversal(null); if (result3.size() != 0) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "void BinaryTreeLevelOrderTraversal(struct TreeNode* root)",
      "testCalls": [
        "struct TreeNode* root1 = buildTree((int[]){3, 9, 20, -1, -1, 15, 7}, 7); BinaryTreeLevelOrderTraversal(root1);",
        "struct TreeNode* root2 = buildTree((int[]){1}, 1); BinaryTreeLevelOrderTraversal(root2);",
        "BinaryTreeLevelOrderTraversal(NULL);"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTree(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == -1) return NULL; struct TreeNode* root = createTree(arr[0]); struct TreeNode* queue[size]; int qFront = 0, qRear = 0; queue[qRear++] = root; int i = 1; while (qFront < qRear && i < size) { struct TreeNode* node = queue[qFront++]; if (i < size && arr[i] != -1) { node->left = createTree(arr[i]); queue[qRear++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = createTree(arr[i]); queue[qRear++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 2000); int resultIdx = 0; struct TreeNode* queue[2000]; int qFront = 0, qRear = 0; queue[qRear++] = root; while (qFront < qRear) { struct TreeNode* node = queue[qFront++]; if (node) { result[resultIdx++] = node->val; if (node->left) queue[qRear++] = node->left; if (node->right) queue[qRear++] = node->right; } } *returnSize = resultIdx; return result; }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeLevelOrderTraversal(root *TreeNode) [][]int { return nil }",
      "testCalls": [
        "func main() { root := buildTree([]interface{}{3, 9, 20, nil, nil, 15, 7}); if !compareArrays(BinaryTreeLevelOrderTraversal(root), [][]int{{3}, {9, 20}, {15, 7}}) { panic(\"Test Case 1 Failed\") } }",
        "func main() { root := buildTree([]interface{}{1}); if !compareArrays(BinaryTreeLevelOrderTraversal(root), [][]int{{1}}) { panic(\"Test Case 2 Failed\") } }",
        "func main() { root := buildTree([]interface{}{}); if !compareArrays(BinaryTreeLevelOrderTraversal(root), [][]int{}) { panic(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if len(arr1[i]) != len(arr2[i]) { return false }; for j := range arr1[i] { if arr1[i][j] != arr2[i][j] { return false } } }; return true }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []interface{}) *TreeNode { if len(arr) == 0 || arr[0] == nil { return nil }; root := &TreeNode{Val: arr[0].(int)}; queue := []*TreeNode{root}; i := 1; for len(queue) > 0 && i < len(arr) { node := queue[0]; queue = queue[1:]; if i < len(arr) && arr[i] != nil { node.Left = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Left) }; i++; if i < len(arr) && arr[i] != nil { node.Right = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Right) }; i++ }; return root }"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeLevelOrderTraversal(root: Option<Rc<RefCell<TreeNode>>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "let root1 = buildTree(vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]); let result1 = BinaryTreeLevelOrderTraversal(root1); assert_eq!(result1, vec![vec![3], vec![9, 20], vec![15, 7]]);",
        "let root2 = buildTree(vec![Some(1), None, None]); let result2 = BinaryTreeLevelOrderTraversal(root2); assert_eq!(result2, vec![vec![1]]);",
        "let root3 = buildTree(vec![]); let result3 = BinaryTreeLevelOrderTraversal(root3); assert_eq!(result3, vec![]);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeLevelOrderTraversal(root)\nend",
      "testCalls": [
        "root = buildTree([3,9,20,nil,nil,15,7])\nif treeToArray(BinaryTreeLevelOrderTraversal(root)) != [[3],[9,20],[15,7]]\n  raise 'Test Case 1 Failed'\nend",
        "root = buildTree([1])\nif treeToArray(BinaryTreeLevelOrderTraversal(root)) != [[1]]\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val=0, left=nil, right=nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  while result[-1] == nil\n    result.pop\n  end\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "[[3],[9,20],[15,7]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1]"
        },
        "expected": "[[1]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "binary-tree-maximum-path-sum": {
    "title": "Binary Tree Maximum Path Sum",
    "content": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeMaximumPathSum(root) { return 0; }",
      "testCalls": [
        "let root1 = buildTree([1,2,3]); if (BinaryTreeMaximumPathSum(root1) !== 6) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([-10,9,20,null,null,15,7]); if (BinaryTreeMaximumPathSum(root2) !== 42) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeMaximumPathSum(root: TreeNode | null): number {}",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(arrayToBinaryTree([1,2,3])) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BinaryTreeMaximumPathSum(arrayToBinaryTree([-10,9,20,null,null,15,7])) !== 42) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arrayToBinaryTree(arr: (number | null)[]): TreeNode | null {}",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function arrayToBinaryTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction binaryTreeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int BinaryTreeMaximumPathSum(TreeNode* root) { return 0; }",
      "testCalls": [
        "int main() { if (BinaryTreeMaximumPathSum(buildTree({1,2,3})) != 6) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (BinaryTreeMaximumPathSum(buildTree({-10,9,20,-1,-1,15,7})) != 42) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def BinaryTreeMaximumPathSum(root):\n  return 0",
      "testCalls": [
        "root = buildTree([1,2,3]); assert BinaryTreeMaximumPathSum(root) == 6",
        "root = buildTree([-10,9,20,None,None,15,7]); assert BinaryTreeMaximumPathSum(root) == 42"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public int BinaryTreeMaximumPathSum(TreeNode root) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode root1 = m.buildTree(new Integer[]{1,2,3}); if (m.BinaryTreeMaximumPathSum(root1) != 6) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode root2 = m.buildTree(new Integer[]{-10,9,20,null,null,15,7}); if (m.BinaryTreeMaximumPathSum(root2) != 42) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "int BinaryTreeMaximumPathSum(struct TreeNode* root)",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(createTreeFromArray((int[]) {1,2,3}, 3)) != 6) { printf(\"Test Case 1 Failed\"); }",
        "int main() { if (BinaryTreeMaximumPathSum(createTreeFromArray((int[]) {-10,9,20,INT_MIN,INT_MIN,15,7}, 7)) != 42) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeMaximumPathSum(root *TreeNode) int { return 0 }",
      "testCalls": [
        "func main() { root := buildTree([]interface{}{1, 2, 3}); if BinaryTreeMaximumPathSum(root) != 6 { panic(\"Test Case 1 Failed\") } }",
        "func main() { root := buildTree([]interface{}{-10, 9, 20, nil, nil, 15, 7}); if BinaryTreeMaximumPathSum(root) != 42 { panic(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": "",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []interface{}) *TreeNode { if len(arr) == 0 || arr[0] == nil { return nil }; root := &TreeNode{Val: arr[0].(int)}; queue := []*TreeNode{root}; i := 1; for len(queue) > 0 && i < len(arr) { node := queue[0]; queue = queue[1:]; if i < len(arr) && arr[i] != nil { node.Left = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Left) }; i++; if i < len(arr) && arr[i] != nil { node.Right = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Right) }; i++ }; return root }"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeMaximumPathSum(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "let root1 = buildTree(vec![Some(1), Some(2), Some(3)]); assert_eq!(BinaryTreeMaximumPathSum(root1), 6);",
        "let root2 = buildTree(vec![Some(-10), Some(9), Some(20), None, None, Some(15), Some(7)]); assert_eq!(BinaryTreeMaximumPathSum(root2), 42);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    fn helper(arr: &[Option<i32>], index: usize) -> Option<Rc<RefCell<TreeNode>>> {\n        if index < arr.len() {\n            if let Some(val) = arr[index] {\n                let node = Rc::new(RefCell::new(TreeNode::new(val)));\n                node.borrow_mut().left = helper(arr, 2 * index + 1);\n                node.borrow_mut().right = helper(arr, 2 * index + 2);\n                Some(node)\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n    helper(&arr, 0)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.borrow().val));\n            queue.push_back(n.borrow().left.clone());\n            queue.push_back(n.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    fn helper(arr: &Vec<Option<i32>>, index: usize) -> Option<Rc<RefCell<TreeNode>>> {\n        if index < arr.len() {\n            if let Some(val) = arr[index] {\n                let node = Rc::new(RefCell::new(TreeNode::new(val)));\n                node.borrow_mut().left = helper(arr, 2 * index + 1);\n                node.borrow_mut().right = helper(arr, 2 * index + 2);\n                return Some(node);\n            }\n        }\n        None\n    }\n    helper(&arr, 0)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.borrow().val));\n            queue.push_back(n.borrow().left.clone());\n            queue.push_back(n.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeMaximumPathSum(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3]); result = BinaryTreeMaximumPathSum(root); raise 'Test Case 1 Failed' unless result == 6",
        "root = buildTree([-10,9,20,nil,nil,15,7]); result = BinaryTreeMaximumPathSum(root); raise 'Test Case 2 Failed' unless result == 42"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[-10,9,20,null,null,15,7]"
        },
        "expected": "42"
      }
    ]
  },
  "binary-tree-right-side-view": {
    "title": "Binary Tree Right Side View",
    "content": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeRightSideView(root) { return []; }",
      "testCalls": [
        "let root1 = buildTree([1,2,3,null,5,null,4]); if (JSON.stringify(BinaryTreeRightSideView(root1)) !== JSON.stringify([1,3,4])) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([1,2,3,4,null,null,null,5]); if (JSON.stringify(BinaryTreeRightSideView(root2)) !== JSON.stringify([1,3,4,5])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeRightSideView(root: TreeNode | null): number[] {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,2,3,null,5,null,4]))) !== JSON.stringify([1,3,4])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,2,3,4,null,null,null,5]))) !== JSON.stringify([1,3,4,5])) throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,null,3]))) !== JSON.stringify([1,3])) throw new Error('Test Case 3 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(null)) !== JSON.stringify([])) throw new Error('Test Case 4 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift(); if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<int> BinaryTreeRightSideView(TreeNode* root) { return {}; }",
      "testCalls": [
        "int main() { std::vector<int> r1 = BinaryTreeRightSideView(buildTree({1,2,3,-1,5,-1,4})); std::vector<int> e1 = {1,3,4}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<int> r2 = BinaryTreeRightSideView(buildTree({1,2,3,4,-1,-1,-1,5})); std::vector<int> e2 = {1,3,4,5}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<int> r3 = BinaryTreeRightSideView(buildTree({1,-1,3})); std::vector<int> e3 = {1,3}; if (r3 != e3) throw std::runtime_error(\"Test 3 failed\"); return 0; }",
        "int main() { std::vector<int> r4 = BinaryTreeRightSideView(nullptr); std::vector<int> e4 = {}; if (r4 != e4) throw std::runtime_error(\"Test 4 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def BinaryTreeRightSideView(root):\n  return []",
      "testCalls": [
        "root = buildTree([1,2,3,None,5,None,4]); assert BinaryTreeRightSideView(root) == [1,3,4]",
        "root = buildTree([1,2,3,4,None,None,None,5]); assert BinaryTreeRightSideView(root) == [1,3,4,5]",
        "root = buildTree([1,None,3]); assert BinaryTreeRightSideView(root) == [1,3]",
        "root = buildTree([]); assert BinaryTreeRightSideView(root) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 == arr2:\n        return True\n    else:\n        raise AssertionError(f'Arrays not equal: {arr1} != {arr2}')",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public List<Integer> BinaryTreeRightSideView(TreeNode root) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode root1 = m.buildTree(new Integer[]{1,2,3,null,5,null,4}); List<Integer> result1 = m.BinaryTreeRightSideView(root1); if (result1.size() != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode root2 = m.buildTree(new Integer[]{1,2,3,4,null,null,null,5}); List<Integer> result2 = m.BinaryTreeRightSideView(root2); if (result2.size() != 4) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "void BinaryTreeRightSideView(struct TreeNode* root)",
      "testCalls": [
        "int main() { BinaryTreeRightSideView(createTreeFromArray((int[]) {1,2,3,INT_MIN,5,INT_MIN,4}, 7)); return 0; }",
        "int main() { BinaryTreeRightSideView(createTreeFromArray((int[]) {1,2,3,4,INT_MIN,INT_MIN,INT_MIN,5}, 8)); return 0; }"
      ],
      "compareHelper": "void compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { printf(\"Test Failed\"); exit(1); } } }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeRightSideView(root *TreeNode) []int { return nil }",
      "testCalls": [
        "func main() { root := buildTree([]interface{}{1, 2, 3, nil, 5, nil, 4}); if !compareArrays(BinaryTreeRightSideView(root), []int{1, 3, 4}) { panic(\"Test Case 1 Failed\") } }",
        "func main() { root := buildTree([]interface{}{1, 2, 3, 4, nil, nil, nil, 5}); if !compareArrays(BinaryTreeRightSideView(root), []int{1, 3, 4, 5}) { panic(\"Test Case 2 Failed\") } }",
        "func main() { root := buildTree([]interface{}{1, nil, 3}); if !compareArrays(BinaryTreeRightSideView(root), []int{1, 3}) { panic(\"Test Case 3 Failed\") } }",
        "func main() { root := buildTree([]interface{}{}); if !compareArrays(BinaryTreeRightSideView(root), []int{}) { panic(\"Test Case 4 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if arr1[i] != arr2[i] { return false } }; return true }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []interface{}) *TreeNode { if len(arr) == 0 || arr[0] == nil { return nil }; root := &TreeNode{Val: arr[0].(int)}; queue := []*TreeNode{root}; i := 1; for len(queue) > 0 && i < len(arr) { node := queue[0]; queue = queue[1:]; if i < len(arr) && arr[i] != nil { node.Left = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Left) }; i++; if i < len(arr) && arr[i] != nil { node.Right = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Right) }; i++ }; return root }"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeRightSideView(root: Option<Rc<RefCell<TreeNode>>) -> Vec<i32> { }",
      "testCalls": [
        "let root1 = buildTree(vec![Some(1), Some(2), Some(3), None, Some(5), None, Some(4)]); assert_eq!(BinaryTreeRightSideView(root1), vec![1, 3, 4]);",
        "let root2 = buildTree(vec![Some(1), Some(2), Some(3), Some(4), None, None, None, Some(5)]); assert_eq!(BinaryTreeRightSideView(root2), vec![1, 3, 4, 5]);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() { return None; }\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(Rc::clone(&root));\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(Some(node)) = queue.pop_front() {\n            if let Some(Some(val)) = arr.get(i) {\n                let left_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().left = Some(Rc::clone(&left_child));\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if let Some(Some(val)) = arr.get(i) {\n                let right_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().right = Some(Rc::clone(&right_child));\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(Some(node));\n    }\n    while !queue.is_empty() {\n        if let Some(Some(node)) = queue.pop_front() {\n            result.push(Some(node.borrow().val));\n            queue.push_back(node.borrow().left.clone());\n            queue.push_back(node.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    fn helper(arr: &Vec<Option<i32>>, index: usize) -> Option<Rc<RefCell<TreeNode>>> {\n        if index < arr.len() {\n            if let Some(val) = arr[index] {\n                let node = Rc::new(RefCell::new(TreeNode::new(val)));\n                node.borrow_mut().left = helper(arr, 2 * index + 1);\n                node.borrow_mut().right = helper(arr, 2 * index + 2);\n                return Some(node);\n            }\n        }\n        None\n    }\n    helper(&arr, 0)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.borrow().val));\n            queue.push_back(n.borrow().left.clone());\n            queue.push_back(n.borrow().right.clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeRightSideView(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,nil,5,nil,4]); result = BinaryTreeRightSideView(root); assert_equal [1,3,4], result",
        "root = buildTree([1,2,3,4,nil,nil,nil,5]); result = BinaryTreeRightSideView(root); assert_equal [1,3,4,5], result",
        "root = buildTree([1,nil,3]); result = BinaryTreeRightSideView(root); assert_equal [1,3], result",
        "root = buildTree([]); result = BinaryTreeRightSideView(root); assert_equal [], result"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3,null,5,null,4]"
        },
        "expected": "[1,3,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,2,3,4,null,null,null,5]"
        },
        "expected": "[1,3,4,5]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[1,null,3]"
        },
        "expected": "[1,3]"
      },
      {
        "caseNumber": 4,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "binary-tree-zigzag-level-order-traversal": {
    "title": "Binary Tree Zigzag Level Order Traversal",
    "content": "Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeZigzagLevelOrderTraversal(root) { return []; }",
      "testCalls": [
        "let root1 = buildTree([3,9,20,null,null,15,7]); if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(root1)) !== '[[3],[20,9],[15,7]]') throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([1]); if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(root2)) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "let root3 = buildTree([]); if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(root3)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}",
      "builders": "function buildTree(arr) {\n  if (!arr.length) return null;\n  let root = new TreeNode(arr[0]);\n  let queue = [root];\n  let i = 1;\n  while (i < arr.length) {\n    let current = queue.shift();\n    if (arr[i] !== null) {\n      current.left = new TreeNode(arr[i]);\n      queue.push(current.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      current.right = new TreeNode(arr[i]);\n      queue.push(current.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  while (queue.length) {\n    let node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeZigzagLevelOrderTraversal(root: TreeNode | null): number[][]",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(createTreeNode([3,9,20,null,null,15,7]))) !== '[[3],[20,9],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(createTreeNode([1]))) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(null)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift(); if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> ZigzagLevelOrder(TreeNode* root) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> r1 = ZigzagLevelOrder(buildTree({3,9,20,-1,-1,15,7})); std::vector<std::vector<int>> e1 = {{3},{20,9},{15,7}}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r2 = ZigzagLevelOrder(buildTree({1})); std::vector<std::vector<int>> e2 = {{1}}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r3 = ZigzagLevelOrder(nullptr); std::vector<std::vector<int>> e3 = {}; if (r3 != e3) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def BinaryTreeZigzagLevelOrderTraversal(root: [TreeNode]) -> list[list[int]]:\n  return []",
      "testCalls": [
        "root = buildTree([3,9,20,None,None,15,7]); assert BinaryTreeZigzagLevelOrderTraversal(root) == [[3],[20,9],[15,7]], 'Test Case 1 Failed'",
        "root = buildTree([1]); assert BinaryTreeZigzagLevelOrderTraversal(root) == [[1]], 'Test Case 2 Failed'",
        "root = buildTree([]); assert BinaryTreeZigzagLevelOrderTraversal(root) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n      self.val = 0\n      self.left = left\n      self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> BinaryTreeZigzagLevelOrderTraversal(TreeNode root) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode root1 = m.buildTree(new Integer[]{3,9,20,null,null,15,7}); List<List<Integer>> result1 = m.BinaryTreeZigzagLevelOrderTraversal(root1); if (result1.size() != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode root2 = m.buildTree(new Integer[]{1}); List<List<Integer>> result2 = m.BinaryTreeZigzagLevelOrderTraversal(root2); if (result2.size() != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result3 = m.BinaryTreeZigzagLevelOrderTraversal(null); if (result3.size() != 0) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "void BinaryTreeZigzagLevelOrderTraversal(struct TreeNode* root)",
      "testCalls": [
        "BinaryTreeZigzagLevelOrderTraversal(createTreeFromArray((int[]) {3,9,20,INT_MIN,INT_MIN,15,7}, 7));",
        "BinaryTreeZigzagLevelOrderTraversal(createTreeFromArray((int[]) {1}, 1));",
        "BinaryTreeZigzagLevelOrderTraversal(createTreeFromArray((int[]) {}, 0));"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeFromArray(int arr[], int size) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func ZigzagLevelOrderTraversal(root *TreeNode) [][]int { return nil }",
      "testCalls": [
        "func main() { root := buildTree([]interface{}{3, 9, 20, nil, nil, 15, 7}); if !compareArrays(ZigzagLevelOrderTraversal(root), [][]int{{3}, {20, 9}, {15, 7}}) { panic(\"Test Case 1 Failed\") } }",
        "func main() { root := buildTree([]interface{}{1}); if !compareArrays(ZigzagLevelOrderTraversal(root), [][]int{{1}}) { panic(\"Test Case 2 Failed\") } }",
        "func main() { root := buildTree([]interface{}{}); if !compareArrays(ZigzagLevelOrderTraversal(root), [][]int{}) { panic(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if len(arr1[i]) != len(arr2[i]) { return false }; for j := range arr1[i] { if arr1[i][j] != arr2[i][j] { return false } } }; return true }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []interface{}) *TreeNode { if len(arr) == 0 || arr[0] == nil { return nil }; root := &TreeNode{Val: arr[0].(int)}; queue := []*TreeNode{root}; i := 1; for len(queue) > 0 && i < len(arr) { node := queue[0]; queue = queue[1:]; if i < len(arr) && arr[i] != nil { node.Left = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Left) }; i++; if i < len(arr) && arr[i] != nil { node.Right = &TreeNode{Val: arr[i].(int)}; queue = append(queue, node.Right) }; i++ }; return root }"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeZigzagLevelOrderTraversal(root)\nend",
      "testCalls": [
        "root = buildTree([3,9,20,nil,nil,15,7]); result = BinaryTreeZigzagLevelOrderTraversal(root); raise 'Test Case 1 Failed' unless result == [[3],[20,9],[15,7]]",
        "root = buildTree([1]); result = BinaryTreeZigzagLevelOrderTraversal(root); raise 'Test Case 2 Failed' unless result == [[1]]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\n\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "[[3],[20,9],[15,7]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1]"
        },
        "expected": "[[1]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "bitwise-and-of-numbers-range": {
    "title": "Bitwise AND of Numbers Range",
    "content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BitwiseAndOfNumbersRange(left, right) { return 0; }",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(BitwiseAndOfNumbersRange(0, 0) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BitwiseAndOfNumbersRange(left: number, right: number): number { return 0; }",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(BitwiseAndOfNumbersRange(0, 0) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int BitwiseAndOfNumbersRange(int left, int right) { return 0; }",
      "testCalls": [
        "int main() { if (BitwiseAndOfNumbersRange(5, 7) != 4) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (BitwiseAndOfNumbersRange(0, 0) != 0) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (BitwiseAndOfNumbersRange(1, 2147483647) != 0) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def BitwiseAndOfNumbersRange(left: int, right: int) -> int:\n    return 0",
      "testCalls": [
        "assert BitwiseAndOfNumbersRange(5, 7) == 4, 'Test Case 1 Failed'",
        "assert BitwiseAndOfNumbersRange(0, 0) == 0, 'Test Case 2 Failed'",
        "assert BitwiseAndOfNumbersRange(1, 2147483647) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BitwiseAndOfNumbersRange(int left, int right) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if(m.BitwiseAndOfNumbersRange(5, 7) != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.BitwiseAndOfNumbersRange(0, 0) != 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.BitwiseAndOfNumbersRange(1, 2147483647) != 0) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BitwiseAndOfNumbersRange(int left, int right) { return 0; }",
      "testCalls": [
        "int main() { if(BitwiseAndOfNumbersRange(5, 7) != 4) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(BitwiseAndOfNumbersRange(0, 0) != 0) { printf(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BitwiseAndOfNumbersRange(left int, right int) int { return 0 }",
      "testCalls": [
        "func main() { if BitwiseAndOfNumbersRange(5, 7) != 4 { panic(\"Test 1 failed\") } }",
        "func main() { if BitwiseAndOfNumbersRange(0, 0) != 0 { panic(\"Test 2 failed\") } }",
        "func main() { if BitwiseAndOfNumbersRange(1, 2147483647) != 0 { panic(\"Test 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BitwiseAndOfNumbersRange(left: i32, right: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(BitwiseAndOfNumbersRange(5, 7), 4);",
        "assert_eq!(BitwiseAndOfNumbersRange(0, 0), 0);",
        "assert_eq!(BitwiseAndOfNumbersRange(1, 2147483647), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BitwiseAndOfNumbersRange(left, right)\nend",
      "testCalls": [
        "result = BitwiseAndOfNumbersRange(5, 7)\nraise 'Test Case 1 Failed' unless result == 4",
        "result = BitwiseAndOfNumbersRange(0, 0)\nraise 'Test Case 2 Failed' unless result == 0",
        "result = BitwiseAndOfNumbersRange(1, 2147483647)\nraise 'Test Case 3 Failed' unless result == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "left": "5",
          "right": "7"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "left": "0",
          "right": "0"
        },
        "expected": "0"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "left": "1",
          "right": "2147483647"
        },
        "expected": "0"
      }
    ]
  },
  "candy": {
    "title": "Candy",
    "content": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you need to have to distribute the candies to the children.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Candy(ratings) { return 0; }",
      "testCalls": [
        "let ratings1 = [1,0,2]; let head1 = buildLinkedList(ratings1); if (Candy(ratings1) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "let ratings2 = [1,2,2]; let head2 = buildLinkedList(ratings2); if (Candy(ratings2) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "function ListNode(val, next = null) {\n  this.val = val;\n  this.next = next;\n}\n\nfunction buildLinkedList(arr) {\n  if (!arr.length) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head) {\n  let arr = [];\n  let current = head;\n  while (current) {\n    arr.push(current.val);\n    current = current.next;\n  }\n  return arr;\n}"
    },
    "typescript": {
      "functionDeclaration": "function Candy(ratings: number[]): number {}",
      "testCalls": [
        "let ratings1 = [1,0,2]; let head1 = buildLinkedList(ratings1); if (Candy(head1) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "let ratings2 = [1,2,2]; let head2 = buildLinkedList(ratings2); if (Candy(head2) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val: number, next: ListNode | null = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "int Candy(std::vector<int> ratings) { return 0; }",
      "testCalls": [
        "int main() { if (Candy({1,0,2}) != 5) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (Candy({1,2,2}) != 4) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def Candy(ratings: list[int]) -> int:\n  return 0",
      "testCalls": [
        "assert Candy([1,0,2]) == 5",
        "assert Candy([1,2,2]) == 4"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "from typing import List"
    },
    "java": {
      "functionDeclaration": "public int Candy(int[] ratings) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.Candy(new int[]{1,0,2}) != 5) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.Candy(new int[]{1,2,2}) != 4) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int Candy(ListNode* ratings, int ratingsSize)",
      "testCalls": [
        "int main() { ListNode* ratings1 = buildLinkedList((int[]) {1,0,2}, 3); if (Candy(ratings1, 3) != 5) { printf(\"Test Case 1 Failed\\n\"); } return 0; }",
        "int main() { ListNode* ratings2 = buildLinkedList((int[]) {1,2,2}, 3); if (Candy(ratings2, 3) != 4) { printf(\"Test Case 2 Failed\\n\"); } return 0; }"
      ],
      "compareHelper": "",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* buildLinkedList(int* arr, int size) { ListNode* head = NULL; ListNode* curr = NULL; for (int i = 0; i < size; i++) { ListNode* newNode = (ListNode*)malloc(sizeof(ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(ListNode* head, int* size) { int count = 0; ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func Candy(ratings []int) int { return 0 }",
      "testCalls": [
        "func main() { if Candy([]int{1,0,2}) != 5 { panic(\"Test case 1 failed\") } }",
        "func main() { if Candy([]int{1,2,2}) != 4 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn Candy(ratings: Vec<i32>) -> i32 {}",
      "testCalls": [
        "let children = buildCandyChildren(vec![1, 0, 2]); assert_eq!(Candy(buildCandyVec(children)), 5);",
        "let children = buildCandyChildren(vec![1, 2, 2]); assert_eq!(Candy(buildCandyVec(children)), 4);"
      ],
      "compareHelper": "",
      "helpers": "struct CandyChild { rating: i32, candy: i32 }\nfn buildCandyChildren(ratings: Vec<i32>) -> Vec<CandyChild> {}\nfn buildCandyVec(candy_children: Vec<CandyChild>) -> Vec<i32> {}",
      "typeDefs": "struct CandyChild { rating: i32, candy: i32 }",
      "builders": "fn buildCandyChildren(ratings: Vec<i32>) -> Vec<CandyChild> {}\nfn buildCandyVec(candy_children: Vec<CandyChild>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def Candy(ratings)\nend",
      "testCalls": [
        "head = buildLinkedList([1,0,2])\nresult = Candy(head)\nputs(result == 5 ? 'Test case 1 passed' : 'Test case 1 failed')",
        "head = buildLinkedList([1,2,2])\nresult = Candy(head)\nputs(result == 4 ? 'Test case 2 passed' : 'Test case 2 failed')"
      ],
      "compareHelper": "",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "ratings": "[1,0,2]"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "ratings": "[1,2,2]"
        },
        "expected": "4"
      }
    ]
  },
  "climbing-stairs": {
    "title": "Climbing Stairs",
    "content": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "difficulty": "Easy",
    "hints": [
      "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
    ],
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ClimbingStairs(n) { return 0; }",
      "testCalls": [
        "if (ClimbingStairs(2) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (ClimbingStairs(3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ClimbingStairs(n: number): number { return 0; }",
      "testCalls": [
        "if (ClimbingStairs(2) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (ClimbingStairs(3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int ClimbStairs(int n) { return 0; }",
      "testCalls": [
        "int main() { if (ClimbStairs(2) != 2) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (ClimbStairs(3) != 3) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def ClimbingStairs(n: int) -> int: return 0",
      "testCalls": [
        "assert ClimbingStairs(2) == 2",
        "assert ClimbingStairs(3) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int ClimbingStairs(int n) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.ClimbingStairs(2) != 2) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.ClimbingStairs(3) != 3) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int ClimbingStairs(int n) { return 0; }",
      "testCalls": [
        "int main() { if (ClimbingStairs(2) != 2) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (ClimbingStairs(3) != 3) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ClimbStairs(n int) int { return 0 }",
      "testCalls": [
        "func main() { if ClimbStairs(2) != 2 { panic(\"Test case 1 failed\") } }",
        "func main() { if ClimbStairs(3) != 3 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ClimbingStairs(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(ClimbingStairs(2), 2);",
        "assert_eq!(ClimbingStairs(3), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ClimbingStairs(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ClimbingStairs(2) == 2",
        "raise 'Test Case 2 Failed' unless ClimbingStairs(3) == 3"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "2"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "3"
        },
        "expected": "3"
      }
    ]
  },
  "clone-graph": {
    "title": "Clone Graph",
    "content": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\nTest case format:\nFor simplicity, each node value is the same as the node index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CloneGraph(node) { return null; }",
      "testCalls": [
        "const test1 = buildGraph([[2,4],[1,3],[2,4],[1,3]]); if(JSON.stringify(graphToArray(CloneGraph(test1))) !== '[[2,4],[1,3],[2,4],[1,3]]') throw new Error('Test Case 1 Failed');",
        "const test2 = buildGraph([[]]); if(JSON.stringify(graphToArray(CloneGraph(test2))) !== '[[]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "class Node {\n  constructor(val, neighbors = []) {\n    this.val = val;\n    this.neighbors = neighbors;\n  }\n}",
      "builders": "function buildGraph(adjList) {\n  if (!adjList.length) return null;\n  const nodes = adjList.map((_, i) => new Node(i + 1));\n  adjList.forEach((neighbors, i) => {\n    nodes[i].neighbors = neighbors.map(j => nodes[j - 1]);\n  });\n  return nodes[0];\n}\n\nfunction graphToArray(node) {\n  if (!node) return [];\n  const visited = new Map();\n  const result = [];\n  const queue = [node];\n  visited.set(node, 0);\n  while (queue.length) {\n    const current = queue.shift();\n    const index = visited.get(current);\n    result[index] = current.neighbors.map(neighbor => {\n      if (!visited.has(neighbor)) {\n        visited.set(neighbor, visited.size);\n        queue.push(neighbor);\n      }\n      return visited.get(neighbor) + 1;\n    });\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function CloneGraph(node: Node | null): Node | null",
      "testCalls": [
        "const testInput1 = [[2,4],[1,3],[2,4],[1,3]]; const graph1 = buildGraph(testInput1); const result1 = CloneGraph(graph1); if(JSON.stringify(graphToAdjList(result1)) !== '[[2,4],[1,3],[2,4],[1,3]]') throw new Error('Test Case 1 Failed');",
        "const testInput2 = [[]]; const graph2 = buildGraph(testInput2); const result2 = CloneGraph(graph2); if(JSON.stringify(graphToAdjList(result2)) !== '[[]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "class Node { val: number; neighbors: Node[]; ...",
      "builders": "class Node {\n  val: number;\n  neighbors: Node[];\n  constructor(val?: number, neighbors?: Node[]) {\n    this.val = val === undefined ? 0 : val;\n    this.neighbors = neighbors === undefined ? [] : neighbors;\n  }\n}\n\nfunction buildGraph(adjList: number[][]): Node | null {\n  if (adjList.length === 0) return null;\n  const nodes: Node[] = adjList.map((_, i) => new Node(i + 1));\n  for (let i = 0; i < adjList.length; i++) {\n    nodes[i].neighbors = adjList[i].map(j => nodes[j - 1]);\n  }\n  return nodes[0];\n}\n\nfunction graphToAdjList(node: Node | null): number[][] {\n  if (!node) return [];\n  const adjList: number[][] = [];\n  const visited = new Map<Node, number>();\n  const queue: Node[] = [node];\n  visited.set(node, 0);\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    const index = visited.get(current)!;\n    adjList[index] = current.neighbors.map(neighbor => {\n      if (!visited.has(neighbor)) {\n        visited.set(neighbor, visited.size);\n        queue.push(neighbor);\n      }\n      return visited.get(neighbor)! + 1;\n    });\n  }\n  return adjList;\n}"
    },
    "cpp": {
      "functionDeclaration": "Node* CloneGraph(Node* node) { return nullptr; }",
      "testCalls": [
        "int main() { Node* r1 = CloneGraph(buildGraph({{2,4},{1,3},{2,4},{1,3}})); if (!compareGraph(r1, buildGraph({{2,4},{1,3},{2,4},{1,3}}))) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { Node* r2 = CloneGraph(buildGraph({{}})); if (!compareGraph(r2, buildGraph({{}}))) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { Node* r3 = CloneGraph(buildGraph({})); if (!compareGraph(r3, buildGraph({}))) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <stdexcept>\n\nclass Node { public: int val; std::vector<Node*> neighbors; Node(int v = 0) : val(v) {} };\n\nNode* buildGraph(std::vector<std::vector<int>> adjList) { if (adjList.empty()) return nullptr; std::unordered_map<int, Node*> nodes; for (size_t i = 0; i < adjList.size(); i++) nodes[i+1] = new Node(i+1); for (size_t i = 0; i < adjList.size(); i++) { for (int n : adjList[i]) nodes[i+1]->neighbors.push_back(nodes[n]); } return nodes[1]; }\n\nbool compareGraph(Node* n1, Node* n2) { if (!n1 && !n2) return true; if (!n1 || !n2) return false; return n1->val == n2->val && n1->neighbors.size() == n2->neighbors.size(); }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def CloneGraph(node: [Node]) -> [Node]:\n pass",
      "testCalls": [
        "graph = buildGraph([[2,4],[1,3],[2,4],[1,3]])\nresult1 = graphToAdjList(CloneGraph(graph))\nif result1 != [[2,4],[1,3],[2,4],[1,3]]:\n    raise AssertionError('Test Case 1 Failed')",
        "graph = buildGraph([[]])\nresult2 = graphToAdjList(CloneGraph(graph))\nif result2 != [[]]:\n    raise AssertionError('Test Case 2 Failed')"
      ],
      "compareHelper": "",
      "typeDefs": "class Node:\n    def __init__(self, val = 0, neighbors = []):\n        self.val = val\n        self.neighbors = neighbors",
      "builders": "def buildGraph(adjList):\n    nodes = {}\n    for i in range(len(adjList)):\n        nodes[i+1] = Node(i+1)\n    for i in range(len(adjList)):\n        for neighbor in adjList[i]:\n            nodes[i+1].neighbors.append(nodes[neighbor])\n    return nodes[1] if nodes else None\n\ndef graphToAdjList(node):\n    adjList = []\n    if not node:\n        return adjList\n    visited = set()\n    queue = [node]\n    while queue:\n        curr = queue.pop(0)\n        if curr.val not in visited:\n            visited.add(curr.val)\n            neighbors = [neighbor.val for neighbor in curr.neighbors]\n            adjList.append(neighbors)\n            for neighbor in curr.neighbors:\n                queue.append(neighbor)\n    return adjList"
    },
    "java": {
      "functionDeclaration": "public Node cloneGraph(Node node) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); Node test1 = m.cloneGraph(m.buildGraph(new int[][]{{2,4},{1,3},{2,4},{1,3}})); if (!m.compareGraph(test1, m.buildGraph(new int[][]{{2,4},{1,3},{2,4},{1,3}}))) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); Node test2 = m.cloneGraph(m.buildGraph(new int[][]{{}})); if (!m.compareGraph(test2, m.buildGraph(new int[][]{{}}))) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass Node { public int val; public List<Node> neighbors; public Node() { val = 0; neighbors = new ArrayList<>(); } public Node(int v) { val = v; neighbors = new ArrayList<>(); } }\n\npublic Node buildGraph(int[][] adjList) { if (adjList.length == 0) return null; Map<Integer, Node> nodes = new HashMap<>(); for (int i = 0; i < adjList.length; i++) nodes.put(i + 1, new Node(i + 1)); for (int i = 0; i < adjList.length; i++) { for (int n : adjList[i]) nodes.get(i + 1).neighbors.add(nodes.get(n)); } return nodes.get(1); }\n\npublic boolean compareGraph(Node n1, Node n2) { if (n1 == null && n2 == null) return true; if (n1 == null || n2 == null) return false; return n1.val == n2.val && n1.neighbors.size() == n2.neighbors.size(); }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "Node* CloneGraph(Node* node)",
      "testCalls": [
        "int adjacencyList1_1[] = {2}; int adjacencyList1_2[] = {1}; int* adjacencyList1[] = {adjacencyList1_1, adjacencyList1_2}; int adjacencyListSize1 = 2; int adjacencyListColSize1[] = {1, 1}; Node* node1 = buildGraph(2, adjacencyList1, adjacencyListSize1, adjacencyListColSize1); Node* test1 = CloneGraph(node1); int returnSize1; int* returnColumnSizes1; int** result1 = graphToArray(test1, &returnSize1, &returnColumnSizes1); if (returnSize1 != 1 || result1[0][0] != 2) { printf(\"Test Case 1 Failed\"); }",
        "int adjacencyList2_1[] = {2, 4}; int adjacencyList2_2[] = {1, 3}; int adjacencyList2_3[] = {2, 4}; int adjacencyList2_4[] = {1, 3}; int* adjacencyList2[] = {adjacencyList2_1, adjacencyList2_2, adjacencyList2_3, adjacencyList2_4}; int adjacencyListSize2 = 4; int adjacencyListColSize2[] = {2, 2, 2, 2}; Node* node2 = buildGraph(4, adjacencyList2, adjacencyListSize2, adjacencyListColSize2); Node* test2 = CloneGraph(node2); int returnSize2; int* returnColumnSizes2; int** result2 = graphToArray(test2, &returnSize2, &returnColumnSizes2); if (returnSize2 != 2 || (result2[0][0] != 2 && result2[1][0] != 4)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareGraph(Node* graph1, Node* graph2) { return 0; }",
      "typeDefs": "typedef struct Node { int val; struct Node** neighbors; int neighborsSize; } Node;",
      "builders": "Node* createNode(int val, int neighborsSize) { Node* newNode = (Node*)malloc(sizeof(Node)); newNode->val = val; newNode->neighbors = (Node**)malloc(neighborsSize * sizeof(Node*)); newNode->neighborsSize = neighborsSize; return newNode; }\nNode* buildGraph(int numNodes, int** adjacencyList, int adjacencyListSize, int* adjacencyListColSize) { Node** nodes = (Node**)malloc(numNodes * sizeof(Node*)); for (int i = 0; i < numNodes; i++) { nodes[i] = createNode(i+1, adjacencyListColSize[i]); } for (int i = 0; i < numNodes; i++) { for (int j = 0; j < adjacencyListColSize[i]; j++) { nodes[i]->neighbors[j] = nodes[adjacencyList[i][j]-1]; } } return nodes[0]; }\nint** graphToArray(Node* node, int* returnSize, int** returnColumnSizes) { *returnSize = node->neighborsSize; *returnColumnSizes = (int*)malloc(node->neighborsSize * sizeof(int)); int** result = (int**)malloc(node->neighborsSize * sizeof(int*)); for (int i = 0; i < node->neighborsSize; i++) { (*returnColumnSizes)[i] = 1; result[i] = (int*)malloc(sizeof(int)); result[i][0] = node->neighbors[i]->val; } return result; }"
    },
    "go": {
      "functionDeclaration": "func CloneGraph(node *Node) *Node { return nil }",
      "testCalls": [
        "func main() { result := CloneGraph(buildGraph([][]int{{2,4},{1,3},{2,4},{1,3}})); if result == nil { panic(\"Test Case 1 Failed\") } }",
        "func main() { result := CloneGraph(buildGraph([][]int{{}})); if result == nil { panic(\"Test Case 2 Failed\") } }",
        "func main() { result := CloneGraph(nil); if result != nil { panic(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": "func compareGraphs(node1, node2 *Node) bool { if node1 == nil && node2 == nil { return true }; if node1 == nil || node2 == nil { return false }; return node1.Val == node2.Val && len(node1.Neighbors) == len(node2.Neighbors) }",
      "typeDefs": "type Node struct {\n    Val       int\n    Neighbors []*Node\n}",
      "builders": "func buildGraph(adjList [][]int) *Node {\n    if len(adjList) == 0 {\n        return nil\n    }\n\n    nodes := make(map[int]*Node)\n\n    for i := range adjList {\n        val := i + 1\n        if _, ok := nodes[val]; !ok {\n            nodes[val] = &Node{Val: val}\n        }\n\n        for _, neighborVal := range adjList[i] {\n            if _, ok := nodes[neighborVal]; !ok {\n                nodes[neighborVal] = &Node{Val: neighborVal}\n            }\n            nodes[val].Neighbors = append(nodes[val].Neighbors, nodes[neighborVal])\n        }\n    }\n\n    return nodes[1]\n}\n"
    },
    "rust": {
      "functionDeclaration": "fn CloneGraph(adj_list: Vec<Vec<i32>>) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let test_case_1 = buildGraph(vec![vec![2, 4], vec![1, 3], vec![2, 4], vec![1, 3]]); assert_eq!(graphToAdjList(CloneGraph(test_case_1)), vec![vec![2, 4], vec![1, 3], vec![2, 4], vec![1, 3]]);",
        "let test_case_2 = buildGraph(vec![vec![]]); assert_eq!(graphToAdjList(CloneGraph(test_case_2)), vec![vec![]]);",
        "let test_case_3 = buildGraph(vec![]); assert_eq!(graphToAdjList(CloneGraph(test_case_3)), vec![]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: &Vec<Vec<i32>>, arr2: &Vec<Vec<i32>>) { assert_eq!(arr1, arr2); }",
      "helpers": "struct Node { val: i32, neighbors: Vec<Node> }\nfn buildGraph(adj_list: Vec<Vec<i32>>) -> Vec<Node> { let mut nodes = vec![]; for _ in 0..adj_list.len() { nodes.push(Node { val: 0, neighbors: vec![] }); } for (i, neighbors) in adj_list.iter().enumerate() { nodes[i].val = (i + 1) as i32; for &neighbor in neighbors { nodes[i].neighbors.push(nodes[(neighbor - 1) as usize].clone()); } } nodes }\nfn graphToAdjList(nodes: Vec<Node>) -> Vec<Vec<i32>> { let mut adj_list = vec![]; for node in nodes { let mut neighbors = vec![]; for neighbor in node.neighbors { neighbors.push(neighbor.val); } adj_list.push(neighbors); } adj_list }",
      "typeDefs": "struct Node { val: i32, neighbors: Vec<Node> }",
      "builders": "fn buildGraph(adj_list: Vec<Vec<i32>>) -> Vec<Node> { let mut nodes = vec![]; for _ in 0..adj_list.len() { nodes.push(Node { val: 0, neighbors: vec![] }); } for (i, neighbors) in adj_list.iter().enumerate() { nodes[i].val = (i + 1) as i32; for &neighbor in neighbors { nodes[i].neighbors.push(nodes[(neighbor - 1) as usize].clone()); } } nodes }\nfn graphToAdjList(nodes: Vec<Node>) -> Vec<Vec<i32>> { let mut adj_list = vec![]; for node in nodes { let mut neighbors = vec![]; for neighbor in node.neighbors { neighbors.push(neighbor.val); } adj_list.push(neighbors); } adj_list }"
    },
    "ruby": {
      "functionDeclaration": "def CloneGraph(node)\n  return nil\nend",
      "testCalls": [
        "node1 = Node.new(1); node2 = Node.new(2); node3 = Node.new(3); node4 = Node.new(4); node1.neighbors = [node2, node4]; node2.neighbors = [node1, node3]; node3.neighbors = [node2, node4]; node4.neighbors = [node1, node3]; result1 = CloneGraph(node1); raise 'Test Case 1 Failed' unless result1.nil?",
        "node1 = Node.new(1); result2 = CloneGraph(node1); raise 'Test Case 2 Failed' unless result2.nil?",
        "node = nil; result3 = CloneGraph(node); raise 'Test Case 3 Failed' unless result3.nil?"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :neighbors\n  def initialize(val = 0, neighbors = [])\n    @val = val\n    @neighbors = neighbors\n  end\nend",
      "builders": "def buildGraph(nodes)\n  return nil if nodes.empty?\n  node_map = {}\n  nodes.each { |val, neighbors| node_map[val] = Node.new(val) }\n  nodes.each do |val, neighbors|\n    node = node_map[val]\n    neighbors.each { |neighbor_val| node.neighbors << node_map[neighbor_val] }\n  end\n  node_map[nodes[0][0]]\nend\n\ndef graphToNodes(node)\n  return [] if node.nil?\n  visited = Set.new\n  result = []\n  queue = [node]\n  while !queue.empty?\n    current = queue.shift\n    next if visited.include?(current)\n    visited.add(current)\n    neighbors = current.neighbors.map { |neighbor| neighbor.val }\n    result << [current.val, neighbors]\n    queue.concat(current.neighbors)\n  end\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "adjList": "[[2,4],[1,3],[2,4],[1,3]]"
        },
        "expected": "[[2,4],[1,3],[2,4],[1,3]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "adjList": "[[]]"
        },
        "expected": "[[]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "adjList": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "coin-change": {
    "title": "Coin Change",
    "content": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CoinChange(coins, amount) { return 0; }",
      "testCalls": [
        "if(CoinChange([1,2,5], 11) !== 3) throw new Error('Test Case 1 Failed');",
        "if(CoinChange([2], 3) !== -1) throw new Error('Test Case 2 Failed');",
        "if(CoinChange([1], 0) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function CoinChange(coins: number[], amount: number): number { return 0; }",
      "testCalls": [
        "if (CoinChange([1,2,5], 11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (CoinChange([2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }",
        "if (CoinChange([1], 0) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int CoinChange(std::vector<int> coins, int amount) { return 0; }",
      "testCalls": [
        "int main() { if (CoinChange({1,2,5}, 11) != 3) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (CoinChange({2}, 3) != -1) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (CoinChange({1}, 0) != 0) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def CoinChange(coins: list[int], amount: int) -> int:\n pass",
      "testCalls": [
        "assert CoinChange([1,2,5], 11) == 3, 'Test Case 1 Failed'",
        "assert CoinChange([2], 3) == -1, 'Test Case 2 Failed'",
        "assert CoinChange([1], 0) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int coinChange(int[] coins, int amount) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.coinChange(new int[]{1,2,5}, 11) != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.coinChange(new int[]{2}, 3) != -1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.coinChange(new int[]{1}, 0) != 0) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int CoinChange(int* coins, int coinsSize, int amount)",
      "testCalls": [
        "int main() { if (CoinChange((int[]) {1, 2, 5}, 3, 11) != 3) { printf(\"Test case 1 failed\"); }",
        "if (CoinChange((int[]) {2}, 1, 3) != -1) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func CoinChange(coins []int, amount int) int { return 0 }",
      "testCalls": [
        "func main() { if CoinChange([]int{1,2,5}, 11) != 3 { panic(\"Test case 1 failed\") } }",
        "func main() { if CoinChange([]int{2}, 3) != -1 { panic(\"Test case 2 failed\") } }",
        "func main() { if CoinChange([]int{1}, 0) != 0 { panic(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn CoinChange(coins: Vec<i32>, amount: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(CoinChange(vec![1, 2, 5], 11), 3);",
        "assert_eq!(CoinChange(vec![2], 3), -1);",
        "assert_eq!(CoinChange(vec![1], 0), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def CoinChange(coins, amount)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless CoinChange([1,2,5], 11) == 3",
        "raise 'Test Case 2 Failed' unless CoinChange([2], 3) == -1",
        "raise 'Test Case 3 Failed' unless CoinChange([1], 0) == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "coins": "[1,2,5]",
          "amount": "11"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "coins": "[2]",
          "amount": "3"
        },
        "expected": "-1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "coins": "[1]",
          "amount": "0"
        },
        "expected": "0"
      }
    ]
  },
  "combination-sum": {
    "title": "Combination Sum",
    "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CombinationSum(candidates, target) { return []; }",
      "testCalls": [
        "const testOutput1 = CombinationSum([2,3,6,7], 7); if(JSON.stringify(testOutput1) !== '[[2,2,3],[7]]') { throw new Error('Test Case 1 Failed'); }",
        "const testOutput2 = CombinationSum([2,3,5], 8); if(JSON.stringify(testOutput2) !== '[[2,2,2,2],[2,3,3],[3,5]]') { throw new Error('Test Case 2 Failed'); }",
        "const testOutput3 = CombinationSum([2], 1); if(JSON.stringify(testOutput3) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function CombinationSum(candidates: number[], target: number): number[][] { }",
      "testCalls": [
        "if (JSON.stringify(CombinationSum([2,3,6,7], 7)) !== '[[2,2,3],[7]]') { throw new Error('Test Case 1 Failed'); }",
        "if (JSON.stringify(CombinationSum([2,3,5], 8)) !== '[[2,2,2,2],[2,3,3],[3,5]]') { throw new Error('Test Case 2 Failed'); }",
        "if (JSON.stringify(CombinationSum([2], 1)) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> CombinationSum(std::vector<int> candidates, int target) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> r1 = CombinationSum({2,3,6,7}, 7); std::vector<std::vector<int>> e1 = {{2,2,3},{7}}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r2 = CombinationSum({2,3,5}, 8); std::vector<std::vector<int>> e2 = {{2,2,2,2},{2,3,3},{3,5}}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r3 = CombinationSum({2}, 1); std::vector<std::vector<int>> e3 = {}; if (r3 != e3) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def CombinationSum(candidates: list[int], target: int) -> list[list[int]]:\n return []",
      "testCalls": [
        "result1 = CombinationSum([2,3,6,7], 7)\nassert result1 == [[2,2,3],[7]], f'Expected [[2,2,3],[7]], but got {result1}'",
        "result2 = CombinationSum([2,3,5], 8)\nassert result2 == [[2,2,2,2],[2,3,3],[3,5]], f'Expected [[2,2,2,2],[2,3,3],[3,5]], but got {result2}'",
        "result3 = CombinationSum([2], 1)\nassert result3 == [], f'Expected [], but got {result3}'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> combinationSum(int[] candidates, int target) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result1 = m.combinationSum(new int[]{2,3,6,7}, 7); List<List<Integer>> expected1 = Arrays.asList(Arrays.asList(2,2,3), Arrays.asList(7)); if (!m.compareLists(result1, expected1)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result2 = m.combinationSum(new int[]{2,3,5}, 8); List<List<Integer>> expected2 = Arrays.asList(Arrays.asList(2,2,2,2), Arrays.asList(2,3,3), Arrays.asList(3,5)); if (!m.compareLists(result2, expected2)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result3 = m.combinationSum(new int[]{2}, 1); if (result3.size() != 0) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nprivate boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) { if (list1.size() != list2.size()) return false; for (List<Integer> l : list1) { boolean found = false; for (List<Integer> l2 : list2) { if (l.size() == l2.size() && l.containsAll(l2)) { found = true; break; } } if (!found) return false; } return true; }"
    },
    "c": {
      "functionDeclaration": "void CombinationSum(int* candidates, int candidatesSize, int target)",
      "testCalls": [
        "int main() { CombinationSum((int[]){2,3,6,7}, 4, 7); return 0; }",
        "int main() { CombinationSum((int[]){2,3,5}, 3, 8); return 0; }",
        "int main() { CombinationSum((int[]){2}, 1, 1); return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n  if(size1 != size2) return 0;\n  for(int i = 0; i < size1; i++) {\n    if(arr1[i] != arr2[i]) return 0;\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func CombinationSum(candidates []int, target int) [][]int { return [][]int{} }",
      "testCalls": [
        "func main() { result1 := CombinationSum([]int{2,3,6,7}, 7); if !compareArrays(result1, [][]int{{2,2,3},{7}}) {panic(\"Test case 1 failed\")} }",
        "func main() { result2 := CombinationSum([]int{2,3,5}, 8); if !compareArrays(result2, [][]int{{2,2,2,2},{2,3,3},{3,5}}) {panic(\"Test case 2 failed\")} }",
        "func main() { result3 := CombinationSum([]int{2}, 1); if !compareArrays(result3, [][]int{}) {panic(\"Test case 3 failed\")} }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn CombinationSum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = CombinationSum(vec![2,3,6,7], 7); assert_eq!(result1, vec![vec![2,2,3], vec![7]]);",
        "let result2 = CombinationSum(vec![2,3,5], 8); assert_eq!(result2, vec![vec![2,2,2,2], vec![2,3,3], vec![3,5]]);",
        "let result3 = CombinationSum(vec![2], 1); assert_eq!(result3, vec![]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) -> bool { arr1.len() == arr2.len() && arr1.iter().all(|x| arr2.contains(x)) }"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "candidates": "[2,3,6,7]",
          "target": "7"
        },
        "expected": "[[2,2,3],[7]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "candidates": "[2,3,5]",
          "target": "8"
        },
        "expected": "[[2,2,2,2],[2,3,3],[3,5]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "candidates": "[2]",
          "target": "1"
        },
        "expected": "[]"
      }
    ]
  },
  "combinations": {
    "title": "Combinations",
    "content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Combinations(n, k) { return []; }",
      "testCalls": [
        "const test1 = Combinations(4, 2); if(JSON.stringify(test1) !== '[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Combinations(1, 1); if(JSON.stringify(test2) !== '[[1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function Combinations(n: number, k: number): number[][] { return []; }",
      "testCalls": [
        "const test1 = Combinations(4, 2); if(JSON.stringify(test1) !== '[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Combinations(1, 1); if(JSON.stringify(test2) !== '[[1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> Combinations(int n, int k) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> r1 = Combinations(4, 2); std::vector<std::vector<int>> e1 = {{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r2 = Combinations(1, 1); std::vector<std::vector<int>> e2 = {{1}}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def Combinations(n: int, k: int) -> list[list[int]]: return []",
      "testCalls": [
        "assert Combinations(4, 2) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]], 'Test Case 1 Failed'",
        "assert Combinations(1, 1) == [[1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> Combinations(int n, int k) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result1 = m.Combinations(4, 2); if (!m.compareLists(result1, Arrays.asList(Arrays.asList(1,2), Arrays.asList(1,3), Arrays.asList(1,4), Arrays.asList(2,3), Arrays.asList(2,4), Arrays.asList(3,4)))) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result2 = m.Combinations(1, 1); if (!m.compareLists(result2, Arrays.asList(Arrays.asList(1)))) throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) { return list1.containsAll(list2) && list2.containsAll(list1); }"
    },
    "c": {
      "functionDeclaration": "int** Combinations(int n, int k)",
      "testCalls": [
        "int main() { int** result1 = Combinations(4, 2); return 0; }",
        "int main() { int** result2 = Combinations(1, 1); return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n    for (int i = 0; i < size; i++) {\n        if (arr1[i] != arr2[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func Combinations(n int, k int) [][]int { return nil }",
      "testCalls": [
        "func main() { result := Combinations(4, 2); if len(result) != 6 { panic(\"Test case 1 failed\") } }",
        "func main() { result := Combinations(1, 1); if len(result) != 1 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if len(arr1[i]) != len(arr2[i]) { return false }; for j := range arr1[i] { if arr1[i][j] != arr2[i][j] { return false } } }; return true }"
    },
    "rust": {
      "functionDeclaration": "fn Combinations(n: i32, k: i32) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(Combinations(4, 2), vec![vec![1, 2], vec![1, 3], vec![1, 4], vec![2, 3], vec![2, 4], vec![3, 4]]);",
        "assert_eq!(Combinations(1, 1), vec![vec![1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: &Vec<Vec<i32>>, arr2: &Vec<Vec<i32>>) { assert_eq!(arr1.len(), arr2.len()); for i in 0..arr1.len() { assert_eq!(arr1[i], arr2[i]); }}"
    },
    "ruby": {
      "functionDeclaration": "def Combinations(n, k)\nend",
      "testCalls": [
        "test_case_1 = Combinations(4, 2)\nraise 'Test Case 1 Failed' unless test_case_1 == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
        "test_case_2 = Combinations(1, 1)\nraise 'Test Case 2 Failed' unless test_case_2 == [[1]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "4",
          "k": "2"
        },
        "expected": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "1",
          "k": "1"
        },
        "expected": "[[1]]"
      }
    ]
  },
  "construct-binary-tree-from-inorder-and-postorder-traversal": {
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "content": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder) { return buildTree(inorder, postorder); }",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3]); if (JSON.stringify(treeToArray(result1)) !== JSON.stringify([3,9,20,null,null,15,7])) throw new Error('Test Case 1 Failed');",
        "let result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1]); if (JSON.stringify(treeToArray(result2)) !== JSON.stringify([-1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}",
      "builders": "function buildTree(inorder, postorder) {\n  if (!inorder.length || !postorder.length) return null;\n  const rootVal = postorder.pop();\n  const root = new TreeNode(rootVal);\n  const index = inorder.indexOf(rootVal);\n  root.right = buildTree(inorder.slice(index + 1), postorder);\n  root.left = buildTree(inorder.slice(0, index), postorder);\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function BuildTree(inorder: number[], postorder: number[]): TreeNode | null",
      "testCalls": [
        "let result1 = BuildTree([9,3,15,20,7], [9,15,7,20,3]); if (!compareTrees(result1, buildTree([3,9,20,null,null,15,7]))) throw new Error('Test Case 1 Failed');",
        "let result2 = BuildTree([-1], [-1]); if (!compareTrees(result2, buildTree([-1]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "compareTrees",
      "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "builders": "function buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n  if (!inorder.length || !postorder.length) return null;\n  const rootVal = postorder.pop()!;\n  const root = new TreeNode(rootVal);\n  const index = inorder.indexOf(rootVal);\n  root.right = buildTree(inorder.slice(index + 1), postorder);\n  root.left = buildTree(inorder.slice(0, index), postorder);\n  return root;\n}\n\nfunction compareTrees(tree1: TreeNode | null, tree2: TreeNode | null): boolean {\n  if (!tree1 && !tree2) return true;\n  if (!tree1 || !tree2 || tree1.val !== tree2.val) return false;\n  return compareTrees(tree1.left, tree2.left) && compareTrees(tree1.right, tree2.right);\n}"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* BuildTreeFromInorderAndPostorder(std::vector<int> inorder, std::vector<int> postorder) { return nullptr; }",
      "testCalls": [
        "int main() { TreeNode* r1 = BuildTreeFromInorderAndPostorder({9,3,15,20,7}, {9,15,7,20,3}); std::vector<int> e1 = {3,9,20,-1,-1,15,7}; if (treeToArray(r1) != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { TreeNode* r2 = BuildTreeFromInorderAndPostorder({-1}, {-1}); std::vector<int> e2 = {-1}; if (treeToArray(r2) != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nstd::vector<int> treeToArray(TreeNode* root) { if (!root) return {}; std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (!result.empty() && result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder: list[int], postorder: list[int]) -> [TreeNode]:\n    return buildTree(inorder, postorder)",
      "testCalls": [
        "inorder = [9,3,15,20,7]\npostorder = [9,15,7,20,3]\nresult = ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder)\nif treeToArray(result) != [3,9,20,None,None,15,7]:\n    raise Exception('Test Case 1 Failed')",
        "inorder = [-1]\npostorder = [-1]\nresult = ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder)\nif treeToArray(result) != [-1]:\n    raise Exception('Test Case 2 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result\n\ndef buildTree(inorder, postorder):\n    if not inorder:\n        return None\n    def build(in_start, in_end, post_start, post_end):\n        if in_start > in_end:\n            return None\n        root_val = postorder[post_end]\n        root = TreeNode(root_val)\n        in_index = inorder.index(root_val)\n        left_size = in_index - in_start\n        root.left = build(in_start, in_index - 1, post_start, post_start + left_size - 1)\n        root.right = build(in_index + 1, in_end, post_start + left_size, post_end - 1)\n        return root\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)"
    },
    "java": {
      "functionDeclaration": "public TreeNode buildTree(int[] inorder, int[] postorder) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode result1 = m.buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3}); TreeNode expected1 = m.buildExpected(new Integer[]{3,9,20,null,null,15,7}); if (!m.compareTrees(result1, expected1)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode result2 = m.buildTree(new int[]{-1}, new int[]{-1}); if (result2 == null || result2.val != -1) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildExpected(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\n\npublic boolean compareTrees(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right); }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "TreeNode* BuildTree(int* inorder, int inorderSize, int* postorder, int postorderSize)",
      "testCalls": [
        "int main() { TreeNode* result1 = BuildTree((int[]){9,3,15,20,7}, 5, (int[]){9,15,7,20,3}, 5); int expected1[] = {3,9,20,-1,-1,15,7}; if (!CompareTrees(result1, CreateTree(expected1, 7))) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { TreeNode* result2 = BuildTree((int[]){-1}, 1, (int[]){-1}, 1); int expected2[] = {-1}; if (!CompareTrees(result2, CreateTree(expected2, 1))) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": "void compareArrays(TreeNode* result, int* expected, int size) { int* resultArr = treeToArray(result); for (int i = 0; i < size; i++) { if (resultArr[i] != expected[i]) { printf(\"Test case failed\"); return; } } }",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func BuildTree(inorder []int, postorder []int) *TreeNode { return nil }",
      "testCalls": [
        "func main() { root := BuildTree([]int{9,3,15,20,7}, []int{9,15,7,20,3}); if root == nil || root.Val != 3 { panic(\"Test case 1 failed\") } }",
        "func main() { root := BuildTree([]int{-1}, []int{-1}); if root == nil || root.Val != -1 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "func compareTrees(tree1, tree2 *TreeNode) bool { if tree1 == nil && tree2 == nil { return true }; if tree1 == nil || tree2 == nil { return false }; return tree1.Val == tree2.Val && compareTrees(tree1.Left, tree2.Left) && compareTrees(tree1.Right, tree2.Right) }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func treeToArray(root *TreeNode) []interface{} { if root == nil { return nil }; result := []interface{}{}; queue := []*TreeNode{root}; for len(queue) > 0 { node := queue[0]; queue = queue[1:]; if node != nil { result = append(result, node.Val); queue = append(queue, node.Left, node.Right) } else { result = append(result, nil) } }; for len(result) > 0 && result[len(result)-1] == nil { result = result[:len(result)-1] }; return result }"
    },
    "rust": {
      "functionDeclaration": "fn ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Box<TreeNode>> { }",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal(vec![9,3,15,20,7], vec![9,15,7,20,3]); assert_eq!(treeToArray(result1), vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);",
        "let result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal(vec![-1], vec![-1]); assert_eq!(treeToArray(result2), vec![Some(-1)]);"
      ],
      "compareHelper": "fn compare_trees(tree1: Option<Box<TreeNode>>, tree2: Option<Box<TreeNode>>) -> bool { if let (Some(node1), Some(node2)) = (tree1, tree2) { node1.val == node2.val && compare_trees(node1.left.clone(), node2.left.clone()) && compare_trees(node1.right.clone(), node2.right.clone()) } else { tree1.is_none() && tree2.is_none() } }",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}",
      "typeDefs": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}"
    },
    "ruby": {
      "functionDeclaration": "def ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder)\nend",
      "testCalls": [
        "result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3]); raise 'Test Case 1 Failed' unless treeToArray(result1) == [3,9,20,nil,nil,15,7]",
        "result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1]); raise 'Test Case 2 Failed' unless treeToArray(result2) == [-1]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(inorder, postorder)\nend\n\ndef treeToArray(root)\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "inorder": "[9,3,15,20,7]",
          "postorder": "[9,15,7,20,3]"
        },
        "expected": "[3,9,20,null,null,15,7]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "inorder": "[-1]",
          "postorder": "[-1]"
        },
        "expected": "[-1]"
      }
    ]
  },
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "content": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder) { return buildTree(preorder, inorder); }",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); if (JSON.stringify(treeToArray(result1)) !== JSON.stringify([3,9,20,null,null,15,7])) throw new Error('Test Case 1 Failed');",
        "let result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); if (JSON.stringify(treeToArray(result2)) !== JSON.stringify([-1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "class TreeNode { constructor(val, left = null, right = null) { this.val = val; this.left = left; this.right = right; } }",
      "builders": "function buildTree(preorder, inorder) { if (!preorder.length || !inorder.length) return null; const rootVal = preorder[0]; const root = new TreeNode(rootVal); const mid = inorder.indexOf(rootVal); root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid)); root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1)); return root; }"
    },
    "typescript": {
      "functionDeclaration": "function ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder: number[], inorder: number[]): TreeNode | null {}",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); if (!compareTrees(result1, buildTree([3,9,20,null,null,15,7]))) throw new Error('Test Case 1 Failed');",
        "let result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); if (!compareTrees(result2, buildTree([-1]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "compareTrees",
      "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "builders": "function buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n  if (!preorder.length || !inorder.length) return null;\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n  const mid = inorder.indexOf(rootVal);\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n  return root;\n}\n\nfunction compareTrees(tree1: TreeNode | null, tree2: TreeNode | null): boolean {\n  if (!tree1 && !tree2) return true;\n  if (!tree1 || !tree2) return false;\n  return (\n    tree1.val === tree2.val &&\n    compareTrees(tree1.left, tree2.left) &&\n    compareTrees(tree1.right, tree2.right)\n  );\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* ConstructBinaryTreeFromPreorderAndInorderTraversal(std::vector<int> preorder, std::vector<int> inorder) { return nullptr; }",
      "testCalls": [
        "int main() { TreeNode* r1 = ConstructBinaryTreeFromPreorderAndInorderTraversal({3,9,20,15,7}, {9,3,15,20,7}); std::vector<int> e1 = {3,9,20,-1,-1,15,7}; if (treeToArray(r1) != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { TreeNode* r2 = ConstructBinaryTreeFromPreorderAndInorderTraversal({-1}, {-1}); std::vector<int> e2 = {-1}; if (treeToArray(r2) != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nstd::vector<int> treeToArray(TreeNode* root) { if (!root) return {}; std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (!result.empty() && result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def ConstructBinaryTreeFromPreorderAndInorder(preorder: list[int], inorder: list[int]) -> [TreeNode]:\n    return buildTree(preorder)",
      "testCalls": [
        "preorder = [3,9,20,15,7]\ninorder = [9,3,15,20,7]\nresult = ConstructBinaryTreeFromPreorderAndInorder(preorder, inorder)\nif treeToArray(result) != [3,9,20,None,None,15,7]:\n    raise Exception('Test Case 1 Failed')",
        "preorder = [-1]\ninorder = [-1]\nresult = ConstructBinaryTreeFromPreorderAndInorder(preorder, inorder)\nif treeToArray(result) != [-1]:\n    raise Exception('Test Case 2 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(preorder):\n    if not preorder:\n        return None\n    def build(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        in_index = inorder.index(root_val)\n        left_size = in_index - in_start\n        root.left = build(pre_start + 1, pre_start + left_size, in_start, in_index - 1)\n        root.right = build(pre_start + left_size + 1, pre_end, in_index + 1, in_end)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode buildTree(int[] preorder, int[] inorder) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode result1 = m.buildTree(new int[]{3,9,20,15,7}, new int[]{9,3,15,20,7}); TreeNode expected1 = m.buildExpected(new Integer[]{3,9,20,null,null,15,7}); if (!m.compareTrees(result1, expected1)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode result2 = m.buildTree(new int[]{-1}, new int[]{-1}); if (result2 == null || result2.val != -1) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildExpected(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\n\npublic boolean compareTrees(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right); }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "TreeNode* BuildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)",
      "testCalls": [
        "int main() { TreeNode* result1 = BuildTree((int[]){3,9,20,15,7}, 5, (int[]){9,3,15,20,7}, 5); int expected1[] = {3,9,20,-1,-1,15,7}; if (!CompareTrees(result1, CreateTree(expected1, 7))) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { TreeNode* result2 = BuildTree((int[]){-1}, 1, (int[]){-1}, 1); int expected2[] = {-1}; if (!CompareTrees(result2, CreateTree(expected2, 1))) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": "bool CompareTrees(TreeNode* tree1, TreeNode* tree2) { if (!tree1 && !tree2) return true; if (!tree1 || !tree2) return false; return tree1->val == tree2->val && CompareTrees(tree1->left, tree2->left) && CompareTrees(tree1->right, tree2->right); }",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder []int, inorder []int) *TreeNode { return nil }",
      "testCalls": [
        "func main() { root := ConstructBinaryTreeFromPreorderAndInorderTraversal([]int{3,9,20,15,7}, []int{9,3,15,20,7}); if root == nil || root.Val != 3 { panic(\"Test 1 Failed\") } }",
        "func main() { root := ConstructBinaryTreeFromPreorderAndInorderTraversal([]int{-1}, []int{-1}); if root == nil || root.Val != -1 { panic(\"Test 2 Failed\") } }"
      ],
      "compareHelper": "func compareTrees(tree1, tree2 *TreeNode) bool { if tree1 == nil && tree2 == nil { return true }; if tree1 == nil || tree2 == nil { return false }; return tree1.Val == tree2.Val && compareTrees(tree1.Left, tree2.Left) && compareTrees(tree1.Right, tree2.Right) }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func treeToArray(root *TreeNode) []interface{} { if root == nil { return nil }; result := []interface{}{}; queue := []*TreeNode{root}; for len(queue) > 0 { node := queue[0]; queue = queue[1:]; if node != nil { result = append(result, node.Val); queue = append(queue, node.Left, node.Right) } else { result = append(result, nil) } }; for len(result) > 0 && result[len(result)-1] == nil { result = result[:len(result)-1] }; return result }"
    },
    "rust": {
      "functionDeclaration": "fn ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {}",
      "testCalls": [
        "let result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal(vec![3,9,20,15,7], vec![9,3,15,20,7]); assert_eq!(treeToArray(result1), vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);",
        "let result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal(vec![-1], vec![-1]); assert_eq!(treeToArray(result2), vec![Some(-1)]);"
      ],
      "compareHelper": "fn compare_trees(a: Option<Rc<RefCell<TreeNode>>>, b: Option<Rc<RefCell<TreeNode>>>) -> bool { if a.is_none() && b.is_none() { return true; } if a.is_none() || b.is_none() { return false; } let a = a.unwrap(); let b = b.unwrap(); a.borrow().val == b.borrow().val && compare_trees(a.borrow().left.clone(), b.borrow().left.clone()) && compare_trees(a.borrow().right.clone(), b.borrow().right.clone()) }",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}",
      "typeDefs": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Implement buildTree function here\n    unimplemented!()\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    // Implement treeToArray function here\n    unimplemented!()\n}"
    },
    "ruby": {
      "functionDeclaration": "def ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder)\nend",
      "testCalls": [
        "result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); raise 'Test Case 1 Failed' unless treeToArray(result1) == [3,9,20,nil,nil,15,7]",
        "result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); raise 'Test Case 2 Failed' unless treeToArray(result2) == [-1]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(preorder, inorder)\nend\n\ndef treeToArray(root)\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "preorder": "[3,9,20,15,7]",
          "inorder": "[9,3,15,20,7]"
        },
        "expected": "[3,9,20,null,null,15,7]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "preorder": "[-1]",
          "inorder": "[-1]"
        },
        "expected": "[-1]"
      }
    ]
  },
  "construct-quad-tree": {
    "title": "Construct Quad Tree",
    "content": "Given a n * n matrix grid of 0 and 1 only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1 or False if the node represents a grid of 0. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1 or all 0) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don&#39;t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructQuadTree(grid) {}",
      "testCalls": [
        "const testOutput1 = buildTree([[0,1],[1,0]]); if(JSON.stringify(treeToArray(testOutput1)) !== '[[false,false],[true,true],[true,true],[true,true],[true,false]]') throw new Error('Test Case 1 Failed');",
        "const testOutput2 = buildTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if(JSON.stringify(treeToArray(testOutput2)) !== '[[false,false],[true,true],[false,true],[true,true],[true,false],null,null,null,null,[true,false],[true,false],[true,true],[true,true]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "",
      "builders": "class Node {\n    constructor(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight) {\n        this.val = val;\n        this.isLeaf = isLeaf;\n        this.topLeft = topLeft;\n        this.topRight = topRight;\n        this.bottomLeft = bottomLeft;\n        this.bottomRight = bottomRight;\n    }\n}\n\nfunction buildTree(grid) {\n    function construct(x, y, length) {\n        if (length === 1) {\n            return new Node(grid[x][y] === 1, true, null, null, null, null);\n        }\n        const half = length / 2;\n        const topLeft = construct(x, y, half);\n        const topRight = construct(x, y + half, half);\n        const bottomLeft = construct(x + half, y, half);\n        const bottomRight = construct(x + half, y + half, half);\n        if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf &&\n            topLeft.val === topRight.val && topRight.val === bottomLeft.val && bottomLeft.val === bottomRight.val) {\n            return new Node(topLeft.val, true, null, null, null, null);\n        }\n        return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\n    }\n    return construct(0, 0, grid.length);\n}\n\nfunction treeToArray(root) {\n    const result = [];\n    function traverse(node) {\n        if (!node) return;\n        result.push([node.val, node.isLeaf]);\n        if (!node.isLeaf) {\n            traverse(node.topLeft);\n            traverse(node.topRight);\n            traverse(node.bottomLeft);\n            traverse(node.bottomRight);\n        }\n    }\n    traverse(root);\n    return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function ConstructQuadTree(grid: number[][]): Node | null {}",
      "testCalls": [
        "let result1 = ConstructQuadTree([[0,1],[1,0]]); if(JSON.stringify(treeToArray(result1)) !== JSON.stringify([[0,1],[1,0],[1,1],[1,1],[1,0]])) { throw new Error('Test Case 1 Failed'); }",
        "let result2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if(JSON.stringify(treeToArray(result2)) !== JSON.stringify([[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "class Node { val: boolean; isLeaf: boolean; topLeft: Node | null; topRight: Node | null; bottomLeft: Node | null; bottomRight: Node | null; constructor(val = false, isLeaf = false, topLeft = null, topRight = null, bottomLeft = null, bottomRight = null) { this.val = val; this.isLeaf = isLeaf; this.topLeft = topLeft; this.topRight = topRight; this.bottomLeft = bottomLeft; this.bottomRight = bottomRight; } }",
      "builders": "function buildTree(grid: number[][], rowStart = 0, rowEnd = grid.length, colStart = 0, colEnd = grid[0].length): Node | null { /* Implementation not provided */ return null; }\nfunction treeToArray(root: Node | null): any[] { /* Implementation not provided */ return []; }"
    },
    "cpp": {
      "functionDeclaration": "Node* ConstructQuadTree(std::vector<std::vector<int>> grid) { return nullptr; }",
      "testCalls": [
        "int main() { Node* r1 = ConstructQuadTree({{0,1},{1,0}}); if (!r1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { Node* r2 = ConstructQuadTree({{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0}}); if (!r2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>\n\nstruct Node { bool val; bool isLeaf; Node* topLeft; Node* topRight; Node* bottomLeft; Node* bottomRight; Node(bool v = false, bool leaf = false, Node* tl = nullptr, Node* tr = nullptr, Node* bl = nullptr, Node* br = nullptr) : val(v), isLeaf(leaf), topLeft(tl), topRight(tr), bottomLeft(bl), bottomRight(br) {} };",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def ConstructQuadTree(grid: list[list[int]]) -> Node:\n return None",
      "testCalls": [
        "result1 = ConstructQuadTree([[0,1],[1,0]])\nif treeToArray(result1).count(None) != 7: raise Exception('Test Case 1 Failed')",
        "result2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]])\nif treeToArray(result2).count(None) != 31: raise Exception('Test Case 2 Failed')"
      ],
      "compareHelper": "",
      "typeDefs": "class Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight",
      "builders": "def buildTree(grid):\n    def construct(x, y, length):\n        if length == 1:\n            return Node(grid[x][y] == 1, True, None, None, None, None)\n        half = length // 2\n        topLeft = construct(x, y, half)\n        topRight = construct(x, y + half, half)\n        bottomLeft = construct(x + half, y, half)\n        bottomRight = construct(x + half, y + half, half)\n        if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and topLeft.val == topRight.val == bottomLeft.val == bottomRight.val:\n            return Node(topLeft.val, True, None, None, None, None)\n        return Node(True, False, topLeft, topRight, bottomLeft, bottomRight)\n    return construct(0, 0, len(grid))\n\ndef treeToArray(root):\n    result = []\n    def traverse(node):\n        if not node:\n            result.append(None)\n            return\n        result.append([node.val, node.isLeaf])\n        if not node.isLeaf:\n            traverse(node.topLeft)\n            traverse(node.topRight)\n            traverse(node.bottomLeft)\n            traverse(node.bottomRight)\n    traverse(root)\n    return result"
    },
    "java": {
      "functionDeclaration": "public Node construct(int[][] grid) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); int[][] grid1 = new int[][]{{0,1},{1,0}}; Node result1 = m.construct(grid1); if (result1 == null || result1.isLeaf) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int[][] grid2 = new int[][]{{1,1},{1,1}}; Node result2 = m.construct(grid2); if (result2 == null || !result2.isLeaf || !result2.val) throw new AssertionError(); }"
      ],
      "compareHelper": "class Node { public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; public Node() {} public Node(boolean val, boolean isLeaf) { this.val = val; this.isLeaf = isLeaf; } public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) { this.val = val; this.isLeaf = isLeaf; this.topLeft = topLeft; this.topRight = topRight; this.bottomLeft = bottomLeft; this.bottomRight = bottomRight; } }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "Node* ConstructQuadTree(int** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "int grid1[2][2] = {{1,1},{1,1}}; int gridColSize1[] = {2, 2}; int* gridPtr1[2] = {grid1[0], grid1[1]}; Node* result1 = ConstructQuadTree(gridPtr1, 2, gridColSize1);",
        "int grid2[8][8] = {{1,0,1,0,0,0,1,1},{1,0,1,0,0,0,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,0,1,0,0,0,1,1},{1,0,1,0,0,0,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1}}; int gridColSize2[] = {8, 8, 8, 8, 8, 8, 8, 8}; int* gridPtr2[8] = {grid2[0], grid2[1], grid2[2], grid2[3], grid2[4], grid2[5], grid2[6], grid2[7]}; Node* result2 = ConstructQuadTree(gridPtr2, 8, gridColSize2);"
      ],
      "compareHelper": "",
      "typeDefs": "typedef struct Node { bool val; bool isLeaf; struct Node* topLeft; struct Node* topRight; struct Node* bottomLeft; struct Node* bottomRight; } Node;",
      "builders": "Node* buildQuadTree(int** grid, int gridSize, int* gridColSize);\nint** quadTreeToArray(Node* root);"
    },
    "go": {
      "functionDeclaration": "func ConstructQuadTree(grid [][]int) *Node { return nil }",
      "testCalls": [
        "func main() { result := ConstructQuadTree([][]int{{0,1},{1,0}}); if result == nil || result.IsLeaf { panic(\"Test 1 Failed\") } }",
        "func main() { result := ConstructQuadTree([][]int{{1,1},{1,1}}); if result == nil || !result.IsLeaf || !result.Val { panic(\"Test 2 Failed\") } }"
      ],
      "compareHelper": "",
      "typeDefs": "type Node struct { Val bool; IsLeaf bool; TopLeft *Node; TopRight *Node; BottomLeft *Node; BottomRight *Node }",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn ConstructQuadTree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> { }",
      "testCalls": [
        "let test_input1 = vec![vec![0, 1], vec![1, 0]]; let result1 = ConstructQuadTree(test_input1); assert_eq!(result1, Some(Box::new(Node { val: false, is_leaf: false, top_left: Some(Box::new(Node { val: false, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), top_right: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_left: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_right: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })) }));",
        "let test_input2 = vec![vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 1, 1, 1, 1], vec![1, 1, 1, 1, 1, 1, 1, 1], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0]]; let result2 = ConstructQuadTree(test_input2); assert_eq!(result2, Some(Box::new(Node { val: false, is_leaf: false, top_left: Some(Box::new(Node { val: false, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), top_right: Some(Box::new(Node { val: true, is_leaf: false, top_left: Some(Box::new(Node { val: false, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), top_right: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_left: Some(Box::new(Node { val: true, is_leaf: true, top_left: None, top_right: None, bottom_left: None, bottom_right: None })), bottom_right: None })) }));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashMap;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: bool,\n    pub is_leaf: bool,\n    pub top_left: Option<Box<Node>>,\n    pub top_right: Option<Box<Node>>,\n    pub bottom_left: Option<Box<Node>>,\n    pub bottom_right: Option<Box<Node>>,\n}\n\nfn build_tree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> {\n    build_tree_helper(&grid, 0, 0, grid.len())\n}\n\nfn build_tree_helper(grid: &Vec<Vec<i32>>, row: usize, col: usize, size: usize) -> Option<Box<Node>> {\n    if size == 1 {\n        return Some(Box::new(Node {\n            val: grid[row][col] == 1,\n            is_leaf: true,\n            top_left: None,\n            top_right: None,\n            bottom_left: None,\n            bottom_right: None,\n        }));\n    }\n    let new_size = size / 2;\n    let top_left = build_tree_helper(grid, row, col, new_size);\n    let top_right = build_tree_helper(grid, row, col + new_size, new_size);\n    let bottom_left = build_tree_helper(grid, row + new_size, col, new_size);\n    let bottom_right = build_tree_helper(grid, row + new_size, col + new_size, new_size);\n\n    if let (Some(tl), Some(tr), Some(bl), Some(br)) = (&top_left, &top_right, &bottom_left, &bottom_right) {\n        if tl.is_leaf && tr.is_leaf && bl.is_leaf && br.is_leaf &&\n           tl.val == tr.val && tr.val == bl.val && bl.val == br.val {\n            return Some(Box::new(Node {\n                val: tl.val,\n                is_leaf: true,\n                top_left: None,\n                top_right: None,\n                bottom_left: None,\n                bottom_right: None,\n            }));\n        }\n    }\n    Some(Box::new(Node {\n        val: true,\n        is_leaf: false,\n        top_left,\n        top_right,\n        bottom_left,\n        bottom_right,\n    }))\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: bool,\n    pub is_leaf: bool,\n    pub top_left: Option<Box<Node>>,\n    pub top_right: Option<Box<Node>>,\n    pub bottom_left: Option<Box<Node>>,\n    pub bottom_right: Option<Box<Node>>,\n}",
      "builders": "struct Node {\n    val: bool,\n    is_leaf: bool,\n    top_left: Option<Box<Node>>,\n    top_right: Option<Box<Node>>,\n    bottom_left: Option<Box<Node>>,\n    bottom_right: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(val: bool, is_leaf: bool, top_left: Option<Box<Node>>, top_right: Option<Box<Node>>, bottom_left: Option<Box<Node>>, bottom_right: Option<Box<Node>>) -> Self {\n        Node { val, is_leaf, top_left, top_right, bottom_left, bottom_right }\n    }\n}\n\nfn build_tree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> {\n    fn build_tree_helper(grid: &Vec<Vec<i32>>, row: usize, col: usize, size: usize) -> Option<Box<Node>> {\n        if size == 1 {\n            return Some(Box::new(Node::new(grid[row][col] == 1, true, None, None, None, None)));\n        }\n        let new_size = size / 2;\n        let top_left = build_tree_helper(grid, row, col, new_size);\n        let top_right = build_tree_helper(grid, row, col + new_size, new_size);\n        let bottom_left = build_tree_helper(grid, row + new_size, col, new_size);\n        let bottom_right = build_tree_helper(grid, row + new_size, col + new_size, new_size);\n        if let (Some(tl), Some(tr), Some(bl), Some(br)) = (&top_left, &top_right, &bottom_left, &bottom_right) {\n            if tl.is_leaf && tr.is_leaf && bl.is_leaf && br.is_leaf &&\n               tl.val == tr.val && tr.val == bl.val && bl.val == br.val {\n                return Some(Box::new(Node::new(tl.val, true, None, None, None, None)));\n            }\n        }\n        Some(Box::new(Node::new(true, false, top_left, top_right, bottom_left, bottom_right)))\n    }\n    build_tree_helper(&grid, 0, 0, grid.len())\n}"
    },
    "ruby": {
      "functionDeclaration": "def ConstructQuadTree(grid)\nend",
      "testCalls": [
        "result1 = ConstructQuadTree([[0,1],[1,0]]); raise 'Test Case 1 Failed' unless quadTreeToArray(result1) == [[0,1],[1,0],[1,1],[1,1],[1,0]]",
        "result2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); raise 'Test Case 2 Failed' unless quadTreeToArray(result2) == [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]"
      ],
      "compareHelper": "",
      "typeDefs": "class Node\n  attr_accessor :val, :is_leaf, :top_left, :top_right, :bottom_left, :bottom_right\n  def initialize(val=false, is_leaf=false, top_left=nil, top_right=nil, bottom_left=nil, bottom_right=nil)\n    @val = val\n    @is_leaf = is_leaf\n    @top_left = top_left\n    @top_right = top_right\n    @bottom_left = bottom_left\n    @bottom_right = bottom_right\n  end\nend",
      "builders": "def buildQuadTree(grid)\nend\n\ndef quadTreeToArray(root)\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "grid": "[[0,1],[1,0]]"
        },
        "expected": "[[0,1],[1,0],[1,1],[1,1],[1,0]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "grid": "[[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]"
        },
        "expected": "[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]"
      }
    ]
  },
  "container-with-most-water": {
    "title": "Container With Most Water",
    "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.",
    "difficulty": "Medium",
    "hints": [
      "If you simulate the problem, it will be O(n^2) which is not efficient.",
      "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
      "How can you calculate the amount of water at each step?"
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ContainerWithMostWater(height) { return 0; }",
      "testCalls": [
        "if(ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) !== 49) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainerWithMostWater([1,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ContainerWithMostWater(height: number[]): number { }",
      "testCalls": [
        "if(ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) !== 49) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainerWithMostWater([1,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxArea(std::vector<int> height) { return 0; }",
      "testCalls": [
        "int main() { if (MaxArea({1,8,6,2,5,4,8,3,7}) != 49) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (MaxArea({1,1}) != 1) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def ContainerWithMostWater(height: list[int]) -> int:\n    return 0",
      "testCalls": [
        "assert ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) == 49",
        "assert ContainerWithMostWater([1,1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int maxArea(int[] height) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { if (new Main().maxArea(new int[]{1,8,6,2,5,4,8,3,7}) != 49) throw new AssertionError(); }",
        "public static void main(String[] args) { if (new Main().maxArea(new int[]{1,1}) != 1) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxArea(int* height, int heightSize)",
      "testCalls": [
        "int main() { if(MaxArea((int[]){1,8,6,2,5,4,8,3,7}, 9) != 49) { printf(\"Test case 1 failed\"); }",
        "if(MaxArea((int[]){1,1}, 2) != 1) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxArea(height []int) int { return 0 }",
      "testCalls": [
        "func main() { if MaxArea([]int{1,8,6,2,5,4,8,3,7}) != 49 { panic(\"Test case 1 failed\") } }",
        "func main() { if MaxArea([]int{1,1}) != 1 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ContainerWithMostWater(height: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(ContainerWithMostWater(vec![1,8,6,2,5,4,8,3,7]), 49);",
        "assert_eq!(ContainerWithMostWater(vec![1,1]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ContainerWithMostWater(height)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) == 49",
        "raise 'Test Case 2 Failed' unless ContainerWithMostWater([1,1]) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "height": "[1,8,6,2,5,4,8,3,7]"
        },
        "expected": "49"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "height": "[1,1]"
        },
        "expected": "1"
      }
    ]
  },
  "contains-duplicate-ii": {
    "title": "Contains Duplicate II",
    "content": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ContainsDuplicateII(nums, k) { return false; }",
      "testCalls": [
        "if(ContainsDuplicateII([1,2,3,1], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainsDuplicateII([1,0,1,1], 1) !== true) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ContainsDuplicateII(nums: number[], k: number): boolean { return false; }",
      "testCalls": [
        "if (ContainsDuplicateII([1,2,3,1], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (ContainsDuplicateII([1,0,1,1], 1) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (ContainsDuplicateII([1,2,3,1,2,3], 2) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool ContainsDuplicateII(std::vector<int> nums, int k) { return false; }",
      "testCalls": [
        "int main() { if (ContainsDuplicateII({1,2,3,1}, 3) != true) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (ContainsDuplicateII({1,0,1,1}, 1) != true) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def ContainsDuplicateII(nums: list[int], k: int) -> bool:\n return False",
      "testCalls": [
        "assert ContainsDuplicateII([1,2,3,1], 3) == True",
        "assert ContainsDuplicateII([1,0,1,1], 1) == True"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean containsNearbyDuplicate(int[] nums, int k) { return false; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.containsNearbyDuplicate(new int[]{1,2,3,1}, 3)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (!m.containsNearbyDuplicate(new int[]{1,0,1,1}, 1)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.containsNearbyDuplicate(new int[]{1,2,3,1,2,3}, 2)) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool ContainsDuplicateII(int* nums, int numsSize, int k)",
      "testCalls": [
        "int main() { if (!ContainsDuplicateII((int[]){1,2,3,1}, 4, 3)) { printf(\"Test Case 1 Failed\"); }",
        "if (!ContainsDuplicateII((int[]){1,0,1,1}, 4, 1)) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ContainsNearbyDuplicate(nums []int, k int) bool { return false }",
      "testCalls": [
        "func main() { if !ContainsNearbyDuplicate([]int{1,2,3,1}, 3) { panic(\"Test case 1 failed\") } }",
        "func main() { if !ContainsNearbyDuplicate([]int{1,0,1,1}, 1) { panic(\"Test case 2 failed\") } }",
        "func main() { if ContainsNearbyDuplicate([]int{1,2,3,1,2,3}, 2) { panic(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ContainsDuplicateII(nums: Vec<i32>, k: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(ContainsDuplicateII(vec![1, 2, 3, 1], 3), true);",
        "assert_eq!(ContainsDuplicateII(vec![1, 0, 1, 1], 1), true); assert_eq!(ContainsDuplicateII(vec![1, 2, 3, 1, 2, 3], 2), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ContainsDuplicateII(nums, k)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ContainsDuplicateII([1,2,3,1], 3) == true",
        "raise 'Test Case 2 Failed' unless ContainsDuplicateII([1,0,1,1], 1) == true",
        "raise 'Test Case 3 Failed' unless ContainsDuplicateII([1,2,3,1,2,3], 2) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,1]",
          "k": "3"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,0,1,1]",
          "k": "1"
        },
        "expected": "true"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1,2,3,1,2,3]",
          "k": "2"
        },
        "expected": "false"
      }
    ]
  },
  "convert-sorted-array-to-binary-search-tree": {
    "title": "Convert Sorted Array to Binary Search Tree",
    "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SortedArrayToBinarySearchTree(nums) {}",
      "testCalls": [
        "if(JSON.stringify(treeToArray(SortedArrayToBinarySearchTree([-10,-3,0,5,9]))) !== JSON.stringify([0,-3,9,-10,null,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(treeToArray(SortedArrayToBinarySearchTree([1,3]))) !== JSON.stringify([3,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n  this.val = val;\n  this.left = left;\n  this.right = right;\n}",
      "builders": "function buildTree(arr) {\n  if (!arr.length) return null;\n  const mid = Math.floor(arr.length / 2);\n  const root = new TreeNode(arr[mid]);\n  root.left = buildTree(arr.slice(0, mid));\n  root.right = buildTree(arr.slice(mid + 1));\n  return root;\n}\n\nfunction treeToArray(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node ? node.val : null);\n    if (node) {\n      queue.push(node.left);\n      queue.push(node.right);\n    }\n  }\n  return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function SortedArrayToBinarySearchTree(nums: number[]): TreeNode | null {}",
      "testCalls": [
        "if(JSON.stringify(ConvertSortedArrayToBinarySearchTree(buildTree([-10,-3,0,5,9]))) !== JSON.stringify([0,-3,9,-10,null,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(ConvertSortedArrayToBinarySearchTree(buildTree([1,3]))) !== JSON.stringify([3,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "",
      "builders": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction buildTree(arr: number[]): TreeNode | null {\n  if (!arr.length) return null;\n  const mid = Math.floor(arr.length / 2);\n  const root = new TreeNode(arr[mid]);\n  root.left = buildTree(arr.slice(0, mid));\n  root.right = buildTree(arr.slice(mid + 1));\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node ? node.val : null);\n    if (node) {\n      queue.push(node.left);\n      queue.push(node.right);\n    }\n  }\n  return result;\n}"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* SortedArrayToBST(std::vector<int> nums) { return nullptr; }",
      "testCalls": [
        "int main() { TreeNode* r1 = SortedArrayToBST({-10,-3,0,5,9}); if (!r1 || r1->val != 0) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { TreeNode* r2 = SortedArrayToBST({1,3}); if (!r2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def ConvertSortedArrayToBinarySearchTree(nums: list[int]) -> TreeNode:\n return None",
      "testCalls": [
        "result1 = ConvertSortedArrayToBinarySearchTree(buildTree([-10,-3,0,5,9])); assert treeToArray(result1) == [0,-3,9,-10,5]",
        "result2 = ConvertSortedArrayToBinarySearchTree(buildTree([1,3])); assert treeToArray(result2) == [3,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2): return arr1 == arr2",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = TreeNode(arr[mid])\n    root.left = buildTree(arr[:mid])\n    root.right = buildTree(arr[mid + 1:])\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode sortedArrayToBST(int[] nums) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode result1 = m.sortedArrayToBST(new int[]{-10,-3,0,5,9}); if (result1 == null || result1.val != 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode result2 = m.sortedArrayToBST(new int[]{1,3}); if (result2 == null) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "TreeNode* SortedArrayToBST(int* nums, int numsSize)",
      "testCalls": [
        "assert(strcmp(treeToArray(SortedArrayToBST((int[]){-10,-3,0,5,9}, 5)), \"[0,-3,9,-10,null,5]\") == 0);",
        "assert(strcmp(treeToArray(SortedArrayToBST((int[]){1,3}, 2)), \"[3,1]\") == 0);"
      ],
      "compareHelper": "char* TreeNodeToString(TreeNode* root) { /* Helper function implementation for converting TreeNode to string */ }",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func SortedArrayToBST(nums []int) *TreeNode { return nil }",
      "testCalls": [
        "func main() { result := SortedArrayToBST([]int{-10,-3,0,5,9}); if result == nil || result.Val != 0 { panic(\"Test case 1 failed\") } }",
        "func main() { result := SortedArrayToBST([]int{1,3}); if result == nil { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "func compareTrees(t1, t2 *TreeNode) bool { if t1 == nil && t2 == nil { return true }; if t1 == nil || t2 == nil { return false }; return t1.Val == t2.Val && compareTrees(t1.Left, t2.Left) && compareTrees(t1.Right, t2.Right) }",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "pub fn ConvertSortedArrayToBinarySearchTree(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {}",
      "testCalls": [
        "let result1 = ConvertSortedArrayToBinarySearchTree(vec![-10,-3,0,5,9]); assert_eq!(tree_to_array(result1), vec![Some(0), Some(-3), Some(9), Some(-10), None, Some(5)]);",
        "let result2 = ConvertSortedArrayToBinarySearchTree(vec![1,3]); assert_eq!(tree_to_array(result2), vec![Some(3), Some(1)]);"
      ],
      "compareHelper": "fn compare_trees(tree1: Option<Rc<RefCell<TreeNode>>>, tree2: Option<Rc<RefCell<TreeNode>>>) -> bool { if tree1.is_none() && tree2.is_none() { return true; } if tree1.is_none() || tree2.is_none() { return false; } let tree1_val = tree1.as_ref().unwrap().borrow().val; let tree2_val = tree2.as_ref().unwrap().borrow().val; let left_result = compare_trees(tree1.as_ref().unwrap().borrow().left.clone(), tree2.as_ref().unwrap().borrow().left.clone()); let right_result = compare_trees(tree1.as_ref().unwrap().borrow().right.clone(), tree2.as_ref().unwrap().borrow().right.clone()); return tree1_val == tree2_val && left_result && right_result; }",
      "helpers": "use std::{cell::RefCell, rc::Rc};\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn build_tree(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def ConvertSortedArrayToBinarySearchTree(nums)\nend",
      "testCalls": [
        "root = buildTree([-10,-3,0,5,9]); result = ConvertSortedArrayToBinarySearchTree(root); raise 'Test Case 1 Failed' unless treeToArray(result) == [0,-3,9,-10,nil,5]",
        "root = buildTree([1,3]); result = ConvertSortedArrayToBinarySearchTree(root); raise 'Test Case 2 Failed' unless treeToArray(result) == [3,1]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Build binary tree from array\nend\n\ndef treeToArray(root)\n  # Convert binary tree to array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[-10,-3,0,5,9]"
        },
        "expected": "[0,-3,9,-10,null,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,3]"
        },
        "expected": "[3,1]"
      }
    ]
  },
  "copy-list-with-random-pointer": {
    "title": "Copy List with Random Pointer",
    "content": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\n\nYour code will only be given the head of the original linked list.",
    "difficulty": "Medium",
    "hints": [
      "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.",
      "You may want to use extra space to keep old_node ---> new_node mapping to prevent creating multiple copies of the same node.",
      "We can avoid using extra space for old_node ---> new_node mapping by tweaking the original linked list. Simply interweave the nodes of the old and copied list. For example:\r\nOld List: A --> B --> C --> D\r\nInterWeaved List: A --> A' --> B --> B' --> C --> C' --> D --> D'",
      "The interweaving is done using next</b> pointers and we can make use of interweaved structure to get the correct reference nodes for random</b> pointers."
    ],
    "topicTags": [
      "Hash Table",
      "Linked List"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CopyListWithRandomPointer(head) { return null; }",
      "testCalls": [
        "const test1 = linkedListToArray(CopyListWithRandomPointer(buildLinkedList([[7,null],[13,0],[11,4],[10,2],[1,0]]))); if(JSON.stringify(test1) !== JSON.stringify([[7,null],[13,0],[11,4],[10,2],[1,0]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = linkedListToArray(CopyListWithRandomPointer(buildLinkedList([[1,1],[2,1]]))); if(JSON.stringify(test2) !== JSON.stringify([[1,1],[2,1]])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = linkedListToArray(CopyListWithRandomPointer(buildLinkedList([[3,null],[3,0],[3,null]]))); if(JSON.stringify(test3) !== JSON.stringify([[3,null],[3,0],[3,null]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function Node(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n}",
      "builders": "function Node(val, next = null, random = null) {\n  this.val = val;\n  this.next = next;\n  this.random = random;\n}\n\nfunction buildLinkedList(arr) {\n  if (!arr.length) return null;\n  const nodes = arr.map(([val]) => new Node(val));\n  arr.forEach(([_, nextIndex, randomIndex], i) => {\n    if (nextIndex !== null) nodes[i].next = nodes[nextIndex];\n    if (randomIndex !== null) nodes[i].random = nodes[randomIndex];\n  });\n  return nodes[0];\n}\n\nfunction linkedListToArray(head) {\n  const arr = [];\n  const map = new Map();\n  let node = head;\n  let index = 0;\n  while (node) {\n    map.set(node, index++);\n    node = node.next;\n  }\n  node = head;\n  while (node) {\n    arr.push([\n      node.val,\n      node.next ? map.get(node.next) : null,\n      node.random ? map.get(node.random) : null\n    ]);\n    node = node.next;\n  }\n  return arr;\n}"
    },
    "typescript": {
      "functionDeclaration": "CopyListWithRandomPointer(head: number[][]): number[][]",
      "testCalls": [
        "const test1 = CopyListWithRandomPointer(buildLinkedList([[7,null],[13,0],[11,4],[10,2],[1,0]])); if(JSON.stringify(test1) !== JSON.stringify([[7,null],[13,0],[11,4],[10,2],[1,0]])) throw new Error('Test Case 1 Failed');",
        "const test2 = CopyListWithRandomPointer(buildLinkedList([[1,1],[2,1]])); if(JSON.stringify(test2) !== JSON.stringify([[1,1],[2,1]])) throw new Error('Test Case 2 Failed');",
        "const test3 = CopyListWithRandomPointer(buildLinkedList([[3,null],[3,0],[3,null]])); if(JSON.stringify(test3) !== JSON.stringify([[3,null],[3,0],[3,null]])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "cpp": {
      "functionDeclaration": "Node* CopyListWithRandomPointer(Node* head) { return nullptr; }",
      "testCalls": [
        "int main() { Node* r1 = CopyListWithRandomPointer(buildLinkedList({{7,-1},{13,0},{11,4},{10,2},{1,0}})); if (!r1 || r1->val != 7) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { Node* r2 = CopyListWithRandomPointer(buildLinkedList({{1,1},{2,1}})); if (!r2 || r2->val != 1) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { Node* r3 = CopyListWithRandomPointer(buildLinkedList({{3,-1},{3,0},{3,-1}})); if (!r3 || r3->val != 3) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>\n\nclass Node { public: int val; Node* next; Node* random; Node(int v) : val(v), next(nullptr), random(nullptr) {} };\n\nNode* buildLinkedList(std::vector<std::vector<int>> nodes) { if (nodes.empty()) return nullptr; std::vector<Node*> nodeList; for (const auto& n : nodes) nodeList.push_back(new Node(n[0])); for (size_t i = 0; i < nodes.size(); ++i) { if (i + 1 < nodeList.size()) nodeList[i]->next = nodeList[i + 1]; if (nodes[i].size() > 1 && nodes[i][1] >= 0 && nodes[i][1] < (int)nodeList.size()) nodeList[i]->random = nodeList[nodes[i][1]]; } return nodeList[0]; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def CopyListWithRandomPointer(head: list[list[int]]) -> list[list[int]]:\n return []",
      "testCalls": [
        "result1 = CopyListWithRandomPointer([[7,None],[13,0],[11,4],[10,2],[1,0]]); assert result1 == [[7,None],[13,0],[11,4],[10,2],[1,0]], 'Test Case 1 Failed'",
        "result2 = CopyListWithRandomPointer([[1,1],[2,1]]); assert result2 == [[1,1],[2,1]], 'Test Case 2 Failed'",
        "result3 = CopyListWithRandomPointer([[3,None],[3,0],[3,None]]); assert result3 == [[3,None],[3,0],[3,None]], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if len(list1) != len(list2):\n        return False\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public Node copyRandomList(Node head) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); Node test1 = m.copyRandomList(m.buildLinkedList(new int[][]{{7,-1},{13,0},{11,4},{10,2},{1,0}})); if (test1 == null || test1.val != 7) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); Node test2 = m.copyRandomList(m.buildLinkedList(new int[][]{{1,1},{2,1}})); if (test2 == null || test2.val != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); Node test3 = m.copyRandomList(m.buildLinkedList(new int[][]{{3,-1},{3,0},{3,-1}})); if (test3 == null || test3.val != 3) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } }\n\npublic Node buildLinkedList(int[][] arr) { if (arr.length == 0) return null; Node[] nodes = new Node[arr.length]; for (int i = 0; i < arr.length; i++) nodes[i] = new Node(arr[i][0]); for (int i = 0; i < arr.length - 1; i++) nodes[i].next = nodes[i + 1]; for (int i = 0; i < arr.length; i++) { if (arr[i][1] >= 0) nodes[i].random = nodes[arr[i][1]]; } return nodes[0]; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "Node* CopyListWithRandomPointer(Node* head)",
      "testCalls": [
        "int main() {\n    Node* head1 = buildLinkedList((int*[]){(int[]){7,0}, (int[]){13,1}, (int[]){11,4}, (int[]){10,2}, (int[]){1,0}}, 5);\n    Node* expected1 = buildLinkedList((int*[]){(int[]){7,0}, (int[]){13,1}, (int[]){11,4}, (int[]){10,2}, (int[]){1,0}}, 5);\n    Node* result1 = CopyListWithRandomPointer(head1);\n    compareLists(expected1, result1);\n    return 0;\n}",
        "int main() {\n    Node* head2 = buildLinkedList((int*[]){(int[]){1,1}, (int[]){2,1}}, 2);\n    Node* expected2 = buildLinkedList((int*[]){(int[]){1,1}, (int[]){2,1}}, 2);\n    Node* result2 = CopyListWithRandomPointer(head2);\n    compareLists(expected2, result2);\n    return 0;\n}",
        "int main() {\n    Node* head3 = buildLinkedList((int*[]){(int[]){3,0}, (int[]){3,1}, (int[]){3,0}}, 3);\n    Node* expected3 = buildLinkedList((int*[]){(int[]){3,0}, (int[]){3,1}, (int[]){3,0}}, 3);\n    Node* result3 = CopyListWithRandomPointer(head3);\n    compareLists(expected3, result3);\n    return 0;\n}"
      ],
      "compareHelper": "void compareLists(Node* expected, Node* result) { /* Comparison logic */ }",
      "typeDefs": "#include <stdlib.h>\n\ntypedef struct Node {\n    int val;\n    struct Node* next;\n    struct Node* random;\n} Node;\n\nNode* createNode(int val) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->val = val;\n    newNode->next = NULL;\n    newNode->random = NULL;\n    return newNode;\n}",
      "builders": "Node* buildLinkedList(int** arr, int size) {\n    if (size == 0) return NULL;\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->val = arr[0][0];\n    head->next = NULL;\n    head->random = NULL;\n    Node* current = head;\n    Node** nodes = (Node**)malloc(size * sizeof(Node*));\n    nodes[0] = head;\n    for (int i = 1; i < size; i++) {\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->val = arr[i][0];\n        newNode->next = NULL;\n        newNode->random = NULL;\n        current->next = newNode;\n        current = newNode;\n        nodes[i] = newNode;\n    }\n    current = head;\n    for (int i = 0; i < size; i++) {\n        if (arr[i][1] != -1) {\n            current->random = nodes[arr[i][1]];\n        }\n        current = current->next;\n    }\n    free(nodes);\n    return head;\n}\n\nint** linkedListToArray(Node* head) {\n    if (!head) return NULL;\n    int size = 0;\n    Node* current = head;\n    while (current) {\n        size++;\n        current = current->next;\n    }\n    int** arr = (int**)malloc(size * sizeof(int*));\n    current = head;\n    Node** nodes = (Node**)malloc(size * sizeof(Node*));\n    for (int i = 0; i < size; i++) {\n        arr[i] = (int*)malloc(2 * sizeof(int));\n        arr[i][0] = current->val;\n        nodes[i] = current;\n        current = current->next;\n    }\n    current = head;\n    for (int i = 0; i < size; i++) {\n        if (current->random) {\n            for (int j = 0; j < size; j++) {\n                if (nodes[j] == current->random) {\n                    arr[i][1] = j;\n                    break;\n                }\n            }\n        } else {\n            arr[i][1] = -1;\n        }\n        current = current->next;\n    }\n    free(nodes);\n    return arr;\n}"
    },
    "go": {
      "functionDeclaration": "func CopyListWithRandomPointer(head *Node) *Node { return nil }",
      "testCalls": [
        "func TestCopyListWithRandomPointer(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tarr  [][]int\n\t}{\n\t\t{\"Test Case 1\", [][]int{{7, -1}, {13, 0}, {11, 4}, {10, 2}, {1, 0}}},\n\t\t{\"Test Case 2\", [][]int{{1, 1}, {2, 1}}},\n\t\t{\"Test Case 3\", [][]int{{3, -1}, {3, 0}, {3, -1}}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\thead := buildList(tt.arr)\n\t\t\tgot := CopyListWithRandomPointer(head)\n\t\t\tif !compareLists(got, head) {\n\t\t\t\tt.Errorf(\"CopyListWithRandomPointer() failed\")\n\t\t\t}\n\t\t\tif got == head && head != nil {\n\t\t\t\tt.Errorf(\"CopyListWithRandomPointer() returned same reference\")\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "func compareLists(l1, l2 *Node) bool {\n\tif l1 == nil && l2 == nil {\n\t\treturn true\n\t}\n\tif l1 == nil || l2 == nil {\n\t\treturn false\n\t}\n\tm1 := make(map[*Node]int)\n\tm2 := make(map[*Node]int)\n\tidx := 0\n\tfor n := l1; n != nil; n = n.Next {\n\t\tm1[n] = idx\n\t\tidx++\n\t}\n\tidx = 0\n\tfor n := l2; n != nil; n = n.Next {\n\t\tm2[n] = idx\n\t\tidx++\n\t}\n\tfor l1 != nil && l2 != nil {\n\t\tif l1.Val != l2.Val {\n\t\t\treturn false\n\t\t}\n\t\tif (l1.Random == nil) != (l2.Random == nil) {\n\t\t\treturn false\n\t\t}\n\t\tif l1.Random != nil && m1[l1.Random] != m2[l2.Random] {\n\t\t\treturn false\n\t\t}\n\t\tl1 = l1.Next\n\t\tl2 = l2.Next\n\t}\n\treturn l1 == nil && l2 == nil\n}",
      "typeDefs": "type Node struct {\n\tVal    int\n\tNext   *Node\n\tRandom *Node\n}",
      "builders": "func buildList(arr [][]int) *Node {\n\tif len(arr) == 0 {\n\t\treturn nil\n\t}\n\tnodes := make([]*Node, len(arr))\n\tfor i, pair := range arr {\n\t\tnodes[i] = &Node{Val: pair[0]}\n\t}\n\tfor i := 0; i < len(nodes)-1; i++ {\n\t\tnodes[i].Next = nodes[i+1]\n\t}\n\tfor i, pair := range arr {\n\t\tif pair[1] != -1 {\n\t\t\tnodes[i].Random = nodes[pair[1]]\n\t\t}\n\t}\n\treturn nodes[0]\n}"
    },
    "ruby": {
      "functionDeclaration": "def CopyListWithRandomPointer(head)\n  # code here\nend",
      "testCalls": [
        "head = buildLinkedList([[7,nil],[13,0],[11,4],[10,2],[1,0]]); result = CopyListWithRandomPointer(head); raise 'Test Case 1 Failed' unless linkedListToArray(result) == [[7,nil],[13,0],[11,4],[10,2],[1,0]]",
        "head = buildLinkedList([[1,1],[2,1]]); result = CopyListWithRandomPointer(head); raise 'Test Case 2 Failed' unless linkedListToArray(result) == [[1,1],[2,1]]",
        "head = buildLinkedList([[3,nil],[3,0],[3,nil]]); result = CopyListWithRandomPointer(head); raise 'Test Case 3 Failed' unless linkedListToArray(result) == [[3,nil],[3,0],[3,nil]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :next, :random\n  def initialize(val = 0, _next = nil, random = nil)\n    @val = val\n    @next = _next\n    @random = random\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  # Build linked list from array\nend\n\ndef linkedListToArray(head)\n  # Convert linked list to array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
        },
        "expected": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[[1,1],[2,1]]"
        },
        "expected": "[[1,1],[2,1]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "head": "[[3,null],[3,0],[3,null]]"
        },
        "expected": "[[3,null],[3,0],[3,null]]"
      }
    ]
  },
  "count-complete-tree-nodes": {
    "title": "Count Complete Tree Nodes",
    "content": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less thanO(n)time complexity.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Binary Search",
      "Bit Manipulation",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CountCompleteTreeNodes(root) { return 0; }",
      "testCalls": [
        "if(CountCompleteTreeNodes(buildTree([1,2,3,4,5,6])) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(CountCompleteTreeNodes(buildTree([])) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(CountCompleteTreeNodes(buildTree([1])) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n}",
      "builders": "function buildTree(arr) {\n    if (!arr.length) return null;\n    let root = new TreeNode(arr[0]);\n    let queue = [root];\n    let i = 1;\n    while (i < arr.length) {\n        let current = queue.shift();\n        if (arr[i] !== null) {\n            current.left = new TreeNode(arr[i]);\n            queue.push(current.left);\n        }\n        i++;\n        if (i < arr.length && arr[i] !== null) {\n            current.right = new TreeNode(arr[i]);\n            queue.push(current.right);\n        }\n        i++;\n    }\n    return root;\n}\n\nfunction treeToArray(root) {\n    if (!root) return [];\n    let arr = [];\n    let queue = [root];\n    while (queue.length) {\n        let node = queue.shift();\n        if (node) {\n            arr.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            arr.push(null);\n        }\n    }\n    while (arr[arr.length - 1] === null) {\n        arr.pop();\n    }\n    return arr;\n}"
    },
    "typescript": {
      "functionDeclaration": "function CountCompleteTreeNodes(root: TreeNode | null): number { return 0; }",
      "testCalls": [
        "if(CountCompleteTreeNodes(buildTree([1,2,3,4,5,6])) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(CountCompleteTreeNodes(buildTree([])) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(CountCompleteTreeNodes(buildTree([1])) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction buildTree(arr: number[]): TreeNode | null {\n  if (arr.length === 0) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (i < arr.length) {\n    const current = queue.shift();\n    if (current) {\n      if (i < arr.length && arr[i] !== null) {\n        current.left = new TreeNode(arr[i]);\n        queue.push(current.left);\n      }\n      i++;\n      if (i < arr.length && arr[i] !== null) {\n        current.right = new TreeNode(arr[i]);\n        queue.push(current.right);\n      }\n      i++;\n    }\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): number[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) {\n    result.pop();\n  }\n  return result as number[];\n}"
    },
    "cpp": {
      "functionDeclaration": "int CountCompleteTreeNodes(TreeNode* root) { return 0; }",
      "testCalls": [
        "int main() { if (CountCompleteTreeNodes(createTree({1,2,3,4,5,6})) != 6) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (CountCompleteTreeNodes(nullptr) != 0) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (CountCompleteTreeNodes(createTree({1})) != 1) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* createTree(std::vector<int> arr) { if (arr.empty()) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def CountCompleteTreeNodes(root: TreeNode) -> int:\n    return 0",
      "testCalls": [
        "assert CountCompleteTreeNodes(buildTree([1,2,3,4,5,6])) == 6",
        "assert CountCompleteTreeNodes(buildTree([])) == 0",
        "assert CountCompleteTreeNodes(buildTree([1])) == 1"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while i < len(arr):\n        current = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            current.left = TreeNode(arr[i])\n            queue.append(current.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            current.right = TreeNode(arr[i])\n            queue.append(current.right)\n        i += 1\n    return root"
    },
    "java": {
      "functionDeclaration": "public int countNodes(TreeNode root) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.countNodes(m.buildTree(new Integer[]{1,2,3,4,5,6})) != 6) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.countNodes(null) != 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.countNodes(m.buildTree(new Integer[]{1})) != 1) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "int CountCompleteTreeNodes(struct TreeNode* root)",
      "testCalls": [
        "int main() { assert(CountCompleteTreeNodes(buildTree((int[]){1, 2, 3, 4, 5, 6}, 6)) == 6); return 0; }",
        "int main() { assert(CountCompleteTreeNodes(NULL) == 0); return 0; }",
        "int main() { assert(CountCompleteTreeNodes(buildTree((int[]){1}, 1)) == 1); return 0; }"
      ],
      "compareHelper": "int* createTreeFromArray(int arr[], int size) { /* implementation here */ }",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;",
      "builders": "TreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func CountCompleteTreeNodes(root *TreeNode) int { return 0 }",
      "testCalls": [
        "func TestCountCompleteTreeNodes(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tarr  []int\n\t\twant int\n\t}{\n\t\t{\"Test Case 1\", []int{1, 2, 3, 4, 5, 6}, 6},\n\t\t{\"Test Case 2\", []int{}, 0},\n\t\t{\"Test Case 3\", []int{1}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot := buildTree(tt.arr)\n\t\t\tif got := CountCompleteTreeNodes(root); got != tt.want {\n\t\t\t\tt.Errorf(\"CountCompleteTreeNodes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "",
      "typeDefs": "type TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}",
      "builders": "func buildTree(arr []int) *TreeNode {\n\tif len(arr) == 0 {\n\t\treturn nil\n\t}\n\troot := &TreeNode{Val: arr[0]}\n\tqueue := []*TreeNode{root}\n\ti := 1\n\tfor len(queue) > 0 && i < len(arr) {\n\t\tnode := queue[0]\n\t\tqueue = queue[1:]\n\t\tif i < len(arr) {\n\t\t\tnode.Left = &TreeNode{Val: arr[i]}\n\t\t\tqueue = append(queue, node.Left)\n\t\t}\n\t\ti++\n\t\tif i < len(arr) {\n\t\t\tnode.Right = &TreeNode{Val: arr[i]}\n\t\t\tqueue = append(queue, node.Right)\n\t\t}\n\t\ti++\n\t}\n\treturn root\n}"
    },
    "rust": {
      "functionDeclaration": "fn CountCompleteTreeNodes(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "let root = build_tree(&[1,2,3,4,5,6]); assert_eq!(CountCompleteTreeNodes(Some(Box::new(root))), 6);",
        "let root = None; assert_eq!(CountCompleteTreeNodes(root), 0);",
        "let root = build_tree(&[1]); assert_eq!(CountCompleteTreeNodes(Some(Box::new(root))), 1);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<TreeNode>>, \n    pub right: Option<Rc<TreeNode>>, \n}\n\nfn build_tree(arr: &[i32]) -> Option<Rc<TreeNode>> {}\n\nfn tree_to_array(root: Option<Rc<TreeNode>>) -> Vec<i32> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<TreeNode>>, \n    pub right: Option<Rc<TreeNode>>, \n}",
      "builders": "fn build_tree(arr: &[i32]) -> Option<Rc<TreeNode>> {}\n\nfn tree_to_array(root: Option<Rc<TreeNode>>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def CountCompleteTreeNodes(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,4,5,6]); result = CountCompleteTreeNodes(root); assert_equal(6, result)",
        "root = buildTree([]); result = CountCompleteTreeNodes(root); assert_equal(0, result)",
        "root = buildTree([1]); result = CountCompleteTreeNodes(root); assert_equal(1, result)"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Build binary tree from array\nend\n\ndef treeToArray(root)\n  # Convert binary tree to array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3,4,5,6]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[]"
        },
        "expected": "0"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[1]"
        },
        "expected": "1"
      }
    ]
  },
  "course-schedule-ii": {
    "title": "Course Schedule II",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
    "difficulty": "Medium",
    "hints": [
      "This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
      "<a href=\"https://www.youtube.com/watch?v=ozso3xxkVGU\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.",
      "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
    ],
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CourseScheduleII(numCourses, prerequisites) { return findOrder(numCourses, prerequisites); }",
      "testCalls": [
        "let testOutput1 = CourseScheduleII(2, [[1,0]]); if(JSON.stringify(testOutput1) !== '[0,1]') { throw new Error('Test Case 1 Failed'); }",
        "let testOutput2 = CourseScheduleII(4, [[1,0],[2,0],[3,1],[3,2]]); if(JSON.stringify(testOutput2) !== '[0,2,1,3]') { throw new Error('Test Case 2 Failed'); }",
        "let testOutput3 = CourseScheduleII(1, []); if(JSON.stringify(testOutput3) !== '[0]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses, prerequisites) {\n    const graph = Array.from({ length: numCourses }, () => []);\n    const indegree = Array(numCourses).fill(0);\n    for (const [course, prereq] of prerequisites) {\n        graph[prereq].push(course);\n        indegree[course]++;\n    }\n    return { graph, indegree };\n}\n\nfunction findOrder(numCourses, prerequisites) {\n    const { graph, indegree } = buildGraph(numCourses, prerequisites);\n    const order = [];\n    const queue = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (indegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n    while (queue.length > 0) {\n        const course = queue.shift();\n        order.push(course);\n        for (const nextCourse of graph[course]) {\n            indegree[nextCourse]--;\n            if (indegree[nextCourse] === 0) {\n                queue.push(nextCourse);\n            }\n        }\n    }\n    return order.length === numCourses ? order : [];\n}"
    },
    "typescript": {
      "functionDeclaration": "function CourseScheduleII(numCourses: number, prerequisites: number[][]): number[]",
      "testCalls": [
        "let result1 = CourseScheduleII(2, buildGraph(2, [[1,0]])); if(JSON.stringify(result1) !== JSON.stringify([0,1])) throw new Error('Test Case 1 Failed');",
        "let result2 = CourseScheduleII(4, buildGraph(4, [[1,0],[2,0],[3,1],[3,2]])); if(JSON.stringify(result2) !== JSON.stringify([0,2,1,3])) throw new Error('Test Case 2 Failed');",
        "let result3 = CourseScheduleII(1, buildGraph(1, [])); if(JSON.stringify(result3) !== JSON.stringify([0])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses: number, prerequisites: number[][]): Map<number, number[]> {\n  const graph = new Map<number, number[]>();\n  for (let i = 0; i < numCourses; i++) {\n    graph.set(i, []);\n  }\n  for (const [course, prereq] of prerequisites) {\n    graph.get(prereq)?.push(course);\n  }\n  return graph;\n}"
    },
    "cpp": {
      "functionDeclaration": "std::vector<int> CourseScheduleII(int numCourses, std::vector<std::vector<int>> prerequisites) { return {}; }",
      "testCalls": [
        "int main() { std::vector<int> r1 = CourseScheduleII(2, {{1,0}}); std::vector<int> e1 = {0,1}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<int> r2 = CourseScheduleII(4, {{1,0},{2,0},{3,1},{3,2}}); if (r2.empty()) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<int> r3 = CourseScheduleII(1, {}); std::vector<int> e3 = {0}; if (r3 != e3) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def CourseScheduleII(numCourses, prerequisites):\n return []",
      "testCalls": [
        "graph = buildGraph(2, [[1,0]])\nresult = CourseScheduleII(2, [[1,0]])\nassert result == [0, 1], 'Test Case 1 Failed'",
        "graph = buildGraph(4, [[1,0],[2,0],[3,1],[3,2]])\nresult = CourseScheduleII(4, [[1,0],[2,0],[3,1],[3,2]])\nassert result == [0, 2, 1, 3], 'Test Case 2 Failed'",
        "graph = buildGraph(1, [])\nresult = CourseScheduleII(1, [])\nassert result == [0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)",
      "typeDefs": "class Graph:\n    def __init__(self, numCourses): ...",
      "builders": "def buildGraph(numCourses, prerequisites): ..."
    },
    "java": {
      "functionDeclaration": "public int[] findOrder(int numCourses, int[][] prerequisites) { return new int[0]; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); int[] result = m.findOrder(2, new int[][]{{1,0}}); if (result.length != 2) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int[] result = m.findOrder(4, new int[][]{{1,0},{2,0},{3,1},{3,2}}); if (result.length != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int[] result = m.findOrder(1, new int[][]{}); if (result.length != 1 || result[0] != 0) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "int* CourseScheduleII(int numCourses, int prerequisites[][2], int prerequisitesSize, int* prerequisitesColSize)",
      "testCalls": [
        "int numCourses1 = 2; int prerequisites1[][2] = {{1,0}}; CourseNode* graph1 = buildGraph(numCourses1, prerequisites1, 1); int* result1 = CourseScheduleII(numCourses1, prerequisites1, 1, (int[]){2}); if (compareArrays(result1, (int[]){0,1}, 2) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int numCourses2 = 4; int prerequisites2[][2] = {{1,0},{2,0},{3,1},{3,2}}; CourseNode* graph2 = buildGraph(numCourses2, prerequisites2, 4); int* result2 = CourseScheduleII(numCourses2, prerequisites2, 4, (int[]){2,2,2,2}); if (compareArrays(result2, (int[]){0,2,1,3}, 4) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return -1; } return 0; }",
      "typeDefs": "typedef struct { int val; int* neighbors; int numNeighbors; } CourseNode;",
      "builders": "CourseNode* buildGraph(int numCourses, int prerequisites[][2], int prerequisitesSize);"
    },
    "go": {
      "functionDeclaration": "func CourseScheduleII(numCourses int, prerequisites [][]int) []int { return nil }",
      "testCalls": [
        "func TestCourseScheduleII(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tnumCourses    int\n\t\tprerequisites [][]int\n\t\twantLen       int\n\t}{\n\t\t{\"Test Case 1\", 2, [][]int{{1, 0}}, 2},\n\t\t{\"Test Case 2\", 4, [][]int{{1, 0}, {2, 0}, {3, 1}, {3, 2}}, 4},\n\t\t{\"Test Case 3\", 1, [][]int{}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := CourseScheduleII(tt.numCourses, tt.prerequisites)\n\t\t\tif len(got) != tt.wantLen {\n\t\t\t\tt.Errorf(\"CourseScheduleII() = %v, want length %v\", got, tt.wantLen)\n\t\t\t}\n\t\t\tif !isValidOrder(got, tt.prerequisites) {\n\t\t\t\tt.Errorf(\"CourseScheduleII() = %v is not valid topological order\", got)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "func isValidOrder(order []int, prerequisites [][]int) bool {\n\tif len(order) == 0 {\n\t\treturn true\n\t}\n\tpos := make(map[int]int)\n\tfor i, course := range order {\n\t\tpos[course] = i\n\t}\n\tfor _, prereq := range prerequisites {\n\t\tcourse, pre := prereq[0], prereq[1]\n\t\tif pos[pre] > pos[course] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
      "typeDefs": "",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn CourseScheduleII(numCourses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {}",
      "testCalls": [
        "let course1 = buildCourse(2, vec![vec![1, 0]]); assert_eq!(courseToArray(CourseScheduleII(course1)), (2, vec![vec![0, 1]]));",
        "let course2 = buildCourse(4, vec![vec![1, 0], vec![2, 0], vec![3, 1], vec![3, 2]]); assert_eq!(courseToArray(CourseScheduleII(course2)), (4, vec![vec![0, 2], vec![1, 3], vec![2, 3]]));",
        "let course3 = buildCourse(1, vec![]); assert_eq!(courseToArray(CourseScheduleII(course3)), (1, vec![]));"
      ],
      "compareHelper": "",
      "helpers": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }\nfn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }",
      "typeDefs": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }",
      "builders": "fn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }"
    },
    "ruby": {
      "functionDeclaration": "def CourseScheduleII(numCourses, prerequisites)\n  \nend",
      "testCalls": [
        "graph = Graph.new\ngraph.add_edge(1, 0)\nresult = CourseScheduleII(2, graph.adj_list)\nraise 'Test Case 1 Failed' unless result == [0, 1]",
        "graph = Graph.new\ngraph.add_edge(1, 0)\ngraph.add_edge(2, 0)\ngraph.add_edge(3, 1)\ngraph.add_edge(3, 2)\nresult = CourseScheduleII(4, graph.adj_list)\nraise 'Test Case 2 Failed' unless result == [0, 2, 1, 3]"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend",
      "typeDefs": "class Graph\n  attr_accessor :adj_list\n  def initialize\n    @adj_list = {}\n  end\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\nend\n",
      "builders": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "numCourses": "2",
          "prerequisites": "[[1,0]]"
        },
        "expected": "[0,1]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "numCourses": "4",
          "prerequisites": "[[1,0],[2,0],[3,1],[3,2]]"
        },
        "expected": "[0,2,1,3]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "numCourses": "1",
          "prerequisites": "[]"
        },
        "expected": "[0]"
      }
    ]
  },
  "course-schedule": {
    "title": "Course Schedule",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.",
    "difficulty": "Medium",
    "hints": [
      "This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
      "<a href=\"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf\" target=\"_blank\">Topological Sort via DFS</a> - A great tutorial explaining the basic concepts of Topological Sort.",
      "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
    ],
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CourseSchedule(numCourses, prerequisites) { return false; }",
      "testCalls": [
        "let testInput1 = buildGraph(2, [[1,0]]); if (CourseSchedule(2, testInput1) !== true) { throw new Error('Test Case 1 Failed'); }",
        "let testInput2 = buildGraph(2, [[1,0],[0,1]]); if (CourseSchedule(2, testInput2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses, prerequisites) { let graph = Array.from({ length: numCourses }, () => []); for (let [course, prereq] of prerequisites) { graph[course].push(prereq); } return graph; }"
    },
    "typescript": {
      "functionDeclaration": "function CourseSchedule(numCourses: number, prerequisites: number[][]): boolean {}",
      "testCalls": [
        "let result1 = CourseSchedule(2, buildGraph(2, [[1,0]])); if(result1 !== true) throw new Error('Test Case 1 Failed');",
        "let result2 = CourseSchedule(2, buildGraph(2, [[1,0],[0,1]])); if(result2 !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "",
      "builders": "function buildGraph(numCourses: number, prerequisites: number[][]): Map<number, number[]> { const graph = new Map(); for (let i = 0; i < numCourses; i++) { graph.set(i, []); } for (const [course, prereq] of prerequisites) { graph.get(course).push(prereq); } return graph; }"
    },
    "cpp": {
      "functionDeclaration": "bool CourseSchedule(int numCourses, std::vector<std::vector<int>> prerequisites) { return false; }",
      "testCalls": [
        "int main() { if (CourseSchedule(2, {{1,0}}) != true) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (CourseSchedule(2, {{1,0},{0,1}}) != false) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def CourseSchedule(numCourses, prerequisites):\n return []",
      "testCalls": [
        "graph = buildGraph(2, [[1,0]])\nresult = CourseSchedule(2, [[1,0]])\nassert result == True, 'Test Case 1 Failed'",
        "graph = buildGraph(2, [[1,0],[0,1]])\nresult = CourseSchedule(2, [[1,0],[0,1]])\nassert result == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": "",
      "typeDefs": "class Graph:\n    def __init__(self, numCourses):\n        self.numCourses = numCourses\n        self.adj_list = {i: [] for i in range(numCourses)}\n\n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n",
      "builders": "def buildGraph(numCourses, prerequisites):\n    graph = Graph(numCourses)\n    for course in prerequisites:\n        graph.add_edge(course[1], course[0])\n    return graph\n"
    },
    "java": {
      "functionDeclaration": "public boolean canFinish(int numCourses, int[][] prerequisites) { return false; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.canFinish(2, new int[][]{{1,0}})) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.canFinish(2, new int[][]{{1,0},{0,1}})) throw new AssertionError(); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "bool CourseSchedule(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize)",
      "testCalls": [
        "int numCourses1 = 2; int prerequisites1[][2] = {{1,0}}; CourseNode* graph1 = buildGraph(numCourses1, prerequisites1, 1); if (!CourseSchedule(numCourses1, prerequisites1, 1, (int[]){2})) { printf(\"Test Case 1 Failed\"); }",
        "int numCourses2 = 2; int prerequisites2[][2] = {{1,0},{0,1}}; CourseNode* graph2 = buildGraph(numCourses2, prerequisites2, 2); if (CourseSchedule(numCourses2, prerequisites2, 2, (int[]){2,2})) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "typeDefs": "typedef struct { int val; int* neighbors; int numNeighbors; } CourseNode;",
      "builders": "CourseNode* buildGraph(int numCourses, int** prerequisites, int prerequisitesSize);\nbool CourseSchedule(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize);"
    },
    "go": {
      "functionDeclaration": "func CourseSchedule(numCourses int, prerequisites [][]int) bool { return false }",
      "testCalls": [
        "func TestCourseSchedule(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tnumCourses    int\n\t\tprerequisites [][]int\n\t\twant          bool\n\t}{\n\t\t{\"Test Case 1\", 2, [][]int{{1, 0}}, true},\n\t\t{\"Test Case 2\", 2, [][]int{{1, 0}, {0, 1}}, false},\n\t\t{\"Test Case 3\", 3, [][]int{{0, 1}, {0, 2}, {1, 2}}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := CourseSchedule(tt.numCourses, tt.prerequisites); got != tt.want {\n\t\t\t\tt.Errorf(\"CourseSchedule() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn CourseSchedule(numCourses: i32, prerequisites: Vec<Vec<i32>>) -> bool {}",
      "testCalls": [
        "let course1 = buildCourse(2, vec![vec![1, 0]]); assert_eq!(courseToArray(CourseSchedule(course1)), (2, vec![vec![0, 1]]));",
        "let course2 = buildCourse(2, vec![vec![1, 0], vec![0, 1]]); assert_eq!(courseToArray(CourseSchedule(course2)), (2, vec![vec![0, 1]]));"
      ],
      "compareHelper": "",
      "helpers": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }\nfn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }",
      "typeDefs": "struct Course { num: i32, prerequisites: Vec<Vec<i32>> }",
      "builders": "fn buildCourse(num: i32, prerequisites: Vec<Vec<i32>>) -> Course { Course { num, prerequisites } }\nfn courseToArray(course: Course) -> (i32, Vec<Vec<i32>>) { (course.num, course.prerequisites) }"
    },
    "ruby": {
      "functionDeclaration": "def CourseSchedule(numCourses, prerequisites)\nend",
      "testCalls": [
        "graph = Graph.new\ngraph.add_edge(1, 0)\nresult = CourseSchedule(2, graph.adj_list)\nraise 'Test Case 1 Failed' unless result == true",
        "graph = Graph.new\ngraph.add_edge(1, 0)\ngraph.add_edge(0, 1)\nresult = CourseSchedule(2, graph.adj_list)\nraise 'Test Case 2 Failed' unless result == false"
      ],
      "compareHelper": "",
      "typeDefs": "class Graph\n  attr_accessor :adj_list\n  def initialize\n    @adj_list = {}\n  end\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\nend\n",
      "builders": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "numCourses": "2",
          "prerequisites": "[[1,0]]"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "numCourses": "2",
          "prerequisites": "[[1,0],[0,1]]"
        },
        "expected": "false"
      }
    ]
  },
  "edit-distance": {
    "title": "Edit Distance",
    "content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EditDistance(word1, word2) { return 0; }",
      "testCalls": [
        "if(EditDistance('horse', 'ros') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(EditDistance('intention', 'execution') !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function EditDistance(word1: string, word2: string): number { return 0; }",
      "testCalls": [
        "if (EditDistance('horse', 'ros') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (EditDistance('intention', 'execution') !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int EditDistance(std::string word1, std::string word2) { return 0; }",
      "testCalls": [
        "int main() { if (EditDistance(\"horse\", \"ros\") != 3) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (EditDistance(\"intention\", \"execution\") != 5) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <string>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def EditDistance(word1: str, word2: str) -> int:\n return 0",
      "testCalls": [
        "assert EditDistance(\"horse\", \"ros\") == 3",
        "assert EditDistance(\"intention\", \"execution\") == 5"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minDistance(String word1, String word2) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.minDistance(\"horse\", \"ros\") != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.minDistance(\"intention\", \"execution\") != 5) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int EditDistance(char* word1, char* word2)",
      "testCalls": [
        "printf(\"EditDistance result: %d\\n\", EditDistance(\"horse\", \"ros\"));",
        "printf(\"EditDistance result: %d\\n\", EditDistance(\"intention\", \"execution\"));"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func EditDistance(word1 string, word2 string) int { return 0 }",
      "testCalls": [
        "func TestEditDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tword1 string\n\t\tword2 string\n\t\twant  int\n\t}{\n\t\t{\"Test Case 1\", \"horse\", \"ros\", 3},\n\t\t{\"Test Case 2\", \"intention\", \"execution\", 5},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EditDistance(tt.word1, tt.word2); got != tt.want {\n\t\t\t\tt.Errorf(\"EditDistance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn EditDistance(word1: String, word2: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(EditDistance(String::from(\"horse\"), String::from(\"ros\")), 3);",
        "assert_eq!(EditDistance(String::from(\"intention\"), String::from(\"execution\")), 5);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EditDistance(word1, word2)\nend",
      "testCalls": [
        "test1 = EditDistance(\"horse\", \"ros\")\nraise 'Test Case 1 Failed' unless test1 == 3",
        "test2 = EditDistance(\"intention\", \"execution\")\nraise 'Test Case 2 Failed' unless test2 == 5"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "word1": "&quot;horse&quot;",
          "word2": "&quot;ros&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "word1": "&quot;intention&quot;",
          "word2": "&quot;execution&quot;"
        },
        "expected": "5"
      }
    ]
  },
  "evaluate-division": {
    "title": "Evaluate Division",
    "content": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote:The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.",
    "difficulty": "Medium",
    "hints": [
      "Do you recognize this as a graph problem?"
    ],
    "topicTags": [
      "Array",
      "String",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph",
      "Shortest Path"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EvaluateDivision(equations, values, queries) {}",
      "testCalls": [
        "let graph1 = buildGraph([['a','b'],['b','c']], [2.0,3.0]); const testOutput1 = EvaluateDivision(graph1, [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]); if(JSON.stringify(testOutput1) !== '[6.00000,0.50000,-1.00000,1.00000,-1.00000]') throw new Error('Test Case 1 Failed');",
        "let graph2 = buildGraph([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0]); const testOutput2 = EvaluateDivision(graph2, [['a','c'],['c','b'],['bc','cd'],['cd','bc']]); if(JSON.stringify(testOutput2) !== '[3.75000,0.40000,5.00000,0.20000]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "",
      "builders": "function buildGraph(equations, values) { let graph = {}; for (let i = 0; i < equations.length; i++) { const [from, to] = equations[i]; const value = values[i]; if (!graph[from]) graph[from] = {}; if (!graph[to]) graph[to] = {}; graph[from][to] = value; graph[to][from] = 1 / value; } return graph; }"
    },
    "typescript": {
      "functionDeclaration": "function EvaluateDivision(equations: string[][], values: number[], queries: string[][]): number[] {}",
      "testCalls": [
        "const test1 = EvaluateDivision([['a','b'],['b','c']], [2.0,3.0], [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]);\nif(JSON.stringify(test1) !== '[6.00000,0.50000,-1.00000,1.00000,-1.00000]') throw new Error('Test Case 1 Failed');",
        "const test2 = EvaluateDivision([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0], [['a','c'],['c','b'],['bc','cd'],['cd','bc']]);\nif(JSON.stringify(test2) !== '[3.75000,0.40000,5.00000,0.20000]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "const compareArrays = (arr1: any[], arr2: any[]): boolean => JSON.stringify(arr1) === JSON.stringify(arr2);",
      "typeDefs": "type Equation = [string, string];\ntype Query = [string, string];",
      "builders": "function buildGraph(equations: string[][], values: number[]): Map<string, Map<string, number>> {}\nfunction dfs(graph: Map<string, Map<string, number>>, start: string, end: string, visited: Set<string>): number {}\nfunction EvaluateDivision(equations: string[][], values: number[], queries: string[][]): number[] {}"
    },
    "cpp": {
      "functionDeclaration": "std::vector<double> EvaluateDivision(std::vector<std::vector<std::string>> equations, std::vector<double> values, std::vector<std::vector<std::string>> queries) { return {}; }",
      "testCalls": [
        "int main() { std::vector<double> r1 = EvaluateDivision({{\"a\",\"b\"},{\"b\",\"c\"}}, {2.0,3.0}, {{\"a\",\"c\"},{\"b\",\"a\"}}); if (r1.empty()) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<double> r2 = EvaluateDivision({{\"a\",\"b\"}}, {0.5}, {{\"a\",\"b\"},{\"b\",\"a\"}}); if (r2.empty()) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <string>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def EvaluateDivision(equations, values, queries):\n return []",
      "testCalls": [
        "assert EvaluateDivision([['a','b'],['b','c']], [2.0,3.0], [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]) == [6.00000,0.50000,-1.00000,1.00000,-1.00000]",
        "assert EvaluateDivision([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0], [['a','c'],['c','b'],['bc','cd'],['cd','bc']]) == [3.75000,0.40000,5.00000,0.20000]",
        "assert EvaluateDivision([['a','b']], [0.5], [['a','b'],['b','a'],['a','c'],['x','y']]) == [0.50000,2.00000,-1.00000,-1.00000]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if abs(arr1[i] - arr2[i]) > 0.00001:\n            return False\n    return True",
      "typeDefs": "class UnionFind:\n    def __init__(self):\n        self.parent = {}\n        self.weight = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.weight[x] = 1.0\n        elif self.parent[x] != x:\n            p, w = self.find(self.parent[x])\n            self.parent[x] = p\n            self.weight[x] *= w\n        return self.parent[x], self.weight[x]\n\n    def union(self, x, y, val):\n        px, wx = self.find(x)\n        py, wy = self.find(y)\n        if px != py:\n            self.parent[px] = py\n            self.weight[px] = val * wy / wx\n\n",
      "builders": "def EvaluateDivision(equations, values, queries):\n    def helper(x, y):\n        if x not in uf.parent or y not in uf.parent:\n            return -1.0\n        px, wx = uf.find(x)\n        py, wy = uf.find(y)\n        if px != py:\n            return -1.0\n        return wx / wy\n\n    uf = UnionFind()\n    for (x, y), val in zip(equations, values):\n        uf.union(x, y, val)\n    return [helper(x, y) for x, y in queries]"
    },
    "java": {
      "functionDeclaration": "public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) { return new double[0]; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<String>> eq1 = Arrays.asList(Arrays.asList(\"a\",\"b\"), Arrays.asList(\"b\",\"c\")); double[] result1 = m.calcEquation(eq1, new double[]{2.0, 3.0}, Arrays.asList(Arrays.asList(\"a\",\"c\"))); if (result1.length == 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<String>> eq2 = Arrays.asList(Arrays.asList(\"a\",\"b\")); double[] result2 = m.calcEquation(eq2, new double[]{0.5}, Arrays.asList(Arrays.asList(\"a\",\"b\"), Arrays.asList(\"b\",\"a\"))); if (result2.length != 2) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "double* EvaluateDivision(char*** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char*** queries, int queriesSize, int* queriesColSize)",
      "testCalls": [
        "Pair* result1 = EvaluateDivision((char***)[[\"a\",\"b\"],[\"b\",\"c\"]], 2, (int[]){2, 2}, (double[]){2.0, 3.0}, 2, (char***)[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]], 5, (int[]){2, 2});\nif (memcmp(result1, (Pair[]){createPair(\"a\", 6.0), createPair(\"b\", 0.5), createPair(\"e\", -1.0), createPair(\"a\", 1.0), createPair(\"x\", -1.0)}, 5 * sizeof(Pair)) != 0) { printf(\"Test case 1 failed\"); }",
        "Pair* result2 = EvaluateDivision((char***)[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], 3, (int[]){2, 2, 2}, (double[]){1.5, 2.5, 5.0}, 3, (char***)[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]], 4, (int[]){2, 2});\nif (memcmp(result2, (Pair[]){createPair(\"a\", 3.75), createPair(\"b\", 0.4), createPair(\"cd\", 5.0), createPair(\"bc\", 0.2)}, 4 * sizeof(Pair)) != 0) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "int compareArrays(double* arr1, double* arr2, int size) {\n  for (int i = 0; i < size; i++) {\n    if (arr1[i] != arr2[i]) return 0;\n  }\n  return 1;\n}",
      "typeDefs": "typedef struct { char* key; double value; } Pair;\nPair* createPair(char* key, double value) { Pair* pair = (Pair*)malloc(sizeof(Pair)); pair->key = key; pair->value = value; return pair; }\n\ntypedef struct { char* val; struct Node* next; double weight; } Node;\nNode* createNode(char* val, double weight) { Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->weight = weight; node->next = NULL; return node; }\n\nNode** createGraph(int size) { return (Node**)malloc(size * sizeof(Node*)); }\n\nvoid addEdge(Node** graph, char* src, char* dest, double weight, int* index) { if (!graph[*index]) graph[*index] = createNode(src, 1.0); Node* node = createNode(dest, weight); node->next = graph[*index]->next; graph[*index]->next = node; }\n\nvoid freeGraph(Node** graph, int size) { for (int i = 0; i < size; i++) { Node* curr = graph[i]; while (curr) { Node* temp = curr; curr = curr->next; free(temp); } } free(graph); }",
      "builders": ""
    },
    "go": {
      "functionDeclaration": "func CalcEquation(equations [][]string, values []float64, queries [][]string) []float64 { return nil }",
      "testCalls": [
        "func TestCalcEquation(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tequations [][]string\n\t\tvalues    []float64\n\t\tqueries   [][]string\n\t\twant      []float64\n\t}{\n\t\t{\"Test Case 1\", [][]string{{\"a\", \"b\"}, {\"b\", \"c\"}}, []float64{2.0, 3.0}, [][]string{{\"a\", \"c\"}, {\"b\", \"a\"}, {\"a\", \"e\"}, {\"a\", \"a\"}, {\"x\", \"x\"}}, []float64{6.0, 0.5, -1.0, 1.0, -1.0}},\n\t\t{\"Test Case 2\", [][]string{{\"a\", \"b\"}, {\"b\", \"c\"}, {\"bc\", \"cd\"}}, []float64{1.5, 2.5, 5.0}, [][]string{{\"a\", \"c\"}, {\"c\", \"b\"}, {\"bc\", \"cd\"}, {\"cd\", \"bc\"}}, []float64{3.75, 0.4, 5.0, 0.2}},\n\t\t{\"Test Case 3\", [][]string{{\"a\", \"b\"}}, []float64{0.5}, [][]string{{\"a\", \"b\"}, {\"b\", \"a\"}, {\"a\", \"c\"}, {\"x\", \"y\"}}, []float64{0.5, 2.0, -1.0, -1.0}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := CalcEquation(tt.equations, tt.values, tt.queries)\n\t\t\tif !compareFloatArrays(got, tt.want) {\n\t\t\t\tt.Errorf(\"CalcEquation() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"math\"\n\nfunc compareFloatArrays(arr1, arr2 []float64) bool {\n\tif len(arr1) != len(arr2) {\n\t\treturn false\n\t}\n\tfor i := range arr1 {\n\t\tif math.Abs(arr1[i]-arr2[i]) > 1e-5 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
      "typeDefs": "",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn EvaluateDivision(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> { }",
      "testCalls": [
        "let mut uf1 = UnionFind::new(2);\nuf1.union(0, 1, 2.0);\nlet result1 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"c\".to_string()]], vec![2.0, 3.0], vec![vec![\"a\".to_string(), \"c\".to_string()], vec![\"b\".to_string(), \"a\".to_string()], vec![\"a\".to_string(), \"e\".to_string()], vec![\"a\".to_string(), \"a\".to_string()], vec![\"x\".to_string(), \"x\".to_string()]);\nassert_eq!(result1, vec![6.0, 0.5, -1.0, 1.0, -1.0]);",
        "let mut uf2 = UnionFind::new(4);\nuf2.union(0, 1, 1.5);\nuf2.union(1, 2, 2.5);\nuf2.union(2, 3, 5.0);\nlet result2 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"c\".to_string()], vec![\"bc\".to_string(), \"cd\".to_string()]], vec![1.5, 2.5, 5.0], vec![vec![\"a\".to_string(), \"c\".to_string()], vec![\"c\".to_string(), \"b\".to_string()], vec![\"bc\".to_string(), \"cd\".to_string()], vec![\"cd\".to_string(), \"bc\".to_string()]]);\nassert_eq!(result2, vec![3.75, 0.4, 5.0, 0.2]);",
        "let mut uf3 = UnionFind::new(3);\nuf3.union(0, 1, 0.5);\nlet result3 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()]], vec![0.5], vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"a\".to_string()], vec![\"a\".to_string(), \"c\".to_string()], vec![\"x\".to_string(), \"y\".to_string()]]);\nassert_eq!(result3, vec![0.5, 2.0, -1.0, -1.0]);"
      ],
      "compareHelper": "",
      "helpers": "struct UnionFind { parent: Vec<usize>, weight: Vec<f64> }\nimpl UnionFind { fn new(n: usize) -> Self { Self { parent: (0..n).collect(), weight: vec![1.0; n] } }\nfn find(&mut self, mut x: usize) -> usize { let mut path = vec![]; while x != self.parent[x] { path.push(x); x = self.parent[x]; } for &p in path.iter() { self.weight[p] *= self.weight[x]; }\nself.parent[x] = x; x }\nfn union(&mut self, mut x: usize, mut y: usize, val: f64) { let root_x = self.find(x); let root_y = self.find(y); if root_x != root_y { self.parent[root_x] = root_y; self.weight[root_x] = val * self.weight[y] / self.weight[x]; } }\n}\n",
      "typeDefs": "struct UnionFind { parent: Vec<usize>, weight: Vec<f64> }\nimpl UnionFind { fn new(n: usize) -> Self { Self { parent: (0..n).collect(), weight: vec![1.0; n] } }\nfn find(&mut self, mut x: usize) -> usize { let mut path = vec![]; while x != self.parent[x] { path.push(x); x = self.parent[x]; } for &p in path.iter() { self.weight[p] *= self.weight[x]; }\nself.parent[x] = x; x }\nfn union(&mut self, mut x: usize, mut y: usize, val: f64) { let root_x = self.find(x); let root_y = self.find(y); if root_x != root_y { self.parent[root_x] = root_y; self.weight[root_x] = val * self.weight[y] / self.weight[x]; } }\n}",
      "builders": ""
    },
    "ruby": {
      "functionDeclaration": "def EvaluateDivision(equations, values, queries)\n  # Function body goes here\nend",
      "testCalls": [
        "result1 = EvaluateDivision([['a', 'b'], ['b', 'c']], [2.0, 3.0], [['a', 'c'], ['b', 'a'], ['a', 'e'], ['a', 'a'], ['x', 'x']]); raise 'Test Case 1 Failed' unless result1 == [6.0, 0.5, -1.0, 1.0, -1.0]",
        "result2 = EvaluateDivision([['a', 'b'], ['b', 'c'], ['bc', 'cd']], [1.5, 2.5, 5.0], [['a', 'c'], ['c', 'b'], ['bc', 'cd'], ['cd', 'bc']]); raise 'Test Case 2 Failed' unless result2 == [3.75, 0.4, 5.0, 0.2]",
        "result3 = EvaluateDivision([['a', 'b']], [0.5], [['a', 'b'], ['b', 'a'], ['a', 'c'], ['x', 'y']]); raise 'Test Case 3 Failed' unless result3 == [0.5, 2.0, -1.0, -1.0]"
      ],
      "compareHelper": "",
      "typeDefs": "class UnionFind\n  def initialize\n    @parent = {}\n    @weight = {}\n  end\n\n  def find(x)\n    @parent[x] = x unless @parent[x]\n    @weight[x] = 1 unless @weight[x]\n    return x if x == @parent[x]\n    px = find(@parent[x])\n    @weight[x] *= @weight[@parent[x]]\n    @parent[x] = px\n    px\n  end\n\n  def union(x, y, val)\n    px, py = find(x), find(y)\n    return false if px == py\n    @parent[px] = py\n    @weight[px] = @weight[y] * val / @weight[x]\n    true\n  end\n\n  def connected(x, y)\n    return false unless @parent[x] && @parent[y]\n    find(x) == find(y)\n  end\n\n  def query(x, y)\n    return -1 unless @parent[x] && @parent[y]\n    wx = @weight[x] || 1\n    wy = @weight[y] || 1\n    wx / wy\n  end\nend",
      "builders": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "equations": "[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]]",
          "values": "[2.0,3.0]",
          "queries": "[[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]"
        },
        "expected": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "equations": "[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]]",
          "values": "[1.5,2.5,5.0]",
          "queries": "[[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]"
        },
        "expected": "[3.75000,0.40000,5.00000,0.20000]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "equations": "[[&quot;a&quot;,&quot;b&quot;]]",
          "values": "[0.5]",
          "queries": "[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]"
        },
        "expected": "[0.50000,2.00000,-1.00000,-1.00000]"
      }
    ]
  },
  "evaluate-reverse-polish-notation": {
    "title": "Evaluate Reverse Polish Notation",
    "content": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\nThe valid operators are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, and &#39;/&#39;.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math",
      "Stack"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EvaluateReversePolishNotation(tokens) { return 0; }",
      "testCalls": [
        "if (EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]) !== 9) { throw new Error('Test Case 1 Failed'); }",
        "if (EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]) !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function EvaluateReversePolishNotation(tokens: string[]): number { return 0; }",
      "testCalls": [
        "const result1 = EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]); if (result1 !== 9) { throw new Error('Test Case 1 Failed'); }",
        "const result2 = EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]); if (result2 !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int EvaluateReversePolishNotation(std::vector<std::string> tokens) { return 0; }",
      "testCalls": [
        "int main() { if (EvaluateReversePolishNotation({\"2\",\"1\",\"+\",\"3\",\"*\"}) != 9) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (EvaluateReversePolishNotation({\"4\",\"13\",\"5\",\"/\",\"+\"}) != 6) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (EvaluateReversePolishNotation({\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"}) != 22) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <string>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def EvaluateReversePolishNotation(tokens: list[str]) -> int:\n return 0",
      "testCalls": [
        "assert EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]) == 9",
        "assert EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]) == 6",
        "assert EvaluateReversePolishNotation([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]) == 22"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int evaluateReversePolishNotation(String[] tokens) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { int result1 = new Main().evaluateReversePolishNotation(new String[]{\"2\",\"1\",\"+\",\"3\",\"*\"}); if (result1 != 9) throw new AssertionError(); }",
        "public static void main(String[] args) { int result2 = new Main().evaluateReversePolishNotation(new String[]{\"4\",\"13\",\"5\",\"/\",\"+\"}); if (result2 != 6) throw new AssertionError(); }",
        "public static void main(String[] args) { int result3 = new Main().evaluateReversePolishNotation(new String[]{\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"}); if (result3 != 22) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int EvaluateReversePolishNotation(char **tokens, int tokensSize)",
      "testCalls": [
        "int main() { if (EvaluateReversePolishNotation((char*[]) {\"2\",\"1\",\"+\",\"3\",\"*\"}, 5) != 9) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { if (EvaluateReversePolishNotation((char*[]) {\"4\",\"13\",\"5\",\"/\",\"+\"}, 5) != 6) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func EvaluateReversePolishNotation(tokens []string) int { return 0 }",
      "testCalls": [
        "func TestEvaluateReversePolishNotation(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ttokens []string\n\t\twant   int\n\t}{\n\t\t{\"Test Case 1\", []string{\"2\", \"1\", \"+\", \"3\", \"*\"}, 9},\n\t\t{\"Test Case 2\", []string{\"4\", \"13\", \"5\", \"/\", \"+\"}, 6},\n\t\t{\"Test Case 3\", []string{\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"}, 22},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EvaluateReversePolishNotation(tt.tokens); got != tt.want {\n\t\t\t\tt.Errorf(\"EvaluateReversePolishNotation() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn EvaluateReversePolishNotation(tokens: Vec<String>) -> i32 {}",
      "testCalls": [
        "assert_eq!(EvaluateReversePolishNotation(vec![\"2\".to_string(), \"1\".to_string(), \"+\".to_string(), \"3\".to_string(), \"*\".to_string()]), 9);",
        "assert_eq!(EvaluateReversePolishNotation(vec![\"4\".to_string(), \"13\".to_string(), \"5\".to_string(), \"/\".to_string(), \"+\".to_string()]), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EvaluateReversePolishNotation(tokens)\nend",
      "testCalls": [
        "result = EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"])\nraise 'Test Case 1 Failed' unless result == 9",
        "result = EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"])\nraise 'Test Case 2 Failed' unless result == 6"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "tokens": "[&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]"
        },
        "expected": "9"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "tokens": "[&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "tokens": "[&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]"
        },
        "expected": "22"
      }
    ]
  },
  "factorial-trailing-zeroes": {
    "title": "Factorial Trailing Zeroes",
    "content": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FactorialTrailingZeroes(n) { return 0; }",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if(FactorialTrailingZeroes(5) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FactorialTrailingZeroes(n: number): number { return 0; }",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) !== 0) throw new Error('Test Case 1 Failed');",
        "if(FactorialTrailingZeroes(5) !== 1) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FactorialTrailingZeroes(int n) { return 0; }",
      "testCalls": [
        "int main() { if (FactorialTrailingZeroes(3) != 0) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (FactorialTrailingZeroes(5) != 1) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def FactorialTrailingZeroes(n: int) -> int:\n return 0",
      "testCalls": [
        "assert FactorialTrailingZeroes(3) == 0, 'Test Case 1 Failed'",
        "assert FactorialTrailingZeroes(5) == 1, 'Test Case 2 Failed'",
        "assert FactorialTrailingZeroes(0) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int trailingZeroes(int n) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.trailingZeroes(3) != 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.trailingZeroes(5) != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.trailingZeroes(0) != 0) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FactorialTrailingZeroes(int n) { return 0; }",
      "testCalls": [
        "int main() { if (FactorialTrailingZeroes(3) != 0) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (FactorialTrailingZeroes(5) != 1) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FactorialTrailingZeroes(n int) int { return 0 }",
      "testCalls": [
        "func TestFactorialTrailingZeroes(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\twant int\n\t}{\n\t\t{\"Test Case 1\", 3, 0},\n\t\t{\"Test Case 2\", 5, 1},\n\t\t{\"Test Case 3\", 0, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := FactorialTrailingZeroes(tt.n); got != tt.want {\n\t\t\t\tt.Errorf(\"FactorialTrailingZeroes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FactorialTrailingZeroes(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(FactorialTrailingZeroes(3), 0);",
        "assert_eq!(FactorialTrailingZeroes(5), 1);",
        "assert_eq!(FactorialTrailingZeroes(0), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FactorialTrailingZeroes(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless FactorialTrailingZeroes(3) == 0",
        "raise 'Test Case 2 Failed' unless FactorialTrailingZeroes(5) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "3"
        },
        "expected": "0"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "5"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "n": "0"
        },
        "expected": "0"
      }
    ]
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
    "title": "Find First and Last Position of Element in Sorted Array",
    "content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou mustwrite an algorithm withO(log n) runtime complexity.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindFirstAndLastPositionOfElementInSortedArray(nums, target) { return null; }",
      "testCalls": [
        "const test1 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8); if(JSON.stringify(test1) !== '[3,4]') throw new Error('Test Case 1 Failed');",
        "const test2 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6); if(JSON.stringify(test2) !== '[-1,-1]') throw new Error('Test Case 2 Failed');",
        "const test3 = FindFirstAndLastPositionOfElementInSortedArray([], 0); if(JSON.stringify(test3) !== '[-1,-1]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FindFirstAndLastPositionOfElementInSortedArray(nums: number[], target: number): number[]",
      "testCalls": [
        "const test1 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8); if (JSON.stringify(test1) !== JSON.stringify([3,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6); if (JSON.stringify(test2) !== JSON.stringify([-1,-1])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = FindFirstAndLastPositionOfElementInSortedArray([], 0); if (JSON.stringify(test3) !== JSON.stringify([-1,-1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<int> FindFirstAndLastPositionOfElementInSortedArray(std::vector<int> nums, int target) { return {}; }",
      "testCalls": [
        "int main() { std::vector<int> r1 = FindFirstAndLastPositionOfElementInSortedArray({5,7,7,8,8,10}, 8); std::vector<int> e1 = {3,4}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<int> r2 = FindFirstAndLastPositionOfElementInSortedArray({5,7,7,8,8,10}, 6); std::vector<int> e2 = {-1,-1}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<int> r3 = FindFirstAndLastPositionOfElementInSortedArray({}, 0); std::vector<int> e3 = {-1,-1}; if (r3 != e3) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def FindFirstAndLastPositionOfElementInSortedArray(nums: list[int], target: int) -> list[int]:\n return []",
      "testCalls": [
        "assert FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8) == [3, 4]",
        "assert FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6) == [-1, -1]",
        "assert FindFirstAndLastPositionOfElementInSortedArray([], 0) == [-1, -1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public int[] searchRange(int[] nums, int target) { return new int[]{-1,-1}; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!Arrays.equals(m.searchRange(new int[]{5,7,7,8,8,10}, 8), new int[]{3,4})) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (!Arrays.equals(m.searchRange(new int[]{5,7,7,8,8,10}, 6), new int[]{-1,-1})) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (!Arrays.equals(m.searchRange(new int[]{}, 0), new int[]{-1,-1})) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;"
    },
    "c": {
      "functionDeclaration": "int* FindFirstAndLastPositionOfElementInSortedArray(int* nums, int numsSize, int target)",
      "testCalls": [
        "int nums1[] = {5,7,7,8,8,10}; int target1 = 8; int* result1 = FindFirstAndLastPositionOfElementInSortedArray(nums1, 6, target1); if (result1[0] != 3 || result1[1] != 4) { printf(\"Test Case 1 Failed\"); }",
        "int nums2[] = {5,7,7,8,8,10}; int target2 = 6; int* result2 = FindFirstAndLastPositionOfElementInSortedArray(nums2, 6, target2); if (result2[0] != -1 || result2[1] != -1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func SearchRange(nums []int, target int) []int { return []int{-1, -1} }",
      "testCalls": [
        "func TestSearchRange(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tnums   []int\n\t\ttarget int\n\t\twant   []int\n\t}{\n\t\t{\"Test Case 1\", []int{5, 7, 7, 8, 8, 10}, 8, []int{3, 4}},\n\t\t{\"Test Case 2\", []int{5, 7, 7, 8, 8, 10}, 6, []int{-1, -1}},\n\t\t{\"Test Case 3\", []int{}, 0, []int{-1, -1}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SearchRange(tt.nums, tt.target)\n\t\t\tif !compareArrays(got, tt.want) {\n\t\t\t\tt.Errorf(\"SearchRange() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n\tif len(arr1) != len(arr2) {\n\t\treturn false\n\t}\n\tfor i := range arr1 {\n\t\tif arr1[i] != arr2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
    },
    "rust": {
      "functionDeclaration": "fn FindFirstAndLastPositionOfElementInSortedArray(nums: Vec<i32>, target: i32) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![5,7,7,8,8,10], 8), vec![3, 4]);",
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![5,7,7,8,8,10], 6), vec![-1, -1]);",
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![], 0), vec![-1, -1]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def FindFirstAndLastPositionOfElementInSortedArray(nums, target)\nend",
      "testCalls": [
        "result = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8)\nraise 'Test Case 1 Failed' unless result == [3,4]",
        "result = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6)\nraise 'Test Case 2 Failed' unless result == [-1,-1]",
        "result = FindFirstAndLastPositionOfElementInSortedArray([], 0)\nraise 'Test Case 3 Failed' unless result == [-1,-1]"
      ],
      "compareHelper": "def arrays_equal(a, b)\na == b\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[5,7,7,8,8,10]",
          "target": "8"
        },
        "expected": "[3,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[5,7,7,8,8,10]",
          "target": "6"
        },
        "expected": "[-1,-1]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[]",
          "target": "0"
        },
        "expected": "[-1,-1]"
      }
    ]
  },
  "find-k-pairs-with-smallest-sums": {
    "title": "Find K Pairs with Smallest Sums",
    "content": "You are given two integer arrays nums1 and nums2 sorted in non-decreasingorder and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindKPairsWithSmallestSums(nums1, nums2, k) { return []; }",
      "testCalls": [
        "const test1 = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3); if(JSON.stringify(test1) !== '[[1,2],[1,4],[1,6]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2 = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2); if(JSON.stringify(test2) !== '[[1,1],[1,1]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FindKPairsWithSmallestSums(nums1: number[], nums2: number[], k: number): number[][] { return []; }",
      "testCalls": [
        "const test1Result = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3); if(JSON.stringify(test1Result) !== '[[1,2],[1,4],[1,6]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2Result = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2); if(JSON.stringify(test2Result) !== '[[1,1],[1,1]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> FindKPairsWithSmallestSums(std::vector<int> nums1, std::vector<int> nums2, int k) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> r1 = FindKPairsWithSmallestSums({1,7,11}, {2,4,6}, 3); std::vector<std::vector<int>> e1 = {{1,2},{1,4},{1,6}}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r2 = FindKPairsWithSmallestSums({1,1,2}, {1,2,3}, 2); std::vector<std::vector<int>> e2 = {{1,1},{1,1}}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def FindKPairsWithSmallestSums(nums1: list[int], nums2: list[int], k: int) -> list[list[int]]:\n return []",
      "testCalls": [
        "assert FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3) == [[1,2],[1,4],[1,6]], 'Test Case 1 Failed'",
        "assert FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2) == [[1,1],[1,1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result1 = m.kSmallestPairs(new int[]{1,7,11}, new int[]{2,4,6}, 3); if (result1.size() != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result2 = m.kSmallestPairs(new int[]{1,1,2}, new int[]{1,2,3}, 2); if (result2.size() != 2) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;"
    },
    "c": {
      "functionDeclaration": "int** FindKPairsWithSmallestSums(int* nums1, int nums1Size, int* nums2, int nums2Size, int k)",
      "testCalls": [
        "int main() { int** result1 = FindKPairsWithSmallestSums((int[]){1,7,11}, 3, (int[]){2,4,6}, 3, 3); if (!CompareArrays(result1, (int*[]){(int[]){1,2}, (int[]){1,4}, (int[]){1,6}}, 3)) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { int** result2 = FindKPairsWithSmallestSums((int[]){1,1,2}, 3, (int[]){1,2,3}, 3, 2); if (!CompareArrays(result2, (int*[]){(int[]){1,1}, (int[]){1,1}}, 2)) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": "int CompareArrays(int** arr1, int** arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i][0] != arr2[i][0] || arr1[i][1] != arr2[i][1]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func FindKPairsWithSmallestSums(nums1 []int, nums2 []int, k int) [][]int { return [][]int{} }",
      "testCalls": [
        "func TestFindKPairsWithSmallestSums(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tnums1 []int\n\t\tnums2 []int\n\t\tk     int\n\t\twant  [][]int\n\t}{\n\t\t{\"Test Case 1\", []int{1, 7, 11}, []int{2, 4, 6}, 3, [][]int{{1, 2}, {1, 4}, {1, 6}}},\n\t\t{\"Test Case 2\", []int{1, 1, 2}, []int{1, 2, 3}, 2, [][]int{{1, 1}, {1, 1}}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := FindKPairsWithSmallestSums(tt.nums1, tt.nums2, tt.k)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"FindKPairsWithSmallestSums() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"reflect\"\n\nfunc compare2DArrays(arr1, arr2 [][]int) bool {\n\treturn reflect.DeepEqual(arr1, arr2)\n}"
    },
    "rust": {
      "functionDeclaration": "fn FindKPairsWithSmallestSums(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = FindKPairsWithSmallestSums(vec![1, 7, 11], vec![2, 4, 6], 3); assert_eq!(result1, vec![vec![1, 2], vec![1, 4], vec![1, 6]]);",
        "let result2 = FindKPairsWithSmallestSums(vec![1, 1, 2], vec![1, 2, 3], 2); assert_eq!(result2, vec![vec![1, 1], vec![1, 1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def FindKPairsWithSmallestSums(nums1, nums2, k)\n  # Function body goes here\nend",
      "testCalls": [
        "result1 = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3)\nraise 'Test Case 1 Failed' unless result1 == [[1,2],[1,4],[1,6]]",
        "result2 = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2)\nraise 'Test Case 2 Failed' unless result2 == [[1,1],[1,1]]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums1": "[1,7,11]",
          "nums2": "[2,4,6]",
          "k": "3"
        },
        "expected": "[[1,2],[1,4],[1,6]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums1": "[1,1,2]",
          "nums2": "[1,2,3]",
          "k": "2"
        },
        "expected": "[[1,1],[1,1]]"
      }
    ]
  },
  "find-minimum-in-rotated-sorted-array": {
    "title": "Find Minimum in Rotated Sorted Array",
    "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\n\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs inO(log n) time.",
    "difficulty": "Medium",
    "hints": [
      "Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2].",
      "You can divide the search space into two and see which direction to go.\r\nCan you think of an algorithm which has O(logN) search complexity?",
      "<ol>\r\n<li>All the elements to the left of inflection point > first element of the array.</li>\r\n<li>All the elements to the right of inflection point < first element of the array.</li>\r\n<ol>"
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindMinimumInRotatedSortedArray(nums) { return null; }",
      "testCalls": [
        "if(FindMinimumInRotatedSortedArray([3,4,5,1,2]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if(FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(FindMinimumInRotatedSortedArray([11,13,15,17]) !== 11) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindMinimumInRotatedSortedArray(nums: number[]): number { return 0; }",
      "testCalls": [
        "if (FindMinimumInRotatedSortedArray([3,4,5,1,2]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if (FindMinimumInRotatedSortedArray([11,13,15,17]) !== 11) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindMinimumInRotatedSortedArray(std::vector<int> nums) { return 0; }",
      "testCalls": [
        "int main() { if (FindMinimumInRotatedSortedArray({3,4,5,1,2}) != 1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (FindMinimumInRotatedSortedArray({4,5,6,7,0,1,2}) != 0) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (FindMinimumInRotatedSortedArray({11,13,15,17}) != 11) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def FindMinimumInRotatedSortedArray(nums: list[int]) -> int:\n return 0",
      "testCalls": [
        "assert FindMinimumInRotatedSortedArray([3,4,5,1,2]) == 1",
        "assert FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) == 0",
        "assert FindMinimumInRotatedSortedArray([11,13,15,17]) == 11"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int findMin(int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.findMin(new int[]{3,4,5,1,2}) != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.findMin(new int[]{4,5,6,7,0,1,2}) != 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.findMin(new int[]{11,13,15,17}) != 11) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindMinimumInRotatedSortedArray(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if (FindMinimumInRotatedSortedArray((int[]) {3,4,5,1,2}, 5) != 1) { printf(\"Test Case 1 Failed\\n\"); } return 0; }",
        "int main() { if (FindMinimumInRotatedSortedArray((int[]) {4,5,6,7,0,1,2}, 7) != 0) { printf(\"Test Case 2 Failed\\n\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindMinimumInRotatedSortedArray(nums []int) int { return 0 }",
      "testCalls": [
        "func TestFindMinimumInRotatedSortedArray(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnums []int\n\t\twant int\n\t}{\n\t\t{\"Test Case 1\", []int{3, 4, 5, 1, 2}, 1},\n\t\t{\"Test Case 2\", []int{4, 5, 6, 7, 0, 1, 2}, 0},\n\t\t{\"Test Case 3\", []int{11, 13, 15, 17}, 11},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := FindMinimumInRotatedSortedArray(tt.nums); got != tt.want {\n\t\t\t\tt.Errorf(\"FindMinimumInRotatedSortedArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindMinimumInRotatedSortedArray(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![3,4,5,1,2]), 1);",
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![4,5,6,7,0,1,2]), 0);",
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![11,13,15,17]), 11);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindMinimumInRotatedSortedArray(nums)\nend",
      "testCalls": [
        "nums1 = [3,4,5,1,2]\nputs FindMinimumInRotatedSortedArray(nums1) == 1 || raise('Test Case 1 Failed')",
        "nums2 = [4,5,6,7,0,1,2]\nputs FindMinimumInRotatedSortedArray(nums2) == 0 || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,4,5,1,2]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[4,5,6,7,0,1,2]"
        },
        "expected": "0"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[11,13,15,17]"
        },
        "expected": "11"
      }
    ]
  },
  "find-peak-element": {
    "title": "Find Peak Element",
    "content": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -&infin;. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindPeakElement(head) { return null; }",
      "testCalls": [
        "let nums1 = [1,2,3,1]; if (FindPeakElement(buildArrayToLinkedList(nums1)) !== 2) throw new Error('Test Case 1 Failed');",
        "let nums2 = [1,2,1,3,5,6,4]; if (FindPeakElement(buildArrayToLinkedList(nums2)) !== 5) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "function buildArrayToLinkedList(arr) { if (!arr.length) return null; let head = { val: arr[0], next: null }; let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = { val: arr[i], next: null }; curr = curr.next; } return head; }\nfunction arrayToLinkedList(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function FindPeakElement(nums: number[]): number { return 0; }",
      "testCalls": [
        "if (FindPeakElement(buildArray([1,2,3,1])) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (FindPeakElement(buildArray([1,2,1,3,5,6,4])) !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "function buildArray(nums: number[]): number[] { return nums; }"
    },
    "cpp": {
      "functionDeclaration": "int FindPeakElement(std::vector<int> nums) { return 0; }",
      "testCalls": [
        "int main() { if (FindPeakElement({1,2,3,1}) != 2) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (FindPeakElement({1,2,1,3,5,6,4}) != 5) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def FindPeakElement(nums: list[int]) -> int:\n return 0",
      "testCalls": [
        "assert FindPeakElement([1,2,3,1]) == 2",
        "assert FindPeakElement([1,2,1,3,5,6,4]) == 5"
      ],
      "compareHelper": "",
      "typeDefs": "from typing import List",
      "builders": ""
    },
    "java": {
      "functionDeclaration": "public int findPeakElement(int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.findPeakElement(new int[]{1,2,3,1}) != 2) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int result = m.findPeakElement(new int[]{1,2,1,3,5,6,4}); if (result != 1 && result != 5) throw new AssertionError(); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "int FindPeakElement(int* nums, int numsSize)",
      "testCalls": [
        "int main() { assert(FindPeakElement(buildArray((int[]){1,2,3,1}, 4), 4) == 2); return 0; }",
        "int main() { assert(FindPeakElement(buildArray((int[]){1,2,1,3,5,6,4}, 7), 7) == 5); return 0; }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "int* buildArray(int* arr, int size) { int* result = malloc(size * sizeof(int)); for (int i = 0; i < size; i++) result[i] = arr[i]; return result; }"
    },
    "go": {
      "functionDeclaration": "func FindPeakElement(nums []int) int { return 0 }",
      "testCalls": [
        "func TestFindPeakElement(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tnums      []int\n\t\tvalidPeaks []int\n\t}{\n\t\t{\"Test Case 1\", []int{1, 2, 3, 1}, []int{2}},\n\t\t{\"Test Case 2\", []int{1, 2, 1, 3, 5, 6, 4}, []int{1, 5}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := FindPeakElement(tt.nums)\n\t\t\tvalid := false\n\t\t\tfor _, peak := range tt.validPeaks {\n\t\t\t\tif got == peak {\n\t\t\t\t\tvalid = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !valid {\n\t\t\t\tt.Errorf(\"FindPeakElement() = %v, want one of %v\", got, tt.validPeaks)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn FindPeakElement(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindPeakElement(vec![1,2,3,1]), 2);",
        "let result = FindPeakElement(vec![1,2,1,3,5,6,4]); assert!(result == 1 || result == 5);"
      ],
      "compareHelper": "",
      "helpers": "struct Solution;\nimpl Solution {\n    fn find_peak_element(nums: Vec<i32>) -> i32 {\n        0\n    }\n}\n",
      "typeDefs": "struct Solution;",
      "builders": "impl Solution {\n    fn find_peak_element(nums: Vec<i32>) -> i32 {\n        0\n    }\n}\n"
    },
    "ruby": {
      "functionDeclaration": "def FindPeakElement(nums)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,1]); raise 'Test Case 1 Failed' unless FindPeakElement(root) == 2",
        "root = buildTree([1,2,1,3,5,6,4]); raise 'Test Case 2 Failed' unless FindPeakElement(root) == 5"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\n",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\n\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  while result[-1].nil?\n    result.pop\n  end\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,1]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,2,1,3,5,6,4]"
        },
        "expected": "5"
      }
    ]
  },
  "find-the-index-of-the-first-occurrence-in-a-string": {
    "title": "Find the Index of the First Occurrence in a String",
    "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Two Pointers",
      "String",
      "String Matching"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindIndexOfTheFirstOccurrenceInAString(haystack, needle) { return null; }",
      "testCalls": [
        "if (FindIndexOfTheFirstOccurrenceInAString('sadbutsad', 'sad') !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if (FindIndexOfTheFirstOccurrenceInAString('leetcode', 'leeto') !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindIndexOfFirstOccurrence(haystack: string, needle: string): number { return 0; }",
      "testCalls": [
        "if (FindIndexOfFirstOccurrence('sadbutsad', 'sad') !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if (FindIndexOfFirstOccurrence('leetcode', 'leeto') !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindIndexOfFirstOccurrenceInString(std::string haystack, std::string needle) { return 0; }",
      "testCalls": [
        "int main() { if (FindIndexOfFirstOccurrenceInString(\"sadbutsad\", \"sad\") != 0) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (FindIndexOfFirstOccurrenceInString(\"leetcode\", \"leeto\") != -1) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <string>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def FindTheIndexOfTheFirstOccurrenceInAString(haystack: str, needle: str) -> int:\n    return haystack.find(needle)",
      "testCalls": [
        "assert FindTheIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\") == 0, 'Test Case 1 Failed'",
        "assert FindTheIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\") == -1, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int strStr(String haystack, String needle) { return -1; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.strStr(\"sadbutsad\", \"sad\") != 0) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.strStr(\"leetcode\", \"leeto\") != -1) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindIndexOfFirstOccurrenceInString(char* haystack, char* needle)",
      "testCalls": [
        "int main() { if (FindIndexOfFirstOccurrenceInString(\"sadbutsad\", \"sad\") != 0) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { if (FindIndexOfFirstOccurrenceInString(\"leetcode\", \"leeto\") != -1) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func StrStr(haystack string, needle string) int { return -1 }",
      "testCalls": [
        "func TestStrStr(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\thaystack string\n\t\tneedle   string\n\t\twant     int\n\t}{\n\t\t{\"Test Case 1\", \"sadbutsad\", \"sad\", 0},\n\t\t{\"Test Case 2\", \"leetcode\", \"leeto\", -1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := StrStr(tt.haystack, tt.needle); got != tt.want {\n\t\t\t\tt.Errorf(\"StrStr() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindIndexOfTheFirstOccurrenceInAString(haystack: &str, needle: &str) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\"), 0);",
        "assert_eq!(FindIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\"), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindTheIndexOfTheFirstOccurrenceInAString(haystack, needle)\nend",
      "testCalls": [
        "result = FindTheIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\")\nraise 'Test Case 1 Failed' unless result == 0",
        "result = FindTheIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\")\nraise 'Test Case 2 Failed' unless result == -1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "haystack": "&quot;sadbutsad&quot;",
          "needle": "&quot;sad&quot;"
        },
        "expected": "0"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "haystack": "&quot;leetcode&quot;",
          "needle": "&quot;leeto&quot;"
        },
        "expected": "-1"
      }
    ]
  },
  "flatten-binary-tree-to-linked-list": {
    "title": "Flatten Binary Tree to Linked List",
    "content": "Given the root of a binary tree, flatten the tree into a &quot;linked list&quot;:\n\nThe &quot;linked list&quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\nThe &quot;linked list&quot; should be in the same order as a pre-order traversal of the binary tree.",
    "difficulty": "Medium",
    "hints": [
      "If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal."
    ],
    "topicTags": [
      "Linked List",
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function FlattenBinaryTreeToLinkedList(root) { return null; }",
      "testCalls": [
        "let root1 = buildTree([1,2,5,3,4,null,6]); if (JSON.stringify(treeToArray(FlattenBinaryTreeToLinkedList(root1))) !== JSON.stringify([1,null,2,null,3,null,4,null,5,null,6])) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([]); if (JSON.stringify(treeToArray(FlattenBinaryTreeToLinkedList(root2))) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function FlattenBinaryTreeToLinkedList(root: TreeNode | null): void",
      "testCalls": [
        "let root1 = buildTree([1,2,5,3,4,null,6]); FlattenBinaryTreeToLinkedList(root1); if(JSON.stringify(treeToArray(root1)) !== '[1,null,2,null,3,null,4,null,5,null,6]') throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([]); FlattenBinaryTreeToLinkedList(root2); if(JSON.stringify(treeToArray(root2)) !== '[]') throw new Error('Test Case 2 Failed');",
        "let root3 = buildTree([0]); FlattenBinaryTreeToLinkedList(root3); if(JSON.stringify(treeToArray(root3)) !== '[0]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }"
    },
    "cpp": {
      "functionDeclaration": "void FlattenBinaryTreeToLinkedList(TreeNode* root) {}",
      "testCalls": [
        "int main() { TreeNode* root1 = buildTree({1,2,5,3,4,-1,6}); FlattenBinaryTreeToLinkedList(root1); if (!root1 || root1->val != 1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { TreeNode* root2 = buildTree({}); FlattenBinaryTreeToLinkedList(root2); return 0; }",
        "int main() { TreeNode* root3 = buildTree({0}); FlattenBinaryTreeToLinkedList(root3); if (!root3 || root3->val != 0) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty()) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def FlattenBinaryTreeToLinkedList(root):\n    pass",
      "testCalls": [
        "root1 = buildTree([1,2,5,3,4,None,6]); FlattenBinaryTreeToLinkedList(root1); assert treeToArray(root1) == [1,None,2,None,3,None,4,None,5,None,6], 'Test Case 1 Failed'",
        "root2 = buildTree([]); FlattenBinaryTreeToLinkedList(root2); assert treeToArray(root2) == [], 'Test Case 2 Failed'",
        "root3 = buildTree([0]); FlattenBinaryTreeToLinkedList(root3); assert treeToArray(root3) == [0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result and result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public void flatten(TreeNode root) { }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode root1 = m.buildTree(new Integer[]{1,2,5,3,4,null,6}); m.flatten(root1); if (root1 == null || root1.val != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); m.flatten(null); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode root3 = m.buildTree(new Integer[]{0}); m.flatten(root3); if (root3 == null || root3.val != 0) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr == null || arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "void FlattenBinaryTreeToLinkedList(struct TreeNode* root)",
      "testCalls": [
        "struct TreeNode* root1 = buildTree((int[]){1,2,5,3,4,0,6}, 7); FlattenBinaryTreeToLinkedList(root1); // Compare result with expected for test case 1",
        "struct TreeNode* root2 = buildTree(NULL, 0); FlattenBinaryTreeToLinkedList(root2); // Compare result with expected for test case 2"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": ""
    },
    "go": {
      "functionDeclaration": "func FlattenBinaryTreeToLinkedList(root *TreeNode) {}",
      "testCalls": [
        "func TestFlattenBinaryTreeToLinkedList(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tarr  []interface{}\n\t\twant []int\n\t}{\n\t\t{\"Test Case 1\", []interface{}{1, 2, 5, 3, 4, nil, 6}, []int{1, 2, 3, 4, 5, 6}},\n\t\t{\"Test Case 2\", []interface{}{}, []int{}},\n\t\t{\"Test Case 3\", []interface{}{0}, []int{0}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot := buildTree(tt.arr)\n\t\t\tFlattenBinaryTreeToLinkedList(root)\n\t\t\tgot := flattenedToArray(root)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"FlattenBinaryTreeToLinkedList() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"reflect\"\n\nfunc flattenedToArray(root *TreeNode) []int {\n\tvar result []int\n\tfor root != nil {\n\t\tresult = append(result, root.Val)\n\t\troot = root.Right\n\t}\n\treturn result\n}",
      "typeDefs": "type TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}",
      "builders": "func buildTree(arr []interface{}) *TreeNode {\n\tif len(arr) == 0 || arr[0] == nil {\n\t\treturn nil\n\t}\n\troot := &TreeNode{Val: arr[0].(int)}\n\tqueue := []*TreeNode{root}\n\ti := 1\n\tfor len(queue) > 0 && i < len(arr) {\n\t\tnode := queue[0]\n\t\tqueue = queue[1:]\n\t\tif i < len(arr) && arr[i] != nil {\n\t\t\tnode.Left = &TreeNode{Val: arr[i].(int)}\n\t\t\tqueue = append(queue, node.Left)\n\t\t}\n\t\ti++\n\t\tif i < len(arr) && arr[i] != nil {\n\t\t\tnode.Right = &TreeNode{Val: arr[i].(int)}\n\t\t\tqueue = append(queue, node.Right)\n\t\t}\n\t\ti++\n\t}\n\treturn root\n}"
    },
    "rust": {
      "functionDeclaration": "fn FlattenBinaryTreeToLinkedList(root: Option<Box<TreeNode>>) {}",
      "testCalls": [
        "let test1_root = Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 3, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })), right: Some(Box::new(TreeNode { val: 5, left: None, right: Some(Box::new(TreeNode { val: 6, left: None, right: None })) })) })); FlattenBinaryTreeToLinkedList(test1_root);",
        "let test2_root = None; FlattenBinaryTreeToLinkedList(test2_root);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<i32>, arr2: Vec<i32>) {\n    if arr1 != arr2 {\n        panic!(\"Arrays are not equal\");\n    }\n}",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n",
      "typeDefs": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n",
      "builders": ""
    },
    "ruby": {
      "functionDeclaration": "def FlattenBinaryTreeToLinkedList(root)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,5,3,4,nil,6]); test_case_1 = FlattenBinaryTreeToLinkedList(head); raise 'Test Case 1 Failed' unless linkedListToArray(test_case_1) == [1,nil,2,nil,3,nil,4,nil,5,nil,6]",
        "head = buildLinkedList([]); test_case_2 = FlattenBinaryTreeToLinkedList(head); raise 'Test Case 2 Failed' unless linkedListToArray(test_case_2) == []",
        "head = buildLinkedList([0]); test_case_3 = FlattenBinaryTreeToLinkedList(head); raise 'Test Case 3 Failed' unless linkedListToArray(test_case_3) == [0]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\n",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  for i in 1...arr.length\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,5,3,4,null,6]"
        },
        "expected": "[1,null,2,null,3,null,4,null,5,null,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[0]"
        },
        "expected": "[0]"
      }
    ]
  },
  "game-of-life": {
    "title": "Game of Life",
    "content": "According to Wikipedia article: &quot;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function GameOfLife(board) { return null; }",
      "testCalls": [
        "GameOfLife(buildTree([0,1,0,null,0,0,1,null,1,1,1,0,0,0,null]))",
        "GameOfLife(buildTree([1,1,null,1,0,null]))"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "",
      "builders": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function GameOfLife(board: number[][]): void",
      "testCalls": [
        "let board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]; GameOfLife(board); if(JSON.stringify(board) !== JSON.stringify([[0,0,0],[1,0,1],[0,1,1],[0,1,0]])) throw new Error('Test Case 1 Failed');",
        "let board = [[1,1],[1,0]]; GameOfLife(board); if(JSON.stringify(board) !== JSON.stringify([[1,1],[1,1]])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: number[][], b: number[][]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "",
      "builders": "function buildTree(arr) { if (!arr.length) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "void GameOfLife(std::vector<std::vector<int>>& board) {}",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> board1 = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; GameOfLife(board1); std::vector<std::vector<int>> e1 = {{0,0,0},{1,0,1},{0,1,1},{0,1,0}}; if (board1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> board2 = {{1,1},{1,0}}; GameOfLife(board2); std::vector<std::vector<int>> e2 = {{1,1},{1,1}}; if (board2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def GameOfLife(board: list[list[int]]) -> None:\n return None",
      "testCalls": [
        "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nGameOfLife(board)\nassert board == [[0,0,0],[1,0,1],[0,1,1],[0,1,0]], 'Test Case 1 Failed'",
        "board = [[1,1],[1,0]]\nGameOfLife(board)\nassert board == [[1,1],[1,1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2) or any(arr1[i] != arr2[i] for i in range(len(arr1))):\n        raise AssertionError('Arrays are not equal')",
      "typeDefs": "from typing import List\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr\n"
    },
    "java": {
      "functionDeclaration": "public void gameOfLife(int[][] board) { }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); int[][] board1 = {{0,1,0},{0,0,1},{1,1,1},{0,0,0}}; m.gameOfLife(board1); if (board1[0][0] != 0 || board1[1][0] != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int[][] board2 = {{1,1},{1,0}}; m.gameOfLife(board2); if (board2[1][1] != 1) throw new AssertionError(); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "void GameOfLife(int** board, int boardSize, int* boardColSize)",
      "testCalls": [
        "int main() {\n    int row1[] = {0,1,0};\n    int row2[] = {0,0,1};\n    int row3[] = {1,1,1};\n    int row4[] = {0,0,0};\n    int* board[] = {row1, row2, row3, row4};\n    int boardColSize[] = {3};\n    int size = 4;\n    GameOfLife(board, size, boardColSize);\n    return 0;\n}",
        "int main() {\n    int row1[] = {1,1};\n    int row2[] = {1,0};\n    int* board[] = {row1, row2};\n    int boardColSize[] = {2};\n    int size = 2;\n    GameOfLife(board, size, boardColSize);\n    return 0;\n}"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) { return 0; } } return 1; }",
      "typeDefs": "typedef struct { int val; struct ListNode* next; } ListNode;\ntypedef struct { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;",
      "builders": "ListNode* buildLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);\nTreeNode* buildTree(int* arr, int size);\nint* treeToArray(TreeNode* root);"
    },
    "go": {
      "functionDeclaration": "func GameOfLife(board [][]int) {}",
      "testCalls": [
        "func TestGameOfLife(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tboard [][]int\n\t\twant  [][]int\n\t}{\n\t\t{\"Test Case 1\", [][]int{{0, 1, 0}, {0, 0, 1}, {1, 1, 1}, {0, 0, 0}}, [][]int{{0, 0, 0}, {1, 0, 1}, {0, 1, 1}, {0, 1, 0}}},\n\t\t{\"Test Case 2\", [][]int{{1, 1}, {1, 0}}, [][]int{{1, 1}, {1, 1}}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tboard := copyBoard(tt.board)\n\t\t\tGameOfLife(board)\n\t\t\tif !reflect.DeepEqual(board, tt.want) {\n\t\t\t\tt.Errorf(\"GameOfLife() = %v, want %v\", board, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"reflect\"\n\nfunc copyBoard(board [][]int) [][]int {\n\tcopy := make([][]int, len(board))\n\tfor i := range board {\n\t\tcopy[i] = make([]int, len(board[i]))\n\t\tfor j := range board[i] {\n\t\t\tcopy[i][j] = board[i][j]\n\t\t}\n\t}\n\treturn copy\n}",
      "typeDefs": "",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn GameOfLife(board: &mut Vec<Vec<i32>>) {}",
      "testCalls": [
        "let mut board1 = GameOfLife::buildBoard(vec![vec![0,1,0],vec![0,0,1],vec![1,1,1],vec![0,0,0]]); GameOfLife::GameOfLife(&mut board1); assert_eq!(board1, vec![vec![0,0,0],vec![1,0,1],vec![0,1,1],vec![0,1,0]]);",
        "let mut board2 = GameOfLife::buildBoard(vec![vec![1,1],vec![1,0]]); GameOfLife::GameOfLife(&mut board2); assert_eq!(board2, vec![vec![1,1],vec![1,1]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_equal(actual: &Vec<Vec<i32>>, expected: &Vec<Vec<i32>>) { for i in 0..actual.len() { assert_eq!(actual[i], expected[i]); }}",
      "helpers": "struct GameOfLife;\nimpl GameOfLife {\n    fn buildBoard(board: Vec<Vec<i32>>) -> Vec<Vec<i32>> { board }\n}\n",
      "typeDefs": "struct GameOfLife;",
      "builders": "impl GameOfLife {\n    fn buildBoard(board: Vec<Vec<i32>>) -> Vec<Vec<i32>> { board }\n}\n"
    },
    "ruby": {
      "functionDeclaration": "def GameOfLife(board)",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])",
        "GameOfLife([[1,1],[1,0]])"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  raise 'Test Failed' unless arr1 == arr2\nend",
      "typeDefs": "class Cell\n  attr_accessor :state\n  def initialize(state)\n    @state = state\n  end\nend",
      "builders": "def GameOfLife(board)\n  # Your code here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "board": "[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]"
        },
        "expected": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "board": "[[1,1],[1,0]]"
        },
        "expected": "[[1,1],[1,1]]"
      }
    ]
  },
  "gas-station": {
    "title": "Gas Station",
    "content": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function GasStation(gas, cost) { return 0; }",
      "testCalls": [
        "if(GasStation([1,2,3,4,5], [3,4,5,1,2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(GasStation([2,3,4], [3,4,3]) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function GasStation(gas: number[], cost: number[]): number { return 0; }",
      "testCalls": [
        "if (GasStation([1,2,3,4,5], [3,4,5,1,2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (GasStation([2,3,4], [3,4,3]) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "const arraysEqual = (a: any[], b: any[]) => JSON.stringify(a) === JSON.stringify(b);"
    },
    "cpp": {
      "functionDeclaration": "int CanCompleteCircuit(std::vector<int> gas, std::vector<int> cost) { return 0; }",
      "testCalls": [
        "int main() { if (CanCompleteCircuit({1,2,3,4,5}, {3,4,5,1,2}) != 3) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (CanCompleteCircuit({2,3,4}, {3,4,3}) != -1) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def GasStation(gas: list[int], cost: list[int]) -> int:\n return 0",
      "testCalls": [
        "assert GasStation([1,2,3,4,5], [3,4,5,1,2]) == 3",
        "assert GasStation([2,3,4], [3,4,3]) == -1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int canCompleteCircuit(int[] gas, int[] cost) { return -1; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.canCompleteCircuit(new int[]{1,2,3,4,5}, new int[]{3,4,5,1,2}) != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.canCompleteCircuit(new int[]{2,3,4}, new int[]{3,4,3}) != -1) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int GasStation(int* gas, int gasSize, int* cost, int costSize)",
      "testCalls": [
        "int main() { if (GasStation((int[]) {1,2,3,4,5}, 5, (int[]) {3,4,5,1,2}, 5) != 3) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { if (GasStation((int[]) {2,3,4}, 3, (int[]) {3,4,3}, 3) != -1) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GasStation(gas []int, cost []int) int { return -1 }",
      "testCalls": [
        "func TestGasStation(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tgas  []int\n\t\tcost []int\n\t\twant int\n\t}{\n\t\t{\"Test Case 1\", []int{1, 2, 3, 4, 5}, []int{3, 4, 5, 1, 2}, 3},\n\t\t{\"Test Case 2\", []int{2, 3, 4}, []int{3, 4, 3}, -1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := GasStation(tt.gas, tt.cost); got != tt.want {\n\t\t\t\tt.Errorf(\"GasStation() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn GasStation(gas: Vec<i32>, cost: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(GasStation(vec![1,2,3,4,5], vec![3,4,5,1,2]), 3);",
        "assert_eq!(GasStation(vec![2,3,4], vec![3,4,3]), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def GasStation(gas, cost)\nend",
      "testCalls": [
        "result = GasStation([1,2,3,4,5], [3,4,5,1,2])\nraise 'Test Case 1 Failed' unless result == 3",
        "result = GasStation([2,3,4], [3,4,3])\nraise 'Test Case 2 Failed' unless result == -1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "gas": "[1,2,3,4,5]",
          "cost": "[3,4,5,1,2]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "gas": "[2,3,4]",
          "cost": "[3,4,3]"
        },
        "expected": "-1"
      }
    ]
  },
  "group-anagrams": {
    "title": "Group Anagrams",
    "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function GroupAnagrams(strs) {}",
      "testCalls": [
        "GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]) === [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "GroupAnagrams([\"\"]) === [[\"\"]]",
        "GroupAnagrams([\"a\"]) === [[\"a\"]]"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function GroupAnagrams(strs: string[]): string[][] { return null as any; }",
      "testCalls": [
        "const test1 = GroupAnagrams(['eat','tea','tan','ate','nat','bat']); if(JSON.stringify(test1) !== '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]') throw new Error('Test Case 1 Failed');",
        "const test2 = GroupAnagrams(['']); if(JSON.stringify(test2) !== '[[\"\"]]') throw new Error('Test Case 2 Failed');",
        "const test3 = GroupAnagrams(['a']); if(JSON.stringify(test3) !== '[[\"a\"]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<std::string>> GroupAnagrams(std::vector<std::string> strs) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<std::string>> r1 = GroupAnagrams({\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}); if (r1.empty()) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<std::string>> r2 = GroupAnagrams({\"\"}); if (r2.empty()) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { std::vector<std::vector<std::string>> r3 = GroupAnagrams({\"a\"}); if (r3.empty()) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <string>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def GroupAnagrams(strs: list[str]) -> list[list[str]]:\n return [[]]",
      "testCalls": [
        "assert compareLists(GroupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']), [['bat'], ['nat', 'tan'], ['ate', 'eat', 'tea']])",
        "assert compareLists(GroupAnagrams(['']), [['']])",
        "assert compareLists(GroupAnagrams(['a']), [['a']])"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if sorted(list1) != sorted(list2):\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public List<List<String>> groupAnagrams(String[] strs) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<String>> result1 = m.groupAnagrams(new String[]{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}); if (result1.size() != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<String>> result2 = m.groupAnagrams(new String[]{\"\"}); if (result2.size() != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<String>> result3 = m.groupAnagrams(new String[]{\"a\"}); if (result3.size() != 1) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;"
    },
    "c": {
      "functionDeclaration": "void GroupAnagrams(char** strs, int strsSize)",
      "testCalls": [
        "int main() { GroupAnagrams((char*[]) {\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}, 6); return 0; }",
        "int main() { GroupAnagrams((char*[]) {\"\"}, 1); return 0; }",
        "int main() { GroupAnagrams((char*[]) {\"a\"}, 1); return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GroupAnagrams(strs []string) [][]string { return [][]string{} }",
      "testCalls": [
        "func TestGroupAnagrams(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tstrs    []string\n\t\twantLen int\n\t}{\n\t\t{\"Test Case 1\", []string{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"}, 3},\n\t\t{\"Test Case 2\", []string{\"\"}, 1},\n\t\t{\"Test Case 3\", []string{\"a\"}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := GroupAnagrams(tt.strs)\n\t\t\tif len(got) != tt.wantLen {\n\t\t\t\tt.Errorf(\"GroupAnagrams() returned %v groups, want %v\", len(got), tt.wantLen)\n\t\t\t}\n\t\t\ttotalStrings := 0\n\t\t\tfor _, group := range got {\n\t\t\t\ttotalStrings += len(group)\n\t\t\t}\n\t\t\tif totalStrings != len(tt.strs) {\n\t\t\t\tt.Errorf(\"GroupAnagrams() returned %v total strings, want %v\", totalStrings, len(tt.strs))\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"sort\"\n\nfunc sortString(s string) string {\n\trunes := []rune(s)\n\tsort.Slice(runes, func(i, j int) bool {\n\t\treturn runes[i] < runes[j]\n\t})\n\treturn string(runes)\n}"
    },
    "rust": {
      "functionDeclaration": "fn GroupAnagrams(strs: Vec<String>) -> Vec<Vec<String>> { }",
      "testCalls": [
        "assert_eq!(GroupAnagrams(vec![\"eat\".to_string(), \"tea\".to_string(), \"tan\".to_string(), \"ate\".to_string(), \"nat\".to_string(), \"bat\".to_string()]), vec![vec![\"bat\".to_string()], vec![\"nat\".to_string(), \"tan\".to_string()], vec![\"ate\".to_string(), \"eat\".to_string(), \"tea\".to_string()]]);",
        "assert_eq!(GroupAnagrams(vec![\"\".to_string()]), vec![vec![\"\".to_string()]]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<Vec<String>>, b: Vec<Vec<String>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i].len(), b[i].len()); for j in 0..a[i].len() { assert_eq!(a[i][j], b[i][j]); } } }"
    },
    "ruby": {
      "functionDeclaration": "def GroupAnagrams(strs)\n  \nend",
      "testCalls": [
        "result1 = GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\nraise 'Test Case 1 Failed' unless result1 == [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "result2 = GroupAnagrams([\"\"])\nraise 'Test Case 2 Failed' unless result2 == [[\"\"]]",
        "result3 = GroupAnagrams([\"a\"])\nraise 'Test Case 3 Failed' unless result3 == [[\"a\"]]"
      ],
      "compareHelper": "def arrays_equal(a, b)\n  a.sort == b.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "strs": "[&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]"
        },
        "expected": "[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "strs": "[&quot;&quot;]"
        },
        "expected": "[[&quot;&quot;]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "strs": "[&quot;a&quot;]"
        },
        "expected": "[[&quot;a&quot;]]"
      }
    ]
  },
  "h-index": {
    "title": "H-Index",
    "content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.",
    "difficulty": "Medium",
    "hints": [
      "An easy approach is to sort the array first.",
      "What are the possible values of h-index?",
      "A faster approach is to use extra space."
    ],
    "topicTags": [
      "Array",
      "Sorting",
      "Counting Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HIndex(citations) { return 0; }",
      "testCalls": [
        "if (HIndex([3,0,6,1,5]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (HIndex([1,3,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HIndex(citations: number[]): number { }",
      "testCalls": [
        "if (HIndex([3,0,6,1,5]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (HIndex([1,3,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "int HIndex(std::vector<int> citations) { return 0; }",
      "testCalls": [
        "int main() { if (HIndex({3,0,6,1,5}) != 3) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (HIndex({1,3,1}) != 1) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def HIndex(citations: list[int]) -> int:\n return 0",
      "testCalls": [
        "assert HIndex([3,0,6,1,5]) == 3",
        "assert HIndex([1,3,1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int hIndex(int[] citations) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.hIndex(new int[]{3,0,6,1,5}) != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.hIndex(new int[]{1,3,1}) != 1) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int HIndex(int* citations, int citationsSize)",
      "testCalls": [
        "int main() { if (HIndex((int[]){3,0,6,1,5}, 5) != 3) { printf(\"Test Case 1 Failed\\n\"); } return 0; }",
        "int main() { if (HIndex((int[]){1,3,1}, 3) != 1) { printf(\"Test Case 2 Failed\\n\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HIndex(citations []int) int { return 0 }",
      "testCalls": [
        "func TestHIndex(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tcitations []int\n\t\twant      int\n\t}{\n\t\t{\"Test Case 1\", []int{3, 0, 6, 1, 5}, 3},\n\t\t{\"Test Case 2\", []int{1, 3, 1}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HIndex(tt.citations); got != tt.want {\n\t\t\t\tt.Errorf(\"HIndex() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HIndex(citations: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(HIndex(vec![3, 0, 6, 1, 5]), 3);",
        "assert_eq!(HIndex(vec![1, 3, 1]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HIndex(citations)\nend",
      "testCalls": [
        "result = HIndex([3,0,6,1,5])\nraise 'Test Case 1 Failed' unless result == 3",
        "result = HIndex([1,3,1])\nraise 'Test Case 2 Failed' unless result == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "citations": "[3,0,6,1,5]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "citations": "[1,3,1]"
        },
        "expected": "1"
      }
    ]
  },
  "happy-number": {
    "title": "Happy Number",
    "content": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\n\nReturn true if n is a happy number, and false if not.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HappyNumber(n) { return null; }",
      "testCalls": [
        "if (HappyNumber(19) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (HappyNumber(2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HappyNumber(n: number): boolean { return false; }",
      "testCalls": [
        "if (HappyNumber(19) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (HappyNumber(2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool HappyNumber(int n) { return false; }",
      "testCalls": [
        "int main() { if (HappyNumber(19) != true) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (HappyNumber(2) != false) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def HappyNumber(n: int) -> bool:\n    return False",
      "testCalls": [
        "assert HappyNumber(19) == True, 'Test Case 1 Failed'",
        "assert HappyNumber(2) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean isHappy(int n) { return false; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.isHappy(19)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.isHappy(2)) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool HappyNumber(int n)",
      "testCalls": [
        "int main() { if (!HappyNumber(19)) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (HappyNumber(2)) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HappyNumber(n int) bool { return false }",
      "testCalls": [
        "func TestHappyNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\twant bool\n\t}{\n\t\t{\"Test Case 1\", 19, true},\n\t\t{\"Test Case 2\", 2, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HappyNumber(tt.n); got != tt.want {\n\t\t\t\tt.Errorf(\"HappyNumber() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HappyNumber(n: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(HappyNumber(19), true);",
        "assert_eq!(HappyNumber(2), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HappyNumber(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless HappyNumber(19) == true",
        "raise 'Test Case 2 Failed' unless HappyNumber(2) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "19"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "2"
        },
        "expected": "false"
      }
    ]
  },
  "house-robber": {
    "title": "House Robber",
    "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HouseRobber(root) { return null; }",
      "testCalls": [
        "if (HouseRobber(buildTree([1,2,3,1])) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (HouseRobber(buildTree([2,7,9,3,1])) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "class TreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction buildTree(arr) {\n    if (!arr.length) return null;\n    const root = new TreeNode(arr[0]);\n    const queue = [root];\n    let i = 1;\n    while (i < arr.length) {\n        const current = queue.shift();\n        if (arr[i] !== null) {\n            current.left = new TreeNode(arr[i]);\n            queue.push(current.left);\n        }\n        i++;\n        if (i < arr.length && arr[i] !== null) {\n            current.right = new TreeNode(arr[i]);\n            queue.push(current.right);\n        }\n        i++;\n    }\n    return root;\n}\n\nfunction treeToArray(root) {\n    if (!root) return [];\n    const result = [];\n    const queue = [root];\n    while (queue.length) {\n        const node = queue.shift();\n        if (node) {\n            result.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            result.push(null);\n        }\n    }\n    while (result[result.length - 1] === null) {\n        result.pop();\n    }\n    return result;\n}"
    },
    "typescript": {
      "functionDeclaration": "function HouseRobber(nums: number[]): number {}",
      "testCalls": [
        "if (HouseRobber(buildTree([1,2,3,1])) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (HouseRobber(buildTree([2,7,9,3,1])) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "function buildTree(arr) { if (!arr.length) return null; let root = { val: arr[0], left: null, right: null }; let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (arr[i] !== null) { node.left = { val: arr[i], left: null, right: null }; queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = { val: arr[i], left: null, right: null }; queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int HouseRobber(std::vector<int> nums) { return 0; }",
      "testCalls": [
        "int main() { if (HouseRobber({1,2,3,1}) != 4) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (HouseRobber({2,7,9,3,1}) != 12) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def HouseRobber(nums: list[int]) -> int:\n return 0",
      "testCalls": [
        "assert HouseRobber(build_tree([1,2,3,1])) == 4",
        "assert HouseRobber(build_tree([2,7,9,3,1])) == 12"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": "def build_tree(arr): ..."
    },
    "java": {
      "functionDeclaration": "public int rob(int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.rob(new int[]{1,2,3,1}) != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.rob(new int[]{2,7,9,3,1}) != 12) throw new AssertionError(); }"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "int HouseRobber(int* nums, int numsSize)",
      "testCalls": [
        "if(HouseRobber((int[]){1,2,3,1}, 4) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(HouseRobber((int[]){2,7,9,3,1}, 5) != 12) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "",
      "typeDefs": "typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } TreeNode;\ntypedef struct ListNode { int val; struct ListNode *next; } ListNode;",
      "builders": "TreeNode* buildTree(int* arr, int size) { return NULL; }\nint* treeToArray(TreeNode* root, int* returnSize) { return NULL; }\nListNode* buildLinkedList(int* arr, int size) { return NULL; }\nint* linkedListToArray(ListNode* head, int* returnSize) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func HouseRobber(nums []int) int { return 0 }",
      "testCalls": [
        "func TestHouseRobber(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnums []int\n\t\twant int\n\t}{\n\t\t{\"Test Case 1\", []int{1, 2, 3, 1}, 4},\n\t\t{\"Test Case 2\", []int{2, 7, 9, 3, 1}, 12},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HouseRobber(tt.nums); got != tt.want {\n\t\t\t\tt.Errorf(\"HouseRobber() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "",
      "typeDefs": "",
      "builders": ""
    },
    "rust": {
      "functionDeclaration": "fn HouseRobber(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "let nums1 = vec![1,2,3,1]; let result1 = HouseRobber(nums1); assert_eq!(result1, 4);",
        "let nums2 = vec![2,7,9,3,1]; let result2 = HouseRobber(nums2); assert_eq!(result2, 12);"
      ],
      "compareHelper": "",
      "helpers": "struct ListNode { val: i32, next: Option<Box<ListNode>> }\n\nfn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {}",
      "typeDefs": "struct ListNode { val: i32, next: Option<Box<ListNode>> }",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {}"
    },
    "ruby": {
      "functionDeclaration": "def HouseRobber(nums)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,1]); raise 'Test Case 1 Failed' unless HouseRobber(head) == 4",
        "head = buildLinkedList([2,7,9,3,1]); raise 'Test Case 2 Failed' unless HouseRobber(head) == 12"
      ],
      "compareHelper": "",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,1]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[2,7,9,3,1]"
        },
        "expected": "12"
      }
    ]
  },
  "insert-interval": {
    "title": "Insert Interval",
    "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don&#39;t need to modify intervals in-place. You can make a new array and return it.",
    "difficulty": "Medium",
    "hints": [
      "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
      "Can you try merging the overlapping intervals while inserting the new interval?",
      "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
    ],
    "topicTags": [
      "Array"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function InsertInterval(intervals, newInterval) {}",
      "testCalls": [
        "arraysEqual(InsertInterval([[1,3],[6,9]], [2,5]), [[1,5],[6,9]]) || throwError(1)",
        "arraysEqual(InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]), [[1,2],[3,10],[12,16]]) || throwError(2)"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); } function throwError(num) { throw new Error(`Test Case ${num} Failed!`); }"
    },
    "typescript": {
      "functionDeclaration": "function InsertInterval(intervals: number[][], newInterval: number[]): number[][] { return []; }",
      "testCalls": [
        "if (JSON.stringify(InsertInterval([[1,3],[6,9]], [2,5])) !== '[[1,5],[6,9]]') { throw new Error('Test Case 1 Failed'); }",
        "if (JSON.stringify(InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])) !== '[[1,2],[3,10],[12,16]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "std::vector<std::vector<int>> InsertInterval(std::vector<std::vector<int>> intervals, std::vector<int> newInterval) { return {}; }",
      "testCalls": [
        "int main() { std::vector<std::vector<int>> r1 = InsertInterval({{1,3},{6,9}}, {2,5}); std::vector<std::vector<int>> e1 = {{1,5},{6,9}}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { std::vector<std::vector<int>> r2 = InsertInterval({{1,2},{3,5},{6,7},{8,10},{12,16}}, {4,8}); std::vector<std::vector<int>> e2 = {{1,2},{3,10},{12,16}}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def InsertInterval(intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:\n return [[]]",
      "testCalls": [
        "assert InsertInterval([[1,3],[6,9]], [2,5]) == [[1,5],[6,9]], 'Test Case 1 Failed'",
        "assert InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) == [[1,2],[3,10],[12,16]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)",
      "typeDefs": "from typing import List"
    },
    "java": {
      "functionDeclaration": "public int[][] InsertInterval(int[][] intervals, int[] newInterval) { return new int[0][0]; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); assert Arrays.deepEquals(m.InsertInterval(new int[][]{{1,3},{6,9}}, new int[]{2,5}), new int[][]{{1,5},{6,9}}); }",
        "public static void main(String[] args) { Main m = new Main(); assert Arrays.deepEquals(m.InsertInterval(new int[][]{{1,2},{3,5},{6,7},{8,10},{12,16}}, new int[]{4,8}), new int[][]{{1,2},{3,10},{12,16}}); }"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) {\n    return Arrays.deepEquals(arr1, arr2);\n}"
    },
    "c": {
      "functionDeclaration": "int** intervalsInsert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) { return NULL; }",
      "testCalls": [
        "int intervals1_data[][2] = {{1,3},{6,9}}; int* intervals1[] = {intervals1_data[0], intervals1_data[1]}; int intervalsSize1 = 2; int intervalsColSize1 = 2; int newInterval1[] = {2,5}; int newIntervalSize1 = 2; int returnSize1; int* returnColumnSizes1; int** result1 = intervalsInsert(intervals1, intervalsSize1, &intervalsColSize1, newInterval1, newIntervalSize1, &returnSize1, &returnColumnSizes1); if (!compareArrays(result1, &returnSize1, returnColumnSizes1, (int*[]){(int[]){1,5},(int[]){6,9}}, 2, 2)) { printf(\"Test Case 1 Failed\"); }",
        "int intervals2_data[][2] = {{1,2},{3,5},{6,7},{8,10},{12,16}}; int* intervals2[] = {intervals2_data[0], intervals2_data[1], intervals2_data[2], intervals2_data[3], intervals2_data[4]}; int intervalsSize2 = 5; int intervalsColSize2 = 2; int newInterval2[] = {4,8}; int newIntervalSize2 = 2; int returnSize2; int* returnColumnSizes2; int** result2 = intervalsInsert(intervals2, intervalsSize2, &intervalsColSize2, newInterval2, newIntervalSize2, &returnSize2, &returnColumnSizes2); if (!compareArrays(result2, &returnSize2, returnColumnSizes2, (int*[]){(int[]){1,2},(int[]){3,10},(int[]){12,16}}, 3, 2)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int** arr1, int* size1, int* colSize1, int** arr2, int size2, int colSize2) { if (*size1 != size2 || *colSize1 != colSize2) { return 0; } for (int i = 0; i < size2; i++) { for (int j = 0; j < colSize2; j++) { if (arr1[i][j] != arr2[i][j]) { return 0; } } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func InsertInterval(intervals [][]int, newInterval []int) [][]int { return [][]int{} }",
      "testCalls": [
        "func TestInsertInterval(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tintervals   [][]int\n\t\tnewInterval []int\n\t\twant        [][]int\n\t}{\n\t\t{\"Test Case 1\", [][]int{{1, 3}, {6, 9}}, []int{2, 5}, [][]int{{1, 5}, {6, 9}}},\n\t\t{\"Test Case 2\", [][]int{{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}}, []int{4, 8}, [][]int{{1, 2}, {3, 10}, {12, 16}}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := InsertInterval(tt.intervals, tt.newInterval)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"InsertInterval() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"reflect\""
    },
    "rust": {
      "functionDeclaration": "fn InsertInterval(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(InsertInterval(vec![vec![1,3], vec![6,9]], vec![2,5]), vec![vec![1,5], vec![6,9]]);",
        "assert_eq!(InsertInterval(vec![vec![1,2], vec![3,5], vec![6,7], vec![8,10], vec![12,16]], vec![4,8]), vec![vec![1,2], vec![3,10], vec![12,16]]);"
      ],
      "compareHelper": "fn assert_2d_vec_eq(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i], b[i]); } }"
    },
    "ruby": {
      "functionDeclaration": "def InsertInterval(intervals, newInterval)\nend",
      "testCalls": [
        "test_case_1 = InsertInterval([[1,3],[6,9]], [2,5])\nraise 'Test Case 1 Failed' unless test_case_1 == [[1,5],[6,9]]",
        "test_case_2 = InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\nraise 'Test Case 2 Failed' unless test_case_2 == [[1,2],[3,10],[12,16]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "intervals": "[[1,3],[6,9]]",
          "newInterval": "[2,5]"
        },
        "expected": "[[1,5],[6,9]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "intervals": "[[1,2],[3,5],[6,7],[8,10],[12,16]]",
          "newInterval": "[4,8]"
        },
        "expected": "[[1,2],[3,10],[12,16]]"
      }
    ]
  },
  "integer-to-roman": {
    "title": "Integer to Roman",
    "content": "Seven different symbols represent Roman numerals with the following values:\n\n\n\nSymbol\nValue\n\n\n\n\nI\n1\n\n\nV\n5\n\n\nX\n10\n\n\nL\n50\n\n\nC\n100\n\n\nD\n500\n\n\nM\n1000\n\n\n\nRoman numerals are formed by appendingthe conversions ofdecimal place valuesfrom highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\nIf the value does not start with 4 or9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\nIf the value starts with 4 or 9 use thesubtractive formrepresentingone symbol subtracted from the following symbol, for example,4 is 1 (I) less than 5 (V): IVand 9 is 1 (I) less than 10 (X): IX.Only the following subtractive forms are used: 4 (IV), 9 (IX),40 (XL), 90 (XC), 400 (CD) and 900 (CM).\nOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5(V), 50 (L), or 500 (D) multiple times. If you need to append a symbol4 timesuse the subtractive form.\n\nGiven an integer, convert it to a Roman numeral.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function IntegerToRoman(num) { return ''; }",
      "testCalls": [
        "if (IntegerToRoman(3749) !== \"MMMDCCXLIX\") { throw new Error(\"Test Case 1 Failed\"); }",
        "if (IntegerToRoman(58) !== \"LVIII\") { throw new Error(\"Test Case 2 Failed\"); }",
        "if (IntegerToRoman(1994) !== \"MCMXCIV\") { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IntegerToRoman(num: number): string { return ''; }",
      "testCalls": [
        "if (IntegerToRoman(3749) !== 'MMMDCCXLIX') throw new Error('Test Case 1 Failed');",
        "if (IntegerToRoman(58) !== 'LVIII') throw new Error('Test Case 2 Failed');",
        "if (IntegerToRoman(1994) !== 'MCMXCIV') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "std::string IntegerToRoman(int num) { return \"\"; }",
      "testCalls": [
        "int main() { if (IntegerToRoman(3749) != \"MMMDCCXLIX\") throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (IntegerToRoman(58) != \"LVIII\") throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (IntegerToRoman(1994) != \"MCMXCIV\") throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <string>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def IntegerToRoman(num: int) -> str:\n return ''",
      "testCalls": [
        "assert IntegerToRoman(3749) == 'MMMDCCXLIX', 'Test Case 1 Failed'",
        "assert IntegerToRoman(58) == 'LVIII', 'Test Case 2 Failed'",
        "assert IntegerToRoman(1994) == 'MCMXCIV', 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String intToRoman(int num) { return \"\"; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.intToRoman(3749).equals(\"MMMDCCXLIX\")) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (!m.intToRoman(58).equals(\"LVIII\")) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (!m.intToRoman(1994).equals(\"MCMXCIV\")) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* IntegerToRoman(int num)",
      "testCalls": [
        "printf(\"%s\\n\", IntegerToRoman(3749));",
        "printf(\"%s\\n\", IntegerToRoman(58));",
        "printf(\"%s\\n\", IntegerToRoman(1994));"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IntegerToRoman(num int) string { return \"\" }",
      "testCalls": [
        "func TestIntegerToRoman(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnum  int\n\t\twant string\n\t}{\n\t\t{\"Test Case 1\", 3749, \"MMMDCCXLIX\"},\n\t\t{\"Test Case 2\", 58, \"LVIII\"},\n\t\t{\"Test Case 3\", 1994, \"MCMXCIV\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := IntegerToRoman(tt.num); got != tt.want {\n\t\t\t\tt.Errorf(\"IntegerToRoman() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn IntegerToRoman(num: i32) -> String { }",
      "testCalls": [
        "assert_eq!(IntegerToRoman(3749), \"MMMDCCXLIX\");",
        "assert_eq!(IntegerToRoman(58), \"LVIII\"); assert_eq!(IntegerToRoman(1994), \"MCMXCIV\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def IntegerToRoman(num)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless IntegerToRoman(3749) == 'MMMDCCXLIX'",
        "raise 'Test Case 2 Failed' unless IntegerToRoman(58) == 'LVIII'"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "num": "3749"
        },
        "expected": "&quot;MMMDCCXLIX&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "num": "58"
        },
        "expected": "&quot;LVIII&quot;"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "num": "1994"
        },
        "expected": "&quot;MCMXCIV&quot;"
      }
    ]
  },
  "interleaving-string": {
    "title": "Interleaving String",
    "content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| <= 1\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function InterleavingString(s1, s2, s3) { return null; }",
      "testCalls": [
        "if(InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if(InterleavingString('', '', '') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function InterleavingString(s1: string, s2: string, s3: string): boolean { return false; }",
      "testCalls": [
        "if (InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if (InterleavingString('', '', '') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool InterleavingString(std::string s1, std::string s2, std::string s3) { return false; }",
      "testCalls": [
        "int main() { if (InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { if (InterleavingString(\"\", \"\", \"\") != true) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <string>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def InterleavingString(s1: str, s2: str, s3: str) -> bool:\n return False",
      "testCalls": [
        "assert InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') == True, 'Test Case 1 Failed'",
        "assert InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') == False, 'Test Case 2 Failed'",
        "assert InterleavingString('', '', '') == True, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean isInterleave(String s1, String s2, String s3) { return false; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.isInterleave(\"aabcc\", \"dbbca\", \"aadbbcbcac\")) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.isInterleave(\"aabcc\", \"dbbca\", \"aadbbbaccc\")) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (!m.isInterleave(\"\", \"\", \"\")) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool InterleavingString(char *s1, char *s2, char *s3)",
      "testCalls": [
        "int main() { if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true) { printf(\"Test Case 1 Failed\"); }",
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false) { printf(\"Test Case 2 Failed\"); }",
        "if(InterleavingString(\"\", \"\", \"\") != true) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsInterleave(s1 string, s2 string, s3 string) bool { return false }",
      "testCalls": [
        "func TestIsInterleave(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   string\n\t\ts2   string\n\t\ts3   string\n\t\twant bool\n\t}{\n\t\t{\"Test Case 1\", \"aabcc\", \"dbbca\", \"aadbbcbcac\", true},\n\t\t{\"Test Case 2\", \"aabcc\", \"dbbca\", \"aadbbbaccc\", false},\n\t\t{\"Test Case 3\", \"\", \"\", \"\", true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := IsInterleave(tt.s1, tt.s2, tt.s3); got != tt.want {\n\t\t\t\tt.Errorf(\"IsInterleave() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn InterleavingString(s1: &str, s2: &str, s3: &str) -> bool {}",
      "testCalls": [
        "assert_eq!(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\"), true);",
        "assert_eq!(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\"), false);",
        "assert_eq!(InterleavingString(\"\", \"\", \"\"), true);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def InterleavingString(s1, s2, s3)\nend",
      "testCalls": [
        "result1 = InterleavingString('aabcc', 'dbbca', 'aadbbcbcac')\nraise 'Test Case 1 Failed' unless result1 == true",
        "result2 = InterleavingString('aabcc', 'dbbca', 'aadbbbaccc')\nraise 'Test Case 2 Failed' unless result2 == false",
        "result3 = InterleavingString('', '', '')\nraise 'Test Case 3 Failed' unless result3 == true"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s1": "&quot;aabcc&quot;",
          "s2": "&quot;dbbca&quot;",
          "s3": "&quot;aadbbcbcac&quot;"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s1": "&quot;aabcc&quot;",
          "s2": "&quot;dbbca&quot;",
          "s3": "&quot;aadbbbaccc&quot;"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s1": "&quot;&quot;",
          "s2": "&quot;&quot;",
          "s3": "&quot;&quot;"
        },
        "expected": "true"
      }
    ]
  },
  "invert-binary-tree": {
    "title": "Invert Binary Tree",
    "content": "Given the root of a binary tree, invert the tree, and return its root.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function InvertBinaryTree(root) {}",
      "testCalls": [
        "let root = buildTree([4,2,7,1,3,6,9]); InvertBinaryTree(root); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([4,7,2,9,6,3,1])) throw 'Test Case 1 Failed';",
        "let root = buildTree([2,1,3]); InvertBinaryTree(root); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([2,3,1])) throw 'Test Case 2 Failed';",
        "let root = buildTree([]); InvertBinaryTree(root); if (JSON.stringify(treeToArray(root)) !== JSON.stringify([])) throw 'Test Case 3 Failed';"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function InvertBinaryTree(root: TreeNode | null): TreeNode | null",
      "testCalls": [
        "let root1 = buildTree([4,2,7,1,3,6,9]); if (JSON.stringify(treeToArray(InvertBinaryTree(root1))) !== JSON.stringify([4,7,2,9,6,3,1])) throw new Error('Test Case 1 Failed');",
        "let root2 = buildTree([2,1,3]); if (JSON.stringify(treeToArray(InvertBinaryTree(root2))) !== JSON.stringify([2,3,1])) throw new Error('Test Case 2 Failed');",
        "let root3 = buildTree([]); if (JSON.stringify(treeToArray(InvertBinaryTree(root3))) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createBinaryTree(arr: number[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift()!; if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }",
      "typeDefs": "type TreeNode = { val: number; left: TreeNode | null; right: TreeNode | null; };",
      "builders": "function buildTree(arr: (number | null)[]): TreeNode | null { /* Builder function code */ }\nfunction treeToArray(root: TreeNode | null): (number | null)[] { /* Converter function code */ }"
    },
    "cpp": {
      "functionDeclaration": "TreeNode* InvertBinaryTree(TreeNode* root) { return nullptr; }",
      "testCalls": [
        "int main() { TreeNode* root1 = buildTree({4,2,7,1,3,6,9}); std::vector<int> r1 = treeToArray(InvertBinaryTree(root1)); std::vector<int> e1 = {4,7,2,9,6,3,1}; if (r1 != e1) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { TreeNode* root2 = buildTree({2,1,3}); std::vector<int> r2 = treeToArray(InvertBinaryTree(root2)); std::vector<int> e2 = {2,3,1}; if (r2 != e2) throw std::runtime_error(\"Test 2 failed\"); return 0; }",
        "int main() { TreeNode* root3 = buildTree({}); std::vector<int> r3 = treeToArray(InvertBinaryTree(root3)); std::vector<int> e3 = {}; if (r3 != e3) throw std::runtime_error(\"Test 3 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <queue>\n#include <stdexcept>\n\nclass TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\n\nstd::vector<int> treeToArray(TreeNode* root) { if (!root) return {}; std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (!result.empty() && result.back() == -1) result.pop_back(); return result; }",
      "typeDefs": "",
      "builders": ""
    },
    "python": {
      "functionDeclaration": "def InvertBinaryTree(root):\n return []",
      "testCalls": [
        "root = buildTree([4,2,7,1,3,6,9]); assert treeToArray(InvertBinaryTree(root)) == [4,7,2,9,6,3,1]",
        "root = buildTree([2,1,3]); assert treeToArray(InvertBinaryTree(root)) == [2,3,1]",
        "root = buildTree([]); assert treeToArray(InvertBinaryTree(root)) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode invertTree(TreeNode root) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); TreeNode root1 = m.buildTree(new Integer[]{4,2,7,1,3,6,9}); TreeNode result1 = m.invertTree(root1); if (result1 == null || result1.val != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode root2 = m.buildTree(new Integer[]{2,1,3}); TreeNode result2 = m.invertTree(root2); if (result2 == null || result2.val != 2) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); TreeNode result3 = m.invertTree(null); if (result3 != null) throw new AssertionError(); }"
      ],
      "compareHelper": "import java.util.*;\n\nclass TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }\n\npublic TreeNode buildTree(Integer[] arr) { if (arr == null || arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }",
      "typeDefs": "",
      "builders": ""
    },
    "c": {
      "functionDeclaration": "struct TreeNode* InvertBinaryTree(struct TreeNode* root);",
      "testCalls": [
        "struct TreeNode* root1 = buildTreeFromArray((int[]) {4, 2, 7, 1, 3, 6, 9}, 7); assert(compareArrays(InvertBinaryTree(root1), buildTreeFromArray((int[]) {4, 7, 2, 9, 6, 3, 1}, 7)));",
        "struct TreeNode* root2 = buildTreeFromArray((int[]) {2, 1, 3}, 3); assert(compareArrays(InvertBinaryTree(root2), buildTreeFromArray((int[]) {2, 3, 1}, 3)));",
        "assert(compareArrays(InvertBinaryTree(NULL), NULL));"
      ],
      "compareHelper": "bool compareArrays(struct TreeNode* root1, struct TreeNode* root2) { int size1 = 0, size2 = 0; int* arr1 = treeToArray(root1, &size1); int* arr2 = treeToArray(root2, &size2); if (size1 != size2) return false; for (int i = 0; i < size1; i++) { if (arr1[i] != arr2[i]) return false; } return true; }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* createTreeNode(int val) { struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node->val = val; node->left = NULL; node->right = NULL; return node; }\nstruct TreeNode* buildTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode** nodes = (struct TreeNode**)malloc(size * sizeof(struct TreeNode*)); for (int i = 0; i < size; i++) { if (arr[i] != -1) nodes[i] = createTreeNode(arr[i]); else nodes[i] = NULL; } for (int i = 0; i < size; i++) { if (nodes[i] != NULL) { int leftIndex = 2 * i + 1; int rightIndex = 2 * i + 2; if (leftIndex < size) nodes[i]->left = nodes[leftIndex]; if (rightIndex < size) nodes[i]->right = nodes[rightIndex]; } } struct TreeNode* root = nodes[0]; free(nodes); return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* arr = (int*)malloc(sizeof(int) * 1000); int index = 0; struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000); int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { arr[index++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { arr[index++] = -1; } } while (index > 0 && arr[index - 1] == -1) index--; *returnSize = index; free(queue); return arr; }"
    },
    "go": {
      "functionDeclaration": "func InvertBinaryTree(root *TreeNode) *TreeNode { return nil }",
      "testCalls": [
        "func TestInvertBinaryTree(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tarr  []int\n\t\twant []int\n\t}{\n\t\t{\"Test Case 1\", []int{4, 2, 7, 1, 3, 6, 9}, []int{4, 7, 2, 9, 6, 3, 1}},\n\t\t{\"Test Case 2\", []int{2, 1, 3}, []int{2, 3, 1}},\n\t\t{\"Test Case 3\", []int{}, []int{}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot := buildTree(tt.arr)\n\t\t\tgot := treeToArray(InvertBinaryTree(root))\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"InvertBinaryTree() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": "import \"reflect\"",
      "typeDefs": "type TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}",
      "builders": "func buildTree(arr []int) *TreeNode {\n\tif len(arr) == 0 {\n\t\treturn nil\n\t}\n\troot := &TreeNode{Val: arr[0]}\n\tqueue := []*TreeNode{root}\n\ti := 1\n\tfor len(queue) > 0 && i < len(arr) {\n\t\tnode := queue[0]\n\t\tqueue = queue[1:]\n\t\tif i < len(arr) {\n\t\t\tnode.Left = &TreeNode{Val: arr[i]}\n\t\t\tqueue = append(queue, node.Left)\n\t\t}\n\t\ti++\n\t\tif i < len(arr) {\n\t\t\tnode.Right = &TreeNode{Val: arr[i]}\n\t\t\tqueue = append(queue, node.Right)\n\t\t}\n\t\ti++\n\t}\n\treturn root\n}\n\nfunc treeToArray(root *TreeNode) []int {\n\tif root == nil {\n\t\treturn []int{}\n\t}\n\tvar result []int\n\tqueue := []*TreeNode{root}\n\tfor len(queue) > 0 {\n\t\tnode := queue[0]\n\t\tqueue = queue[1:]\n\t\tif node != nil {\n\t\t\tresult = append(result, node.Val)\n\t\t\tqueue = append(queue, node.Left)\n\t\t\tqueue = append(queue, node.Right)\n\t\t}\n\t}\n\treturn result\n}"
    },
    "rust": {
      "functionDeclaration": "fn InvertBinaryTree(root: Option<Box<TreeNode>>) -> Option<Box<TreeNode>> { }",
      "testCalls": [
        "let root = build_tree(vec![Some(4), Some(2), Some(7), Some(1), Some(3), Some(6), Some(9)]); assert_eq!(tree_to_array(InvertBinaryTree(root)), vec![Some(4), Some(7), Some(2), Some(9), Some(6), Some(3), Some(1)], \"Test case 1 failed\");",
        "let root = build_tree(vec![Some(2), Some(1), Some(3)]); assert_eq!(tree_to_array(InvertBinaryTree(root)), vec![Some(2), Some(3), Some(1)], \"Test case 2 failed\");"
      ],
      "compareHelper": "fn assert_tree_eq(tree1: Option<Box<TreeNode>>, tree2: Option<Box<TreeNode>>) { }",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let root = Box::new(TreeNode::new(arr[0].unwrap()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                node.left = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.left.clone().unwrap());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.right = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.right.clone().unwrap());\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.val));\n            if node.left.is_some() || node.right.is_some() {\n                queue.push_back(node.left.unwrap_or_else(|| Box::new(TreeNode::new(0))));\n                queue.push_back(node.right.unwrap_or_else(|| Box::new(TreeNode::new(0))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let root = Some(Box::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(Some(node)) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                node.left = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.left.clone());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.right = Some(Box::new(TreeNode::new(arr[i].unwrap())));\n                queue.push_back(node.right.clone());\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    // Remove trailing None values\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def InvertBinaryTree(root)\nend",
      "testCalls": [
        "root = buildTree([4,2,7,1,3,6,9]); if treeToArray(InvertBinaryTree(root)) != [4,7,2,9,6,3,1]; raise 'Test Case 1 Failed'; end",
        "root = buildTree([2,1,3]); if treeToArray(InvertBinaryTree(root)) != [2,3,1]; raise 'Test Case 2 Failed'; end",
        "root = buildTree([]); if treeToArray(InvertBinaryTree(root)) != []; raise 'Test Case 3 Failed'; end"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[4,2,7,1,3,6,9]"
        },
        "expected": "[4,7,2,9,6,3,1]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[2,1,3]"
        },
        "expected": "[2,3,1]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "ipo": {
    "title": "IPO",
    "content": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function IPO(k, w, profits, capital) { return 0; }",
      "testCalls": [
        "if (IPO(2, 0, [1,2,3], [0,1,1]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (IPO(3, 0, [1,2,3], [0,1,2]) !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IPO(k: number, w: number, profits: number[], capital: number[]): number { return 0; }",
      "testCalls": [
        "if (IPO(2, 0, [1,2,3], [0,1,1]) !== 4) throw new Error('Test Case 1 Failed');",
        "if (IPO(3, 0, [1,2,3], [0,1,2]) !== 6) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindMaximizedCapital(int k, int w, std::vector<int> profits, std::vector<int> capital) { return 0; }",
      "testCalls": [
        "int main() { if (FindMaximizedCapital(2, 0, {1,2,3}, {0,1,1}) != 4) throw std::runtime_error(\"Test 1 failed\"); return 0; }",
        "int main() { if (FindMaximizedCapital(3, 0, {1,2,3}, {0,1,2}) != 6) throw std::runtime_error(\"Test 2 failed\"); return 0; }"
      ],
      "compareHelper": "#include <vector>\n#include <stdexcept>"
    },
    "python": {
      "functionDeclaration": "def IPO(k: int, w: int, profits: list[int], capital: list[int]) -> int:\n return 0",
      "testCalls": [
        "assert IPO(2, 0, [1,2,3], [0,1,1]) == 4",
        "assert IPO(3, 0, [1,2,3], [0,1,2]) == 6"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.findMaximizedCapital(2, 0, new int[]{1,2,3}, new int[]{0,1,1}) != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.findMaximizedCapital(3, 0, new int[]{1,2,3}, new int[]{0,1,2}) != 6) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int IPO(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize)",
      "testCalls": [
        "int main() { if(IPO(2, 0, (int[]){1,2,3}, 3, (int[]){0,1,1}, 3) != 4) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(IPO(3, 0, (int[]){1,2,3}, 3, (int[]){0,1,2}, 3) != 6) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IPO(k int, w int, profits []int, capital []int) int { return 0 }",
      "testCalls": [
        "func TestIPO(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tk       int\n\t\tw       int\n\t\tprofits []int\n\t\tcapital []int\n\t\twant    int\n\t}{\n\t\t{\"Test Case 1\", 2, 0, []int{1, 2, 3}, []int{0, 1, 1}, 4},\n\t\t{\"Test Case 2\", 3, 0, []int{1, 2, 3}, []int{0, 1, 2}, 6},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := IPO(tt.k, tt.w, tt.profits, tt.capital); got != tt.want {\n\t\t\t\tt.Errorf(\"IPO() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn Ipo(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(Ipo(2, 0, vec![1, 2, 3], vec![0, 1, 1]), 4);",
        "assert_eq!(Ipo(3, 0, vec![1, 2, 3], vec![0, 1, 2]), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def Ipo(k, w, profits, capital)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless Ipo(2, 0, [1,2,3], [0,1,1]) == 4",
        "raise 'Test Case 2 Failed' unless Ipo(3, 0, [1,2,3], [0,1,2]) == 6"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "k": "2",
          "w": "0",
          "profits": "[1,2,3]",
          "capital": "[0,1,1]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "k": "3",
          "w": "0",
          "profits": "[1,2,3]",
          "capital": "[0,1,2]"
        },
        "expected": "6"
      }
    ]
  },
  "isomorphic-strings": {
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function IsomorphicStrings(s, t) { return null; }",
      "testCalls": [
        "if(IsomorphicStrings('egg', 'add') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(IsomorphicStrings('foo', 'bar') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if(IsomorphicStrings('paper', 'title') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IsomorphicStrings(s: string, t: string): boolean { return false; }",
      "testCalls": [
        "if(IsomorphicStrings('egg', 'add') !== true) throw new Error('Test Case 1 Failed');",
        "if(IsomorphicStrings('foo', 'bar') !== false) throw new Error('Test Case 2 Failed');",
        "if(IsomorphicStrings('paper', 'title') !== true) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool IsomorphicStrings(string s, string t);",
      "testCalls": [
        "int main() { if(IsomorphicStrings(\"egg\", \"add\") != true) { throw std::runtime_error(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(IsomorphicStrings(\"foo\", \"bar\") != false) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if(IsomorphicStrings(\"paper\", \"title\") != true) { throw std::runtime_error(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IsomorphicStrings(s: str, t: str) -> bool:\n    return False",
      "testCalls": [
        "assert IsomorphicStrings(\"egg\", \"add\") == True, 'Test Case 1 Failed'",
        "assert IsomorphicStrings(\"foo\", \"bar\") == False, 'Test Case 2 Failed'",
        "assert IsomorphicStrings(\"paper\", \"title\") == True, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean IsomorphicStrings(String s, String t) { return false; }",
      "testCalls": [
        "if(!m.IsomorphicStrings(\"egg\", \"add\")) throw new AssertionError();",
        "if(m.IsomorphicStrings(\"foo\", \"bar\")) throw new AssertionError();",
        "if(!m.IsomorphicStrings(\"paper\", \"title\")) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool IsomorphicStrings(char* s, char* t)",
      "testCalls": [
        "int main() { if(IsomorphicStrings(\"egg\", \"add\") != true) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(IsomorphicStrings(\"foo\", \"bar\") != false) { printf(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if(IsomorphicStrings(\"paper\", \"title\") != true) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsomorphicStrings(s string, t string) bool {}",
      "testCalls": [
        "func main() { if IsomorphicStrings(\"egg\", \"add\") != true {panic(\"Test case 1 failed\")}}",
        "func main() { if IsomorphicStrings(\"foo\", \"bar\") != false {panic(\"Test case 2 failed\")}}",
        "func main() { if IsomorphicStrings(\"paper\", \"title\") != true {panic(\"Test case 3 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn IsomorphicStrings(s: String, t: String) -> bool {}",
      "testCalls": [
        "assert_eq!(IsomorphicStrings(String::from(\"egg\"), String::from(\"add\")), true);",
        "assert_eq!(IsomorphicStrings(String::from(\"foo\"), String::from(\"bar\")), false);",
        "assert_eq!(IsomorphicStrings(String::from(\"paper\"), String::from(\"title\")), true);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def IsomorphicStrings(s, t)\nend",
      "testCalls": [
        "puts(IsomorphicStrings('egg', 'add')) == true || raise('Test Case 1 Failed')",
        "puts(IsomorphicStrings('foo', 'bar')) == false || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;egg&quot;",
          "t": "&quot;add&quot;"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;foo&quot;",
          "t": "&quot;bar&quot;"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;paper&quot;",
          "t": "&quot;title&quot;"
        },
        "expected": "true"
      }
    ]
  },
  "jump-game-ii": {
    "title": "Jump Game II",
    "content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned atindex 0.\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j)where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach indexn - 1.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function JumpGameII(nums) { return 0; }",
      "testCalls": [
        "if(JumpGameII([2,3,1,1,4]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(JumpGameII([2,3,0,1,4]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function JumpGameII(nums: number[]): number { return 0; }",
      "testCalls": [
        "if (JumpGameII([2,3,1,1,4]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGameII([2,3,0,1,4]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int JumpGameII(std::vector<int>& nums);",
      "testCalls": [
        "int main() { assert(JumpGameII(vector<int>{2,3,1,1,4}) == 2); return 0; }",
        "int main() { assert(JumpGameII(vector<int>{2,3,0,1,4}) == 2); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def JumpGameII(nums: List[int]) -> int:",
      "testCalls": [
        "assert JumpGameII([2,3,1,1,4]) == 2",
        "assert JumpGameII([2,3,0,1,4]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int JumpGameII(int[] nums) { return 0; }",
      "testCalls": [
        "if (JumpGameII(new int[]{2, 3, 1, 1, 4}) != 2) throw new AssertionError();",
        "if (JumpGameII(new int[]{2, 3, 0, 1, 4}) != 2) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int JumpGameII(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if(JumpGameII((int[]){2,3,1,1,4}, 5) != 2) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(JumpGameII((int[]){2,3,0,1,4}, 5) != 2) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func JumpGameII(nums []int) int {}",
      "testCalls": [
        "func main() { if JumpGameII([]int{2,3,1,1,4}) != 2 {panic(\"Test case 1 failed\")}}",
        "func main() { if JumpGameII([]int{2,3,0,1,4}) != 2 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn JumpGameIi(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(JumpGameIi(vec![2,3,1,1,4]), 2);",
        "assert_eq!(JumpGameIi(vec![2,3,0,1,4]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def JumpGameII(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless JumpGameII([2,3,1,1,4]) == 2",
        "raise 'Test Case 2 Failed' unless JumpGameII([2,3,0,1,4]) == 2"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[2,3,1,1,4]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[2,3,0,1,4]"
        },
        "expected": "2"
      }
    ]
  },
  "jump-game": {
    "title": "Jump Game",
    "content": "You are given an integer array nums. You are initially positioned at the array first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function JumpGame(nums) { return false; }",
      "testCalls": [
        "if (JumpGame([2,3,1,1,4]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGame([3,2,1,0,4]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function JumpGame(nums: number[]): boolean { return false; }",
      "testCalls": [
        "if (JumpGame([2,3,1,1,4]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGame([3,2,1,0,4]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool JumpGame(std::vector<int>& nums);",
      "testCalls": [
        "int main() { if (JumpGame({2,3,1,1,4}) != true) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { if (JumpGame({3,2,1,0,4}) != false) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def JumpGame(nums: List[int]) -> bool:",
      "testCalls": [
        "assert JumpGame([2,3,1,1,4]) == True, 'Test Case 1 Failed'",
        "assert JumpGame([3,2,1,0,4]) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean JumpGame(int[] nums) { return false; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.JumpGame(new int[]{2,3,1,1,4}) != true) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.JumpGame(new int[]{3,2,1,0,4}) != false) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool CanJump(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if (CanJump((int[]){2,3,1,1,4}, 5) != true) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (CanJump((int[]){3,2,1,0,4}, 5) != false) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func JumpGame(nums []int) bool {}",
      "testCalls": [
        "func main() { if JumpGame([]int{2,3,1,1,4}) != true { panic(\"Test case 1 failed\") } }",
        "func main() { if JumpGame([]int{3,2,1,0,4}) != false { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn JumpGame(nums: Vec<i32>) -> bool {}",
      "testCalls": [
        "assert_eq!(JumpGame(vec![2,3,1,1,4]), true);",
        "assert_eq!(JumpGame(vec![3,2,1,0,4]), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def JumpGame(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless JumpGame([2,3,1,1,4]) == true",
        "raise 'Test Case 2 Failed' unless JumpGame([3,2,1,0,4]) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[2,3,1,1,4]"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[3,2,1,0,4]"
        },
        "expected": "false"
      }
    ]
  },
  "kth-largest-element-in-an-array": {
    "title": "Kth Largest Element in an Array",
    "content": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function KthLargestElementInAnArray(nums, k) { return null; }",
      "testCalls": [
        "if(KthLargestElementInAnArray([3,2,1,5,6,4], 2) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function KthLargestElementInAnArray(nums: number[], k: number): number { return 0; }",
      "testCalls": [
        "if (KthLargestElementInAnArray([3,2,1,5,6,4], 2) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if (KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int KthLargestElementInAnArray(std::vector<int>& nums, int k) { return 0; }",
      "testCalls": [
        "assert(KthLargestElementInAnArray(std::vector<int>{3, 2, 1, 5, 6, 4}, 2) == 5);",
        "assert(KthLargestElementInAnArray(std::vector<int>{3, 2, 3, 1, 2, 4, 5, 5, 6}, 4) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def KthLargestElementInArray(nums: List[int], k: int) -> int:",
      "testCalls": [
        "assert KthLargestElementInArray([3,2,1,5,6,4], 2) == 5",
        "assert KthLargestElementInArray([3,2,3,1,2,4,5,5,6], 4) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int KthLargestElementInArray(int[] nums, int k) { return 0; }",
      "testCalls": [
        "if (m.KthLargestElementInArray(new int[]{3,2,1,5,6,4}, 2) != 5) throw new AssertionError();",
        "if (m.KthLargestElementInArray(new int[]{3,2,3,1,2,4,5,5,6}, 4) != 4) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int KthLargestElementInAnArray(int* nums, int numsSize, int k) { return 0; }",
      "testCalls": [
        "int result1 = KthLargestElementInAnArray((int[]){3,2,1,5,6,4}, 6, 2); // Expected: 5",
        "int result2 = KthLargestElementInAnArray((int[]){3,2,3,1,2,4,5,5,6}, 9, 4); // Expected: 4"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindKthLargest(nums []int, k int) int {}",
      "testCalls": [
        "func main() { if FindKthLargest([]int{3,2,1,5,6,4}, 2) != 5 { panic(\"Test case 1 failed\") } }",
        "func main() { if FindKthLargest([]int{3,2,3,1,2,4,5,5,6}, 4) != 4 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn KthLargestElementInAnArray(nums: Vec<i32>, k: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(KthLargestElementInAnArray(vec![3,2,1,5,6,4], 2), 5);",
        "assert_eq!(KthLargestElementInAnArray(vec![3,2,3,1,2,4,5,5,6], 4), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def KthLargestElementInAnArray(nums, k)\n  \nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless KthLargestElementInAnArray([3,2,1,5,6,4], 2) == 5",
        "raise 'Test Case 2 Failed' unless KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,2,1,5,6,4]",
          "k": "2"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[3,2,3,1,2,4,5,5,6]",
          "k": "4"
        },
        "expected": "4"
      }
    ]
  },
  "kth-smallest-element-in-a-bst": {
    "title": "Kth Smallest Element in a BST",
    "content": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
    "difficulty": "Medium",
    "hints": [
      "Try to utilize the property of a BST.",
      "Try in-order traversal. (Credits to @chan13)",
      "What if you could modify the BST node's structure?",
      "The optimal runtime complexity is O(height of BST)."
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function KthSmallestElementInABST(root, k) { return 0; }",
      "testCalls": [
        "let root1 = buildTree([3,1,4,null,2]); if (KthSmallestElementInABST(root1, 1) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "let root2 = buildTree([5,3,6,2,4,null,null,1]); if (KthSmallestElementInABST(root2, 3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function KthSmallestElementInBST(root: TreeNode | null, k: number): number { }",
      "testCalls": [
        "if (KthSmallestElementInBST(TreeNode.fromArray([3,1,4,null,2]), 1) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (KthSmallestElementInBST(TreeNode.fromArray([5,3,6,2,4,null,null,1]), 3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "class TreeNode { val: number; left: TreeNode | null; right: TreeNode | null; constructor(val = 0, left = null, right = null) { this.val = val; this.left = left; this.right = right; } }",
      "builders": "static fromArray(arr: Array<number | null>): TreeNode | null { if (arr.length === 0 || arr[0] === null) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (queue.length && i < arr.length) { const node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }"
    },
    "cpp": {
      "functionDeclaration": "int KthSmallestElementInABST(TreeNode* root, int k);",
      "testCalls": [
        "if (KthSmallestElementInABST(createTree({3,1,4,-1,2}), 1) != 1) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (KthSmallestElementInABST(createTree({5,3,6,2,4,-1,-1,1}), 3) != 3) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "std::vector<int> helperCreateTree(std::vector<int> values) { /* Helper function to create a binary tree from values */ }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == -1) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != -1) { node->left = new TreeNode(arr[i]); q.push(node->left); } ++i; if (i < arr.size() && arr[i] != -1) { node->right = new TreeNode(arr[i]); q.push(node->right); } ++i; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; if (!root) return result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (result.back() == -1) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def KthSmallestElementInABST(root: TreeNode, k: int) -> int:",
      "testCalls": [
        "root = buildTree([3,1,4,None,2]); assert KthSmallestElementInABST(root, 1) == 1, 'Test Case 1 Failed'",
        "root = buildTree([5,3,6,2,4,None,None,1]); assert KthSmallestElementInABST(root, 3) == 3, 'Test Case 2 Failed'"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr:\n        return None\n    nodes = [TreeNode(val) if val is not None else None for val in arr]\n    root = nodes[0]\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if node:\n            node.left = nodes[i]\n            queue.append(node.left)\n            i += 1\n            if i < len(arr):\n                node.right = nodes[i]\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public int KthSmallestElementInBST(TreeNode root, int k) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { if(new Main().KthSmallestElementInBST(buildTree(new Integer[]{3,1,4,null,2}), 1) != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { if(new Main().KthSmallestElementInBST(buildTree(new Integer[]{5,3,6,2,4,null,null,1}), 3) != 3) throw new AssertionError(); }"
      ],
      "compareHelper": "public static class TreeNode { static TreeNode buildTree(Integer[] values) { return null; } }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public static TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }"
    },
    "c": {
      "functionDeclaration": "int KthSmallestElementInBST(struct TreeNode* root, int k)",
      "testCalls": [
        "int main() { if(KthSmallestElementInBST(buildTree((int[]){3,1,4,-1,2}, 5), 1) != 1) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(KthSmallestElementInBST(buildTree((int[]){5,3,6,2,4,-1,-1,1}, 8), 3) != 3) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": "struct TreeNode* createTreeFromString(char* str) { /* implementation to create tree from string */ }",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createNode(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; }\nstruct TreeNode* buildTree(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = createNode(arr[0]); struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (front < rear && i < size) { struct TreeNode* node = queue[front++]; if (arr[i] != -1) { node->left = createNode(arr[i]); queue[rear++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = createNode(arr[i]); queue[rear++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 10000); int index = 0; struct TreeNode* queue[10000]; int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { result[index++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { result[index++] = -1; } } while (index > 0 && result[index - 1] == -1) index--; *returnSize = index; return result; }"
    },
    "go": {
      "functionDeclaration": "func KthSmallestElementInBST(root *TreeNode, k int) int {}",
      "testCalls": [
        "func test1() { root := buildTree([]int{3,1,4,-1,2}); if KthSmallestElementInBST(root, 1) != 1 {panic(\"Test case 1 failed\")}}",
        "func test2() { root := buildTree([]int{5,3,6,2,4,-1,-1,1}); if KthSmallestElementInBST(root, 3) != 3 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": "",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode { return nil } func treeToArray(root *TreeNode) []int { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn KthSmallestElementInBST(root: Option<Box<TreeNode>>, k: i32) -> i32 { }",
      "testCalls": [
        "let root1 = build_tree(vec![Some(3), Some(1), Some(4), None, Some(2)]); assert_eq!(KthSmallestElementInBST(root1, 1), 1);",
        "let root2 = build_tree(vec![Some(5), Some(3), Some(6), Some(2), Some(4), None, None, Some(1)]); assert_eq!(KthSmallestElementInBST(root2, 3), 3);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() { return None; }\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(Some(val)) = arr.get(i) {\n                let left_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().left = Some(left_child.clone());\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if let Some(Some(val)) = arr.get(i) {\n                let right_child = Rc::new(RefCell::new(TreeNode::new(*val)));\n                node.borrow_mut().right = Some(right_child.clone());\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.borrow().val));\n            if node.borrow().left.is_some() || node.borrow().right.is_some() {\n                queue.push_back(node.borrow().left.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(-1)))));\n                queue.push_back(node.borrow().right.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(-1)))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "use std::collections::VecDeque;\nuse std::collections::LinkedList;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                let left_child = Rc::new(RefCell::new(TreeNode::new(arr[i].unwrap())));\n                node.borrow_mut().left = Some(left_child.clone());\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                let right_child = Rc::new(RefCell::new(TreeNode::new(arr[i].unwrap())));\n                node.borrow_mut().right = Some(right_child.clone());\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            let node_borrowed = node.borrow();\n            result.push(Some(node_borrowed.val));\n            if node_borrowed.left.is_some() || node_borrowed.right.is_some() {\n                queue.push_back(node_borrowed.left.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(0)))));\n                queue.push_back(node_borrowed.right.clone().unwrap_or_else(|| Rc::new(RefCell::new(TreeNode::new(0)))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def KthSmallestElementInABST(root, k)\nend",
      "testCalls": [
        "root = buildTree([3,1,4,nil,2]); raise 'Test Case 1 Failed' unless KthSmallestElementInABST(root, 1) == 1",
        "root = buildTree([5,3,6,2,4,nil,nil,1]); raise 'Test Case 2 Failed' unless KthSmallestElementInABST(root, 3) == 3"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,1,4,null,2]",
          "k": "1"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[5,3,6,2,4,null,null,1]",
          "k": "3"
        },
        "expected": "3"
      }
    ]
  },
  "length-of-last-word": {
    "title": "Length of Last Word",
    "content": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LengthOfLastWord(s) {}",
      "testCalls": [
        "if(LengthOfLastWord(\"Hello World\") !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(LengthOfLastWord(\"   fly me   to   the moon  \") !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LengthOfLastWord(s: string): number { return 0; }",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") !== 5) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") !== 4) { throw new Error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int LengthOfLastWord(string s);",
      "testCalls": [
        "int main() { if (LengthOfLastWord(\"Hello World\") != 5) { throw std::runtime_error(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LengthOfLastWord(s: str) -> int:",
      "testCalls": [
        "assert LengthOfLastWord(\"Hello World\") == 5",
        "assert LengthOfLastWord(\"   fly me   to   the moon  \") == 4",
        "assert LengthOfLastWord(\"luffy is still joyboy\") == 6"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LengthOfLastWord(String s) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.LengthOfLastWord(\"Hello World\") != 5) { throw new AssertionError(); } }",
        "public static void main(String[] args) { Main m = new Main(); if (m.LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { throw new AssertionError(); } }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LengthOfLastWord(char *s)",
      "testCalls": [
        "int main() { if (LengthOfLastWord(\"Hello World\") != 5) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LengthOfLastWord(s string) int {}",
      "testCalls": [
        "func main() { if LengthOfLastWord(\"Hello World\") != 5 {panic(\"Test case 1 failed\")}}",
        "func main() { if LengthOfLastWord(\"   fly me   to   the moon  \") != 4 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LengthOfLastWord(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(LengthOfLastWord(String::from(\"Hello World\")), 5);",
        "assert_eq!(LengthOfLastWord(String::from(\"   fly me   to   the moon  \")), 4);",
        "assert_eq!(LengthOfLastWord(String::from(\"luffy is still joyboy\")), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LengthOfLastWord(s)\n  return 0\nend",
      "testCalls": [
        "if LengthOfLastWord(\"Hello World\") != 5\n  raise 'Test Case 1 Failed'\nend",
        "if LengthOfLastWord(\"   fly me   to   the moon  \") != 4\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;HelloWorld&quot;"
        },
        "expected": "5"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;flymetothemoon&quot;"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;luffyisstilljoyboy&quot;"
        },
        "expected": "6"
      }
    ]
  },
  "letter-combinations-of-a-phone-number": {
    "title": "Letter Combinations of a Phone Number",
    "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LetterCombinationsOfAPhoneNumber(digits) { return []; }",
      "testCalls": [
        "if(JSON.stringify(LetterCombinationsOfAPhoneNumber('23')) !== JSON.stringify(['ad','ae','af','bd','be','bf','cd','ce','cf'])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(LetterCombinationsOfAPhoneNumber('2')) !== JSON.stringify(['a','b','c'])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function LetterCombinations(digits: string): string[] { return []; }",
      "testCalls": [
        "const test1 = LetterCombinations(\"23\"); if (JSON.stringify(test1) !== JSON.stringify([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])) { throw new Error(\"Test Case 1 Failed\"); }",
        "const test2 = LetterCombinations(\"2\"); if (JSON.stringify(test2) !== JSON.stringify([\"a\",\"b\",\"c\"])) { throw new Error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<string> LetterCombinationsOfAPhoneNumber(string digits) { return {}; }",
      "testCalls": [
        "auto result1 = LetterCombinationsOfAPhoneNumber(\"23\"); assert((result1 == vector<string>{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"}));",
        "auto result2 = LetterCombinationsOfAPhoneNumber(\"2\"); assert((result2 == vector<string>{\"a\",\"b\",\"c\"}));"
      ],
      "compareHelper": "bool compareVectors(const vector<string>& v1, const vector<string>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def LetterCombinations(digits: str) -> List[str]:",
      "testCalls": [
        "assert LetterCombinations(\"23\") == [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "assert LetterCombinations(\"2\") == [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if len(list1) != len(list2):\n        raise AssertionError\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            raise AssertionError"
    },
    "java": {
      "functionDeclaration": "public List<String> letterCombinations(String digits) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { List<String> result1 = letterCombinations(\"23\"); if (!Arrays.equals(result1.toArray(), new String[]{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"})) throw new AssertionError(); }",
        "public static void main(String[] args) { List<String> result2 = letterCombinations(\"2\"); if (!Arrays.equals(result2.toArray(), new String[]{\"a\",\"b\",\"c\"})) throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean arraysEqual(String[] arr1, String[] arr2) {\n    return Arrays.equals(arr1, arr2);\n}"
    },
    "c": {
      "functionDeclaration": "void LetterCombinationsOfAPhoneNumber(char* digits)",
      "testCalls": [
        "int main() { LetterCombinationsOfAPhoneNumber(\"23\"); return 0; }",
        "int main() { LetterCombinationsOfAPhoneNumber(\"2\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LetterCombinations(digits string) []string {}",
      "testCalls": [
        "func TestLetterCombinations(t *testing.T) { if !compareArrays(LetterCombinations(\"23\"), []string{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"}) { t.Error(\"Test case 1 failed\") } }",
        "func TestLetterCombinationsSingleDigit(t *testing.T) { if !compareArrays(LetterCombinations(\"2\"), []string{\"a\",\"b\",\"c\"}) { t.Error(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []string) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn LetterCombinations(digits: &str) -> Vec<String> {}",
      "testCalls": [
        "let result1 = LetterCombinations(\"23\"); assert_eq!(result1, vec![\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]);",
        "let result2 = LetterCombinations(\"2\"); assert_eq!(result2, vec![\"a\",\"b\",\"c\"]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<String>, arr2: Vec<String>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def LetterCombinations(digits)\n  # code here\nend",
      "testCalls": [
        "result1 = LetterCombinations(\"23\")\nraise 'Test Case 1 Failed' unless result1 == [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "result2 = LetterCombinations(\"2\")\nraise 'Test Case 2 Failed' unless result2 == [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "digits": "&quot;23&quot;"
        },
        "expected": "[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "digits": "&quot;2&quot;"
        },
        "expected": "[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]"
      }
    ]
  },
  "linked-list-cycle": {
    "title": "Linked List Cycle",
    "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following thenextpointer. Internally, posis used to denote the index of the node thattailnextpointer is connected to.Note thatposis not passed as a parameter.\nReturntrue if there is a cycle in the linked list. Otherwise, return false.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LinkedListCycle(head, pos) { return null; }",
      "testCalls": [
        "let head1 = buildLinkedList([3,2,0,-4]); head1.next.next.next.next = head1.next; if (LinkedListCycle(head1, 1) !== true) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1,2]); head2.next.next = head2; if (LinkedListCycle(head2, 0) !== true) { throw new Error('Test Case 2 Failed'); }",
        "let head3 = buildLinkedList([1]); if (LinkedListCycle(head3, -1) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function LinkedListCycle(head: ListNode | null): boolean {}",
      "testCalls": [
        "if (LinkedListCycle(createLinkedList([3,2,0,-4], 1)) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (LinkedListCycle(createLinkedList([1,2], 0)) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (LinkedListCycle(createLinkedList([1], -1)) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function createLinkedList(arr: number[], pos: number): ListNode | null {}",
      "typeDefs": "class ListNode { val: number; next: ListNode | null; constructor(val=0, next=null) { this.val = val; this.next = next; } }",
      "builders": "function createLinkedList(arr: number[], pos: number): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; let cycleNode: ListNode | null = null; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; if (i === pos) cycleNode = curr; } if (pos !== -1) curr.next = cycleNode; return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr: number[] = []; let curr = head; while (curr) { arr.push(curr.val); curr = curr.next; if (arr.length > 10) break; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "bool HasCycle(ListNode* head) { return false; }",
      "testCalls": [
        "int main() { assert(HasCycle(createLinkedList({3,2,0,-4}, 1)) == true); return 0; }",
        "int main() { assert(HasCycle(createLinkedList({1,2}, 0)) == true); return 0; }",
        "int main() { assert(HasCycle(createLinkedList({1}, -1)) == false); return 0; }"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values, int pos) { if (values.empty()) return nullptr; ListNode* head = new ListNode(values[0]); ListNode* curr = head; ListNode* cycleNode = nullptr; for (int i = 1; i < values.size(); ++i) { curr->next = new ListNode(values[i]); curr = curr->next; if (i == pos) cycleNode = curr; } if (pos != -1) curr->next = cycleNode; return head; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }"
    },
    "python": {
      "functionDeclaration": "def LinkedListCycle(head: ListNode) -> bool:",
      "testCalls": [
        "head = buildLinkedList([3,2,0,-4])\nhead.next.next.next.next = head.next\nassert LinkedListCycle(head) == True",
        "head = buildLinkedList([1,2])\nhead.next.next = head\nassert LinkedListCycle(head) == True",
        "head = buildLinkedList([1])\nassert LinkedListCycle(head) == False"
      ],
      "compareHelper": "",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public boolean LinkedListCycle(ListNode head) { return false; }",
      "testCalls": [
        "assert m.LinkedListCycle(m.buildLinkedList(new int[]{3, 2, 0, -4, 1})) == true;",
        "assert m.LinkedListCycle(m.buildLinkedList(new int[]{1, 2, 0})) == true;"
      ],
      "compareHelper": "private boolean compareLinkedList(ListNode expected, ListNode actual) {\n    while (expected != null && actual != null) {\n        if (expected.val != actual.val) {\n            return false;\n        }\n        expected = expected.next;\n        actual = actual.next;\n    }\n    return expected == null && actual == null;\n}",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; this.next = null; } }",
      "builders": "ListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "bool HasCycle(struct ListNode* head)",
      "testCalls": [
        "assert(HasCycle(createLinkedListFromArray((int[]) {3, 2, 0, -4}, 4)) == 1);",
        "assert(HasCycle(createLinkedListFromArray((int[]) {1, 2}, 2)) == 0);"
      ],
      "compareHelper": "",
      "typeDefs": "struct ListNode { int val; struct ListNode *next; };",
      "builders": "struct ListNode* createLinkedListFromArray(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (head == NULL) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head) { int size = 0; struct ListNode* curr = head; while (curr) { size++; curr = curr->next; } int* arr = (int*)malloc(sizeof(int) * size); curr = head; for (int i = 0; i < size; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func HasCycle(head *ListNode) bool { return false }",
      "testCalls": [
        "func TestHasCycle(t *testing.T) { if result := HasCycle(NewLinkedList([]int{3, 2, 0, -4}, 1)); result != true { t.Errorf(\"Test 1 Failed: expected true, got %v\", result) } if result := HasCycle(NewLinkedList([]int{1, 2}, 0)); result != true { t.Errorf(\"Test 2 Failed: expected true, got %v\", result) } if result := HasCycle(NewLinkedList([]int{1}, -1)); result != false { t.Errorf(\"Test 3 Failed: expected false, got %v\", result) } }"
      ],
      "compareHelper": "func (l *ListNode) HasCycle() bool { slow, fast := l, l for fast != nil && fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func NewLinkedList(arr []int, pos int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head for i := 1; i < len(arr); i++ { node := &ListNode{Val: arr[i]} curr.Next = node curr = node } if pos != -1 { tail := head for pos > 0 { tail = tail.Next pos-- } curr.Next = tail } return head }"
    },
    "rust": {
      "functionDeclaration": "fn LinkedListCycle(head: Option<Box<ListNode>>) -> bool {}",
      "testCalls": [
        "assert_eq!(LinkedListCycle(build_linked_list(vec![3, 2, 0, -4], 1)), true);",
        "assert_eq!(LinkedListCycle(build_linked_list(vec![1, 2], 0)), true);",
        "assert_eq!(LinkedListCycle(build_linked_list(vec![1], -1)), false);"
      ],
      "compareHelper": "impl Solution { pub fn create_linked_list_from_vec(values: Vec<i32>, pos: i32) -> Option<Box<ListNode>> { let mut head = None; let mut tail = &mut head; let mut cycle_node = None; for val in values { let new_node = Some(Box::new(ListNode { val, next: None })); if let Some(ref mut node) = tail { node.next = new_node.clone(); } if pos >= 0 && values.iter().position(|&x| x == val).unwrap() == pos as usize { cycle_node = tail; } tail = &mut tail.as_mut().unwrap().next; } if let Some(ref mut node) = tail { node.next = cycle_node; } head } }",
      "helpers": "use std::collections::HashSet;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>, pos: i32) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut tail = None;\n    let mut cycle_node = None;\n    let mut current = None;\n    let mut index = 0;\n\n    for val in arr {\n        let new_node = Some(Box::new(ListNode::new(val));\n        if index == pos {\n            cycle_node = new_node.clone();\n        }\n        if head.is_none() {\n            head = new_node.clone();\n        }\n        if let Some(ref mut node) = current {\n            node.next = new_node.clone();\n        }\n        current = new_node.clone();\n        index += 1;\n    }\n\n    if let Some(ref mut node) = current {\n        node.next = cycle_node;\n    }\n\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n\n    result\n}",
      "typeDefs": "use std::collections::HashSet;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: Vec<i32>, pos: i32) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut tail = None;\n    let mut cycle_node = None;\n    let mut current = None;\n    let mut index = 0;\n\n    for val in arr {\n        let new_node = Some(Box::new(ListNode::new(val));\n        if index == pos {\n            cycle_node = new_node.clone();\n        }\n        if head.is_none() {\n            head = new_node.clone();\n        }\n        if let Some(ref mut node) = current {\n            node.next = new_node.clone();\n        }\n        current = new_node.clone();\n        index += 1;\n    }\n\n    if let Some(ref mut node) = current {\n        node.next = cycle_node;\n    }\n\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def LinkedListCycle(head, pos)\nend",
      "testCalls": [
        "head1 = buildLinkedList([3,2,0,-4]); result1 = LinkedListCycle(head1, 1); raise 'Test Case 1 Failed' unless result1 == true",
        "head2 = buildLinkedList([1,2]); result2 = LinkedListCycle(head2, 0); raise 'Test Case 2 Failed' unless result2 == true",
        "head3 = buildLinkedList([1]); result3 = LinkedListCycle(head3, -1); raise 'Test Case 3 Failed' unless result3 == false"
      ],
      "compareHelper": "",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[3,2,0,-4]",
          "pos": "1"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1,2]",
          "pos": "0"
        },
        "expected": "true"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "head": "[1]",
          "pos": "-1"
        },
        "expected": "false"
      }
    ]
  },
  "longest-common-prefix": {
    "title": "Longest Common Prefix",
    "content": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "String",
      "Trie"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestCommonPrefix(strs) { return ''; }",
      "testCalls": [
        "if(LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) !== \"fl\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) !== \"\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestCommonPrefix(strs: string[]): string { return ''; }",
      "testCalls": [
        "if(LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) !== \"fl\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) !== \"\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string LongestCommonPrefix(vector<string>& strs) { return \"\"; }",
      "testCalls": [
        "int main() { assert(LongestCommonPrefix({\"flower\",\"flow\",\"flight\"}) == \"fl\"); return 0; }",
        "int main() { assert(LongestCommonPrefix({\"dog\",\"racecar\",\"car\"}) == \"\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestCommonPrefix(strs: List[str]) -> str:",
      "testCalls": [
        "assert LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"",
        "assert LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String LongestCommonPrefix(String[] strs) { return null; }",
      "testCalls": [
        "if (!LongestCommonPrefix(new String[]{\"flower\",\"flow\",\"flight\"}).equals(\"fl\")) { throw new AssertionError(); }",
        "if (!LongestCommonPrefix(new String[]{\"dog\",\"racecar\",\"car\"}).equals(\"\")) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* LongestCommonPrefix(char** strs, int strsSize)",
      "testCalls": [
        "printf(\"%s\\n\", LongestCommonPrefix((char*[]) {\"flower\",\"flow\",\"flight\"}, 3));",
        "printf(\"%s\\n\", LongestCommonPrefix((char*[]) {\"dog\",\"racecar\",\"car\"}, 3));"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestCommonPrefix(strs []string) string {}",
      "testCalls": [
        "func main() {",
        "    if LongestCommonPrefix([]string{\"flower\",\"flow\",\"flight\"}) != \"fl\" {panic(\"Test case 1 failed\")}",
        "    if LongestCommonPrefix([]string{\"dog\",\"racecar\",\"car\"}) != \"\" {panic(\"Test case 2 failed\")}",
        "}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestCommonPrefix(strs: Vec<String>) -> String {}",
      "testCalls": [
        "assert_eq!(LongestCommonPrefix(vec![String::from(\"flower\"), String::from(\"flow\"), String::from(\"flight\")]), \"fl\");",
        "assert_eq!(LongestCommonPrefix(vec![String::from(\"dog\"), String::from(\"racecar\"), String::from(\"car\")]), \"\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestCommonPrefix(strs)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"",
        "raise 'Test Case 2 Failed' unless LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\""
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "strs": "[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]"
        },
        "expected": "&quot;fl&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "strs": "[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]"
        },
        "expected": "&quot;&quot;"
      }
    ]
  },
  "longest-consecutive-sequence": {
    "title": "Longest Consecutive Sequence",
    "content": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs inO(n)time.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestConsecutiveSequence(nums) { return 0; }",
      "testCalls": [
        "if(LongestConsecutiveSequence([100,4,200,1,3,2]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) !== 9) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestConsecutiveSequence([1,0,1,2]) !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function LongestConsecutiveSequence(nums: number[]): number { return 0; }",
      "testCalls": [
        "if(LongestConsecutiveSequence([100,4,200,1,3,2]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) !== 9) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestConsecutiveSequence([1,0,1,2]) !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "const arraysEqual = (a: number[], b: number[]) => JSON.stringify(a) === JSON.stringify(b);"
    },
    "cpp": {
      "functionDeclaration": "int LongestConsecutiveSequence(vector<int>& nums);",
      "testCalls": [
        "int main() { if(LongestConsecutiveSequence({100,4,200,1,3,2}) != 4) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { if(LongestConsecutiveSequence({0,3,7,2,5,8,4,6,0,1}) != 9) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": "bool compareArrays(const vector<int>& arr1, const vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def LongestConsecutiveSequence(nums: List[int]) -> int:\n    return 0",
      "testCalls": [
        "assert LongestConsecutiveSequence([100,4,200,1,3,2]) == 4",
        "assert LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) == 9",
        "assert LongestConsecutiveSequence([1,0,1,2]) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestConsecutiveSequence(int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if(m.LongestConsecutiveSequence(new int[]{100,4,200,1,3,2}) != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.LongestConsecutiveSequence(new int[]{0,3,7,2,5,8,4,6,0,1}) != 9) throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int LongestConsecutiveSequence(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if(LongestConsecutiveSequence((int[]){100,4,200,1,3,2}, 6) != 4) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(LongestConsecutiveSequence((int[]){0,3,7,2,5,8,4,6,0,1}, 10) != 9) { printf(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if(LongestConsecutiveSequence((int[]){1,0,1,2}, 4) != 3) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestConsecutiveSequence(nums []int) int {}",
      "testCalls": [
        "func main() { if LongestConsecutiveSequence([]int{100,4,200,1,3,2}) != 4 {panic(\"Test case 1 failed\")}}",
        "func main() { if LongestConsecutiveSequence([]int{0,3,7,2,5,8,4,6,0,1}) != 9 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestConsecutiveSequence(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestConsecutiveSequence(vec![100, 4, 200, 1, 3, 2]), 4);",
        "assert_eq!(LongestConsecutiveSequence(vec![0, 3, 7, 2, 5, 8, 4, 6, 0, 1]), 9);",
        "assert_eq!(LongestConsecutiveSequence(vec![1, 0, 1, 2]), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestConsecutiveSequence(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestConsecutiveSequence([100,4,200,1,3,2]) == 4",
        "raise 'Test Case 2 Failed' unless LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) == 9",
        "raise 'Test Case 3 Failed' unless LongestConsecutiveSequence([1,0,1,2]) == 3"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[100,4,200,1,3,2]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,3,7,2,5,8,4,6,0,1]"
        },
        "expected": "9"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1,0,1,2]"
        },
        "expected": "3"
      }
    ]
  },
  "longest-increasing-subsequence": {
    "title": "Longest Increasing Subsequence",
    "content": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestIncreasingSubsequence(nums) { return 0; }",
      "testCalls": [
        "if(LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestIncreasingSubsequence([0,1,0,3,2,3]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestIncreasingSubsequence([7,7,7,7,7,7,7]) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestIncreasingSubsequence(nums: number[]): number { }",
      "testCalls": [
        "if(LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(LongestIncreasingSubsequence([0,1,0,3,2,3]) !== 4) throw new Error('Test Case 2 Failed');",
        "if(LongestIncreasingSubsequence([7,7,7,7,7,7,7]) !== 1) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int LongestIncreasingSubsequence(vector<int>& nums);",
      "testCalls": [
        "int main() {",
        "    if(LongestIncreasingSubsequence(vector<int>{10,9,2,5,3,7,101,18}) != 4) throw std::runtime_error(\"Test Case 1 Failed\");",
        "    if(LongestIncreasingSubsequence(vector<int>{0,1,0,3,2,3}) != 4) throw std::runtime_error(\"Test Case 2 Failed\");",
        "    if(LongestIncreasingSubsequence(vector<int>{7,7,7,7,7,7,7}) != 1) throw std::runtime_error(\"Test Case 3 Failed\");",
        "    return 0;",
        "}"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestIncreasingSubsequence(nums: List[int]) -> int:",
      "testCalls": [
        "assert LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) == 4",
        "assert LongestIncreasingSubsequence([0,1,0,3,2,3]) == 4",
        "assert LongestIncreasingSubsequence([7,7,7,7,7,7,7]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestIncreasingSubsequence(int[] nums) { return 0; }",
      "testCalls": [
        "if(m.LongestIncreasingSubsequence(new int[]{10,9,2,5,3,7,101,18}) != 4) throw new AssertionError();",
        "if(m.LongestIncreasingSubsequence(new int[]{0,1,0,3,2,3}) != 4) throw new AssertionError();",
        "if(m.LongestIncreasingSubsequence(new int[]{7,7,7,7,7,7,7}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LongestIncreasingSubsequence(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if(LongestIncreasingSubsequence((int[]){10,9,2,5,3,7,101,18}, 8) != 4) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(LongestIncreasingSubsequence((int[]){0,1,0,3,2,3}, 6) != 4) { printf(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if(LongestIncreasingSubsequence((int[]){7,7,7,7,7,7,7}, 7) != 1) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestIncreasingSubsequence(nums []int) int {}",
      "testCalls": [
        "func main() { if LongestIncreasingSubsequence([]int{10,9,2,5,3,7,101,18}) != 4 { panic(\"Test case 1 failed\") } }",
        "func main() { if LongestIncreasingSubsequence([]int{0,1,0,3,2,3}) != 4 { panic(\"Test case 2 failed\") } }",
        "func main() { if LongestIncreasingSubsequence([]int{7,7,7,7,7,7,7}) != 1 { panic(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestIncreasingSubsequence(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestIncreasingSubsequence(vec![10,9,2,5,3,7,101,18]), 4);",
        "assert_eq!(LongestIncreasingSubsequence(vec![0,1,0,3,2,3]), 4);",
        "assert_eq!(LongestIncreasingSubsequence(vec![7,7,7,7,7,7,7]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestIncreasingSubsequence(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) == 4",
        "raise 'Test Case 2 Failed' unless LongestIncreasingSubsequence([0,1,0,3,2,3]) == 4",
        "raise 'Test Case 3 Failed' unless LongestIncreasingSubsequence([7,7,7,7,7,7,7]) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[10,9,2,5,3,7,101,18]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1,0,3,2,3]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[7,7,7,7,7,7,7]"
        },
        "expected": "1"
      }
    ]
  },
  "longest-palindromic-substring": {
    "title": "Longest Palindromic Substring",
    "content": "Given a string s, return the longest palindromic substring in s.",
    "difficulty": "Medium",
    "hints": [
      "How can we reuse a previously computed palindrome to compute a larger palindrome?",
      "If aba is a palindrome, is xabax a palindrome? Similarly is xabay a palindrome?",
      "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
    ],
    "topicTags": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestPalindromicSubstring(s) {}",
      "testCalls": [
        "if(LongestPalindromicSubstring(\"babad\") !== \"bab\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestPalindromicSubstring(\"cbbd\") !== \"bb\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestPalindromicSubstring(s: string): string {}",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) !== &quot;bab&quot;) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) !== &quot;bb&quot;) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string LongestPalindromicSubstring(string s) { return \"\"; }",
      "testCalls": [
        "if(LongestPalindromicSubstring(\"babad\") != \"bab\") throw std::runtime_error(\"Test 1 failed\");",
        "if(LongestPalindromicSubstring(\"cbbd\") != \"bb\") throw std::runtime_error(\"Test 2 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestPalindromicSubstring(s: str) -> str:",
      "testCalls": [
        "assert LongestPalindromicSubstring('babad') == 'bab' or LongestPalindromicSubstring('babad') == 'aba', 'Test Case 1 Failed'",
        "assert LongestPalindromicSubstring('cbbd') == 'bb', 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String LongestPalindromicSubstring(String s) { return \"\"; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.LongestPalindromicSubstring(\"babad\").equals(\"bab\")) { throw new AssertionError(); } }",
        "public static void main(String[] args) { Main m = new Main(); if (!m.LongestPalindromicSubstring(\"cbbd\").equals(\"bb\")) { throw new AssertionError(); } }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* LongestPalindromicSubstring(char* s) { return NULL; }",
      "testCalls": [
        "printf(\"%s\\n\", LongestPalindromicSubstring(\"babad\"));",
        "printf(\"%s\\n\", LongestPalindromicSubstring(\"cbbd\"));"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestPalindromicSubstring(s string) string {}",
      "testCalls": [
        "func main() {",
        "    if LongestPalindromicSubstring(\"babad\") != \"bab\" {panic(\"Test case 1 failed\")}",
        "    if LongestPalindromicSubstring(\"cbbd\") != \"bb\" {panic(\"Test case 2 failed\")}",
        "}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestPalindromicSubstring(s: &str) -> String { }",
      "testCalls": [
        "assert_eq!(LongestPalindromicSubstring(\"babad\"), \"bab\");",
        "assert_eq!(LongestPalindromicSubstring(\"cbbd\"), \"bb\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestPalindromicSubstring(s)\n  nil\nend",
      "testCalls": [
        "result = LongestPalindromicSubstring(\"babad\")\nraise 'Test Case 1 Failed' unless result == \"bab\"",
        "result = LongestPalindromicSubstring(\"cbbd\")\nraise 'Test Case 2 Failed' unless result == \"bb\""
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;babad&quot;"
        },
        "expected": "&quot;bab&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;cbbd&quot;"
        },
        "expected": "&quot;bb&quot;"
      }
    ]
  },
  "longest-substring-without-repeating-characters": {
    "title": "Longest Substring Without Repeating Characters",
    "content": "Given a string s, find the length of the longest substring without duplicate characters.",
    "difficulty": "Medium",
    "hints": [
      "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestSubstringWithoutRepeatingCharacters(s) { return 0; }",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters('abcabcbb') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters('bbbbb') !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters('pwwkew') !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestSubstringWithoutRepeatingCharacters(s: string): number {}",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(&quot;abcabcbb&quot;) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters(&quot;bbbbb&quot;) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int LongestSubstringWithoutRepeatingCharacters(string s);",
      "testCalls": [
        "int main() { if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestSubstringWithoutRepeatingCharacters(s: str) -> int:",
      "testCalls": [
        "assert LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") == 3",
        "assert LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") == 1",
        "assert LongestSubstringWithoutRepeatingCharacters(\"pwwkew\") == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestSubstringWithoutRepeatingCharacters(String s) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if(m.LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LongestSubstringWithoutRepeatingCharacters(char* s)",
      "testCalls": [
        "int main() { if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestSubstringWithoutRepeatingCharacters(s string) int {}",
      "testCalls": [
        "func TestLongestSubstringWithoutRepeatingCharacters(t *testing.T) { if LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3 { t.Error(\"Test Case 1 Failed\") } }",
        "func TestLongestSubstringWithoutRepeatingCharacters2(t *testing.T) { if LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1 { t.Error(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestSubstringWithoutRepeatingCharacters(s: &str) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestSubstringWithoutRepeatingCharacters(&\"abcabcbb\"), 3);",
        "assert_eq!(LongestSubstringWithoutRepeatingCharacters(&\"bbbbb\"), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestSubstringWithoutRepeatingCharacters(s)\n  nil\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") == 3",
        "raise 'Test Case 2 Failed' unless LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;abcabcbb&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;bbbbb&quot;"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;pwwkew&quot;"
        },
        "expected": "3"
      }
    ]
  },
  "lowest-common-ancestor-of-a-binary-tree": {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LowestCommonAncestor(root, p, q) {}",
      "testCalls": [
        "let root1 = buildTree([3,5,1,6,2,0,8,null,null,7,4]); if (LowestCommonAncestor(root1, root1.left, root1.right) !== root1) { throw new Error('Test Case 1 Failed'); }",
        "let root2 = buildTree([3,5,1,6,2,0,8,null,null,7,4]); if (LowestCommonAncestor(root2, root2.left, root2.left.right.right) !== root2.left) { throw new Error('Test Case 2 Failed'); }",
        "let root3 = buildTree([1,2]); if (LowestCommonAncestor(root3, root3, root3.left) !== root3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function LowestCommonAncestor(root: TreeNode | null, p: number, q: number): TreeNode | null {}",
      "testCalls": [
        "if (LowestCommonAncestor(buildTree([3,5,1,6,2,0,8,null,null,7,4]), 5, 1)?.val !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (LowestCommonAncestor(buildTree([3,5,1,6,2,0,8,null,null,7,4]), 5, 4)?.val !== 5) { throw new Error('Test Case 2 Failed'); }",
        "if (LowestCommonAncestor(buildTree([1,2]), 1, 2)?.val !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }",
      "typeDefs": "class TreeNode { val: number; left: TreeNode | null; right: TreeNode | null; constructor(val = 0, left = null, right = null) { this.val = val; this.left = left; this.right = right; } }",
      "builders": "static fromArray(arr: Array<number | null>): TreeNode | null { if (!arr.length || arr[0] === null) return null; const root = new TreeNode(arr[0] as number); const queue = [root]; let i = 1; while (queue.length && i < arr.length) { const node = queue.shift() as TreeNode; if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i] as number); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i] as number); queue.push(node.right); } i++; } return root; }"
    },
    "cpp": {
      "functionDeclaration": "int LowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);",
      "testCalls": [
        "int main() {",
        "    assert(LowestCommonAncestor(createTree({3,5,1,6,2,0,8,INT_MIN,INT_MIN,7,4}), new TreeNode(5), new TreeNode(1)) == 3);",
        "    assert(LowestCommonAncestor(createTree({3,5,1,6,2,0,8,INT_MIN,INT_MIN,7,4}), new TreeNode(5), new TreeNode(4)) == 5);",
        "    assert(LowestCommonAncestor(createTree({1,2}), new TreeNode(1), new TreeNode(2)) == 1);",
        "    return 0;",
        "}"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); ++i) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def LowestCommonAncestor(root, p, q):",
      "testCalls": [
        "root = buildTree([3,5,1,6,2,0,8,None,None,7,4]); assert LowestCommonAncestor(root, 5, 1) == 3",
        "root = buildTree([3,5,1,6,2,0,8,None,None,7,4]); assert LowestCommonAncestor(root, 5, 4) == 5",
        "root = buildTree([1,2]); assert LowestCommonAncestor(root, 1, 2) == 1"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { TreeNode root1 = createTree(new Integer[]{3,5,1,6,2,0,8,null,null,7,4}); TreeNode p1 = new TreeNode(5); TreeNode q1 = new TreeNode(1); assert lowestCommonAncestor(root1, p1, q1).val == 3 : \"Test Case 1 Failed\"; }",
        "public static void main(String[] args) { TreeNode root2 = createTree(new Integer[]{3,5,1,6,2,0,8,null,null,7,4}); TreeNode p2 = new TreeNode(5); TreeNode q2 = new TreeNode(4); assert lowestCommonAncestor(root2, p2, q2).val == 5 : \"Test Case 2 Failed\"; }",
        "public static void main(String[] args) { TreeNode root3 = createTree(new Integer[]{1,2}); TreeNode p3 = new TreeNode(1); TreeNode q3 = new TreeNode(2); assert lowestCommonAncestor(root3, p3, q3).val == 1 : \"Test Case 3 Failed\"; }"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}",
      "typeDefs": "public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode createTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); List<TreeNode> queue = new ArrayList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.remove(0); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }"
    },
    "c": {
      "functionDeclaration": "int LowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)",
      "testCalls": [
        "int arr1[] = {3,5,1,6,2,0,8,-1,-1,7,4}; struct TreeNode* root1 = buildTree(arr1, 11); struct TreeNode* p1 = root1->left; struct TreeNode* q1 = root1->right; LowestCommonAncestor(root1, p1, q1); // Expected: 3",
        "int arr2[] = {3,5,1,6,2,0,-1,-1,-1,-1,7,4}; struct TreeNode* root2 = buildTree(arr2, 12); struct TreeNode* p2 = root2->left; struct TreeNode* q2 = root2->right->left; LowestCommonAncestor(root2, p2, q2); // Expected: 5",
        "int arr3[] = {3,5,1,6,2,0,-1,-1,-1,-1,7,4}; struct TreeNode* root3 = buildTree(arr3, 12); struct TreeNode* p3 = root3->left; struct TreeNode* q3 = root3->right; LowestCommonAncestor(root3, p3, q3); // Expected: 1"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == -1) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root->val = arr[0]; root->left = NULL; root->right = NULL; struct TreeNode* queue[size]; int i = 1, qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd && i < size) { struct TreeNode* node = queue[qStart++]; if (i < size && arr[i] != -1) { node->left = malloc(sizeof(struct TreeNode)); node->left->val = arr[i]; node->left->left = NULL; node->left->right = NULL; queue[qEnd++] = node->left; } i++; if (i < size && arr[i] != -1) { node->right = malloc(sizeof(struct TreeNode)); node->right->val = arr[i]; node->right->left = NULL; node->right->right = NULL; queue[qEnd++] = node->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = malloc(sizeof(int) * 1000); int resultIdx = 0; struct TreeNode* queue[1000]; int qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd) { struct TreeNode* node = queue[qStart++]; if (node) { result[resultIdx++] = node->val; if (node->left || node->right) { if (node->left) queue[qEnd++] = node->left; else queue[qEnd++] = NULL; if (node->right) queue[qEnd++] = node->right; else queue[qEnd++] = NULL; } } else { result[resultIdx++] = -1; } } while (result[resultIdx-1] == -1) resultIdx--; *returnSize = resultIdx; return result; }"
    },
    "go": {
      "functionDeclaration": "func LowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode {}",
      "testCalls": [
        "if !reflect.DeepEqual(LowestCommonAncestor(BuildTree([]int{3,5,1,6,2,0,8,0,0,7,4}), &TreeNode{Val: 5}, &TreeNode{Val: 1}), &TreeNode{Val: 3}) { t.Error(\"Test Case 1 Failed\") }",
        "if !reflect.DeepEqual(LowestCommonAncestor(BuildTree([]int{3,5,1,6,2,0,8,0,0,7,4}), &TreeNode{Val: 5}, &TreeNode{Val: 4}), &TreeNode{Val: 5}) { t.Error(\"Test Case 2 Failed\") }",
        "if !reflect.DeepEqual(LowestCommonAncestor(BuildTree([]int{1,2}), &TreeNode{Val: 1}, &TreeNode{Val: 2}), &TreeNode{Val: 1}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func BuildTree(arr []int) *TreeNode { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn LowestCommonAncestor(root: Option<Box<TreeNode>>, p: i32, q: i32) -> Option<Box<TreeNode>> {}",
      "testCalls": [
        "let root = build_tree(vec![Some(3), Some(5), Some(1), Some(6), Some(2), Some(0), Some(8), None, None, Some(7), Some(4)]);\nassert_eq!(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) })), right: Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 0, left: None, right: None })), right: Some(Box::new(TreeNode { val: 8, left: None, right: None })) }))), LowestCommonAncestor(root, 5, 1));",
        "let root = build_tree(vec![Some(3), Some(5), Some(1), Some(6), Some(2), Some(0), Some(8), None, None, Some(7), Some(4)]);\nassert_eq!(Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) }), LowestCommonAncestor(root, 5, 4));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashMap;\nuse std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    let mut nodes: HashMap<i32, Box<TreeNode>> = HashMap::new();\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            nodes.insert(i as i32, Box::new(TreeNode::new(*v)));\n        }\n    }\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            if let Some(node) = nodes.get_mut(&(i as i32)) {\n                if let Some(left_val) = arr.get(2 * i + 1) {\n                    if let Some(left_node) = nodes.get(left_val) {\n                        node.left = Some(left_node.clone());\n                    }\n                }\n                if let Some(right_val) = arr.get(2 * i + 2) {\n                    if let Some(right_node) = nodes.get(right_val) {\n                        node.right = Some(right_node.clone());\n                    }\n                }\n            }\n        }\n    }\n    nodes.get(&0).cloned()\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(last) = result.last() {\n        if last.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}",
      "typeDefs": "use std::collections::HashMap;\nuse std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    let mut nodes: HashMap<i32, Box<TreeNode>> = HashMap::new();\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            nodes.insert(i as i32, Box::new(TreeNode::new(*v)));\n        }\n    }\n    for (i, val) in arr.iter().enumerate() {\n        if let Some(v) = val {\n            if let Some(node) = nodes.get_mut(&(i as i32)) {\n                if let Some(left_val) = arr.get(2 * i + 1) {\n                    if let Some(left_node) = nodes.get(left_val) {\n                        node.left = Some(left_node.clone());\n                    }\n                }\n                if let Some(right_val) = arr.get(2 * i + 2) {\n                    if let Some(right_node) = nodes.get(right_val) {\n                        node.right = Some(right_node.clone());\n                    }\n                }\n            }\n        }\n    }\n    nodes.get(&0).cloned()\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(last) = result.last() {\n        if last.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def LowestCommonAncestor(root, p, q)\n  \nend",
      "testCalls": [
        "root = buildTree([3,5,1,6,2,0,8,nil,nil,7,4]); LowestCommonAncestor(root, 5, 1)",
        "root = buildTree([3,5,1,6,2,0,8,nil,nil,7,4]); LowestCommonAncestor(root, 5, 4)",
        "root = buildTree([1,2]); LowestCommonAncestor(root, 1, 2)"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implement buildTree function here\nend\ndef treeToArray(root)\n  # Implement treeToArray function here\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,5,1,6,2,0,8,null,null,7,4]",
          "p": "5",
          "q": "1"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[3,5,1,6,2,0,8,null,null,7,4]",
          "p": "5",
          "q": "4"
        },
        "expected": "5"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[1,2]",
          "p": "1",
          "q": "2"
        },
        "expected": "1"
      }
    ]
  },
  "majority-element": {
    "title": "Majority Element",
    "content": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than &lfloor;n / 2&rfloor; times. You may assume that the majority element always exists in the array.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Counting"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function MajorityElement(nums) { return null; }",
      "testCalls": [
        "if (MajorityElement([3,2,3]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (MajorityElement([2,2,1,1,1,2,2]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MajorityElement(nums: number[]): number { }",
      "testCalls": [
        "const test1 = MajorityElement([3,2,3]); if (test1 !== 3) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MajorityElement([2,2,1,1,1,2,2]); if (test2 !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MajorityElement(vector<int>& nums);",
      "testCalls": [
        "int main() { assert(MajorityElement(vector<int>{3,2,3}) == 3); return 0; }",
        "int main() { assert(MajorityElement(vector<int>{2,2,1,1,1,2,2}) == 2); return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MajorityElement(nums: List[int]) -> int:",
      "testCalls": [
        "assert MajorityElement([3,2,3]) == 3",
        "assert MajorityElement([2,2,1,1,1,2,2]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MajorityElement(int[] nums) { }",
      "testCalls": [
        "assert MajorityElement(new int[]{3,2,3}) == 3;",
        "assert MajorityElement(new int[]{2,2,1,1,1,2,2}) == 2;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MajorityElement(int* nums, int numsSize)",
      "testCalls": [
        "int main() {",
        "    if (MajorityElement((int[]){3,2,3}, 3) != 3) { printf(\"Test Case 1 Failed\\n\"); }",
        "    if (MajorityElement((int[]){2,2,1,1,1,2,2}, 7) != 2) { printf(\"Test Case 2 Failed\\n\"); }",
        "    return 0;",
        "}"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MajorityElement(nums []int) int {}",
      "testCalls": [
        "func main() {",
        "    if MajorityElement([]int{3,2,3}) != 3 {panic(\"Test case 1 failed\")}",
        "    if MajorityElement([]int{2,2,1,1,1,2,2}) != 2 {panic(\"Test case 2 failed\")}",
        "}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MajorityElement(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MajorityElement(vec![3,2,3]), 3);",
        "assert_eq!(MajorityElement(vec![2,2,1,1,1,2,2]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MajorityElement(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MajorityElement([3,2,3]) == 3",
        "raise 'Test Case 2 Failed' unless MajorityElement([2,2,1,1,1,2,2]) == 2"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,2,3]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[2,2,1,1,1,2,2]"
        },
        "expected": "2"
      }
    ]
  },
  "max-points-on-a-line": {
    "title": "Max Points on a Line",
    "content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaxPointsOnALine(points) { return 0; }",
      "testCalls": [
        "if(MaxPointsOnALine([[1,1],[2,2],[3,3]]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxPointsOnALine(points: number[][]): number { }",
      "testCalls": [
        "const test1 = MaxPointsOnALine([[1,1],[2,2],[3,3]]); if(test1 !== 3) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]); if(test2 !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxPointsOnALine(vector<vector<int>>& points) { return 0; }",
      "testCalls": [
        "int main() { assert(MaxPointsOnALine({{1,1},{2,2},{3,3}}) == 3);",
        "assert(MaxPointsOnALine({{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}) == 4); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaxPointsOnALine(points: List[List[int]]) -> int:",
      "testCalls": [
        "assert MaxPointsOnALine([[1,1],[2,2],[3,3]]) == 3",
        "assert MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public int MaxPointsOnALine(int[][] points) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { int[][] test1 = {{1,1},{2,2},{3,3}}; int result1 = new Main().MaxPointsOnALine(test1); if (result1 != 3) { throw new AssertionError(); } }",
        "public static void main(String[] args) { int[][] test2 = {{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}; int result2 = new Main().MaxPointsOnALine(test2); if (result2 != 4) { throw new AssertionError(); } }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxPointsOnALine(int** points, int pointsSize, int* pointsColSize)",
      "testCalls": [
        "int main() { if(MaxPointsOnALine((int*[]){{1,1},{2,2},{3,3}}, 3, (int[]){2, 2}) != 3) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(MaxPointsOnALine((int*[]){{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}, 6, (int[]){2, 2}) != 4) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxPointsOnALine(points [][]int) int {}",
      "testCalls": [
        "func main() { if MaxPointsOnALine([][]int{{1,1},{2,2},{3,3}}) != 3 {panic(\"Test case 1 failed\")} }",
        "func main() { if MaxPointsOnALine([][]int{{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}) != 4 {panic(\"Test case 2 failed\")} }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaxPointsOnALine(points: Vec<Vec<i32>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MaxPointsOnALine(vec![vec![1,1],vec![2,2],vec![3,3]]), 3);",
        "assert_eq!(MaxPointsOnALine(vec![vec![1,1],vec![3,2],vec![5,3],vec![4,1],vec![2,3],vec![1,4]]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaxPointsOnALine(points)\nend",
      "testCalls": [
        "test_case_1 = MaxPointsOnALine([[1,1],[2,2],[3,3]])\nraise 'Test Case 1 Failed' unless test_case_1 == 3",
        "test_case_2 = MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]])\nraise 'Test Case 2 Failed' unless test_case_2 == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "points": "[[1,1],[2,2],[3,3]]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "points": "[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]"
        },
        "expected": "4"
      }
    ]
  },
  "maximal-square": {
    "title": "Maximal Square",
    "content": "Given an m x n binary matrix filled with 0 and 1, find the largest square containing only 1 and return its area.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximalSquare(matrix) { return 0; }",
      "testCalls": [
        "if(MaximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(MaximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]]) !== 1) throw new Error('Test Case 2 Failed');",
        "if(MaximalSquare([[\"0\"]]) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximalSquare(matrix: string[][]): number { }",
      "testCalls": [
        "if(MaximalSquare([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(MaximalSquare([['0','1'],['1','0']]) !== 1) throw new Error('Test Case 2 Failed');",
        "if(MaximalSquare([['0']]) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaximalSquare(std::vector<std::vector<char>>& matrix) { return 0; }",
      "testCalls": [
        "if(MaximalSquare(std::vector<std::vector<char>>{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}) != 4) throw std::runtime_error(\"Test 1 failed!\");",
        "if(MaximalSquare(std::vector<std::vector<char>>{{'0','1'},{'1','0'}}) != 1) throw std::runtime_error(\"Test 2 failed!\");",
        "if(MaximalSquare(std::vector<std::vector<char>>{{'0'}}) != 0) throw std::runtime_error(\"Test 3 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximalSquare(matrix: List[List[str]]) -> int:",
      "testCalls": [
        "assert MaximalSquare([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) == 4",
        "assert MaximalSquare([['0','1'],['1','0']]) == 1",
        "assert MaximalSquare([['0']]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximalSquare(char[][] matrix) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); int result1 = m.MaximalSquare(new char[][]{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}); if (result1 != 4) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int result2 = m.MaximalSquare(new char[][]{{'0','1'},{'1','0'}}); if (result2 != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); int result3 = m.MaximalSquare(new char[][]{{'0'}}); if (result3 != 0) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaximalSquare(char** matrix, int matrixSize, int* matrixColSize)",
      "testCalls": [
        "int main() { MaximalSquare((char*[]) {\"1\",\"0\",\"1\",\"0\",\"0\"}, 4, (int[]) {5}) == 4 ? printf(\"Test case 1 passed\\n\") : printf(\"Test case 1 failed\\n\"); return 0; }",
        "int main() { MaximalSquare((char*[]) {\"0\",\"1\",\"1\",\"0\"}, 2, (int[]) {2}) == 1 ? printf(\"Test case 2 passed\\n\") : printf(\"Test case 2 failed\\n\"); return 0; }",
        "int main() { MaximalSquare((char*[]) {\"0\"}, 1, (int[]) {1}) == 0 ? printf(\"Test case 3 passed\\n\") : printf(\"Test case 3 failed\\n\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaximalSquare(matrix [][]string) int {}",
      "testCalls": [
        "func TestMaximalSquare(t *testing.T) { if MaximalSquare([][]string{{\"1\",\"0\",\"1\",\"0\",\"0\"},{\"1\",\"0\",\"1\",\"1\",\"1\"},{\"1\",\"1\",\"1\",\"1\",\"1\"},{\"1\",\"0\",\"0\",\"1\",\"0\"}}) != 4 { t.Error(\"Test Case 1 Failed\") } }",
        "func TestMaximalSquare2(t *testing.T) { if MaximalSquare([][]string{{\"0\",\"1\"},{\"1\",\"0\"}}) != 1 { t.Error(\"Test Case 2 Failed\") } }",
        "func TestMaximalSquare3(t *testing.T) { if MaximalSquare([][]string{{\"0\"}}) != 0 { t.Error(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximalSquare(matrix: Vec<Vec<char>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaximalSquare(vec![vec![&'1', &'0', &'1', &'0', &'0'], vec![&'1', &'0', &'1', &'1', &'1'], vec![&'1', &'1', &'1', &'1', &'1'], vec![&'1', &'0', &'0', &'1', &'0']]), 4);",
        "assert_eq!(MaximalSquare(vec![vec![&'0', &'1'], vec![&'1', &'0']]), 1);",
        "assert_eq!(MaximalSquare(vec![vec![&'0']]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximalSquare(matrix)\nend",
      "testCalls": [
        "test1 = MaximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])\nraise 'Test Case 1 Failed' unless test1 == 4",
        "test2 = MaximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]])\nraise 'Test Case 2 Failed' unless test2 == 1",
        "test3 = MaximalSquare([[\"0\"]])\nraise 'Test Case 3 Failed' unless test3 == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "matrix": "[[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "matrix": "[[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "matrix": "[[&quot;0&quot;]]"
        },
        "expected": "0"
      }
    ]
  },
  "maximum-depth-of-binary-tree": {
    "title": "Maximum Depth of Binary Tree",
    "content": "Given the root of a binary tree, return its maximum depth.\nA binary tree maximum depthis the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaxDepthOfBinaryTree(root) { return 0; }",
      "testCalls": [
        "if(MaxDepthOfBinaryTree(buildTree([3,9,20,null,null,15,7])) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxDepthOfBinaryTree(buildTree([1,null,2])) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function MaxDepthOfBinaryTree(root: TreeNode | null): number { }",
      "testCalls": [
        "if(MaxDepthOfBinaryTree(buildTree([3,9,20,null,null,15,7])) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxDepthOfBinaryTree(buildTree([1,null,2])) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function createBinaryTree(arr: Array<number | null>): TreeNode | null { }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int MaxDepth(TreeNode* root) { return 0; }",
      "testCalls": [
        "int main() { assert(MaxDepth(createTree({3,9,20,INT_MIN,INT_MIN,15,7})) == 3); assert(MaxDepth(createTree({1,INT_MIN,2})) == 2); return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* createTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } ++i; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } ++i; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def MaximumDepthOfBinaryTree(root: TreeNode) -> int: pass",
      "testCalls": [
        "assert MaximumDepthOfBinaryTree(buildTree([3,9,20,None,None,15,7])) == 3",
        "assert MaximumDepthOfBinaryTree(buildTree([1,None,2])) == 2"
      ],
      "compareHelper": "def buildTree(nodes): pass",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public int maxDepth(TreeNode root) { return 0; }",
      "testCalls": [
        "public static void runTests() { if (maxDepth(buildTree(new Integer[]{3,9,20,null,null,15,7})) != 3) { throw new AssertionError(); } if (maxDepth(buildTree(new Integer[]{1,null,2})) != 2) { throw new AssertionError(); } }"
      ],
      "compareHelper": "public static boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { if (root == null) return new int[0]; List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.add(node.left); queue.add(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "int MaxDepth(struct TreeNode* root)",
      "testCalls": [
        "int main() { assert(MaxDepth(buildTreeFromArray((int[]) {3,9,20,-1,-1,15,7}, 7)) == 3); return 0; }",
        "int main() { assert(MaxDepth(buildTreeFromArray((int[]) {1,-1,2}, 3)) == 2); return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n    for (int i = 0; i < size; i++) {\n        if (arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createTreeNode(int val) { struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); node->val = val; node->left = NULL; node->right = NULL; return node; }\nstruct TreeNode* buildTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = createTreeNode(arr[0]); struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (i < size) { struct TreeNode* current = queue[front++]; if (arr[i] != -1) { current->left = createTreeNode(arr[i]); queue[rear++] = current->left; } i++; if (i < size && arr[i] != -1) { current->right = createTreeNode(arr[i]); queue[rear++] = current->right; } i++; } return root; }\nint* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int capacity = 1000, index = 0; int* result = (int*)malloc(sizeof(int) * capacity); struct TreeNode* queue[capacity]; int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* current = queue[front++]; if (current) { result[index++] = current->val; if (index == capacity) { capacity *= 2; result = (int*)realloc(result, sizeof(int) * capacity); } queue[rear++] = current->left; queue[rear++] = current->right; } else { result[index++] = -1; } } while (index > 0 && result[index - 1] == -1) index--; *returnSize = index; return result; }"
    },
    "go": {
      "functionDeclaration": "func MaxDepth(root *TreeNode) int {}",
      "testCalls": [
        "func test1() { root := buildTree([]interface{}{3, 9, 20, nil, nil, 15, 7}); if MaxDepth(root) != 3 { panic(\"Test case 1 failed\") } }",
        "func test2() { root := buildTree([]interface{}{1, nil, 2}); if MaxDepth(root) != 2 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []interface{}) *TreeNode { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn MaxDepth(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "let root1 = buildTree(vec![Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]); assert_eq!(MaxDepth(root1), 3);",
        "let root2 = buildTree(vec![Some(1), None, Some(2)]); assert_eq!(MaxDepth(root2), 2);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() { return None; }\n    let root = Box::new(TreeNode::new(arr[0].unwrap()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(Some(val)) = arr.get(i) {\n                let left_child = Box::new(TreeNode::new(*val));\n                node.left = Some(left_child.clone());\n                queue.push_back(left_child);\n            }\n            i += 1;\n            if let Some(Some(val)) = arr.get(i) {\n                let right_child = Box::new(TreeNode::new(*val));\n                node.right = Some(right_child.clone());\n                queue.push_back(right_child);\n            }\n            i += 1;\n        }\n    }\n    Some(root)\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.val));\n            if node.left.is_some() || node.right.is_some() {\n                queue.push_back(node.left.unwrap_or_else(|| Box::new(TreeNode::new(-1))));\n                queue.push_back(node.right.unwrap_or_else(|| Box::new(TreeNode::new(-1))));\n            }\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}",
      "builders": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n\n    let root = Rc::new(RefCell::new(TreeNode::new(arr[0].unwrap())));\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(Rc::clone(&root));\n    let mut i = 1;\n\n    while i < arr.len() {\n        if let Some(Some(val)) = arr.get(i) {\n            let left_node = Rc::new(RefCell::new(TreeNode::new(*val)));\n            if let Some(node) = queue.front() {\n                node.borrow_mut().left = Some(Rc::clone(&left_node));\n            }\n            queue.push_back(left_node);\n        }\n        i += 1;\n\n        if i < arr.len() {\n            if let Some(Some(val)) = arr.get(i) {\n                let right_node = Rc::new(RefCell::new(TreeNode::new(*val)));\n                if let Some(node) = queue.front() {\n                    node.borrow_mut().right = Some(Rc::clone(&right_node));\n                }\n                queue.push_back(right_node);\n            }\n            i += 1;\n        }\n\n        queue.pop_front();\n    }\n\n    Some(root)\n}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = std::collections::VecDeque::new();\n\n    if let Some(node) = root {\n        queue.push_back(Some(node));\n    }\n\n    while !queue.is_empty() {\n        if let Some(Some(node)) = queue.pop_front() {\n            result.push(Some(node.borrow().val));\n            if node.borrow().left.is_some() || node.borrow().right.is_some() {\n                queue.push_back(node.borrow().left.clone());\n                queue.push_back(node.borrow().right.clone());\n            }\n        } else {\n            result.push(None);\n        }\n    }\n\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def MaximumDepthOfBinaryTree(root)\nend",
      "testCalls": [
        "root = buildTree([3,9,20,nil,nil,15,7]); test_case_1 = MaximumDepthOfBinaryTree(root); raise 'Test Case 1 Failed' unless test_case_1 == 3",
        "root = buildTree([1,nil,2]); test_case_2 = MaximumDepthOfBinaryTree(root); raise 'Test Case 2 Failed' unless test_case_2 == 2"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[3,9,20,null,null,15,7]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,null,2]"
        },
        "expected": "2"
      }
    ]
  },
  "maximum-subarray": {
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximumSubarray(nums) { return 0; }",
      "testCalls": [
        "if(MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSubarray([1]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(MaximumSubarray([5,4,-1,7,8]) !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximumSubarray(nums: number[]): number { return 0; }",
      "testCalls": [
        "if (MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (MaximumSubarray([1]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if (MaximumSubarray([5,4,-1,7,8]) !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaxSubarray(std::vector<int>& nums);",
      "testCalls": [
        "int main() { if(MaxSubarray({-2,1,-3,4,-1,2,1,-5,4}) != 6) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(MaxSubarray({1}) != 1) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximumSubarray(nums: List[int]) -> int:",
      "testCalls": [
        "assert MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) == 6",
        "assert MaximumSubarray([1]) == 1",
        "assert MaximumSubarray([5,4,-1,7,8]) == 23"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximumSubarray(int[] nums) { return 0; }",
      "testCalls": [
        "if(m.MaximumSubarray(new int[]{-2,1,-3,4,-1,2,1,-5,4}) != 6) throw new AssertionError();",
        "if(m.MaximumSubarray(new int[]{1}) != 1) throw new AssertionError();",
        "if(m.MaximumSubarray(new int[]{5,4,-1,7,8}) != 23) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxSubarray(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if(MaxSubarray((int[]){-2,1,-3,4,-1,2,1,-5,4}, 9) != 6) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(MaxSubarray((int[]){1}, 1) != 1) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxSubarray(nums []int) int {}",
      "testCalls": [
        "func main() { if MaxSubarray([]int{-2,1,-3,4,-1,2,1,-5,4}) != 6 { panic(\"Test case 1 failed\") } }",
        "func main() { if MaxSubarray([]int{1}) != 1 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximumSubarray(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaximumSubarray(vec![-2,1,-3,4,-1,2,1,-5,4]), 6);",
        "assert_eq!(MaximumSubarray(vec![1]), 1);",
        "assert_eq!(MaximumSubarray(vec![5,4,-1,7,8]), 23);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumSubarray(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) == 6",
        "raise 'Test Case 2 Failed' unless MaximumSubarray([1]) == 1",
        "raise 'Test Case 3 Failed' unless MaximumSubarray([5,4,-1,7,8]) == 23"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[-2,1,-3,4,-1,2,1,-5,4]"
        },
        "expected": "6"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[5,4,-1,7,8]"
        },
        "expected": "23"
      }
    ]
  },
  "maximum-sum-circular-subarray": {
    "title": "Maximum Sum Circular Subarray",
    "content": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.",
    "difficulty": "Medium",
    "hints": [
      "For those of you who are familiar with the Kadane's algorithm, think in terms of that. For the newbies, Kadane's algorithm is used to finding the maximum sum subarray from a given array. This problem is a twist on that idea and it is advisable to read up on that algorithm first before starting this problem. Unless you already have a great algorithm brewing up in your mind in which case, go right ahead!",
      "What is an alternate way of representing a circular array so that it appears to be a straight array?\r\nEssentially, there are two cases of this problem that we need to take care of. Let's look at the figure below to understand those two cases:\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/circular_subarray_hint_1.png\" width=\"700\"/>",
      "The first case can be handled by the good old Kadane's algorithm. However, is there a smarter way of going about handling the second case as well?"
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming",
      "Queue",
      "Monotonic Queue"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximumSumCircularSubarray(nums) { return 0; }",
      "testCalls": [
        "if(MaximumSumCircularSubarray([1,-2,3,-2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSumCircularSubarray([5,-3,5]) !== 10) { throw new Error('Test Case 2 Failed'); }",
        "if(MaximumSumCircularSubarray([-3,-2,-3]) !== -2) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximumSumCircularSubarray(nums: number[]): number { return 0; }",
      "testCalls": [
        "if(MaximumSumCircularSubarray([1,-2,3,-2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSumCircularSubarray([5,-3,5]) !== 10) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MaximumSumCircularSubarray(vector<int>& nums) { return 0; }",
      "testCalls": [
        "if(MaximumSumCircularSubarray(vector<int>{1,-2,3,-2}) != 3) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(MaximumSumCircularSubarray(vector<int>{5,-3,5}) != 10) throw std::runtime_error(\"Test Case 2 Failed\");",
        "if(MaximumSumCircularSubarray(vector<int>{-3,-2,-3}) != -2) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximumSumCircularSubarray(nums: List[int]) -> int:",
      "testCalls": [
        "assert MaximumSumCircularSubarray([1,-2,3,-2]) == 3, 'Test Case 1 Failed'",
        "assert MaximumSumCircularSubarray([5,-3,5]) == 10, 'Test Case 2 Failed'",
        "assert MaximumSumCircularSubarray([-3,-2,-3]) == -2, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximumSumCircularSubarray(int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.MaximumSumCircularSubarray(new int[]{1,-2,3,-2}) != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.MaximumSumCircularSubarray(new int[]{5,-3,5}) != 10) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaximumSumCircularSubarray(int* nums, int numsSize)",
      "testCalls": [
        "int main() { if(MaximumSumCircularSubarray((int[]){1,-2,3,-2}, 4) != 3) { printf(\"Test Case 1 Failed\\n\"); }",
        "if(MaximumSumCircularSubarray((int[]){5,-3,5}, 3) != 10) { printf(\"Test Case 2 Failed\\n\"); }",
        "if(MaximumSumCircularSubarray((int[]){-3,-2,-3}, 3) != -2) { printf(\"Test Case 3 Failed\\n\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaximumSumCircularSubarray(nums []int) int {}",
      "testCalls": [
        "if MaximumSumCircularSubarray([]int{1,-2,3,-2}) != 3 {panic(\"Test case 1 failed\")}",
        "func test2() { if MaximumSumCircularSubarray([]int{5,-3,5}) != 10 {panic(\"Test case 2 failed\")}}",
        "func test3() { if MaximumSumCircularSubarray([]int{-3,-2,-3}) != -2 {panic(\"Test case 3 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximumSumCircularSubarray(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MaximumSumCircularSubarray(vec![1, -2, 3, -2]), 3);",
        "assert_eq!(MaximumSumCircularSubarray(vec![5, -3, 5]), 10);",
        "assert_eq!(MaximumSumCircularSubarray(vec![-3, -2, -3]), -2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumSumCircularSubarray(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MaximumSumCircularSubarray([1,-2,3,-2]) == 3",
        "raise 'Test Case 2 Failed' unless MaximumSumCircularSubarray([5,-3,5]) == 10"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,-2,3,-2]"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[5,-3,5]"
        },
        "expected": "10"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[-3,-2,-3]"
        },
        "expected": "-2"
      }
    ]
  },
  "median-of-two-sorted-arrays": {
    "title": "Median of Two Sorted Arrays",
    "content": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MedianOfTwoSortedArrays(nums1, nums2) { return 0; }",
      "testCalls": [
        "if (MedianOfTwoSortedArrays([1,3], [2]) !== 2.00000) { throw new Error('Test Case 1 Failed'); }",
        "if (MedianOfTwoSortedArrays([1,2], [3,4]) !== 2.50000) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindMedianSortedArrays(nums1: number[], nums2: number[]): number[]",
      "testCalls": [
        "const test1Result = FindMedianSortedArrays([1,3], [2]); if (test1Result !== 2.00000) { throw new Error('Test Case 1 Failed'); }",
        "const test2Result = FindMedianSortedArrays([1,2], [3,4]); if (test2Result !== 2.50000) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "double FindMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { return 0.0; }",
      "testCalls": [
        "int main() { assert(FindMedianSortedArrays({1,3}, {2}) == 2.00000); return 0; }",
        "int main() { assert(FindMedianSortedArrays({1,2}, {3,4}) == 2.50000); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MedianOfTwoSortedArrays(nums1, nums2):",
      "testCalls": [
        "result1 = MedianOfTwoSortedArrays([1,3], [2])\nif result1 != 2.00000:\n    raise AssertionError",
        "result2 = MedianOfTwoSortedArrays([1,2], [3,4])\nif result2 != 2.50000:\n    raise AssertionError"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public double FindMedianSortedArrays(int[] nums1, int[] nums2) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { if (new Main().FindMedianSortedArrays(new int[]{1,3}, new int[]{2}) != 2.00000) throw new AssertionError(); }",
        "public static void main(String[] args) { if (new Main().FindMedianSortedArrays(new int[]{1,2}, new int[]{3,4}) != 2.50000) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "double FindMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size)",
      "testCalls": [
        "int main() { if (FindMedianSortedArrays((int[]){1,3}, 2, (int[]){2}, 1) != 2.00000) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { if (FindMedianSortedArrays((int[]){1,2}, 2, (int[]){3,4}, 2) != 2.50000) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindMedianSortedArrays(nums1 []int, nums2 []int) float64 {}",
      "testCalls": [
        "func TestFindMedianSortedArrays(t *testing.T) { if FindMedianSortedArrays([]int{1,3}, []int{2}) != 2.00000 { t.Error() } }",
        "func TestFindMedianSortedArrays2(t *testing.T) { if FindMedianSortedArrays([]int{1,2}, []int{3,4}) != 2.50000 { t.Error() } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MedianOfTwoSortedArrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {}",
      "testCalls": [
        "assert_eq!(MedianOfTwoSortedArrays(vec![1, 3], vec![2]), 2.00000);",
        "assert_eq!(MedianOfTwoSortedArrays(vec![1, 2], vec![3, 4]), 2.50000);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MedianOfTwoSortedArrays(nums1, nums2)\nend",
      "testCalls": [
        "result1 = MedianOfTwoSortedArrays([1,3], [2])\nraise 'Test Case 1 Failed' unless result1 == 2.00000",
        "result2 = MedianOfTwoSortedArrays([1,2], [3,4])\nraise 'Test Case 2 Failed' unless result2 == 2.50000"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums1": "[1,3]",
          "nums2": "[2]"
        },
        "expected": "2.00000"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums1": "[1,2]",
          "nums2": "[3,4]"
        },
        "expected": "2.50000"
      }
    ]
  },
  "merge-intervals": {
    "title": "Merge Intervals",
    "content": "Given an arrayof intervalswhere intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeIntervals(intervals) { return []; }",
      "testCalls": [
        "const test1 = MergeIntervals([[1,3],[2,6],[8,10],[15,18]]); if(JSON.stringify(test1) !== '[[1,6],[8,10],[15,18]]') throw new Error('Test Case 1 Failed');",
        "const test2 = MergeIntervals([[1,4],[4,5]]); if(JSON.stringify(test2) !== '[[1,5]]') throw new Error('Test Case 2 Failed');",
        "const test3 = MergeIntervals([[4,7],[1,4]]); if(JSON.stringify(test3) !== '[[1,7]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeIntervals(intervals: number[][]): number[][] { return []; }",
      "testCalls": [
        "const test1 = MergeIntervals([[1,3],[2,6],[8,10],[15,18]]); if (JSON.stringify(test1) !== '[[1,6],[8,10],[15,18]]') throw new Error('Test Case 1 Failed');",
        "const test2 = MergeIntervals([[1,4],[4,5]]); if (JSON.stringify(test2) !== '[[1,5]]') throw new Error('Test Case 2 Failed');",
        "const test3 = MergeIntervals([[4,7],[1,4]]); if (JSON.stringify(test3) !== '[[1,7]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> MergeIntervals(vector<vector<int>> intervals);",
      "testCalls": [
        "auto res1 = MergeIntervals(vector<vector<int>>{{1,3},{2,6},{8,10},{15,18}}); assert((res1 == vector<vector<int>>{{1,6},{8,10},{15,18}}));",
        "auto res2 = MergeIntervals(vector<vector<int>>{{1,4},{4,5}}); assert((res2 == vector<vector<int>>{{1,5}}));",
        "auto res3 = MergeIntervals(vector<vector<int>>{{4,7},{1,4}}); assert((res3 == vector<vector<int>>{{1,7}}));"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MergeIntervals(intervals: List[List[int]]) -> List[List[int]]:",
      "testCalls": [
        "assert compareArrays(MergeIntervals([[1,3],[2,6],[8,10],[15,18]]), [[1,6],[8,10],[15,18]])",
        "assert compareArrays(MergeIntervals([[1,4],[4,5]]), [[1,5]])",
        "assert compareArrays(MergeIntervals([[4,7],[1,4]]), [[1,7]])"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public int[][] MergeIntervals(int[][] intervals) { return new int[0][0]; }",
      "testCalls": [
        "int[][] test1 = MergeIntervals(new int[][]{{1,3},{2,6},{8,10},{15,18}}); if (!Arrays.deepEquals(test1, new int[][]{{1,6},{8,10},{15,18}})) throw new AssertionError();",
        "int[][] test2 = MergeIntervals(new int[][]{{1,4},{4,5}}); if (!Arrays.deepEquals(test2, new int[][]{{1,5}})) throw new AssertionError();",
        "int[][] test3 = MergeIntervals(new int[][]{{4,7},{1,4}}); if (!Arrays.deepEquals(test3, new int[][]{{1,7}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) { return Arrays.deepEquals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int** MergeIntervals(int** intervals, int intervalsSize, int* intervalsColSize)",
      "testCalls": [
        "int** result1 = MergeIntervals((int*[]){{1,3},{2,6},{8,10},{15,18}}, 4, (int[]){2, 2}); // Expected: [[1,6],[8,10],[15,18]]",
        "int** result2 = MergeIntervals((int*[]){{1,4},{4,5}}, 2, (int[]){2, 2}); // Expected: [[1,5]]",
        "int** result3 = MergeIntervals((int*[]){{4,7},{1,4}}, 2, (int[]){2, 2}); // Expected: [[1,7]]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n    if(size1 != size2) return 0;\n    for(int i = 0; i < size1; i++) {\n        if(arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MergeIntervals(intervals [][]int) [][]int { return [][]int{} }",
      "testCalls": [
        "func test1() { result1 := MergeIntervals([][]int{{1,3},{2,6},{8,10},{15,18}}); if !compareArrays(result1, [][]int{{1,6},{8,10},{15,18}}) { fmt.Println(\"Test case 1 failed\") } }",
        "func test2() { result2 := MergeIntervals([][]int{{1,4},{4,5}}); if !compareArrays(result2, [][]int{{1,5}}) { fmt.Println(\"Test case 2 failed\") } }",
        "func test3() { result3 := MergeIntervals([][]int{{4,7},{1,4}}); if !compareArrays(result3, [][]int{{1,7}}) { fmt.Println(\"Test case 3 failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i][0] != arr2[i][0] || arr1[i][1] != arr2[i][1] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeIntervals(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = MergeIntervals(vec![vec![1,3], vec![2,6], vec![8,10], vec![15,18]]); assert_eq!(result1, vec![vec![1,6], vec![8,10], vec![15,18]]);",
        "let result2 = MergeIntervals(vec![vec![1,4], vec![4,5]]); assert_eq!(result2, vec![vec![1,5]]);",
        "let result3 = MergeIntervals(vec![vec![4,7], vec![1,4]]); assert_eq!(result3, vec![vec![1,7]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_eq(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i], b[i]); } }"
    },
    "ruby": {
      "functionDeclaration": "def MergeIntervals(intervals)\n  \nend",
      "testCalls": [
        "intervals1 = [[1,3],[2,6],[8,10],[15,18]]\nexpected_result1 = [[1,6],[8,10],[15,18]]\nresult1 = MergeIntervals(intervals1)\nraise 'Test Case 1 Failed' unless result1 == expected_result1",
        "intervals2 = [[1,4],[4,5]]\nexpected_result2 = [[1,5]]\nresult2 = MergeIntervals(intervals2)\nraise 'Test Case 2 Failed' unless result2 == expected_result2"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "intervals": "[[1,3],[2,6],[8,10],[15,18]]"
        },
        "expected": "[[1,6],[8,10],[15,18]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "intervals": "[[1,4],[4,5]]"
        },
        "expected": "[[1,5]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "intervals": "[[4,7],[1,4]]"
        },
        "expected": "[[1,7]]"
      }
    ]
  },
  "merge-k-sorted-lists": {
    "title": "Merge k Sorted Lists",
    "content": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeKSortedLists(lists) {}",
      "testCalls": [
        "let test1 = MergeKSortedLists([buildLinkedList([1,4,5]), buildLinkedList([1,3,4]), buildLinkedList([2,6])]); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,1,2,3,4,4,5,6])) throw new Error('Test Case 1 Failed');",
        "let test2 = MergeKSortedLists([]); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');",
        "let test3 = MergeKSortedLists([buildLinkedList([])]); if(JSON.stringify(linkedListToArray(test3)) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function MergeKSortedLists(lists: number[][]): number[] | null {}",
      "testCalls": [
        "const test1 = MergeKSortedLists([buildLinkedList([1,4,5]), buildLinkedList([1,3,4]), buildLinkedList([2,6])]); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,1,2,3,4,4,5,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = MergeKSortedLists([]); if(JSON.stringify(test2) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');",
        "const test3 = MergeKSortedLists([null]); if(JSON.stringify(test3) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "",
      "builders": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* MergeKSortedLists(vector<ListNode*>& lists) { return nullptr; }",
      "testCalls": [
        "assert(compareLinkedLists(MergeKSortedLists({buildLinkedList({1,4,5}), buildLinkedList({1,3,4}), buildLinkedList({2,6})}), buildLinkedList({1,1,2,3,4,4,5,6})));",
        "assert(compareLinkedLists(MergeKSortedLists({}), nullptr));",
        "assert(compareLinkedLists(MergeKSortedLists({nullptr}), nullptr));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def MergeKSortedLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:",
      "testCalls": [
        "l1 = buildLinkedList([1,4,5]); l2 = buildLinkedList([1,3,4]); l3 = buildLinkedList([2,6]); result = MergeKSortedLists([l1, l2, l3]); assert linkedListToArray(result) == [1,1,2,3,4,4,5,6], 'Test Case 1 Failed'",
        "result = MergeKSortedLists([]); assert linkedListToArray(result) == [], 'Test Case 2 Failed'",
        "result = MergeKSortedLists([None]); assert linkedListToArray(result) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):...",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for value in arr[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linkedListToArray(head):\n    array = []\n    current = head\n    while current:\n        array.append(current.val)\n        current = current.next\n    return array"
    },
    "java": {
      "functionDeclaration": "public ListNode mergeKSortedLists(ListNode[] lists) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode[] testInput1 = {buildLinkedList(new int[]{1,4,5}), buildLinkedList(new int[]{1,3,4}), buildLinkedList(new int[]{2,6})}; ListNode expectedResult1 = buildLinkedList(new int[]{1,1,2,3,4,4,5,6}); compareLinkedLists(expectedResult1, mergeKSortedLists(testInput1)); }",
        "public static void main(String[] args) { ListNode[] testInput2 = {}; ListNode expectedResult2 = null; compareLinkedLists(expectedResult2, mergeKSortedLists(testInput2)); }",
        "public static void main(String[] args) { ListNode[] testInput3 = {buildLinkedList(new int[]{})}; ListNode expectedResult3 = null; compareLinkedLists(expectedResult3, mergeKSortedLists(testInput3)); }"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode expected, ListNode actual) {\n    while (expected != null && actual != null) {\n        if (expected.val != actual.val) {\n            throw new AssertionError(\"Mismatch in linked list values\");\n        }\n        expected = expected.next;\n        actual = actual.next;\n    }\n    if (expected != null || actual != null) {\n        throw new AssertionError(\"Linked lists are of different lengths\");\n    }\n}",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "struct ListNode* MergeKSortedLists(struct ListNode** lists, int listsSize, int* listsColSize) { return NULL; }",
      "testCalls": [
        "struct ListNode* l1 = buildLinkedList((int[]){1,4,5}, 3); struct ListNode* l2 = buildLinkedList((int[]){1,3,4}, 3); struct ListNode* l3 = buildLinkedList((int[]){2,6}, 2); struct ListNode* lists[3] = {l1, l2, l3}; int listsColSize[3] = {3, 3, 2}; MergeKSortedLists(lists, 3, listsColSize);",
        "MergeKSortedLists(NULL, 0, NULL);"
      ],
      "compareHelper": "",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func MergeKSortedLists(lists [][]int) []int {}",
      "testCalls": [
        "func test1() { result1 := MergeKSortedLists([][]int{{1,4,5},{1,3,4},{2,6}}); if !compareArrays(result1, []int{1,1,2,3,4,4,5,6}) { fmt.Println(\"Test case 1 failed\") } }",
        "func test2() { result2 := MergeKSortedLists([][]int{}); if !compareArrays(result2, []int{}) { fmt.Println(\"Test case 2 failed\") } }",
        "func test3() { result3 := MergeKSortedLists([][]int{{}}); if !compareArrays(result3, []int{}) { fmt.Println(\"Test case 3 failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeKSortedLists(lists: Vec<Vec<i32>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode::from(vec![1, 1, 2, 3, 4, 4, 5, 6]))), MergeKSortedLists(vec![vec![1, 4, 5], vec![1, 3, 4], vec![2, 6]]));",
        "assert_eq!(None, MergeKSortedLists(vec![]));",
        "assert_eq!(None, MergeKSortedLists(vec![vec![]]));"
      ],
      "compareHelper": "fn compare_linked_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) { }",
      "helpers": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}",
      "typeDefs": "#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}",
      "builders": "impl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeKSortedLists(lists)\nend",
      "testCalls": [
        "l1 = buildLinkedList([1,4,5]); l2 = buildLinkedList([1,3,4]); l3 = buildLinkedList([2,6]); result1 = MergeKSortedLists([l1, l2, l3]); raise 'Test Case 1 Failed' unless linkedListToArray(result1) == [1,1,2,3,4,4,5,6]",
        "result2 = MergeKSortedLists([]); raise 'Test Case 2 Failed' unless linkedListToArray(result2) == []",
        "result3 = MergeKSortedLists([nil]); raise 'Test Case 3 Failed' unless linkedListToArray(result3) == []"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "lists": "[[1,4,5],[1,3,4],[2,6]]"
        },
        "expected": "[1,1,2,3,4,4,5,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "lists": "[]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "lists": "[[]]"
        },
        "expected": "[]"
      }
    ]
  },
  "merge-sorted-array": {
    "title": "Merge Sorted Array",
    "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
    "difficulty": "Easy",
    "hints": [
      "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
      "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeSortedArray(nums1, m, nums2, n) {}",
      "testCalls": [
        "MergeSortedArray([1,2,3,0,0,0], 3, [2,5,6], 3);",
        "MergeSortedArray([1], 1, [], 0);",
        "MergeSortedArray([0], 0, [1], 1);"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeSortedArray(nums1: number[], m: number, nums2: number[], n: number): void {}",
      "testCalls": [
        "MergeSortedArray([1,2,3,0,0,0], 3, [2,5,6], 3); if (JSON.stringify(nums1) !== JSON.stringify([1,2,2,3,5,6])) throw new Error('Test Case 1 Failed');",
        "MergeSortedArray([1], 1, [], 0); if (JSON.stringify(nums1) !== JSON.stringify([1])) throw new Error('Test Case 2 Failed');",
        "MergeSortedArray([0], 0, [1], 1); if (JSON.stringify(nums1) !== JSON.stringify([1])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "void MergeSortedArray(vector<int>& nums1, int m, vector<int>& nums2, int n) {}",
      "testCalls": [
        "vector<int> nums1_0 = {1,2,3,0,0,0}; vector<int> nums2_0 = {2,5,6}; MergeSortedArray(nums1_0, 3, nums2_0, 3);",
        "vector<int> nums1_1 = {1}; vector<int> nums2_1 = {}; MergeSortedArray(nums1_1, 1, nums2_1, 0);",
        "vector<int> nums1_2 = {0}; vector<int> nums2_2 = {1}; MergeSortedArray(nums1_2, 0, nums2_2, 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def MergeSortedArray(nums1, m, nums2, n):",
      "testCalls": [
        "result1 = [1,2,3,0,0,0]\nMergeSortedArray(result1, 3, [2,5,6], 3)\nassert result1 == [1,2,2,3,5,6]",
        "result2 = [1]\nMergeSortedArray(result2, 1, [], 0)\nassert result2 == [1]",
        "result3 = [0]\nMergeSortedArray(result3, 0, [1], 1)\nassert result3 == [1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public void MergeSortedArray(int[] nums1, int m, int[] nums2, int n) { return; }",
      "testCalls": [
        "m.MergeSortedArray(new int[]{1,2,3,0,0,0}, 3, new int[]{2,5,6}, 3); m.compareArrays(new int[]{1,2,3,0,0,0}, new int[]{1,2,2,3,5,6});",
        "m.MergeSortedArray(new int[]{1}, 1, new int[]{}, 0); m.compareArrays(new int[]{1}, new int[]{1});",
        "m.MergeSortedArray(new int[]{0}, 0, new int[]{1}, 1); m.compareArrays(new int[]{0}, new int[]{1});"
      ],
      "compareHelper": "private void compareArrays(int[] arr1, int[] arr2) { for (int i = 0; i < arr1.length; i++) { if (arr1[i] != arr2[i]) { throw new AssertionError(\"Arrays differ at index \" + i); } } }"
    },
    "c": {
      "functionDeclaration": "void MergeSortedArray(int* nums1, int m, int* nums2, int n)",
      "testCalls": [
        "int nums1_0[] = {1,2,3,0,0,0}; int nums2_0[] = {2,5,6}; MergeSortedArray(nums1_0, 3, nums2_0, 3);",
        "int nums1_1[] = {1}; int nums2_1[] = {}; MergeSortedArray(nums1_1, 1, nums2_1, 0);",
        "int nums1_2[] = {0}; int nums2_2[] = {1}; MergeSortedArray(nums1_2, 0, nums2_2, 1);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n  for (int i = 0; i < size; i++) {\n    if (arr1[i] != arr2[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MergeSortedArray(nums1 []int, m int, nums2 []int, n int) []int { return []int{} }",
      "testCalls": [
        "func test() {",
        "    if !compareArrays(MergeSortedArray([]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3), []int{1, 2, 2, 3, 5, 6}) { fmt.Println(\"Test Case 1 Failed\") }",
        "    if !compareArrays(MergeSortedArray([]int{1}, 1, []int{}, 0), []int{1}) { fmt.Println(\"Test Case 2 Failed\") }",
        "    if !compareArrays(MergeSortedArray([]int{0}, 0, []int{1}, 1), []int{1}) { fmt.Println(\"Test Case 3 Failed\") }",
        "}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeSortedArray(nums1: &mut Vec<i32>, m: i32, nums2: &Vec<i32>, n: i32) {}",
      "testCalls": [
        "let mut test1_nums1 = vec![1, 2, 3, 0, 0, 0];\nlet test1_nums2 = vec![2, 5, 6];\nMergeSortedArray(&mut test1_nums1, 3, &test1_nums2, 3);\nassert_eq!(test1_nums1, vec![1, 2, 2, 3, 5, 6]);",
        "let mut test2_nums1 = vec![1];\nlet test2_nums2 = vec![];\nMergeSortedArray(&mut test2_nums1, 1, &test2_nums2, 0);\nassert_eq!(test2_nums1, vec![1]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: &Vec<i32>, b: &Vec<i32>) {\n    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert_eq!(a[i], b[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeSortedArray(nums1, m, nums2, n)\nend",
      "testCalls": [
        "nums1 = [1,2,3,0,0,0]\nm = 3\nnums2 = [2,5,6]\nn = 3\nMergeSortedArray(nums1, m, nums2, n)\nraise 'Test Case 1 Failed' unless nums1 == [1,2,2,3,5,6]",
        "nums1 = [1]\nm = 1\nnums2 = []\nn = 0\nMergeSortedArray(nums1, m, nums2, n)\nraise 'Test Case 2 Failed' unless nums1 == [1]"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums1": "[1,2,3,0,0,0]",
          "m": "3",
          "nums2": "[2,5,6]",
          "n": "3"
        },
        "expected": "[1,2,2,3,5,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums1": "[1]",
          "m": "1",
          "nums2": "[]",
          "n": "0"
        },
        "expected": "[1]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums1": "[0]",
          "m": "0",
          "nums2": "[1]",
          "n": "1"
        },
        "expected": "[1]"
      }
    ]
  },
  "merge-two-sorted-lists": {
    "title": "Merge Two Sorted Lists",
    "content": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeTwoSortedLists(list1, list2) { return null; }",
      "testCalls": [
        "let test1 = MergeTwoSortedLists(buildLinkedList([1,2,4]), buildLinkedList([1,3,4])); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,1,2,3,4,4])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = MergeTwoSortedLists(null, null); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "let test3 = MergeTwoSortedLists(null, buildLinkedList([0])); if(JSON.stringify(linkedListToArray(test3)) !== JSON.stringify([0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function MergeTwoSortedLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {}",
      "testCalls": [
        "const test1Result = MergeTwoSortedLists(buildLinkedList([1,2,4]), buildLinkedList([1,3,4])); compareLinkedLists(test1Result, buildLinkedList([1,1,2,3,4,4]));",
        "const test2Result = MergeTwoSortedLists(null, null); compareLinkedLists(test2Result, null);",
        "const test3Result = MergeTwoSortedLists(null, buildLinkedList([0])); compareLinkedLists(test3Result, buildLinkedList([0]));"
      ],
      "compareHelper": "function compareLinkedLists(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); } }",
      "typeDefs": "",
      "builders": "function buildLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head: ListNode | null): number[] { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* MergeTwoSortedLists(ListNode* list1, ListNode* list2) { return nullptr; }",
      "testCalls": [
        "assert(compareLinkedLists(MergeTwoSortedLists(buildLinkedList({1,2,4}), buildLinkedList({1,3,4})), buildLinkedList({1,1,2,3,4,4})));",
        "assert(compareLinkedLists(MergeTwoSortedLists(buildLinkedList({}), buildLinkedList({})), buildLinkedList({})));",
        "assert(compareLinkedLists(MergeTwoSortedLists(buildLinkedList({}), buildLinkedList({0})), buildLinkedList({0})));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def MergeTwoSortedLists(list1, list2):",
      "testCalls": [
        "l1 = buildLinkedList([1,2,4]); l2 = buildLinkedList([1,3,4]); result = MergeTwoSortedLists(l1, l2); assert compareArrays(linkedListToArray(result), [1,1,2,3,4,4]), 'Test Case 1 Failed'",
        "result = MergeTwoSortedLists(None, None); assert compareArrays(linkedListToArray(result), []), 'Test Case 2 Failed'",
        "l = buildLinkedList([0]); result = MergeTwoSortedLists(None, l); assert compareArrays(linkedListToArray(result), [0]), 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for value in arr[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    current = head\n    while current:\n        arr.append(current.val)\n        current = current.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode mergeTwoSortedLists(ListNode list1, ListNode list2) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode expected1 = buildLinkedList(new int[]{1, 1, 2, 3, 4, 4}); ListNode result1 = mergeTwoSortedLists(buildLinkedList(new int[]{1, 2, 4}), buildLinkedList(new int[]{1, 3, 4})); assertLinkedListEquals(expected1, result1); }",
        "public static void main(String[] args) { ListNode expected2 = buildLinkedList(new int[]{}); ListNode result2 = mergeTwoSortedLists(buildLinkedList(new int[]{}), buildLinkedList(new int[]{})); assertLinkedListEquals(expected2, result2); }",
        "public static void main(String[] args) { ListNode expected3 = buildLinkedList(new int[]{0}); ListNode result3 = mergeTwoSortedLists(buildLinkedList(new int[]{}), buildLinkedList(new int[]{0})); assertLinkedListEquals(expected3, result3); }"
      ],
      "compareHelper": "private void assertLinkedListEquals(ListNode expected, ListNode actual) { while (expected != null && actual != null) { if (expected.val != actual.val) { throw new AssertionError(\"Value mismatch: expected=\" + expected.val + \", actual=\" + actual.val); } expected = expected.next; actual = actual.next; } if (expected != null || actual != null) { throw new AssertionError(\"Length mismatch\"); } }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "struct ListNode* MergeTwoSortedLists(struct ListNode* list1, struct ListNode* list2) { return NULL; }",
      "testCalls": [
        "struct ListNode* list1 = buildLinkedList((int[]){1,2,4}, 3); struct ListNode* list2 = buildLinkedList((int[]){1,3,4}, 3); MergeTwoSortedLists(list1, list2);",
        "MergeTwoSortedLists(NULL, NULL);",
        "struct ListNode* list2 = buildLinkedList((int[]){0}, 1); MergeTwoSortedLists(NULL, list2);"
      ],
      "compareHelper": "int compareArrays(struct ListNode* l1, struct ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return 0; l1 = l1->next; l2 = l2->next; } return l1 == NULL && l2 == NULL; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func MergeTwoSortedLists(list1 *ListNode, list2 *ListNode) *ListNode {}",
      "testCalls": [
        "func TestMergeTwoSortedLists(t *testing.T) { if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{1, 2, 4}), sliceToListNode([]int{1, 3, 4})), sliceToListNode([]int{1, 1, 2, 3, 4, 4})) { t.Error(\"Test Case 1 Failed\") } if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{}), sliceToListNode([]int{})), sliceToListNode([]int{})) { t.Error(\"Test Case 2 Failed\") } if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{}), sliceToListNode([]int{0})), sliceToListNode([]int{0})) { t.Error(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }"
    },
    "rust": {
      "functionDeclaration": "fn MergeTwoSortedLists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 4, next: None) } } } } } } } } } } } } } })), MergeTwoSortedLists(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 4, next: None) } } } })), Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: None) } } } })))).unwrap());",
        "assert_eq!(None, MergeTwoSortedLists(None, None));",
        "assert_eq!(Some(Box::new(ListNode { val: 0, next: None })), MergeTwoSortedLists(None, Some(Box::new(ListNode { val: 0, next: None })));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}",
      "typeDefs": "#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}",
      "builders": "impl ListNode {\n    fn from(arr: Vec<i32>) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: None });\n        let mut current = &mut dummy;\n        for &val in arr.iter() {\n            current.next = Some(Box::new(ListNode { val, next: None }));\n            current = current.next.as_mut().unwrap();\n        }\n        dummy.next\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeTwoSortedLists(list1, list2)\nend",
      "testCalls": [
        "l1 = buildLinkedList([1,2,4]); l2 = buildLinkedList([1,3,4]); result1 = MergeTwoSortedLists(l1, l2); raise 'Test Case 1 Failed' unless linkedListToArray(result1) == [1,1,2,3,4,4]",
        "result2 = MergeTwoSortedLists(nil, nil); raise 'Test Case 2 Failed' unless linkedListToArray(result2) == []",
        "result3 = MergeTwoSortedLists(nil, buildLinkedList([0])); raise 'Test Case 3 Failed' unless linkedListToArray(result3) == [0]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "list1": "[1,2,4]",
          "list2": "[1,3,4]"
        },
        "expected": "[1,1,2,3,4,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "list1": "[]",
          "list2": "[]"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "list1": "[]",
          "list2": "[0]"
        },
        "expected": "[0]"
      }
    ]
  },
  "minimum-absolute-difference-in-bst": {
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumAbsoluteDifferenceInBST(root) { return 0; }",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(buildTree([4,2,6,1,3])) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumAbsoluteDifferenceInBST(buildTree([1,0,48,null,null,12,49])) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function MinimumAbsoluteDifferenceInBST(root: TreeNode | null): number {}",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(createTreeNode([4,2,6,1,3])) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumAbsoluteDifferenceInBST(createTreeNode([1,0,48,null,null,12,49])) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function createTreeNode(arr: Array<number | null>): TreeNode | null {}",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function createTreeNode(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "int MinDiffInBST(TreeNode* root) { return 0; }",
      "testCalls": [
        "int main() { assert(MinDiffInBST(buildTree({4,2,6,1,3})) == 1); return 0; }",
        "int main() { assert(MinDiffInBST(buildTree({1,0,48,INT_MIN,INT_MIN,12,49})) == 1); return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(std::vector<int> arr) { if (arr.empty() || arr[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(arr[0]); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { TreeNode* node = q.front(); q.pop(); if (i < arr.size() && arr[i] != INT_MIN) { node->left = new TreeNode(arr[i]); q.push(node->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { node->right = new TreeNode(arr[i]); q.push(node->right); } i++; } return root; }\nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def MinimumAbsoluteDifferenceInBST(root):",
      "testCalls": [
        "root = buildTree([4,2,6,1,3]); assert MinimumAbsoluteDifferenceInBST(root) == 1",
        "root = buildTree([1,0,48,None,None,12,49]); assert MinimumAbsoluteDifferenceInBST(root) == 1"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public int MinimumAbsoluteDifferenceInBST(TreeNode root) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.MinimumAbsoluteDifferenceInBST(m.buildTree(new Integer[]{4,2,6,1,3})) != 1) { throw new AssertionError(); } }",
        "public static void main(String[] args) { Main m = new Main(); if (m.MinimumAbsoluteDifferenceInBST(m.buildTree(new Integer[]{1,0,48,null,null,12,49})) != 1) { throw new AssertionError(); } }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }",
      "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (i < arr.length && arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic List<Integer> treeToArray(TreeNode root) { List<Integer> result = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "int GetMinimumDifference(struct TreeNode* root)",
      "testCalls": [
        "int main() { if(GetMinimumDifference(buildTree((int[]){4,2,6,1,3}, 5)) != 1) { printf(\"Test Case 1 Failed\"); } if(GetMinimumDifference(buildTree((int[]){1,0,48,INT_MIN,INT_MIN,12,49}, 7)) != 1) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; };",
      "builders": "struct TreeNode* createNode(int val) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode->val = val; newNode->left = NULL; newNode->right = NULL; return newNode; } struct TreeNode* buildTree(int* arr, int size) { if (size == 0 || arr[0] == INT_MIN) return NULL; struct TreeNode* root = createNode(arr[0]); struct TreeNode* queue[size]; int i = 1, qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd && i < size) { struct TreeNode* node = queue[qStart++]; if (i < size && arr[i] != INT_MIN) { node->left = createNode(arr[i]); queue[qEnd++] = node->left; } i++; if (i < size && arr[i] != INT_MIN) { node->right = createNode(arr[i]); queue[qEnd++] = node->right; } i++; } return root; } int* treeToArray(struct TreeNode* root, int* returnSize) { if (!root) { *returnSize = 0; return NULL; } int* result = (int*)malloc(sizeof(int) * 10000); int index = 0; struct TreeNode* queue[10000]; int qStart = 0, qEnd = 0; queue[qEnd++] = root; while (qStart < qEnd) { struct TreeNode* node = queue[qStart++]; if (node) { result[index++] = node->val; queue[qEnd++] = node->left; queue[qEnd++] = node->right; } else { result[index++] = INT_MIN; } } while (result[index-1] == INT_MIN) index--; *returnSize = index; return result; }"
    },
    "go": {
      "functionDeclaration": "func GetMinimumDifference(root *TreeNode) int {}",
      "testCalls": [
        "func test1() { root := buildTree([]int{4,2,6,1,3}); if GetMinimumDifference(root) != 1 { panic(\"Test case 1 failed\") } }",
        "func test2() { root := buildTree([]int{1,0,48,0,0,12,49}); if GetMinimumDifference(root) != 1 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode; }",
      "builders": "func buildTree(arr []int) *TreeNode { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn MinimumAbsoluteDifferenceInBST(root: Option<Rc<RefCell<TreeNode>>) -> i32 {}",
      "testCalls": [
        "let root1 = buildTree(vec![Some(4), Some(2), Some(6), Some(1), Some(3)]); assert_eq!(MinimumAbsoluteDifferenceInBST(root1), 1);",
        "let root2 = buildTree(vec![Some(1), Some(0), Some(48), None, None, Some(12), Some(49)]); assert_eq!(MinimumAbsoluteDifferenceInBST(root2), 1);"
      ],
      "compareHelper": "",
      "helpers": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}",
      "builders": "impl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Rc<RefCell<TreeNode>>> {}\n\nfn treeToArray(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {}"
    },
    "ruby": {
      "functionDeclaration": "def MinimumAbsoluteDifferenceInBst(root)\nend",
      "testCalls": [
        "root = buildTree([4,2,6,1,3]); raise 'Test Case 1 Failed' unless MinimumAbsoluteDifferenceInBst(root) == 1",
        "root = buildTree([1,0,48,nil,nil,12,49]); raise 'Test Case 2 Failed' unless MinimumAbsoluteDifferenceInBst(root) == 1"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[4,2,6,1,3]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,0,48,null,null,12,49]"
        },
        "expected": "1"
      }
    ]
  },
  "minimum-genetic-mutation": {
    "title": "Minimum Genetic Mutation",
    "content": "A gene string can be represented by an 8-character long string, with choices from &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\nFor example, &quot;AACCGGTT&quot; --> &quot;AACCGGTA&quot; is one mutation.\n\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Breadth-First Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumGeneticMutation(startGene, endGene, bank) { return 0; }",
      "testCalls": [
        "const test1 = MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA']);\nif (test1 !== 1) { throw new Error('Test case 1 failed'); }",
        "const test2 = MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA']);\nif (test2 !== 2) { throw new Error('Test case 2 failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumGeneticMutation(startGene: string, endGene: string, bank: string[]): number { return 0; }",
      "testCalls": [
        "if (MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA']) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA']) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MinGeneticMutation(string startGene, string endGene, vector<string>& bank) { return 0; }",
      "testCalls": [
        "assert(MinGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", vector<string>{\"AACCGGTA\"}) == 1);",
        "assert(MinGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", vector<string>{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumGeneticMutation(startGene: str, endGene: str, bank: List[str]) -> int:",
      "testCalls": [
        "assert MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", [\"AACCGGTA\"]) == 1",
        "assert MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int minMutation(String startGene, String endGene, String[] bank) { return 0; }",
      "testCalls": [
        "if (minMutation(\"AACCGGTT\", \"AACCGGTA\", new String[]{\"AACCGGTA\"}) != 1) { throw new AssertionError(); }",
        "if (minMutation(\"AACCGGTT\", \"AAACGGTA\", new String[]{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) != 2) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinimumGeneticMutation(char *startGene, char *endGene, char **bank, int bankSize)",
      "testCalls": [
        "void test_example_1() { assert(MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", (char*[]){\"AACCGGTA\"}, 1) == 1); }",
        "void test_example_2() { assert(MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", (char*[]){\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"}, 3) == 2); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumGeneticMutation(startGene string, endGene string, bank []string) int {}",
      "testCalls": [
        "func main() { if MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", []string{\"AACCGGTA\"}) != 1 {panic(\"Test case 1 failed\")} }",
        "func main() { if MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", []string{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) != 2 {panic(\"Test case 2 failed\")} }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumGeneticMutation(start_gene: &str, end_gene: &str, bank: Vec<&str>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", vec![\"AACCGGTA\"]), 1);",
        "assert_eq!(MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", vec![\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumGeneticMutation(start_gene, end_gene, bank)\n  \nend",
      "testCalls": [
        "result1 = MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA'])\nraise 'Test Case 1 Failed' unless result1 == 1",
        "result2 = MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA'])\nraise 'Test Case 2 Failed' unless result2 == 2"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "startGene": "&quot;AACCGGTT&quot;",
          "endGene": "&quot;AACCGGTA&quot;",
          "bank": "[&quot;AACCGGTA&quot;]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "startGene": "&quot;AACCGGTT&quot;",
          "endGene": "&quot;AAACGGTA&quot;",
          "bank": "[&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]"
        },
        "expected": "2"
      }
    ]
  },
  "minimum-number-of-arrows-to-burst-balloons": {
    "title": "Minimum Number of Arrows to Burst Balloons",
    "content": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumNumberOfArrowsToBurstBalloons(points) { return 0; }",
      "testCalls": [
        "const test1 = MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]); if(test1 !== 2) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]); if(test2 !== 4) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = MinimumNumberOfArrowsToBurstBalloons([[1,2],[2,3],[3,4],[4,5]]); if(test3 !== 2) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function MinimumNumberOfArrowsToBurstBalloons(points: number[][]): number { return 0; }",
      "testCalls": [
        "if (MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int FindMinArrowShots(vector<vector<int>>& points) { return 0; }",
      "testCalls": [
        "int main() { assert(FindMinArrowShots({{10,16},{2,8},{1,6},{7,12}}) == 2); return 0; }",
        "int main() { assert(FindMinArrowShots({{1,2},{3,4},{5,6},{7,8}}) == 4); return 0; }",
        "int main() { assert(FindMinArrowShots({{1,2},{2,3},{3,4},{4,5}}) == 2); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumNumberOfArrowsToBurstBalloons(points: List[List[int]]) -> int:",
      "testCalls": [
        "assert MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]) == 2",
        "assert MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]) == 4",
        "assert MinimumNumberOfArrowsToBurstBalloons([[1,2],[2,3],[3,4],[4,5]]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int findMinArrowShots(int[][] points) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { int[][] points1 = {{10,16},{2,8},{1,6},{7,12}}; int expected1 = 2; int result1 = findMinArrowShots(points1); if(result1 != expected1) throw new AssertionError(); }",
        "public static void main(String[] args) { int[][] points2 = {{1,2},{3,4},{5,6},{7,8}}; int expected2 = 4; int result2 = findMinArrowShots(points2); if(result2 != expected2) throw new AssertionError(); }",
        "public static void main(String[] args) { int[][] points3 = {{1,2},{2,3},{3,4},{4,5}}; int expected3 = 2; int result3 = findMinArrowShots(points3); if(result3 != expected3) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinimumNumberOfArrowsToBurstBalloons(int** points, int pointsSize, int* pointsColSize)",
      "testCalls": [
        "int** points1 = (int*[]){{10,16},{2,8},{1,6},{7,12}}; int pointsSize1 = 4; int pointsColSize1 = 2; int result1 = MinimumNumberOfArrowsToBurstBalloons(points1, pointsSize1, &pointsColSize1); if(result1 != 2) { printf(\"Test Case 1 Failed\"); }",
        "int** points2 = (int*[]){{1,2},{3,4},{5,6},{7,8}}; int pointsSize2 = 4; int pointsColSize2 = 2; int result2 = MinimumNumberOfArrowsToBurstBalloons(points2, pointsSize2, &pointsColSize2); if(result2 != 4) { printf(\"Test Case 2 Failed\"); }",
        "int** points3 = (int*[]){{1,2},{2,3},{3,4},{4,5}}; int pointsSize3 = 4; int pointsColSize3 = 2; int result3 = MinimumNumberOfArrowsToBurstBalloons(points3, pointsSize3, &pointsColSize3); if(result3 != 2) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumNumberOfArrowsToBurstBalloons(points [][]int) int {}",
      "testCalls": [
        "func main() { if MinimumNumberOfArrowsToBurstBalloons([][]int{{10,16},{2,8},{1,6},{7,12}}) != 2 {panic(\"Test case 1 failed\")}}",
        "func main() { if MinimumNumberOfArrowsToBurstBalloons([][]int{{1,2},{3,4},{5,6},{7,8}}) != 4 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumNumberOfArrowsToBurstBalloons(points: Vec<Vec<i32>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![10,16],vec![2,8],vec![1,6],vec![7,12]]), 2);",
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![1,2],vec![3,4],vec![5,6],vec![7,8]]), 4);",
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![1,2],vec![2,3],vec![3,4],vec![4,5]]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumNumberOfArrowsToBurstBalloons(points)\nend",
      "testCalls": [
        "points1 = [[10,16],[2,8],[1,6],[7,12]]\nputs(MinimumNumberOfArrowsToBurstBalloons(points1) == 2)",
        "points2 = [[1,2],[3,4],[5,6],[7,8]]\nputs(MinimumNumberOfArrowsToBurstBalloons(points2) == 4)"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "points": "[[10,16],[2,8],[1,6],[7,12]]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "points": "[[1,2],[3,4],[5,6],[7,8]]"
        },
        "expected": "4"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "points": "[[1,2],[2,3],[3,4],[4,5]]"
        },
        "expected": "2"
      }
    ]
  },
  "minimum-path-sum": {
    "title": "Minimum Path Sum",
    "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumPathSum(grid) { return 0; }",
      "testCalls": [
        "if (MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumPathSum([[1,2,3],[4,5,6]]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumPathSum(grid: number[][]): number { return 0; }",
      "testCalls": [
        "if (MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumPathSum([[1,2,3],[4,5,6]]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MinPathSum(vector<vector<int>>& grid) { return 0; }",
      "testCalls": [
        "int main() { assert(MinPathSum({{1,3,1},{1,5,1},{4,2,1}}) == 7); return 0; }",
        "int main() { assert(MinPathSum({{1,2,3},{4,5,6}}) == 12); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumPathSum(grid: List[List[int]]) -> int:",
      "testCalls": [
        "assert MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7",
        "assert MinimumPathSum([[1,2,3],[4,5,6]]) == 12"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minPathSum(int[][] grid) { return 0; }",
      "testCalls": [
        "if (m.minPathSum(new int[][]{{1,3,1},{1,5,1},{4,2,1}}) != 7) throw new AssertionError();",
        "if (m.minPathSum(new int[][]{{1,2,3},{4,5,6}}) != 12) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinPathSum(int** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "int main() { assert(MinPathSum((int*[]){(int[]){1,3,1}, (int[]){1,5,1}, (int[]){4,2,1}}, 3, (int[]){3, 3}) == 7); return 0; }",
        "int main() { assert(MinPathSum((int*[]){(int[]){1,2,3}, (int[]){4,5,6}}, 2, (int[]){3, 3}) == 12); return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinPathSum(grid [][]int) int {}",
      "testCalls": [
        "func TestMinPathSum1(t *testing.T) { if MinPathSum([][]int{{1,3,1},{1,5,1},{4,2,1}}) != 7 { t.Error(\"Test case 1 failed\") } }",
        "func TestMinPathSum2(t *testing.T) { if MinPathSum([][]int{{1,2,3},{4,5,6}}) != 12 { t.Error(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumPathSum(grid: Vec<Vec<i32>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MinimumPathSum(vec![vec![1,3,1], vec![1,5,1], vec![4,2,1]]), 7);",
        "assert_eq!(MinimumPathSum(vec![vec![1,2,3], vec![4,5,6]]), 12);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumPathSum(grid)\nend",
      "testCalls": [
        "test1 = MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]])\nraise 'Test Case 1 Failed' unless test1 == 7",
        "test2 = MinimumPathSum([[1,2,3],[4,5,6]])\nraise 'Test Case 2 Failed' unless test2 == 12"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "grid": "[[1,3,1],[1,5,1],[4,2,1]]"
        },
        "expected": "7"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "grid": "[[1,2,3],[4,5,6]]"
        },
        "expected": "12"
      }
    ]
  },
  "minimum-size-subarray-sum": {
    "title": "Minimum Size Subarray Sum",
    "content": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Sliding Window",
      "Prefix Sum"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumSizeSubarraySum(target, nums) { return 0; }",
      "testCalls": [
        "if(MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(MinimumSizeSubarraySum(4, [1,4,4]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinSizeSubarraySum(target: number, nums: number[]): number { return 0; }",
      "testCalls": [
        "if (MinSizeSubarraySum(7, [2,3,1,2,4,3]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (MinSizeSubarraySum(4, [1,4,4]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if (MinSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int MinSizeSubarraySum(int target, vector<int>& nums);",
      "testCalls": [
        "int main() { assert(MinSizeSubarraySum(7, vector<int>{2,3,1,2,4,3}) == 2); return 0; }",
        "int main() { assert(MinSizeSubarraySum(4, vector<int>{1,4,4}) == 1); return 0; }",
        "int main() { assert(MinSizeSubarraySum(11, vector<int>{1,1,1,1,1,1,1,1}) == 0); return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MinimumSizeSubarraySum(target: int, nums: List[int]) -> int:",
      "testCalls": [
        "assert MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) == 2",
        "assert MinimumSizeSubarraySum(4, [1,4,4]) == 1",
        "assert MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minSubArrayLen(int target, int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.minSubArrayLen(7, new int[]{2,3,1,2,4,3}) != 2) { throw new AssertionError(); } }",
        "public static void main(String[] args) { Main m = new Main(); if (m.minSubArrayLen(4, new int[]{1,4,4}) != 1) { throw new AssertionError(); } }",
        "public static void main(String[] args) { Main m = new Main(); if (m.minSubArrayLen(11, new int[]{1,1,1,1,1,1,1,1}) != 0) { throw new AssertionError(); } }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinSubarraySum(int target, int* nums, int numsSize)",
      "testCalls": [
        "int main() { if(MinSubarraySum(7, (int[]){2,3,1,2,4,3}, 6) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(MinSubarraySum(4, (int[]){1,4,4}, 3) != 1) { printf(\"Test Case 2 Failed\"); }",
        "if(MinSubarraySum(11, (int[]){1,1,1,1,1,1,1,1}, 8) != 0) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinSubArrayLen(target int, nums []int) int {}",
      "testCalls": [
        "func TestMinSubArrayLen(t *testing.T) { if got := MinSubArrayLen(7, []int{2,3,1,2,4,3}); got != 2 { t.Errorf(\"Expected: %v, Got: %v\", 2, got) } }",
        "func TestMinSubArrayLen(t *testing.T) { if got := MinSubArrayLen(4, []int{1,4,4}); got != 1 { t.Errorf(\"Expected: %v, Got: %v\", 1, got) } }",
        "func TestMinSubArrayLen(t *testing.T) { if got := MinSubArrayLen(11, []int{1,1,1,1,1,1,1,1}); got != 0 { t.Errorf(\"Expected: %v, Got: %v\", 0, got) } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumSizeSubarraySum(target: i32, nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumSizeSubarraySum(7, vec![2,3,1,2,4,3]), 2);",
        "assert_eq!(MinimumSizeSubarraySum(4, vec![1,4,4]), 1);",
        "assert_eq!(MinimumSizeSubarraySum(11, vec![1,1,1,1,1,1,1,1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumSizeSubarraySum(target, nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) == 2",
        "raise 'Test Case 2 Failed' unless MinimumSizeSubarraySum(4, [1,4,4]) == 1",
        "raise 'Test Case 3 Failed' unless MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) == 0"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "target": "7",
          "nums": "[2,3,1,2,4,3]"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "target": "4",
          "nums": "[1,4,4]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "target": "11",
          "nums": "[1,1,1,1,1,1,1,1]"
        },
        "expected": "0"
      }
    ]
  },
  "minimum-window-substring": {
    "title": "Minimum Window Substring",
    "content": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &quot;&quot;.\nThe testcases will be generated such that the answer is unique.",
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to create a window of letters in s, which would have all the characters from t.",
      "Expand the right pointer until all the characters of t are covered.",
      "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
      "Continue expanding the right and left pointers until you reach the end of s."
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumWindowSubstring(s, t) { return ''; }",
      "testCalls": [
        "if (MinimumWindowSubstring('ADOBECODEBANC', 'ABC') !== 'BANC') { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumWindowSubstring('a', 'a') !== 'a') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumWindowSubstring(s: string, t: string): string { return ''; }",
      "testCalls": [
        "if (MinimumWindowSubstring('ADOBECODEBANC', 'ABC') !== 'BANC') { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumWindowSubstring('a', 'a') !== 'a') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string MinimumWindowSubstring(string s, string t) { return \"\"; }",
      "testCalls": [
        "int main() { assert(MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"); return 0; }",
        "int main() { assert(MinimumWindowSubstring(\"a\", \"a\") == \"a\"); assert(MinimumWindowSubstring(\"a\", \"aa\") == \"\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumWindowSubstring(s: str, t: str) -> str:",
      "testCalls": [
        "assert MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"",
        "assert MinimumWindowSubstring(\"a\", \"a\") == \"a\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String MinimumWindowSubstring(String s, String t) { return \"\"; }",
      "testCalls": [
        "assert m.MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\").equals(\"BANC\");",
        "assert m.MinimumWindowSubstring(\"a\", \"a\").equals(\"a\");"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* MinimumWindowSubstring(char* s, char* t)",
      "testCalls": [
        "printf(\"%s\\n\", MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\"));",
        "printf(\"%s\\n\", MinimumWindowSubstring(\"a\", \"a\"));",
        "printf(\"%s\\n\", MinimumWindowSubstring(\"a\", \"aa\"));"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumWindowSubstring(s string, t string) string {}",
      "testCalls": [
        "func main() {",
        "    if MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") != \"BANC\" { panic(\"Test case 1 failed\") }",
        "    if MinimumWindowSubstring(\"a\", \"a\") != \"a\" { panic(\"Test case 2 failed\") }",
        "}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumWindowSubstring(s: String, t: String) -> String {}",
      "testCalls": [
        "assert_eq!(MinimumWindowSubstring(String::from(\"ADOBECODEBANC\"), String::from(\"ABC\")), String::from(\"BANC\"));",
        "assert_eq!(MinimumWindowSubstring(String::from(\"a\"), String::from(\"a\")), String::from(\"a\")); assert_eq!(MinimumWindowSubstring(String::from(\"a\"), String::from(\"aa\")), String::from(\"\"));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumWindowSubstring(s, t)\nend",
      "testCalls": [
        "assert_equal(\"BANC\", MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\"))",
        "assert_equal(\"a\", MinimumWindowSubstring(\"a\", \"a\"))",
        "assert_equal(\"\", MinimumWindowSubstring(\"a\", \"aa\"))"
      ],
      "compareHelper": "def assert_equal(expected, result)\n  raise 'Test Case Failed' unless expected == result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;ADOBECODEBANC&quot;",
          "t": "&quot;ABC&quot;"
        },
        "expected": "&quot;BANC&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;a&quot;",
          "t": "&quot;a&quot;"
        },
        "expected": "&quot;a&quot;"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;a&quot;",
          "t": "&quot;aa&quot;"
        },
        "expected": "&quot;&quot;"
      }
    ]
  },
  "n-queens-ii": {
    "title": "N-Queens II",
    "content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to then-queens puzzle.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NQueensII(n) { return 0; }",
      "testCalls": [
        "if(NQueensII(4) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(NQueensII(1) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function TotalNQueens(n: number): number { return 0; }",
      "testCalls": [
        "if (TotalNQueens(4) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (TotalNQueens(1) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int TotalNQueens(int n);",
      "testCalls": [
        "int main() { if(TotalNQueens(4) != 2) throw std::runtime_error(\"Test 1 failed!\"); return 0; }",
        "int main() { if(TotalNQueens(1) != 1) throw std::runtime_error(\"Test 2 failed!\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NQueensII(n: int) -> int:",
      "testCalls": [
        "assert NQueensII(4) == 2",
        "assert NQueensII(1) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int TotalNQueens(int n) { return 0; }",
      "testCalls": [
        "if(m.TotalNQueens(4) != 2) throw new AssertionError();",
        "if(m.TotalNQueens(1) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int TotalNQueens(int n) { return 0; }",
      "testCalls": [
        "int main() { if (TotalNQueens(4) != 2) { printf(\"Test case 1 failed\"); } if (TotalNQueens(1) != 1) { printf(\"Test case 2 failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func TotalNQueens(n int) int {}",
      "testCalls": [
        "func TestTotalNQueens(t *testing.T) { if TotalNQueens(4) != 2 { t.Error(\"Test case 1 failed\") } }",
        "func TestTotalNQueens(t *testing.T) { if TotalNQueens(1) != 1 { t.Error(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NQueensII(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(NQueensII(4), 2);",
        "assert_eq!(NQueensII(1), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NQueensII(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless NQueensII(4) == 2",
        "raise 'Test Case 2 Failed' unless NQueensII(1) == 1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "4"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "1"
        },
        "expected": "1"
      }
    ]
  },
  "number-of-1-bits": {
    "title": "Number of 1 Bits",
    "content": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NumberOf1Bits(n) { return 0; }",
      "testCalls": [
        "if(NumberOf1Bits(11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(NumberOf1Bits(128) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(NumberOf1Bits(2147483645) !== 30) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function NumberOf1Bits(n: number): number { return 0; }",
      "testCalls": [
        "if(NumberOf1Bits(11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(NumberOf1Bits(128) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(NumberOf1Bits(2147483645) !== 30) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int NumberOf1Bits(int n);",
      "testCalls": [
        "int main() { if (NumberOf1Bits(11) != 3) { throw std::runtime_error(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (NumberOf1Bits(128) != 1) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if (NumberOf1Bits(2147483645) != 30) { throw std::runtime_error(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NumberOf1Bits(n: int) -> int:",
      "testCalls": [
        "assert NumberOf1Bits(11) == 3",
        "assert NumberOf1Bits(128) == 1",
        "assert NumberOf1Bits(2147483645) == 30"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int NumberOf1Bits(int n) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if(m.NumberOf1Bits(11) != 3) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.NumberOf1Bits(128) != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if(m.NumberOf1Bits(2147483645) != 30) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int NumberOf1Bits(int n) { return 0; }",
      "testCalls": [
        "int main() { if (NumberOf1Bits(11) != 3) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (NumberOf1Bits(128) != 1) { printf(\"Test Case 2 Failed\"); } return 0; }",
        "int main() { if (NumberOf1Bits(2147483645) != 30) { printf(\"Test Case 3 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func NumberOf1Bits(n uint32) int { return 0 }",
      "testCalls": [
        "func testNumberOf1Bits() { if NumberOf1Bits(11) != 3 { fmt.Println(\"Test case 1 failed\") } }",
        "func testNumberOf1Bits() { if NumberOf1Bits(128) != 1 { fmt.Println(\"Test case 2 failed\") } }",
        "func testNumberOf1Bits() { if NumberOf1Bits(2147483645) != 30 { fmt.Println(\"Test case 3 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NumberOf1Bits(n: u32) -> i32 {}",
      "testCalls": [
        "assert_eq!(NumberOf1Bits(11), 3);",
        "assert_eq!(NumberOf1Bits(128), 1);",
        "assert_eq!(NumberOf1Bits(2147483645), 30);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NumberOf1Bits(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless NumberOf1Bits(11) == 3",
        "raise 'Test Case 2 Failed' unless NumberOf1Bits(128) == 1",
        "raise 'Test Case 3 Failed' unless NumberOf1Bits(2147483645) == 30"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "11"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "128"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "n": "2147483645"
        },
        "expected": "30"
      }
    ]
  },
  "number-of-islands": {
    "title": "Number of Islands",
    "content": "Given an m x n 2D binary grid grid which represents a map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NumberOfIslands(grid) { return 0; }",
      "testCalls": [
        "const test1 = NumberOfIslands([['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]); if(test1 !== 1) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = NumberOfIslands([['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]); if(test2 !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function NumberOfIslands(grid: string[][]): number { return 0; }",
      "testCalls": [
        "if(NumberOfIslands([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]) !== 1) throw new Error('Test Case 1 Failed');",
        "if(NumberOfIslands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]) !== 3) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int NumIslands(vector<vector<char>>& grid) { return 0; }",
      "testCalls": [
        "assert(NumIslands(vector<vector<char>>{{'1','1','1','1','0'},{'1','1','0','1','0'},{'1','1','0','0','0'},{'0','0','0','0','0'}}) == 1);",
        "assert(NumIslands(vector<vector<char>>{{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}}) == 3);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NumberOfIslands(grid: List[List[str]]) -> int:",
      "testCalls": [
        "assert NumberOfIslands([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]) == 1",
        "assert NumberOfIslands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int NumberOfIslands(char[][] grid) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { int result1 = new Main().NumberOfIslands(new char[][]{{'1','1','1','1','0'},{'1','1','0','1','0'},{'1','1','0','0','0'},{'0','0','0','0','0'}}); if(result1 != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { int result2 = new Main().NumberOfIslands(new char[][]{{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}}); if(result2 != 3) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int NumberOfIslands(char** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "char* grid1[] = {\"1100\", \"1100\", \"0010\", \"0001\"}; int gridColSize1[] = {4, 4, 4, 4}; int result1 = NumberOfIslands(grid1, 4, gridColSize1); if(result1 != 1) { printf(\"Test Case 1 Failed\"); }",
        "char* grid2[] = {\"1110\", \"1100\", \"0001\", \"0111\"}; int gridColSize2[] = {4, 4, 4, 4}; int result2 = NumberOfIslands(grid2, 4, gridColSize2); if(result2 != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func NumIslands(grid [][]string) int {}",
      "testCalls": [
        "func TestNumIslands(t *testing.T) { if NumIslands([][]string{{\"1\",\"1\",\"1\",\"1\",\"0\"},{\"1\",\"1\",\"0\",\"1\",\"0\"},{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"0\",\"0\",\"0\",\"0\",\"0\"}}) != 1 { t.Error(\"Test case 1 failed\") } }",
        "func TestNumIslands(t *testing.T) { if NumIslands([][]string{{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"0\",\"0\",\"1\",\"0\",\"0\"},{\"0\",\"0\",\"0\",\"1\",\"1\"}}) != 3 { t.Error(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NumberOfIslands(grid: Vec<Vec<char>>) -> i32 { }",
      "testCalls": [
        "let result1 = NumberOfIslands(vec![vec!['1', '1', '1', '1', '0'], vec!['1', '1', '0', '1', '0'], vec!['1', '1', '0', '0', '0'], vec!['0', '0', '0', '0', '0']]);\nassert_eq!(result1, 1);",
        "let result2 = NumberOfIslands(vec![vec!['1', '1', '0', '0', '0'], vec!['1', '1', '0', '0', '0'], vec!['0', '0', '1', '0', '0'], vec!['0', '0', '0', '1', '1']]);\nassert_eq!(result2, 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NumberOfIslands(grid)\nend",
      "testCalls": [
        "grid1 = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]\nputs NumberOfIslands(grid1) == 1 || raise('Test Case 1 Failed')",
        "grid2 = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]\nputs NumberOfIslands(grid2) == 3 || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "grid": "[[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]"
        },
        "expected": "1"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "grid": "[[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]"
        },
        "expected": "3"
      }
    ]
  },
  "palindrome-number": {
    "title": "Palindrome Number",
    "content": "Given an integer x, return true if x is a palindrome, and false otherwise.",
    "difficulty": "Easy",
    "hints": [
      "Beware of overflow when you reverse the integer."
    ],
    "topicTags": [
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PalindromeNumber(x) { return null; }",
      "testCalls": [
        "if (PalindromeNumber(121) !== null) { throw new Error('Test Case 1 Failed'); }",
        "if (PalindromeNumber(-121) !== null) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IsPalindrome(x: number): boolean { return x.toString() === x.toString().split('').reverse().join(''); }",
      "testCalls": [
        "if (IsPalindrome(121) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (IsPalindrome(-121) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool PalindromeNumber(int x);",
      "testCalls": [
        "int main() { if (PalindromeNumber(121) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (PalindromeNumber(-121) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def PalindromeNumber(x: int) -> bool:\n    return False",
      "testCalls": [
        "assert PalindromeNumber(121) == True, 'Test Case 1 Failed'",
        "assert PalindromeNumber(-121) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean PalindromeNumber(int x) { return false; }",
      "testCalls": [
        "if (!m.PalindromeNumber(121)) throw new AssertionError();",
        "if (m.PalindromeNumber(-121)) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool IsPalindrome(int x)",
      "testCalls": [
        "int main() { if(IsPalindrome(121) != true) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(IsPalindrome(-121) != false) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsPalindrome(x int) bool {}",
      "testCalls": [
        "func TestIsPalindrome(t *testing.T) { if IsPalindrome(121) != true { t.Error(\"Test case 1 failed\") } }",
        "func TestIsPalindrome(t *testing.T) { if IsPalindrome(-121) != false { t.Error(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn PalindromeNumber(x: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(PalindromeNumber(121), true);",
        "assert_eq!(PalindromeNumber(-121), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def PalindromeNumber(x)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless PalindromeNumber(121) == true",
        "raise 'Test Case 2 Failed' unless PalindromeNumber(-121) == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "x": "121"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "x": "-121"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "x": "10"
        },
        "expected": "false"
      }
    ]
  },
  "partition-list": {
    "title": "Partition List",
    "content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PartitionList(head, x) { return null; }",
      "testCalls": [
        "const test1 = PartitionList(buildLinkedList([1,4,3,2,5,2]), 3); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,2,2,4,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = PartitionList(buildLinkedList([2,1]), 2); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([1,2])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function PartitionList(head: ListNode | null, x: number): ListNode | null {}",
      "testCalls": [
        "if(JSON.stringify(PartitionList(arrayToLinkedList([1,4,3,2,5,2]), 3)) !== JSON.stringify(arrayToLinkedList([1,2,2,4,3,5]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(PartitionList(arrayToLinkedList([2,1]), 2)) !== JSON.stringify(arrayToLinkedList([1,2]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToLinkedList(arr: number[]): ListNode | null { if(arr.length === 0) return null; const head = new ListNode(arr[0]); let current = head; for(let i = 1; i < arr.length; i++) { current.next = new ListNode(arr[i]); current = current.next; } return head; }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function arrayToLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "void PartitionList(ListNode* head, int x);",
      "testCalls": [
        "int main() { PartitionList(createLinkedList({1,4,3,2,5,2}), 3); // Expected: [1,2,2,4,3,5] return 0; }",
        "int main() { PartitionList(createLinkedList({2,1}), 2); // Expected: [1,2] return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : values) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }"
    },
    "python": {
      "functionDeclaration": "def PartitionList(head, x):",
      "testCalls": [
        "head = buildLinkedList([1,4,3,2,5,2])\nassert linkedListToArray(PartitionList(head, 3)) == [1,2,2,4,3,5], 'Test Case 1 Failed'",
        "head = buildLinkedList([2,1])\nassert linkedListToArray(PartitionList(head, 2)) == [1,2], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode partition(ListNode head, int x) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode head1 = createLinkedList(new int[]{1,4,3,2,5,2}); ListNode expected1 = createLinkedList(new int[]{1,2,2,4,3,5}); partition(head1, 3); compareLinkedLists(head1, expected1); }",
        "public static void main(String[] args) { ListNode head2 = createLinkedList(new int[]{2,1}); ListNode expected2 = createLinkedList(new int[]{1,2}); partition(head2, 2); compareLinkedLists(head2, expected2); }"
      ],
      "compareHelper": "public void compareLinkedLists(ListNode l1, ListNode l2) { while (l1 != null && l2 != null) { if (l1.val != l2.val) throw new AssertionError(); l1 = l1.next; l2 = l2.next; } if (l1 != null || l2 != null) throw new AssertionError(); }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode createLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "void PartitionList(struct ListNode* head, int x) { return; }",
      "testCalls": [
        "void test0() { PartitionList(createLinkedList((int[]){1,4,3,2,5,2}, 6), 3); } // Expected: [1,2,2,4,3,5]",
        "void test1() { PartitionList(createLinkedList((int[]){2,1}, 2), 2); } // Expected: [1,2]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* createLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* linkedListToArray(struct ListNode* head) { int size = 0; struct ListNode* curr = head; while (curr) { size++; curr = curr->next; } int* arr = (int*)malloc(size * sizeof(int)); curr = head; int i = 0; while (curr) { arr[i++] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func PartitionList(head *ListNode, x int) *ListNode {}",
      "testCalls": [
        "func test1() { if result := PartitionList(buildLinkedList([]int{1,4,3,2,5,2}), 3); !compareLinkedLists(result, buildLinkedList([]int{1,2,2,4,3,5})) { fmt.Println(\"Test case 1 failed\") } }",
        "func test2() { if result := PartitionList(buildLinkedList([]int{2,1}), 2); !compareLinkedLists(result, buildLinkedList([]int{1,2})) { fmt.Println(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "func compareLinkedLists(l1 *ListNode, l2 *ListNode) bool { return false }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { return nil }\nfunc linkedListToArray(head *ListNode) []int { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn PartitionList(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = build_linked_list(vec![1, 4, 3, 2, 5, 2]);\nassert_eq!(linked_list_to_vec(PartitionList(head1, 3)), vec![1, 2, 2, 4, 3, 5]);",
        "let head2 = build_linked_list(vec![2, 1]);\nassert_eq!(linked_list_to_vec(PartitionList(head2, 2)), vec![1, 2]);"
      ],
      "compareHelper": "fn compare_linked_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) { }",
      "helpers": "use std::collections::LinkedList;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}",
      "builders": "impl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linked_list_to_vec(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut result = Vec::new();\n    let mut current = head;\n    while let Some(node) = current {\n        result.push(node.val);\n        current = node.next;\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def PartitionList(head, x)\nend",
      "testCalls": [
        "head = buildLinkedList([1,4,3,2,5,2])\nresult1 = PartitionList(head, 3)\nraise 'Test Case 1 Failed' unless linkedListToArray(result1) == [1,2,2,4,3,5]",
        "head = buildLinkedList([2,1])\nresult2 = PartitionList(head, 2)\nraise 'Test Case 2 Failed' unless linkedListToArray(result2) == [1,2]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,4,3,2,5,2]",
          "x": "3"
        },
        "expected": "[1,2,2,4,3,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[2,1]",
          "x": "2"
        },
        "expected": "[1,2]"
      }
    ]
  },
  "path-sum": {
    "title": "Path Sum",
    "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PathSum(root, targetSum) { return null; }",
      "testCalls": [
        "if (PathSum(buildTree([5,4,8,11,null,13,4,7,2,null,null,null,1]), 22) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PathSum(buildTree([1,2,3]), 5) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function PathSum(root: TreeNode | null, targetSum: number): boolean {}",
      "testCalls": [
        "if (PathSum(buildTree([5,4,8,11,null,13,4,7,2,null,null,null,1]), 22) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PathSum(buildTree([1,2,3]), 5) !== false) { throw new Error('Test Case 2 Failed'); }",
        "if (PathSum(null, 0) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "bool HasPathSum(TreeNode* root, int targetSum);",
      "testCalls": [
        "int main() { if (HasPathSum(createTree({5,4,8,11,-1,13,4,7,2,-1,-1,-1,1}), 22) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (HasPathSum(createTree({1,2,3}), 5) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} };",
      "builders": "TreeNode* createTree(std::vector<int> values) { if (values.empty()) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (i < values.size() && !q.empty()) { TreeNode* node = q.front(); q.pop(); if (values[i] != -1) { node->left = new TreeNode(values[i]); q.push(node->left); } ++i; if (i < values.size() && values[i] != -1) { node->right = new TreeNode(values[i]); q.push(node->right); } ++i; } return root; } std::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(-1); } } while (!result.empty() && result.back() == -1) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def PathSum(root, targetSum):",
      "testCalls": [
        "root = buildTree([5,4,8,11,None,13,4,7,2,None,None,None,1])\nassert PathSum(root, 22) == True",
        "root = buildTree([1,2,3])\nassert PathSum(root, 5) == False",
        "root = buildTree([])\nassert PathSum(root, 0) == False"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None): ...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "public boolean PathSum(TreeNode root, int targetSum) { return false; }",
      "testCalls": [
        "if (new Solution().PathSum(new Solution().buildTree(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1}), 22) != true) throw new AssertionError();",
        "if (new Solution().PathSum(new Solution().buildTree(new Integer[]{1,2,3}), 5) != false) throw new AssertionError();",
        "if (new Solution().PathSum(null, 0) != false) throw new AssertionError();"
      ],
      "compareHelper": "private static boolean compareArrays(int[] arr1, int[] arr2) {\n        return Arrays.equals(arr1, arr2);\n    }",
      "typeDefs": "public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; TreeNode root = new TreeNode(arr[0]); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.add(node.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.add(node.left); queue.add(node.right); } else { list.add(null); } } while (list.get(list.size()-1) == null) list.remove(list.size()-1); return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "bool HasPathSum(struct TreeNode* root, int targetSum)",
      "testCalls": [
        "assert(HasPathSum(createTreeFromArray((int[]) {5,4,8,11,NULL,13,4,7,2,NULL,NULL,NULL,1}, 13), 22) == true);",
        "assert(HasPathSum(createTreeFromArray((int[]) {1,2,3}, 3), 5) == false);",
        "assert(HasPathSum(NULL, 0) == false);"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* createTreeFromArray(int* arr, int size) { if (size == 0) return NULL; struct TreeNode** nodes = (struct TreeNode**)malloc(size * sizeof(struct TreeNode*)); for (int i = 0; i < size; i++) { if (arr[i] == NULL) nodes[i] = NULL; else { nodes[i] = (struct TreeNode*)malloc(sizeof(struct TreeNode)); nodes[i]->val = arr[i]; nodes[i]->left = NULL; nodes[i]->right = NULL; } } struct TreeNode* root = nodes[0]; int pos = 1; for (int i = 0; i < size && pos < size; i++) { if (nodes[i]) { nodes[i]->left = nodes[pos++]; if (pos < size) nodes[i]->right = nodes[pos++]; } } free(nodes); return root; } \nint* treeToArray(struct TreeNode* root) { int* arr = (int*)malloc(1000 * sizeof(int)); int size = 0; struct TreeNode** queue = (struct TreeNode**)malloc(1000 * sizeof(struct TreeNode*)); int front = 0, rear = 0; queue[rear++] = root; while (front < rear) { struct TreeNode* node = queue[front++]; if (node) { arr[size++] = node->val; queue[rear++] = node->left; queue[rear++] = node->right; } else { arr[size++] = NULL; } } while (size > 0 && arr[size-1] == NULL) size--; int* result = (int*)malloc(size * sizeof(int)); for (int i = 0; i < size; i++) result[i] = arr[i]; free(arr); free(queue); return result; }"
    },
    "go": {
      "functionDeclaration": "func PathSum(root *TreeNode, targetSum int) bool {}",
      "testCalls": [
        "if PathSum(buildTree([]int{5,4,8,11,-1,13,4,7,2,-1,-1,-1,-1,1}, 0), 22) != true { t.Error(\"Test Case 1 Failed\") }",
        "if PathSum(buildTree([]int{1,2,3}, 0), 5) != false { t.Error(\"Test Case 2 Failed\") }",
        "if PathSum(nil, 0) != false { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func buildTree(arr []int, idx int) *TreeNode {\n    if idx >= len(arr) || arr[idx] == -1 {\n        return nil\n    }\n    root := &TreeNode{Val: arr[idx]}\n    root.Left = buildTree(arr, 2*idx+1)\n    root.Right = buildTree(arr, 2*idx+2)\n    return root\n}",
      "typeDefs": "type TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }",
      "builders": "func buildTree(arr []int, idx int) *TreeNode { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn PathSum(root: Option<Box<TreeNode>>, target_sum: i32) -> bool {}",
      "testCalls": [
        "let root1 = build_tree(vec![Some(5), Some(4), Some(8), Some(11), None, Some(13), Some(4), Some(7), Some(2), None, None, None, Some(1)]);\nassert_eq!(PathSum(root1, 22), true);",
        "let root2 = build_tree(vec![Some(1), Some(2), Some(3)]);\nassert_eq!(PathSum(root2, 5), false);",
        "assert_eq!(PathSum(None, 0), false);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let mut nodes = arr.iter().map(|&val| val.map(TreeNode::new)).collect::<Vec<_>>();\n    let root = Some(Box::new(nodes[0].as_ref().unwrap().clone()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(val) = arr[i] {\n                node.borrow_mut().left = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().left.as_ref().unwrap().clone());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.borrow_mut().right = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().right.as_ref().unwrap().clone());\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_vec(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    while let Some(node) = queue.pop_front() {\n        result.push(Some(node.val));\n        if let Some(left) = &node.left {\n            queue.push_back(left.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n        if let Some(right) = &node.right {\n            queue.push_back(right.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(val) = result.last() {\n        if val.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}",
      "builders": "fn build_tree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n    let mut nodes = arr.iter().map(|&val| val.map(TreeNode::new)).collect::<Vec<_>>();\n    let root = Some(Box::new(nodes[0].as_ref().unwrap().clone()));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if let Some(val) = arr[i] {\n                node.borrow_mut().left = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().left.as_ref().unwrap().clone());\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                node.borrow_mut().right = Some(Box::new(nodes[i].as_ref().unwrap().clone()));\n                queue.push_back(node.borrow().right.as_ref().unwrap().clone());\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_vec(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_ref().unwrap().clone());\n    while let Some(node) = queue.pop_front() {\n        result.push(Some(node.val));\n        if let Some(left) = &node.left {\n            queue.push_back(left.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n        if let Some(right) = &node.right {\n            queue.push_back(right.as_ref().clone());\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(val) = result.last() {\n        if val.is_none() {\n            result.pop();\n        } else {\n            break;\n        }\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def PathSum(root, targetSum)\nend",
      "testCalls": [
        "root = buildTree([5,4,8,11,nil,13,4,7,2,nil,nil,nil,1])\nassert_equal(true, PathSum(root, 22))",
        "root = buildTree([1,2,3])\nassert_equal(false, PathSum(root, 5))",
        "root = buildTree([])\nassert_equal(false, PathSum(root, 0))"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test Case Failed' unless expected == actual\nend",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result << node.val\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result << nil\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[5,4,8,11,null,13,4,7,2,null,null,null,1]",
          "targetSum": "22"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[1,2,3]",
          "targetSum": "5"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "root": "[]",
          "targetSum": "0"
        },
        "expected": "false"
      }
    ]
  },
  "permutations": {
    "title": "Permutations",
    "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Permutations(nums) { return []; }",
      "testCalls": [
        "const test1 = Permutations([1,2,3]); if(JSON.stringify(test1) !== '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Permutations([0,1]); if(JSON.stringify(test2) !== '[[0,1],[1,0]]') throw new Error('Test Case 2 Failed');",
        "const test3 = Permutations([1]); if(JSON.stringify(test3) !== '[[1]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function Permutations(nums: number[]): number[][] { }",
      "testCalls": [
        "const test1 = Permutations([1,2,3]); if(JSON.stringify(test1) !== '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Permutations([0,1]); if(JSON.stringify(test2) !== '[[0,1],[1,0]]') throw new Error('Test Case 2 Failed');",
        "const test3 = Permutations([1]); if(JSON.stringify(test3) !== '[[1]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<vector<int>> Permutations(const vector<int>& nums);",
      "testCalls": [
        "vector<int> nums1 = {1,2,3}; auto result1 = Permutations(nums1); if (result1 != vector<vector<int>>{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}) throw std::runtime_error(\"Test Case 1 Failed\");",
        "vector<int> nums2 = {0,1}; auto result2 = Permutations(nums2); if (result2 != vector<vector<int>>{{0,1},{1,0}}) throw std::runtime_error(\"Test Case 2 Failed\");",
        "vector<int> nums3 = {1}; auto result3 = Permutations(nums3); if (result3 != vector<vector<int>>{{1}}) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def Permutations(nums: List[int]) -> List[List[int]]:",
      "testCalls": [
        "assert Permutations([1,2,3]) == [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "assert Permutations([0,1]) == [[0,1],[1,0]]",
        "assert Permutations([1]) == [[1]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> Permutations(int[] nums) { return new ArrayList<>(); }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result1 = m.Permutations(new int[]{1,2,3}); if (!m.compareArrays(result1, new int[][]{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}})) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result2 = m.Permutations(new int[]{0,1}); if (!m.compareArrays(result2, new int[][]{{0,1},{1,0}})) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); List<List<Integer>> result3 = m.Permutations(new int[]{1}); if (!m.compareArrays(result3, new int[][]{{1}})) throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, int[][] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n        List<Integer> list1 = arr1.get(i);\n        int[] list2 = arr2[i];\n        if (list1.size() != list2.length) return false;\n        for (int j = 0; j < list1.size(); j++) {\n            if (list1.get(j) != list2[j]) return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int** Permutations(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int main() { int* nums1 = (int[]){1, 2, 3}; int returnSize1; int* returnColumnSizes1; int** result1 = Permutations(nums1, 3, &returnSize1, &returnColumnSizes1); if (compareArrays(result1, returnSize1, returnColumnSizes1, 6, \"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\") == 0) { printf(\"Test case 1 failed\"); } return 0; }",
        "int main() { int* nums2 = (int[]){0, 1}; int returnSize2; int* returnColumnSizes2; int** result2 = Permutations(nums2, 2, &returnSize2, &returnColumnSizes2); if (compareArrays(result2, returnSize2, returnColumnSizes2, 2, \"[[0,1],[1,0]]\") == 0) { printf(\"Test case 2 failed\"); } return 0; }",
        "int main() { int* nums3 = (int[]){1}; int returnSize3; int* returnColumnSizes3; int** result3 = Permutations(nums3, 1, &returnSize3, &returnColumnSizes3); if (compareArrays(result3, returnSize3, returnColumnSizes3, 1, \"[[1]]\") == 0) { printf(\"Test case 3 failed\"); } return 0; }"
      ],
      "compareHelper": "int compareArrays(int** result, int returnSize, int* returnColumnSizes, int expectedSize, char* expected) { /* Compare logic here, return 0 if arrays are not equal */ }"
    },
    "go": {
      "functionDeclaration": "func Permutations(nums []int) [][]int { return [][]int{} }",
      "testCalls": [
        "func TestPermutations(t *testing.T) { if !compareArrays(Permutations([]int{1,2,3}), [][]int{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}) { t.Error(\"Test Case 1 Failed\") } }",
        "func TestPermutations(t *testing.T) { if !compareArrays(Permutations([]int{0,1}), [][]int{{0,1},{1,0}}) { t.Error(\"Test Case 2 Failed\") } }",
        "func TestPermutations(t *testing.T) { if !compareArrays(Permutations([]int{1}), [][]int{{1}}) { t.Error(\"Test Case 3 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn Permutations(nums: Vec<i32>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(Permutations(vec![1,2,3]), vec![vec![1,2,3],vec![1,3,2],vec![2,1,3],vec![2,3,1],vec![3,1,2],vec![3,2,1]]);",
        "assert_eq!(Permutations(vec![0,1]), vec![vec![0,1],vec![1,0]]); assert_eq!(Permutations(vec![1]), vec![vec![1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) { for (a, b) in arr1.iter().zip(arr2.iter()) { assert_eq!(a, b); }}"
    },
    "ruby": {
      "functionDeclaration": "def Permutations(nums)\nend",
      "testCalls": [
        "test_input = [1,2,3]\nexpected_output = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nresult = Permutations(test_input)\nraise 'Test Case 1 Failed' unless result == expected_output",
        "test_input = [0,1]\nexpected_output = [[0,1],[1,0]]\nresult = Permutations(test_input)\nraise 'Test Case 2 Failed' unless result == expected_output",
        "test_input = [1]\nexpected_output = [[1]]\nresult = Permutations(test_input)\nraise 'Test Case 3 Failed' unless result == expected_output"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3]"
        },
        "expected": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1]"
        },
        "expected": "[[0,1],[1,0]]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1]"
        },
        "expected": "[[1]]"
      }
    ]
  },
  "plus-one": {
    "title": "Plus One",
    "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0.\nIncrement the large integer by one and return the resulting array of digits.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PlusOne(digits) { return []; }",
      "testCalls": [
        "const test1 = PlusOne([1,2,3]); if(JSON.stringify(test1) !== JSON.stringify([1,2,4])) throw new Error('Test Case 1 Failed');",
        "const test2 = PlusOne([4,3,2,1]); if(JSON.stringify(test2) !== JSON.stringify([4,3,2,2])) throw new Error('Test Case 2 Failed');",
        "const test3 = PlusOne([9]); if(JSON.stringify(test3) !== JSON.stringify([1,0])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function PlusOne(digits: number[]): number[]",
      "testCalls": [
        "const test1 = PlusOne([1,2,3]); if (JSON.stringify(test1) !== JSON.stringify([1,2,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = PlusOne([4,3,2,1]); if (JSON.stringify(test2) !== JSON.stringify([4,3,2,2])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = PlusOne([9]); if (JSON.stringify(test3) !== JSON.stringify([1,0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<int> PlusOne(const vector<int>& digits);",
      "testCalls": [
        "vector<int> input1 = {1,2,3}; auto result1 = PlusOne(input1); if (result1 != vector<int>({1,2,4})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "vector<int> input2 = {4,3,2,1}; auto result2 = PlusOne(input2); if (result2 != vector<int>({4,3,2,2})) throw std::runtime_error(\"Test Case 2 Failed\");",
        "vector<int> input3 = {9}; auto result3 = PlusOne(input3); if (result3 != vector<int>({1,0})) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool compareArrays(const vector<int>& arr1, const vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def PlusOne(digits: List[int]) -> List[int]:",
      "testCalls": [
        "result1 = PlusOne([1,2,3]); assert result1 == [1,2,4], 'Test Case 1 Failed'",
        "result2 = PlusOne([4,3,2,1]); assert result2 == [4,3,2,2], 'Test Case 2 Failed'",
        "result3 = PlusOne([9]); assert result3 == [1,0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2) or any(arr1[i] != arr2[i] for i in range(len(arr1))):\n        return False\n    return True",
      "typeDefs": "from typing import List"
    },
    "java": {
      "functionDeclaration": "public int[] PlusOne(int[] digits) { return null; }",
      "testCalls": [
        "assert java.util.Arrays.equals(PlusOne(new int[]{1,2,3}), new int[]{1,2,4}) : \"Test Case 1 Failed\";",
        "assert java.util.Arrays.equals(PlusOne(new int[]{4,3,2,1}), new int[]{4,3,2,2}) : \"Test Case 2 Failed\";"
      ],
      "compareHelper": "Arrays.equals method for comparing arrays"
    },
    "c": {
      "functionDeclaration": "int* PlusOne(int* digits, int digitsSize)",
      "testCalls": [
        "int digits1[] = {1, 2, 3}; int* result1 = PlusOne(digits1, 3); int expected1[] = {1, 2, 4}; if (compareArrays(result1, expected1, 3) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int digits2[] = {4, 3, 2, 1}; int* result2 = PlusOne(digits2, 4); int expected2[] = {4, 3, 2, 2}; if (compareArrays(result2, expected2, 4) != 0) { printf(\"Test Case 2 Failed\"); }",
        "int digits3[] = {9}; int* result3 = PlusOne(digits3, 1); int expected3[] = {1, 0}; if (compareArrays(result3, expected3, 2) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return -1; } return 0; }"
    },
    "go": {
      "functionDeclaration": "func PlusOne(digits []int) []int { return nil }",
      "testCalls": [
        "if !compareArrays(PlusOne([]int{1,2,3}), []int{1,2,4}) { fmt.Println(\"Test Case 1 Failed\") }",
        "if !compareArrays(PlusOne([]int{4,3,2,1}), []int{4,3,2,2}) { fmt.Println(\"Test Case 2 Failed\") }",
        "if !compareArrays(PlusOne([]int{9}), []int{1,0}) { fmt.Println(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn PlusOne(digits: Vec<i32>) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(PlusOne(vec![1,2,3]), vec![1,2,4]);",
        "assert_eq!(PlusOne(vec![4,3,2,1]), vec![4,3,2,2]);",
        "assert_eq!(PlusOne(vec![9]), vec![1,0]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def PlusOne(digits)\n  \nend",
      "testCalls": [
        "result = PlusOne([1,2,3])\nraise 'Test Case 1 Failed' unless result == [1,2,4]",
        "result = PlusOne([4,3,2,1])\nraise 'Test Case 2 Failed' unless result == [4,3,2,2]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "digits": "[1,2,3]"
        },
        "expected": "[1,2,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "digits": "[4,3,2,1]"
        },
        "expected": "[4,3,2,2]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "digits": "[9]"
        },
        "expected": "[1,0]"
      }
    ]
  },
  "populating-next-right-pointers-in-each-node-ii": {
    "title": "Populating Next Right Pointers in Each Node II",
    "content": "Given a binary tree\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PopulatingNextRightPointersInEachNodeII(root) {}",
      "testCalls": [
        "let root = buildTree([1,2,3,4,5,null,7]); PopulatingNextRightPointersInEachNodeII(root);",
        "let emptyRoot = buildTree([]); PopulatingNextRightPointersInEachNodeII(emptyRoot);"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function Node(val, left, right, next) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; this.next = next === undefined ? null : next; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new Node(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new Node(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new Node(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function ConnectNextRight(root: Node | null): Node | null {}",
      "testCalls": [
        "if(JSON.stringify(ConnectNextRight(buildTree([1,2,3,4,5,null,7]))) !== JSON.stringify(buildTree([1,null,2,3,null,4,5,7,null]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(ConnectNextRight(buildTree([]))) !== JSON.stringify(buildTree([]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function parseTree(arr: (number | null)[]): Node | null { if(arr.length === 0) return null; const root = { val: arr[0], left: null, right: null, next: null }; const queue = [root]; let i = 1; while(i < arr.length) { const current = queue.shift(); if(arr[i] !== null) { current.left = { val: arr[i], left: null, right: null, next: null }; queue.push(current.left); } i++; if(i < arr.length && arr[i] !== null) { current.right = { val: arr[i], left: null, right: null, next: null }; queue.push(current.right); } i++; } return root; }",
      "typeDefs": "class Node { val: number; left: Node | null; right: Node | null; next: Node | null; constructor(val?: number, left?: Node | null, right?: Node | null, next?: Node | null) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; this.next = next === undefined ? null : next; } }",
      "builders": "function buildTree(arr: (number | null)[]): Node | null { if (!arr.length || arr[0] === null) return null; let root = new Node(arr[0] as number); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift() as Node; if (i < arr.length && arr[i] !== null) { node.left = new Node(arr[i] as number); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new Node(arr[i] as number); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root: Node | null): (number | null)[] { if (!root) return []; let result: (number | null)[] = []; let queue = [root]; while (queue.length) { let node = queue.shift() as Node; if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "void PopulatingNextRightPointersInEachNodeII(Node* root) {}",
      "testCalls": [
        "std::vector<int> input1 = {1,2,3,4,5,INT_MIN,7}; Node* root = buildTree(input1); PopulatingNextRightPointersInEachNodeII(root); // Test Case 1",
        "int main() { PopulatingNextRightPointersInEachNodeII(nullptr); return 0; } // Test Case 2"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "typeDefs": "struct Node { int val; Node* left; Node* right; Node* next; };",
      "builders": "Node* buildTree(std::vector<int>& arr) { if (arr.empty()) return nullptr; Node* root = new Node{arr[0]}; std::queue<Node*> q; q.push(root); int i = 1; while (!q.empty() && i < arr.size()) { Node* curr = q.front(); q.pop(); if (arr[i] != INT_MIN) { curr->left = new Node{arr[i]}; q.push(curr->left); } i++; if (i < arr.size() && arr[i] != INT_MIN) { curr->right = new Node{arr[i]}; q.push(curr->right); } i++; } return root; }\nstd::vector<int> treeToArray(Node* root) { std::vector<int> result; if (!root) return result; std::queue<Node*> q; q.push(root); while (!q.empty()) { Node* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def PopulatingNextRightPointersInEachNodeII(root: 'Node') -> 'Node':",
      "testCalls": [
        "root = buildTree([1,2,3,4,5,None,7]); assert treeToArray(PopulatingNextRightPointersInEachNodeII(root)) == [1,None,2,3,None,4,5,7,None], 'Test 1 Failed'",
        "emptyRoot = buildTree([]); assert treeToArray(PopulatingNextRightPointersInEachNodeII(emptyRoot)) == [], 'Test 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        raise AssertionError('Arrays have different lengths')\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            raise AssertionError(f'Arrays differ at index {i}')",
      "typeDefs": "class Node:\n    def __init__(self, val=0, left=None, right=None, next=None): ...",
      "builders": "def buildTree(arr): ...\ndef treeToArray(root): ..."
    },
    "java": {
      "functionDeclaration": "void connect(Node root) {}",
      "testCalls": [
        "Node root1 = buildTree(new Integer[]{1,2,3,4,5,null,7}); connect(root1); if (!compareTree(root1, new Integer[]{1,null,2,3,null,4,5,7,null})) throw new AssertionError();",
        "Node root2 = buildTree(new Integer[]{}); connect(root2); if (!compareTree(root2, new Integer[]{})) throw new AssertionError();"
      ],
      "compareHelper": "boolean compareTree(Node root, Integer[] expected) { List<Integer> actual = treeToArray(root); List<Integer> expList = Arrays.asList(expected); return actual.equals(expList); }",
      "typeDefs": "class Node { int val; Node left; Node right; Node next; Node() {} Node(int val) { this.val = val; } }",
      "builders": "Node buildTree(Integer[] arr) { if (arr.length == 0) return null; Node root = new Node(arr[0]); Queue<Node> queue = new LinkedList<>(); queue.add(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { Node node = queue.poll(); if (arr[i] != null) { node.left = new Node(arr[i]); queue.add(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new Node(arr[i]); queue.add(node.right); } i++; } return root; } List<Integer> treeToArray(Node root) { List<Integer> result = new ArrayList<>(); Queue<Node> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { Node node = queue.poll(); if (node != null) { result.add(node.val); queue.add(node.left); queue.add(node.right); } else { result.add(null); } } while (result.get(result.size()-1) == null) result.remove(result.size()-1); return result; }"
    },
    "c": {
      "functionDeclaration": "void PopulatingNextRightPointersInEachNodeII(struct Node* root)",
      "testCalls": [
        "int arr1[] = {1,2,3,4,5,0,7}; struct Node* root = buildTree(arr1, 7); PopulatingNextRightPointersInEachNodeII(root); // Expected: [1,#,2,3,#,4,5,7,#]",
        "int arr2[] = {}; struct Node* root = buildTree(arr2, 0); PopulatingNextRightPointersInEachNodeII(root); // Expected: []"
      ],
      "compareHelper": "",
      "typeDefs": "struct Node { int val; struct Node *left; struct Node *right; struct Node *next; };",
      "builders": "struct Node* buildTree(int* arr, int size) { return NULL; } \nint* treeToArray(struct Node* root, int* returnSize) { return NULL; }"
    },
    "go": {
      "functionDeclaration": "func Connect(root *Node) *Node { return nil }",
      "testCalls": [
        "root := buildTree([]); if !reflect.DeepEqual(treeToArray(Connect(root)), []int{}) { panic(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func (n *Node) String() string { if n == nil { return \"[]\" } return fmt.Sprintf(\"[%d,%s,%s]\", n.Val, n.Left.String(), n.Right.String()) }",
      "typeDefs": "type Node struct { Val int; Left *Node; Right *Node; Next *Node }",
      "builders": "type Node struct { Val int; Left *Node; Right *Node; Next *Node }\n\nfunc buildTree(arr []int) *Node {\n    if len(arr) == 0 {\n        return nil\n    }\n    root := &Node{Val: arr[0]}\n    queue := []*Node{root}\n    i := 1\n    for len(queue) > 0 && i < len(arr) {\n        current := queue[0]\n        queue = queue[1:]\n        if i < len(arr) && arr[i] != -1 {\n            current.Left = &Node{Val: arr[i]}\n            queue = append(queue, current.Left)\n        }\n        i++\n        if i < len(arr) && arr[i] != -1 {\n            current.Right = &Node{Val: arr[i]}\n            queue = append(queue, current.Right)\n        }\n        i++\n    }\n    return root\n}\n\nfunc treeToArray(root *Node) []int {\n    if root == nil {\n        return []int{}\n    }\n    result := []int{}\n    queue := []*Node{root}\n    for len(queue) > 0 {\n        current := queue[0]\n        queue = queue[1:]\n        if current != nil {\n            result = append(result, current.Val)\n            queue = append(queue, current.Left)\n            queue = append(queue, current.Right)\n        } else {\n            result = append(result, -1)\n        }\n    }\n    // Trim trailing -1s\n    for len(result) > 0 && result[len(result)-1] == -1 {\n        result = result[:len(result)-1]\n    }\n    return result\n}"
    },
    "rust": {
      "functionDeclaration": "fn PopulatingNextRightPointersInEachNodeII(root: Option<Box<Node>>) -> Option<Box<Node>> { }",
      "testCalls": [
        "let root = buildTree(vec![Some(1), Some(2), Some(3), Some(4), Some(5), None, Some(7)]); assert_eq!(treeToArray(PopulatingNextRightPointersInEachNodeII(root.clone())), vec![Some(1), None, Some(2), Some(3), None, Some(4), Some(5), Some(7), None]);",
        "assert_eq!(PopulatingNextRightPointersInEachNodeII(None), None)"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: i32,\n    pub left: Option<Box<Node>>, \n    pub right: Option<Box<Node>>, \n    pub next: Option<Box<Node>>,\n}\n\nimpl Node {\n    pub fn new(val: i32) -> Self {\n        Node {\n            val,\n            left: None,\n            right: None,\n            next: None,\n        }\n    }\n}\n\nfn buildTree(arr: Vec<Option<i32>>) -> Option<Box<Node>> {\n    if arr.is_empty() || arr[0].is_none() {\n        return None;\n    }\n\n    let mut root = Box::new(Node::new(arr[0].unwrap()));\n    let mut queue = VecDeque::new();\n    queue.push_back(&mut root);\n\n    let mut i = 1;\n    while i < arr.len() {\n        if let Some(node) = queue.pop_front() {\n            if i < arr.len() && arr[i].is_some() {\n                node.left = Some(Box::new(Node::new(arr[i].unwrap())));\n                queue.push_back(node.left.as_mut().unwrap());\n            }\n            i += 1;\n\n            if i < arr.len() && arr[i].is_some() {\n                node.right = Some(Box::new(Node::new(arr[i].unwrap())));\n                queue.push_back(node.right.as_mut().unwrap());\n            }\n            i += 1;\n        }\n    }\n\n    Some(root)\n}\n\nfn treeToArray(root: Option<Box<Node>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n\n    if let Some(node) = root {\n        queue.push_back(node);\n    }\n\n    while !queue.is_empty() {\n        if let Some(node) = queue.pop_front() {\n            result.push(Some(node.val));\n\n            if let Some(left) = node.left {\n                queue.push_back(left);\n            } else {\n                result.push(None);\n            }\n\n            if let Some(right) = node.right {\n                queue.push_back(right);\n            } else {\n                result.push(None);\n            }\n        }\n    }\n\n    // Remove trailing None values\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n\n    result\n}",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: i32,\n    pub left: Option<Box<Node>>, \n    pub right: Option<Box<Node>>, \n    pub next: Option<Box<Node>>,\n}",
      "builders": "#[derive(Debug)]\nstruct Node {\n    val: i32,\n    left: Option<Box<Node>>,\n    right: Option<Box<Node>>,\n    next: Option<*mut Node>,\n}\n\nfn build_tree(arr: Vec<Option<i32>>) -> Option<Box<Node>> {\n    if arr.is_empty() {\n        return None;\n    }\n    let root = Some(Box::new(Node { val: arr[0].unwrap(), left: None, right: None, next: None }));\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(root.as_ref().map(|node| node as *const _ as *mut _));\n    let mut i = 1;\n    while let Some(current) = queue.pop_front() {\n        unsafe {\n            if i < arr.len() && arr[i].is_some() {\n                let left_node = Box::new(Node { val: arr[i].unwrap(), left: None, right: None, next: None });\n                (*current).left = Some(left_node);\n                queue.push_back((*current).left.as_ref().map(|node| node as *const _ as *mut _));\n            }\n            i += 1;\n            if i < arr.len() && arr[i].is_some() {\n                let right_node = Box::new(Node { val: arr[i].unwrap(), left: None, right: None, next: None });\n                (*current).right = Some(right_node);\n                queue.push_back((*current).right.as_ref().map(|node| node as *const _ as *mut _));\n            }\n            i += 1;\n        }\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<Node>>) -> Vec<Option<i32>> {\n    let mut result = vec![];\n    let mut queue = std::collections::VecDeque::new();\n    if let Some(node) = root {\n        queue.push_back(Some(node));\n    }\n    while let Some(current) = queue.pop_front() {\n        if let Some(node) = current {\n            result.push(Some(node.val));\n            queue.push_back(node.left);\n            queue.push_back(node.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while result.last() == Some(&None) {\n        result.pop();\n    }\n    result\n}"
    },
    "ruby": {
      "functionDeclaration": "def PopulatingNextRightPointersInEachNodeII(root)\nend",
      "testCalls": [
        "root = buildTree([1,2,3,4,5,nil,7])\nPopulatingNextRightPointersInEachNodeII(root)",
        "root_empty = buildTree([])\nPopulatingNextRightPointersInEachNodeII(root_empty)"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class Node\n  attr_accessor :val, :left, :right, :next\n  def initialize(val = 0, left = nil, right = nil, next_node = nil)\n    @val = val\n    @left = left\n    @right = right\n    @next = next_node\n  end\nend",
      "builders": "def buildTree(arr)\n  # Implementation for building a binary tree from an array\nend\n\ndef treeToArray(root)\n  # Implementation for converting a binary tree to an array\nend\n\ndef buildLinkedList(arr)\n  # Implementation for building a linked list from an array\nend\n\ndef linkedListToArray(head)\n  # Implementation for converting a linked list to an array\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "root": "[1,2,3,4,5,null,7]"
        },
        "expected": "[1,#,2,3,#,4,5,7,#]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "root": "[]"
        },
        "expected": "[]"
      }
    ]
  },
  "product-of-array-except-self": {
    "title": "Product of Array Except Self",
    "content": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs inO(n)time and without using the division operation.",
    "difficulty": "Medium",
    "hints": [
      "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
      "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
    ],
    "topicTags": [
      "Array",
      "Prefix Sum"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ProductOfArrayExceptSelf(nums) { return null; }",
      "testCalls": [
        "const test1 = ProductOfArrayExceptSelf([1,2,3,4]); if(JSON.stringify(test1) !== JSON.stringify([24,12,8,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = ProductOfArrayExceptSelf([-1,1,0,-3,3]); if(JSON.stringify(test2) !== JSON.stringify([0,0,9,0,0])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function ProductOfArrayExceptSelf(nums: number[]): number[]",
      "testCalls": [
        "const test1 = ProductOfArrayExceptSelf([1,2,3,4]); if (JSON.stringify(test1) !== JSON.stringify([24,12,8,6])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ProductOfArrayExceptSelf([-1,1,0,-3,3]); if (JSON.stringify(test2) !== JSON.stringify([0,0,9,0,0])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "vector<int> ProductOfArrayExceptSelf(vector<int>& nums) { return {}; }",
      "testCalls": [
        "int main() { auto result1 = ProductOfArrayExceptSelf(vector<int>{1,2,3,4}); if(result1 != vector<int>({24,12,8,6})) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { auto result2 = ProductOfArrayExceptSelf(vector<int>{-1,1,0,-3,3}); if(result2 != vector<int>({0,0,9,0,0})) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def ProductOfArrayExceptSelf(nums: List[int]) -> List[int]:\n    return []",
      "testCalls": [
        "assert ProductOfArrayExceptSelf([1,2,3,4]) == [24,12,8,6]",
        "assert ProductOfArrayExceptSelf([-1,1,0,-3,3]) == [0,0,9,0,0]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int[] ProductOfArrayExceptSelf(int[] nums) { return null; }",
      "testCalls": [
        "if (!Arrays.equals(ProductOfArrayExceptSelf(new int[]{1,2,3,4}), new int[]{24,12,8,6})) throw new AssertionError();",
        "if (!Arrays.equals(ProductOfArrayExceptSelf(new int[]{-1,1,0,-3,3}), new int[]{0,0,9,0,0})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int* ProductOfArrayExceptSelf(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1,2,3,4}; int expected1[] = {24,12,8,6}; int* result1; int main() { result1 = ProductOfArrayExceptSelf(nums1, 4); if(memcmp(result1, expected1, 4*sizeof(int)) != 0) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int nums2[] = {-1,1,0,-3,3}; int expected2[] = {0,0,9,0,0}; int* result2; int main() { result2 = ProductOfArrayExceptSelf(nums2, 5); if(memcmp(result2, expected2, 5*sizeof(int)) != 0) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func ProductOfArrayExceptSelf(nums []int) []int {}",
      "testCalls": [
        "func TestProductOfArrayExceptSelf(t *testing.T) { if !compareArrays(ProductOfArrayExceptSelf([]int{1,2,3,4}), []int{24,12,8,6}) { t.Error(\"Test case 1 failed\") } }",
        "func TestProductOfArrayExceptSelf2(t *testing.T) { if !compareArrays(ProductOfArrayExceptSelf([]int{-1,1,0,-3,3}), []int{0,0,9,0,0}) { t.Error(\"Test case 2 failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn ProductOfArrayExceptSelf(nums: Vec<i32>) -> Vec<i32> {}",
      "testCalls": [
        "let result1 = ProductOfArrayExceptSelf(vec![1,2,3,4]); assert_eq!(result1, vec![24,12,8,6]);",
        "let result2 = ProductOfArrayExceptSelf(vec![-1,1,0,-3,3]); assert_eq!(result2, vec![0,0,9,0,0]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def ProductOfArrayExceptSelf(nums)\nend",
      "testCalls": [
        "nums = [1,2,3,4]\nexpected_result = [24,12,8,6]\nresult = ProductOfArrayExceptSelf(nums)\nraise 'Test Case 1 Failed' unless result == expected_result",
        "nums = [-1,1,0,-3,3]\nexpected_result = [0,0,9,0,0]\nresult = ProductOfArrayExceptSelf(nums)\nraise 'Test Case 2 Failed' unless result == expected_result"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,4]"
        },
        "expected": "[24,12,8,6]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[-1,1,0,-3,3]"
        },
        "expected": "[0,0,9,0,0]"
      }
    ]
  },
  "remove-duplicates-from-sorted-array-ii": {
    "title": "Remove Duplicates from Sorted Array II",
    "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of numsshould hold the final result. It does not matter what you leave beyond the firstkelements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArrayII(nums) {}",
      "testCalls": [
        "let nums1 = [1,1,1,2,2,3]; let expectedResult1 = [1,1,2,2,3]; let expectedLength1 = 5; let result1 = RemoveDuplicatesFromSortedArrayII(nums1); if (result1 !== expectedLength1 || !arraysEqual(nums1.slice(0, expectedLength1), expectedResult1)) { throw new Error('Test Case 1 Failed'); }",
        "let nums2 = [0,0,1,1,1,1,2,3,3]; let expectedResult2 = [0,0,1,1,2,3,3]; let expectedLength2 = 7; let result2 = RemoveDuplicatesFromSortedArrayII(nums2); if (result2 !== expectedLength2 || !arraysEqual(nums2.slice(0, expectedLength2), expectedResult2)) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0; i < arr1.length; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArrayII(nums: number[]): number { return 0; }",
      "testCalls": [
        "const test1Nums = [1,1,1,2,2,3];\nconst expectedNums1 = [1,1,2,2,3];\nconst k1 = RemoveDuplicatesFromSortedArrayII(test1Nums);\nif (k1 !== expectedNums1.length || !arraysEqual(test1Nums.slice(0, k1), expectedNums1)) {\n  throw new Error('Test Case 1 Failed');\n}",
        "const test2Nums = [0,0,1,1,1,1,2,3,3];\nconst expectedNums2 = [0,0,1,1,2,3,3];\nconst k2 = RemoveDuplicatesFromSortedArrayII(test2Nums);\nif (k2 !== expectedNums2.length || !arraysEqual(test2Nums.slice(0, k2), expectedNums2)) {\n  throw new Error('Test Case 2 Failed');\n}"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}"
    },
    "cpp": {
      "functionDeclaration": "int RemoveDuplicatesFromSortedArrayII(vector<int>& nums) { return 0; }",
      "testCalls": [
        "vector<int> nums1 = {1, 1, 1, 2, 2, 3}; int k1 = RemoveDuplicatesFromSortedArrayII(nums1); vector<int> expectedNums1 = {1, 1, 2, 2, 3}; assert(k1 == expectedNums1.size()); for(int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "vector<int> nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3}; int k2 = RemoveDuplicatesFromSortedArrayII(nums2); vector<int> expectedNums2 = {0, 0, 1, 1, 2, 3, 3}; assert(k2 == expectedNums2.size()); for(int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArrayII(nums: List[int]) -> int:",
      "testCalls": [
        "nums1 = [1,1,1,2,2,3]\nexpectedNums1 = [1,1,2,2,3]\nexpectedResult1 = 5\nk1 = RemoveDuplicatesFromSortedArrayII(nums1)\nassert k1 == expectedResult1\nassert nums1[:k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,1,2,3,3]\nexpectedNums2 = [0,0,1,1,2,3,3]\nexpectedResult2 = 7\nk2 = RemoveDuplicatesFromSortedArrayII(nums2)\nassert k2 == expectedResult2\nassert nums2[:k2] == expectedNums2"
      ],
      "compareHelper": "def assertArraysEqual(arr1, arr2):\n    assert len(arr1) == len(arr2)\n    for i in range(len(arr1)):\n        assert arr1[i] == arr2[i]"
    },
    "java": {
      "functionDeclaration": "public int RemoveDuplicatesFromSortedArrayII(int[] nums) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) {\n    int[] nums1 = {1, 1, 1, 2, 2, 3};\n    int expectedLength1 = 5;\n    int[] expectedNums1 = {1, 1, 2, 2, 3};\n    int k1 = new Main().RemoveDuplicatesFromSortedArrayII(nums1);\n    if (k1 != expectedLength1) throw new AssertionError();\n    for (int i = 0; i < k1; i++) {\n        if (nums1[i] != expectedNums1[i]) throw new AssertionError();\n    }\n}",
        "public static void main(String[] args) {\n    int[] nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3};\n    int expectedLength2 = 7;\n    int[] expectedNums2 = {0, 0, 1, 1, 2, 3, 3};\n    int k2 = new Main().RemoveDuplicatesFromSortedArrayII(nums2);\n    if (k2 != expectedLength2) throw new AssertionError();\n    for (int i = 0; i < k2; i++) {\n        if (nums2[i] != expectedNums2[i]) throw new AssertionError();\n    }\n}"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int RemoveDuplicatesFromSortedArrayII(int* nums, int numsSize)",
      "testCalls": [
        "int main() {\n    int nums1[] = {1, 1, 1, 2, 2, 3};\n    int expectedNums1[] = {1, 1, 2, 2, 3};\n    int k1 = RemoveDuplicatesFromSortedArrayII(nums1, 6);\n    if (k1 != 5) { printf(\"Test Case 1 Failed\\n\"); }\n    for (int i = 0; i < k1; i++) { if (nums1[i] != expectedNums1[i]) { printf(\"Test Case 1 Failed\\n\"); }}\n\n    int nums2[] = {0, 0, 1, 1, 1, 1, 2, 3, 3};\n    int expectedNums2[] = {0, 0, 1, 1, 2, 3, 3};\n    int k2 = RemoveDuplicatesFromSortedArrayII(nums2, 9);\n    if (k2 != 7) { printf(\"Test Case 2 Failed\\n\"); }\n    for (int i = 0; i < k2; i++) { if (nums2[i] != expectedNums2[i]) { printf(\"Test Case 2 Failed\\n\"); }}\n\n    return 0;\n}"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; }} return 1; }"
    },
    "go": {
      "functionDeclaration": "func RemoveDuplicatesFromSortedArrayII(nums []int) int {}",
      "testCalls": [
        "func main() { k1 := RemoveDuplicatesFromSortedArrayII([]int{1,1,1,2,2,3}); if k1 != 5 {panic(\"Test case 1 failed\")} }",
        "func main() { k2 := RemoveDuplicatesFromSortedArrayII([]int{0,0,1,1,1,1,2,3,3}); if k2 != 7 {panic(\"Test case 2 failed\")} }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicatesFromSortedArrayII(nums: &mut Vec<i32>) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![1, 1, 1, 2, 2, 3];\nlet expected_nums1 = vec![1, 1, 2, 2, 3];\nlet k1 = RemoveDuplicatesFromSortedArrayII(&mut nums1);\nassert_eq!(k1, expected_nums1.len() as i32);\nassert_eq!(&nums1[0..expected_nums1.len()], &expected_nums1[..]);",
        "let mut nums2 = vec![0, 0, 1, 1, 1, 1, 2, 3, 3];\nlet expected_nums2 = vec![0, 0, 1, 1, 2, 3, 3];\nlet k2 = RemoveDuplicatesFromSortedArrayII(&mut nums2);\nassert_eq!(k2, expected_nums2.len() as i32);\nassert_eq!(&nums2[0..expected_nums2.len()], &expected_nums2[..]);"
      ],
      "compareHelper": "fn assert_arrays_equal(arr1: &[i32], arr2: &[i32]) {\n    assert_eq!(arr1, arr2);\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArrayII(nums)\n  return 0\nend",
      "testCalls": [
        "nums1 = [1,1,1,2,2,3]; expectedNums1 = [1,1,2,2,3]; k1 = RemoveDuplicatesFromSortedArrayII(nums1); raise 'Test Case 1 Failed' unless k1 == expectedNums1.length && nums1[0...k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,1,2,3,3]; expectedNums2 = [0,0,1,1,2,3,3]; k2 = RemoveDuplicatesFromSortedArrayII(nums2); raise 'Test Case 2 Failed' unless k2 == expectedNums2.length && nums2[0...k2] == expectedNums2"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,1,1,2,2,3]"
        },
        "expected": "5,nums=[1,1,2,2,3,_]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,0,1,1,1,1,2,3,3]"
        },
        "expected": "7,nums=[0,0,1,1,2,3,3,_,_]"
      }
    ]
  },
  "remove-duplicates-from-sorted-array": {
    "title": "Remove Duplicates from Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nConsider the number of unique elements innums to be k. After removing duplicates, return the number of unique elementsk.\nThe firstkelements ofnumsshould contain the unique numbers in sorted order. The remaining elements beyond indexk - 1can be ignored.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
    "difficulty": "Easy",
    "hints": [
      "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n\r\n",
      "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
      "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArray(nums) {}",
      "testCalls": [
        "RemoveDuplicatesFromSortedArray([1,1,2])",
        "RemoveDuplicatesFromSortedArray([0,0,1,1,1,2,2,3,3,4])"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArray(nums: number[]): number { return 0; }",
      "testCalls": [
        "const nums1: number[] = [1,1,2];\nconst expectedNums1: number[] = [1,2];\nconst k1: number = RemoveDuplicatesFromSortedArray(nums1);\nif (k1 !== expectedNums1.length || !arraysEqual(nums1.slice(0, k1), expectedNums1)) {\n  throw new Error('Test Case 1 Failed');\n}",
        "const nums2: number[] = [0,0,1,1,1,2,2,3,3,4];\nconst expectedNums2: number[] = [0,1,2,3,4];\nconst k2: number = RemoveDuplicatesFromSortedArray(nums2);\nif (k2 !== expectedNums2.length || !arraysEqual(nums2.slice(0, k2), expectedNums2)) {\n  throw new Error('Test Case 2 Failed');\n}"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}"
    },
    "cpp": {
      "functionDeclaration": "int RemoveDuplicates(vector<int>& nums) { return 0; }",
      "testCalls": [
        "vector<int> nums1 = {1, 1, 2}; int k1 = RemoveDuplicates(nums1); assert(k1 == 2); vector<int> expectedNums1 = {1, 2}; assert(compareHelper(nums1, k1, expectedNums1));",
        "vector<int> nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int k2 = RemoveDuplicates(nums2); assert(k2 == 5); vector<int> expectedNums2 = {0, 1, 2, 3, 4}; assert(compareHelper(nums2, k2, expectedNums2));"
      ],
      "compareHelper": "bool compareHelper(const vector<int>& nums, int k, const vector<int>& expectedNums) { return std::equal(nums.begin(), nums.begin() + k, expectedNums.begin()); }"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArray(nums: List[int]) -> int:",
      "testCalls": [
        "nums1 = [1,1,2]; expectedResult1 = 2; expectedNums1 = [1,2]; k1 = RemoveDuplicatesFromSortedArray(nums1); assert k1 == expectedResult1; assert nums1[:k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,2,2,3,3,4]; expectedResult2 = 5; expectedNums2 = [0,1,2,3,4]; k2 = RemoveDuplicatesFromSortedArray(nums2); assert k2 == expectedResult2; assert nums2[:k2] == expectedNums2"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return all(x == y for x, y in zip(arr1, arr2))"
    },
    "java": {
      "functionDeclaration": "public int removeDuplicates(int[] nums) { return 0; }",
      "testCalls": [
        "int[] nums1 = {1, 1, 2}; int[] expectedNums1 = {1, 2}; int k1 = removeDuplicates(nums1); assert k1 == expectedNums1.length; for (int i = 0; i < k1; i++) { assert nums1[i] == expectedNums1[i]; }",
        "int[] nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int[] expectedNums2 = {0, 1, 2, 3, 4}; int k2 = removeDuplicates(nums2); assert k2 == expectedNums2.length; for (int i = 0; i < k2; i++) { assert nums2[i] == expectedNums2[i]; }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { if (arr1.length != arr2.length) { return false; } for (int i = 0; i < arr1.length; i++) { if (arr1[i] != arr2[i]) { return false; } } return true; }"
    },
    "c": {
      "functionDeclaration": "int RemoveDuplicates(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1, 1, 2}; int expectedNums1[] = {1, 2}; int k1 = RemoveDuplicates(nums1, 3); assert(k1 == 2); for (int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "int nums2[] = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int expectedNums2[] = {0, 1, 2, 3, 4}; int k2; k2 = RemoveDuplicates(nums2, 10); assert(k2 == 5); for (int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RemoveDuplicates(nums []int) int {}",
      "testCalls": [
        "func main() { if RemoveDuplicates([]int{1, 1, 2}) != 2 {panic(\"Test case 1 failed\")}}",
        "func main() { if RemoveDuplicates([]int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}) != 5 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n    if len(arr1) != len(arr2) { return false }\n    for i := range arr1 {\n        if arr1[i] != arr2[i] { return false }\n    }\n    return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicates(nums: &mut Vec<i32>) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![1, 1, 2];\nlet expected_nums1 = vec![1, 2];\nlet k1 = RemoveDuplicates(&mut nums1);\nassert_eq!(k1, expected_nums1.len() as i32);\nassert_eq!(&nums1[0..k1 as usize], &expected_nums1[..]);",
        "let mut nums2 = vec![0, 0, 1, 1, 1, 2, 2, 3, 3, 4];\nlet expected_nums2 = vec![0, 1, 2, 3, 4];\nlet k2 = RemoveDuplicates(&mut nums2);\nassert_eq!(k2, expected_nums2.len() as i32);\nassert_eq!(&nums2[0..k2 as usize], &expected_nums2[..]);"
      ],
      "compareHelper": "fn assert_arrays_equal(arr1: &[i32], arr2: &[i32]) {\n    assert_eq!(arr1, arr2);\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArray(nums)\nend",
      "testCalls": [
        "nums1 = [1,1,2]\nexpected_nums1 = [1,2]\nexpected_result1 = 2\nresult1 = RemoveDuplicatesFromSortedArray(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected_result1 && nums1[0...result1] == expected_nums1",
        "nums2 = [0,0,1,1,1,2,2,3,3,4]\nexpected_nums2 = [0,1,2,3,4]\nexpected_result2 = 5\nresult2 = RemoveDuplicatesFromSortedArray(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected_result2 && nums2[0...result2] == expected_nums2"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,1,2]"
        },
        "expected": "2,nums=[1,2,_]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,0,1,1,1,2,2,3,3,4]"
        },
        "expected": "5,nums=[0,1,2,3,4,_,_,_,_,_]"
      }
    ]
  },
  "remove-duplicates-from-sorted-list-ii": {
    "title": "Remove Duplicates from Sorted List II",
    "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedListII(head) {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,3,4,4,5]); if(!arraysEqual(linkedListToArray(RemoveDuplicatesFromSortedListII(head1)), [1,2,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1,1,1,2,3]); if(!arraysEqual(linkedListToArray(RemoveDuplicatesFromSortedListII(head2)), [2,3])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function DeleteDuplicatesFromSortedListII(head: ListNode | null): ListNode | null",
      "testCalls": [
        "if (JSON.stringify(DeleteDuplicatesFromSortedListII(arrayToLinkedList([1,2,3,3,4,4,5]))) !== JSON.stringify(arrayToLinkedList([1,2,5]))) throw new Error('Test Case 1 Failed');",
        "if (JSON.stringify(DeleteDuplicatesFromSortedListII(arrayToLinkedList([1,1,1,2,3]))) !== JSON.stringify(arrayToLinkedList([2,3]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  const head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function arrayToLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* DeleteDuplicates(ListNode* head) { return nullptr; }",
      "testCalls": [
        "assert(compareLinkedList(DeleteDuplicates(buildLinkedList({1,2,3,3,4,4,5})), buildLinkedList({1,2,5})));",
        "assert(compareLinkedList(DeleteDuplicates(buildLinkedList({1,1,1,2,3})), buildLinkedList({2,3})));"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedListII(head):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,3,4,4,5])\nresult = RemoveDuplicatesFromSortedListII(head)\nassert linkedListToArray(result) == [1,2,5]",
        "head = buildLinkedList([1,1,1,2,3])\nresult = RemoveDuplicatesFromSortedListII(head)\nassert linkedListToArray(result) == [2,3]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None): ...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public static ListNode deleteDuplicates(ListNode head) { return null; }",
      "testCalls": [
        "ListNode test1 = deleteDuplicates(buildLinkedList(new int[]{1,2,3,3,4,4,5})); if (!Arrays.equals(linkedListToArray(test1), new int[]{1,2,5})) throw new AssertionError();",
        "ListNode test2 = deleteDuplicates(buildLinkedList(new int[]{1,1,1,2,3})); if (!Arrays.equals(linkedListToArray(test2), new int[]{2,3})) throw new AssertionError();"
      ],
      "compareHelper": "public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } public static ListNode fromArray(int[] arr) { ListNode dummy = new ListNode(0); ListNode current = dummy; for (int val : arr) { current.next = new ListNode(val); current = current.next; } return dummy.next; } public static boolean equalsArray(ListNode head, int[] arr) { ListNode current = head; for (int val : arr) { if (current == null || current.val != val) { return false; } current = current.next; } return current == null; } }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; } public static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "void DeleteDuplicatesFromSortedListII(struct ListNode* head)",
      "testCalls": [
        "int main() { int arr1[] = {1,2,3,3,4,4,5}; struct ListNode* head1 = buildLinkedList(arr1, 7); DeleteDuplicatesFromSortedListII(head1); // Compare result with expected for input [1,2,3,3,4,4,5]",
        "int arr2[] = {1,1,1,2,3}; struct ListNode* head2 = buildLinkedList(arr2, 5); DeleteDuplicatesFromSortedListII(head2); // Compare result with expected for input [1,1,1,2,3]; return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n    if (size1 != size2) return 0;\n    for (int i = 0; i < size1; i++) {\n        if (arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func DeleteDuplicates(head *ListNode) *ListNode { return nil }",
      "testCalls": [
        "if result := DeleteDuplicates(buildLinkedList([]int{1,2,3,3,4,4,5})); !compareLinkedList(result, buildLinkedList([]int{1,2,5})) { fmt.Println(\"Test 1 Failed\") }",
        "if result := DeleteDuplicates(buildLinkedList([]int{1,1,1,2,3})); !compareLinkedList(result, buildLinkedList([]int{2,3})) { fmt.Println(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next; l2 = l2.Next } return l1 == nil && l2 == nil }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head; for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]}; curr = curr.Next } return head } func linkedListToArray(head *ListNode) []int { arr := make([]int, 0); for head != nil { arr = append(arr, head.Val); head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicatesFromSortedListII(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = build_linked_list(vec![1, 2, 5]); assert_eq!(Some(Box::new(ListNode::new(1))), RemoveDuplicatesFromSortedListII(head1));",
        "let head2 = build_linked_list(vec![1, 1, 1, 2, 3]); assert_eq!(Some(Box::new(ListNode::new(2))), RemoveDuplicatesFromSortedListII(head2));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashSet;\nuse std::iter::FromIterator;\nuse std::mem;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedListII(head)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,3,4,4,5])\nresult = RemoveDuplicatesFromSortedListII(head)\nraise 'Test Case 1 Failed' unless linkedListToArray(result) == [1,2,5]",
        "head = buildLinkedList([1,1,1,2,3])\nresult = RemoveDuplicatesFromSortedListII(head)\nraise 'Test Case 2 Failed' unless linkedListToArray(result) == [2,3]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,3,4,4,5]"
        },
        "expected": "[1,2,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1,1,1,2,3]"
        },
        "expected": "[2,3]"
      }
    ]
  },
  "remove-element": {
    "title": "Remove Element",
    "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\n\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
    "difficulty": "Easy",
    "hints": [
      "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to remove that element per se, right?",
      "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
      "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveElement(nums, val) {}",
      "testCalls": [
        "const test1Nums = [3,2,2,3]; const test1Val = 3; const test1Expected = 2; const test1Result = RemoveElement(test1Nums, test1Val); if (test1Result !== test1Expected) { throw new Error(`Test case 1 failed: Expected ${test1Expected}, got ${test1Result}`); }",
        "const test2Nums = [0,1,2,2,3,0,4,2]; const test2Val = 2; const test2Expected = 5; const test2Result = RemoveElement(test2Nums, test2Val); if (test2Result !== test2Expected) { throw new Error(`Test case 2 failed: Expected ${test2Expected}, got ${test2Result}`); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveElement(nums: number[], val: number): number { return 0; }",
      "testCalls": [
        "const test1Nums = [3,2,2,3]; const test1Val = 3; const test1Expected = 2; const test1Result = RemoveElement(test1Nums, test1Val); if (test1Result !== test1Expected) { throw new Error(`Test case 1 failed: Expected ${test1Expected}, got ${test1Result}`); }",
        "const test2Nums = [0,1,2,2,3,0,4,2]; const test2Val = 2; const test2Expected = 5; const test2Result = RemoveElement(test2Nums, test2Val); if (test2Result !== test2Expected) { throw new Error(`Test case 2 failed: Expected ${test2Expected}, got ${test2Result}`); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "int RemoveElement(vector<int>& nums, int val);",
      "testCalls": [
        "vector<int> nums1 = {3, 2, 2, 3}; int val1 = 3; int k1 = RemoveElement(nums1, val1); assert(k1 == 2); vector<int> expectedNums1 = {2, 2}; sort(nums1.begin(), nums1.begin() + k1); assert(equal(nums1.begin(), nums1.begin() + k1, expectedNums1.begin()));",
        "vector<int> nums2 = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int k2 = RemoveElement(nums2, val2); assert(k2 == 5); vector<int> expectedNums2 = {0, 1, 4, 0, 3}; sort(nums2.begin(), nums2.begin() + k2); assert(equal(nums2.begin(), nums2.begin() + k2, expectedNums2.begin()));"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def RemoveElement(nums: List[int], val: int) -> int:",
      "testCalls": [
        "assert RemoveElement([3,2,2,3], 3) == 2",
        "assert RemoveElement([0,1,2,2,3,0,4,2], 2) == 5"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        raise AssertionError('Arrays have different lengths')\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            raise AssertionError(f'Arrays differ at index {i}')"
    },
    "java": {
      "functionDeclaration": "public int RemoveElement(int[] nums, int val) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { int[] nums1 = {3, 2, 2, 3}; int val1 = 3; int expected1 = 2; int k1 = new Main().RemoveElement(nums1, val1); assert k1 == expected1; }",
        "public static void main(String[] args) { int[] nums2 = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int expected2 = 5; int k2 = new Main().RemoveElement(nums2, val2); assert k2 == expected2; }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2, int length) {\n    for (int i = 0; i < length; i++) {\n        if (arr1[i] != arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int RemoveElement(int* nums, int numsSize, int val) { return 0; }",
      "testCalls": [
        "int nums1[] = {3, 2, 2, 3}; int val1 = 3; int expected1 = 2; int k1 = RemoveElement(nums1, 4, val1); assert(k1 == expected1);",
        "int nums2[] = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int expected2 = 5; int k2 = RemoveElement(nums2, 8, val2); assert(k2 == expected2);"
      ],
      "compareHelper": "void assertArrayEquals(int* arr1, int* arr2, int size) { for(int i = 0; i < size; i++) { assert(arr1[i] == arr2[i]); } }"
    },
    "go": {
      "functionDeclaration": "func RemoveElement(nums []int, val int) int {}",
      "testCalls": [
        "func main() { if RemoveElement([]int{3,2,2,3}, 3) != 2 {panic(\"Test case 1 failed\")}}",
        "func main() { if RemoveElement([]int{0,1,2,2,3,0,4,2}, 2) != 5 {panic(\"Test case 2 failed\")}}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n  if len(arr1) != len(arr2) { return false }\n  for i := range arr1 {\n    if arr1[i] != arr2[i] { return false }\n  }\n  return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn RemoveElement(nums: &mut Vec<i32>, val: i32) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![3, 2, 2, 3];\nlet val1 = 3;\nlet result1 = RemoveElement(&mut nums1, val1);\nassert_eq!(result1, 2);\nassert_eq!(nums1, vec![2, 2]);",
        "let mut nums2 = vec![0, 1, 2, 2, 3, 0, 4, 2];\nlet val2 = 2;\nlet result2 = RemoveElement(&mut nums2, val2);\nassert_eq!(result2, 5);\nassert_eq!(nums2, vec![0, 1, 4, 0, 3]);"
      ],
      "compareHelper": "fn assert_vec_eq(actual: Vec<i32>, expected: Vec<i32>) {\n    assert_eq!(actual.len(), expected.len());\n    for i in 0..actual.len() {\n        assert_eq!(actual[i], expected[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveElement(nums, val)\nend",
      "testCalls": [
        "nums1 = [3,2,2,3]\nval1 = 3\nexpected_result1 = 2\nRemoveElement(nums1, val1) # Call function\nif nums1[0...expected_result1] != [2, 2]\n  raise 'Test Case 1 Failed'\nend",
        "nums2 = [0,1,2,2,3,0,4,2]\nval2 = 2\nexpected_result2 = 5\nRemoveElement(nums2, val2) # Call function\nif nums2[0...expected_result2].sort != [0, 0, 1, 3, 4]\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[3,2,2,3]",
          "val": "3"
        },
        "expected": "2,nums=[2,2,_,_]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[0,1,2,2,3,0,4,2]",
          "val": "2"
        },
        "expected": "5,nums=[0,1,4,0,3,_,_,_]"
      }
    ]
  },
  "remove-nth-node-from-end-of-list": {
    "title": "Remove Nth Node From End of List",
    "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
    "difficulty": "Medium",
    "hints": [
      "Maintain two pointers and update one with a delay of n steps."
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RemoveNthNodeFromEndOfList(head, n) { return null; }",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); let test1 = RemoveNthNodeFromEndOfList(head1, 2); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,2,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1]); let test2 = RemoveNthNodeFromEndOfList(head2, 1); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "let head3 = buildLinkedList([1,2]); let test3 = RemoveNthNodeFromEndOfList(head3, 1); if(JSON.stringify(linkedListToArray(test3)) !== JSON.stringify([1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveNthNodeFromEndOfList(head: ListNode | null, n: number): ListNode | null {}",
      "testCalls": [
        "const test1 = RemoveNthNodeFromEndOfList(createLinkedList([1,2,3,4,5]), 2); compareLinkedList(test1, createLinkedList([1,2,3,5]));",
        "const test2 = RemoveNthNodeFromEndOfList(createLinkedList([1]), 1); compareLinkedList(test2, createLinkedList([]));",
        "const test3 = RemoveNthNodeFromEndOfList(createLinkedList([1,2]), 1); compareLinkedList(test3, createLinkedList([1]));"
      ],
      "compareHelper": "function compareLinkedList(head1, head2) { let arr1 = []; let arr2 = []; while (head1) { arr1.push(head1.val); head1 = head1.next; } while (head2) { arr2.push(head2.val); head2 = head2.next; } if (JSON.stringify(arr1) !== JSON.stringify(arr2)) throw new Error('Test Failed'); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function createLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1, head2) { let arr1 = []; let arr2 = []; while (head1) { arr1.push(head1.val); head1 = head1.next; } while (head2) { arr2.push(head2.val); head2 = head2.next; } if (JSON.stringify(arr1) !== JSON.stringify(arr2)) throw new Error('Test Failed'); }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* RemoveNthNodeFromEndOfList(ListNode* head, int n) { return nullptr; }",
      "testCalls": [
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(buildLinkedList({1,2,3,4,5}), 2), buildLinkedList({1,2,3,5})));",
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(buildLinkedList({1}), 1), buildLinkedList({})));",
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(buildLinkedList({1,2}), 1), buildLinkedList({1})));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
    },
    "python": {
      "functionDeclaration": "def RemoveNthNodeFromEndOfList(head, n):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nresult = RemoveNthNodeFromEndOfList(head, 2)\nassert linkedListToArray(result) == [1,2,3,5]",
        "head = buildLinkedList([1])\nresult = RemoveNthNodeFromEndOfList(head, 1)\nassert linkedListToArray(result) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None): ...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode removeNthFromEnd(ListNode head, int n) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode test1 = removeNthFromEnd(buildLinkedList(new int[]{1,2,3,4,5}), 2); if (!Arrays.equals(linkedListToArray(test1), new int[]{1,2,3,5})) throw new AssertionError(); }",
        "public static void main(String[] args) { ListNode test2 = removeNthFromEnd(buildLinkedList(new int[]{1}), 1); if (!Arrays.equals(linkedListToArray(test2), new int[]{})) throw new AssertionError(); }",
        "public static void main(String[] args) { ListNode test3 = removeNthFromEnd(buildLinkedList(new int[]{1,2}), 1); if (!Arrays.equals(linkedListToArray(test3), new int[]{1})) throw new AssertionError(); }"
      ],
      "compareHelper": "public static boolean equalsArray(ListNode node, int[] expected) { return false; }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
    },
    "c": {
      "functionDeclaration": "struct ListNode* RemoveNthFromEnd(struct ListNode* head, int n)",
      "testCalls": [
        "int arr1[] = {1,2,3,4,5}; struct ListNode* head1 = buildLinkedList(arr1, 5); assert(compareArrays(RemoveNthFromEnd(head1, 2), buildLinkedList((int[]) {1,2,3,5}, 4)));",
        "int arr2[] = {1}; struct ListNode* head2 = buildLinkedList(arr2, 1); assert(compareArrays(RemoveNthFromEnd(head2, 1), buildLinkedList((int[]) {}, 0)));",
        "int arr3[] = {1,2}; struct ListNode* head3 = buildLinkedList(arr3, 2); assert(compareArrays(RemoveNthFromEnd(head3, 1), buildLinkedList((int[]) {1}, 1)));"
      ],
      "compareHelper": "bool compareArrays(struct ListNode* head1, struct ListNode* head2) { while (head1 && head2) { if (head1->val != head2->val) return false; head1 = head1->next; head2 = head2->next; } return !head1 && !head2; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* buildLinkedList(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; }\nint* linkedListToArray(struct ListNode* head, int* size) { int count = 0; struct ListNode* curr = head; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func RemoveNthFromEnd(head *ListNode, n int) *ListNode {}",
      "testCalls": [
        "func testRemoveNthFromEnd() { if result := RemoveNthFromEnd(buildLinkedList([]int{1, 2, 3, 4, 5}), 2); !compareLinkedList(result, buildLinkedList([]int{1, 2, 3, 5})) { fmt.Println(\"Test 1 failed\") } if result := RemoveNthFromEnd(buildLinkedList([]int{1}), 1); !compareLinkedList(result, buildLinkedList([]int{})) { fmt.Println(\"Test 2 failed\") } if result := RemoveNthFromEnd(buildLinkedList([]int{1, 2}), 1); !compareLinkedList(result, buildLinkedList([]int{1})) { fmt.Println(\"Test 3 failed\") } }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next; l2 = l2.Next } return l1 == nil && l2 == nil }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &ListNode{Val: arr[0]} curr := head; for i := 1; i < len(arr); i++ { curr.Next = &ListNode{Val: arr[i]}; curr = curr.Next } return head } func linkedListToArray(head *ListNode) []int { arr := make([]int, 0); for head != nil { arr = append(arr, head.Val); head = head.Next } return arr }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveNthNodeFromEndOfList(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = build_linked_list(vec![1, 2, 3, 5]); assert_eq!(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })), RemoveNthNodeFromEndOfList(head1, 2));",
        "let head2 = build_linked_list(vec![1]); assert_eq!(None, RemoveNthNodeFromEndOfList(head2, 1));"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::HashSet;\nuse std::iter::FromIterator;\nuse std::mem;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[allow(dead_code)]\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn build_linked_list(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr.iter() {\n        *curr = Some(Box::new(ListNode { val, next: None }));\n        curr = &mut curr.as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveNthNodeFromEndOfList(head, n)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nresult = RemoveNthNodeFromEndOfList(head, 2)\nraise 'Test Case 1 Failed' unless linkedListToArray(result) == [1,2,3,5]",
        "head = buildLinkedList([1])\nresult = RemoveNthNodeFromEndOfList(head, 1)\nraise 'Test Case 2 Failed' unless linkedListToArray(result) == []",
        "head = buildLinkedList([1,2])\nresult = RemoveNthNodeFromEndOfList(head, 1)\nraise 'Test Case 3 Failed' unless linkedListToArray(result) == [1]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\n\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "n": "2"
        },
        "expected": "[1,2,3,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1]",
          "n": "1"
        },
        "expected": "[]"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "head": "[1,2]",
          "n": "1"
        },
        "expected": "[1]"
      }
    ]
  },
  "reverse-bits": {
    "title": "Reverse Bits",
    "content": "Reverse bits of a given 32 bits signed integer.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseBits(n) { return 0; }",
      "testCalls": [
        "if (ReverseBits(43261596) !== 964176192) { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseBits(2147483644) !== 1073741822) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ReverseBits(n: number): number { return 0; }",
      "testCalls": [
        "if (ReverseBits(43261596) !== 964176192) { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseBits(2147483644) !== 1073741822) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int ReverseBits(int n);",
      "testCalls": [
        "int main() { if(ReverseBits(43261596) != 964176192) throw std::runtime_error(\"Test Case 1 Failed\"); return 0; }",
        "int main() { if(ReverseBits(2147483644) != 1073741822) throw std::runtime_error(\"Test Case 2 Failed\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ReverseBits(n: int) -> int:",
      "testCalls": [
        "assert ReverseBits(43261596) == 964176192",
        "assert ReverseBits(2147483644) == 1073741822"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int ReverseBits(int n) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { if (new Main().ReverseBits(43261596) != 964176192) throw new AssertionError(); }",
        "public static void main(String[] args) { if (new Main().ReverseBits(2147483644) != 1073741822) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int ReverseBits(int n)",
      "testCalls": [
        "int main() { if (ReverseBits(43261596) != 964176192) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (ReverseBits(2147483644) != 1073741822) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ReverseBits(n uint32) uint32 { return 0 }",
      "testCalls": [
        "func TestReverseBits(t *testing.T) { if ReverseBits(43261596) != 964176192 { t.Error(\"Test Case 1 Failed\") } }",
        "func TestReverseBits(t *testing.T) { if ReverseBits(2147483644) != 1073741822 { t.Error(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ReverseBits(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(ReverseBits(43261596), 964176192);",
        "assert_eq!(ReverseBits(2147483644), 1073741822);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseBits(n)\n  return 0\nend",
      "testCalls": [
        "test_case_1 = ReverseBits(43261596); raise 'Test Case 1 Failed' unless test_case_1 == 964176192",
        "test_case_2 = ReverseBits(2147483644); raise 'Test Case 2 Failed' unless test_case_2 == 1073741822"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "n": "43261596"
        },
        "expected": "964176192"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "n": "2147483644"
        },
        "expected": "1073741822"
      }
    ]
  },
  "reverse-linked-list-ii": {
    "title": "Reverse Linked List II",
    "content": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseLinkedListII(head, left, right) { return head; }",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); const test1 = ReverseLinkedListII(head1, 2, 4); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([1,4,3,2,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([5]); const test2 = ReverseLinkedListII(head2, 1, 1); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([5])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function ReverseLinkedListII(head: ListNode | null, left: number, right: number): ListNode | null {}",
      "testCalls": [
        "const test1 = ReverseLinkedListII(createLinkedList([1,2,3,4,5]), 2, 4); compareLinkedList(test1, createLinkedList([1,4,3,2,5]));",
        "const test2 = ReverseLinkedListII(createLinkedList([5]), 1, 1); compareLinkedList(test2, createLinkedList([5]));"
      ],
      "compareHelper": "function compareLinkedList(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); }}",
      "typeDefs": "class ListNode { val: number; next: ListNode | null; constructor(val = 0, next: ListNode | null = null) { this.val = val; this.next = next; } }",
      "builders": "function createLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1: ListNode | null, head2: ListNode | null): boolean { while (head1 && head2) { if (head1.val !== head2.val) return false; head1 = head1.next; head2 = head2.next; } return !head1 && !head2; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* ReverseLinkedListII(ListNode* head, int left, int right);",
      "testCalls": [
        "assert(linkedListToString(ReverseLinkedListII(buildLinkedList({1,2,3,4,5}), 2, 4)) == \"1,4,3,2,5\");",
        "assert(linkedListToString(ReverseLinkedListII(buildLinkedList({5}), 1, 1)) == \"5\");"
      ],
      "compareHelper": "std::string ListNodeToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + ','; head = head->next; } if (!res.empty()) res.pop_back(); return '[' + res + ']'; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::string linkedListToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + \",\"; head = head->next; } return res; }"
    },
    "python": {
      "functionDeclaration": "def ReverseLinkedListII(head, left, right):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(ReverseLinkedListII(head, 2, 4)) == [1,4,3,2,5]",
        "head = buildLinkedList([5])\nassert linkedListToArray(ReverseLinkedListII(head, 1, 1)) == [5]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None): ...",
      "builders": "def buildLinkedList(arr): ...\ndef linkedListToArray(head): ..."
    },
    "java": {
      "functionDeclaration": "public ListNode reverseBetween(ListNode head, int left, int right) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode test1 = reverseBetween(buildLinkedList(new int[]{1,2,3,4,5}), 2, 4); if (!Arrays.equals(linkedListToArray(test1), new int[]{1,4,3,2,5})) throw new AssertionError(); }",
        "public static void main(String[] args) { ListNode test2 = reverseBetween(buildLinkedList(new int[]{5}), 1, 1); if (!Arrays.equals(linkedListToArray(test2), new int[]{5})) throw new AssertionError(); }"
      ],
      "compareHelper": "private static boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* ReverseLinkedListII(ListNode* head, int left, int right) { return NULL; }",
      "testCalls": [
        "ListNode* test1 = ReverseLinkedListII(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2, 4); assert(compareLinkedListToArray(test1, (int[]) {1,4,3,2,5}, 5));",
        "ListNode* test2 = ReverseLinkedListII(createLinkedListFromArray((int[]) {5}, 1), 1, 1); assert(compareLinkedListToArray(test2, (int[]) {5}, 1));"
      ],
      "compareHelper": "int compareLinkedListToArray(ListNode* head, int* arr, int size);",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* createLinkedListFromArray(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
    },
    "go": {
      "functionDeclaration": "func ReverseLinkedListII(head *ListNode, left int, right int) *ListNode {}",
      "testCalls": [
        "func test() { if result := ReverseLinkedListII(buildLinkedList([]int{1,2,3,4,5}), 2, 4); !compareLinkedList(result, buildLinkedList([]int{1,4,3,2,5})) { fmt.Println(\"Test 1 Failed\") } }",
        "func test() { if result := ReverseLinkedListII(buildLinkedList([]int{5}), 1, 1); !compareLinkedList(result, buildLinkedList([]int{5})) { fmt.Println(\"Test 2 Failed\") } }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { return false }",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode { return nil }"
    },
    "rust": {
      "functionDeclaration": "fn ReverseLinkedListII(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {}",
      "testCalls": [
        "let head = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(ReverseLinkedListII(head, 2, 4)), vec![1,4,3,2,5]);",
        "let head = buildLinkedList(vec![5]); assert_eq!(linkedListToArray(ReverseLinkedListII(head, 1, 1)), vec![5]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::LinkedList;\nuse std::iter::FromIterator;\n\n#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def ReverseLinkedListII(head, left, right)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5]); test_case_1 = ReverseLinkedListII(head, 2, 4); raise 'Test Case 1 Failed' unless linkedListToArray(test_case_1) == [1,4,3,2,5]",
        "head = buildLinkedList([5]); test_case_2 = ReverseLinkedListII(head, 1, 1); raise 'Test Case 2 Failed' unless linkedListToArray(test_case_2) == [5]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "left": "2",
          "right": "4"
        },
        "expected": "[1,4,3,2,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[5]",
          "left": "1",
          "right": "1"
        },
        "expected": "[5]"
      }
    ]
  },
  "reverse-nodes-in-k-group": {
    "title": "Reverse Nodes in k-Group",
    "content": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list nodes, only nodes themselves may be changed.",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseNodesInKGroup(head, k) { return null; }",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); const test1 = ReverseNodesInKGroup(head1, 2); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([2,1,4,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "let head2 = buildLinkedList([1,2,3,4,5]); const test2 = ReverseNodesInKGroup(head2, 3); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([3,2,1,4,5])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function ReverseNodesInKGroup(head: ListNode | null, k: number): ListNode | null {}",
      "testCalls": [
        "if (JSON.stringify(ReverseNodesInKGroup(createLinkedList([1,2,3,4,5]), 2)?.toArray()) !== JSON.stringify([2,1,4,3,5])) throw new Error('Test Case 1 Failed');",
        "if (JSON.stringify(ReverseNodesInKGroup(createLinkedList([1,2,3,4,5]), 3)?.toArray()) !== JSON.stringify([3,2,1,4,5])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "class ListNode { val: number; next: ListNode | null; constructor(val = 0, next: ListNode | null = null) { this.val = val; this.next = next; } }",
      "builders": "function createLinkedList(arr: number[]): ListNode | null { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction compareLinkedList(head1: ListNode | null, head2: ListNode | null): boolean { while (head1 && head2) { if (head1.val !== head2.val) return false; head1 = head1.next; head2 = head2.next; } return !head1 && !head2; }"
    },
    "cpp": {
      "functionDeclaration": "ListNode* ReverseNodesInKGroup(ListNode* head, int k) { return nullptr; }",
      "testCalls": [
        "assert(linkedListToString(ReverseNodesInKGroup(buildLinkedList({1,2,3,4,5}), 2)) == \"2,1,4,3,5\");",
        "assert(linkedListToString(ReverseNodesInKGroup(buildLinkedList({1,2,3,4,5}), 3)) == \"3,2,1,4,5\");"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }",
      "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} };",
      "builders": "ListNode* buildLinkedList(std::vector<int> arr) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : arr) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } std::string linkedListToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + \",\"; head = head->next; } return res; }"
    },
    "python": {
      "functionDeclaration": "def ReverseNodesInKGroup(head, k):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(ReverseNodesInKGroup(head, 2)) == [2,1,4,3,5]",
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(ReverseNodesInKGroup(head, 3)) == [3,2,1,4,5]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode reverseKGroup(ListNode head, int k) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode test1Head = new ListNode(1); test1Head.next = new ListNode(2); test1Head.next.next = new ListNode(3); test1Head.next.next.next = new ListNode(4); test1Head.next.next.next.next = new ListNode(5); ListNode expected1 = new ListNode(2); expected1.next = new ListNode(1); expected1.next.next = new ListNode(4); expected1.next.next.next = new ListNode(3); expected1.next.next.next.next = new ListNode(5); ListNode result1 = reverseKGroup(test1Head, 2); if (!compareLinkedLists(result1, expected1)) { throw new AssertionError(); } }",
        "public static void main(String[] args) { ListNode test2Head = new ListNode(1); test2Head.next = new ListNode(2); test2Head.next.next = new ListNode(3); test2Head.next.next.next = new ListNode(4); test2Head.next.next.next.next = new ListNode(5); ListNode expected2 = new ListNode(3); expected2.next = new ListNode(2); expected2.next.next = new ListNode(1); expected2.next.next.next = new ListNode(4); expected2.next.next.next.next = new ListNode(5); ListNode result2 = reverseKGroup(test2Head, 3); if (!compareLinkedLists(result2, expected2)) { throw new AssertionError(); } }"
      ],
      "compareHelper": "public static boolean compareLinkedLists(ListNode l1, ListNode l2) { while (l1 != null && l2 != null) { if (l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; } return l1 == null && l2 == null; }",
      "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public static ListNode buildLinkedList(int[] arr) { if (arr.length == 0) return null; ListNode head = new ListNode(arr[0]); ListNode curr = head; for (int i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\npublic static int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "ListNode* ReverseNodesInKGroup(ListNode* head, int k)",
      "testCalls": [
        "void testReverseNodesInKGroup(ListNode* input, int k, ListNode* expected) { /* Test implementation here */ }\n\nint main() {\n    testReverseNodesInKGroup(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2, createLinkedListFromArray((int[]) {2,1,4,3,5}, 5));\n    return 0;\n}",
        "void testReverseNodesInKGroup(ListNode* input, int k, ListNode* expected) { /* Test implementation here */ }\n\nint main() {\n    testReverseNodesInKGroup(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 3, createLinkedListFromArray((int[]) {3,2,1,4,5}, 5));\n    return 0;\n}"
      ],
      "compareHelper": "int compareLinkedListToArray(ListNode* head, int* arr, int size);",
      "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
      "builders": "ListNode* createLinkedListFromArray(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
    },
    "go": {
      "functionDeclaration": "func ReverseNodesInKGroup(head *ListNode, k int) *ListNode { return nil }",
      "testCalls": [
        "func test() { if !compareLinkedList(ReverseNodesInKGroup(buildLinkedList([]int{1,2,3,4,5}), 2), buildLinkedList([]int{2,1,4,3,5})) { fmt.Println(\"Test Case 1 Failed\") } }",
        "func test() { if !compareLinkedList(ReverseNodesInKGroup(buildLinkedList([]int{1,2,3,4,5}), 3), buildLinkedList([]int{3,2,1,4,5})) { fmt.Println(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool {}",
      "typeDefs": "type ListNode struct { Val int; Next *ListNode }",
      "builders": "func buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}"
    },
    "rust": {
      "functionDeclaration": "fn ReverseNodesInKGroup(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(ReverseNodesInKGroup(head, 2)), vec![2,1,4,3,5]);",
        "let head = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(ReverseNodesInKGroup(head, 3)), vec![3,2,1,4,5]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::LinkedList;\nuse std::iter::FromIterator;\n\n#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}",
      "typeDefs": "#[derive(Debug, Clone)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> {\n    let mut list = LinkedList::new();\n    for &val in arr.iter().rev() {\n        list.push_front(ListNode { val, next: None });\n    }\n    let mut head = None;\n    for node in list {\n        head = Some(Box::new(ListNode { val: node.val, next: head }));\n    }\n    head\n}\n\nfn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = &head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = &node.next;\n    }\n    arr\n}"
    },
    "ruby": {
      "functionDeclaration": "def ReverseNodesInKGroup(head, k)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5]); test_case_1 = ReverseNodesInKGroup(head, 2); raise 'Test Case 1 Failed' unless linkedListToArray(test_case_1) == [2,1,4,3,5]",
        "head = buildLinkedList([1,2,3,4,5]); test_case_2 = ReverseNodesInKGroup(head, 3); raise 'Test Case 2 Failed' unless linkedListToArray(test_case_2) == [3,2,1,4,5]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "k": "2"
        },
        "expected": "[2,1,4,3,5]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "k": "3"
        },
        "expected": "[3,2,1,4,5]"
      }
    ]
  },
  "reverse-words-in-a-string": {
    "title": "Reverse Words in a String",
    "content": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Two Pointers",
      "String"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function ReverseWordsInAString(s) { return ''; }",
      "testCalls": [
        "if (ReverseWordsInAString('the sky is blue') !== 'blue is sky the') { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseWordsInAString('  hello world  ') !== 'world hello') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ReverseWordsInAString(s: string): string { return ''; }",
      "testCalls": [
        "if (ReverseWordsInAString('the sky is blue') !== 'blue is sky the') { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseWordsInAString('hello world') !== 'world hello') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "string ReverseWordsInAString(string s) { return \"\"; }",
      "testCalls": [
        "int main() { assert(ReverseWordsInAString(\"the sky is blue\") == \"blue is sky the\"); return 0; }",
        "int main() { assert(ReverseWordsInAString(\"  hello world  \") == \"world hello\"); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ReverseWordsInAString(s: str) -> str:",
      "testCalls": [
        "assert ReverseWordsInAString(\"the sky is blue\") == \"blue is sky the\"",
        "assert ReverseWordsInAString(\"  hello world  \") == \"world hello\"",
        "assert ReverseWordsInAString(\"a good   example\") == \"example good a\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String ReverseWordsInAString(String s) { return null; }",
      "testCalls": [
        "if (!m.ReverseWordsInAString(\"the sky is blue\").equals(\"blue is sky the\")) { throw new AssertionError(); }",
        "if (!m.ReverseWordsInAString(\"hello world\").equals(\"world hello\")) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* ReverseWordsInAString(char* s)",
      "testCalls": [
        "int main() { ReverseWordsInAString(\"the sky is blue\"); return 0; }",
        "int main() { ReverseWordsInAString(\"  hello world  \"); return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ReverseWordsInAString(s string) string {}",
      "testCalls": [
        "func main() { if ReverseWordsInAString(\"the sky is blue\") != \"blue is sky the\" {panic(\"Test 1 failed\")}}",
        "func main() { if ReverseWordsInAString(\"  hello world  \") != \"world hello\" {panic(\"Test 2 failed\")}}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ReverseWordsInAString(s: String) -> String {}",
      "testCalls": [
        "assert_eq!(ReverseWordsInAString(String::from(\"theskyisblue\")), \"blueisskythe\");",
        "assert_eq!(ReverseWordsInAString(String::from(\"helloworld\")), \"worldhello\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseWordsInAString(s)\n  return \"\"\nend",
      "testCalls": [
        "puts ReverseWordsInAString(\"theskyisblue\") == \"blueisskythe\" || raise(\"Test Case 1 Failed\")",
        "puts ReverseWordsInAString(\"helloworld\") == \"worldhello\" || raise(\"Test Case 2 Failed\")"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;theskyisblue&quot;"
        },
        "expected": "&quot;blueisskythe&quot;"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;helloworld&quot;"
        },
        "expected": "&quot;worldhello&quot;"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;agoodexample&quot;"
        },
        "expected": "&quot;examplegooda&quot;"
      }
    ]
  },
  "roman-to-integer": {
    "title": "Roman to Integer",
    "content": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,2 is written as IIin Roman numeral, just two ones added together. 12 is written asXII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.",
    "difficulty": "Easy",
    "hints": [
      "Problem is simpler to solve by working the string from back to front and using a map."
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RomanToInteger(s) { return 0; }",
      "testCalls": [
        "if (RomanToInteger(\"III\") !== 3) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") !== 58) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (RomanToInteger(\"MCMXCIV\") !== 1994) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function RomanToInteger(s: string): number { return 0; }",
      "testCalls": [
        "if (RomanToInteger(\"III\") !== 3) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") !== 58) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (RomanToInteger(\"MCMXCIV\") !== 1994) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int RomanToInteger(string s) { return 0; }",
      "testCalls": [
        "int main() { if (RomanToInteger(\"III\") != 3) { throw \"Test 1 failed\"; } if (RomanToInteger(\"LVIII\") != 58) { throw \"Test 2 failed\"; } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def RomanToInteger(s: str) -> int:",
      "testCalls": [
        "assert RomanToInteger(\"III\") == 3",
        "assert RomanToInteger(\"LVIII\") == 58"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int RomanToInteger(String s) { return 0; }",
      "testCalls": [
        "if (m.RomanToInteger(\"III\") != 3) { throw new AssertionError(); }",
        "if (m.RomanToInteger(\"LVIII\") != 58) { throw new AssertionError(); }",
        "if (m.RomanToInteger(\"MCMXCIV\") != 1994) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int RomanToInteger(char *s)",
      "testCalls": [
        "int main() { if (RomanToInteger(\"III\") != 3) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if (RomanToInteger(\"LVIII\") != 58) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func RomanToInteger(s string) int {\n\t// Function body will be implemented here\n}",
      "testCalls": [
        "func TestRomanToInteger(t *testing.T) {\n    if RomanToInteger(\"III\") != 3 {\n        t.Errorf(\"Test case 1 failed\")\n    }\n    if RomanToInteger(\"LVIII\") != 58 {\n        t.Errorf(\"Test case 2 failed\")\n    }\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn RomanToInteger(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(RomanToInteger(String::from(\"III\")), 3);",
        "assert_eq!(RomanToInteger(String::from(\"LVIII\")), 58);",
        "assert_eq!(RomanToInteger(String::from(\"MCMXCIV\")), 1994);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def RomanToInteger(s)\n  return 0\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless RomanToInteger('III') == 3",
        "raise 'Test Case 2 Failed' unless RomanToInteger('LVIII') == 58",
        "raise 'Test Case 3 Failed' unless RomanToInteger('MCMXCIV') == 1994"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "s": "&quot;III&quot;"
        },
        "expected": "3"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "s": "&quot;LVIII&quot;"
        },
        "expected": "58"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "s": "&quot;MCMXCIV&quot;"
        },
        "expected": "1994"
      }
    ]
  },
  "rotate-array": {
    "title": "Rotate Array",
    "content": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
    "difficulty": "Medium",
    "hints": [
      "The easiest solution would use additional memory and that is perfectly fine.",
      "The actual trick comes when trying to solve this problem without using any additional memory. This means you need to use the original array somehow to move the elements around. Now, we can place each element in its original location and shift all the elements around it to adjust as that would be too costly and most likely will time out on larger input arrays.",
      "One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example.",
      "The other line of thought is a tad bit complicated but essentially it builds on the idea of placing each element in its original position while keeping track of the element originally in that position. Basically, at every step, we place an element in its rightful position and keep track of the element already there or the one being overwritten in an additional variable. We can't do this in one linear pass and the idea here is based on <b>cyclic-dependencies</b> between elements."
    ],
    "topicTags": [
      "Array",
      "Math",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RotateArray(nums, k) { return []; }",
      "testCalls": [
        "let test1 = RotateArray([1,2,3,4,5,6,7], 3); if(JSON.stringify(test1) !== JSON.stringify([5,6,7,1,2,3,4])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RotateArray([-1,-100,3,99], 2); if(JSON.stringify(test2) !== JSON.stringify([3,99,-1,-100])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateArray(nums: number[], k: number): void {}",
      "testCalls": [
        "RotateArray([1,2,3,4,5,6,7], 3); // should output [5,6,7,1,2,3,4]",
        "RotateArray([-1,-100,3,99], 2); // should output [3,99,-1,-100]"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "cpp": {
      "functionDeclaration": "void RotateArray(vector<int>& nums, int k);",
      "testCalls": [
        "vector<int> test1 = {1,2,3,4,5,6,7}; RotateArray(test1, 3); // Expected output: [5,6,7,1,2,3,4]",
        "vector<int> test2 = {-1,-100,3,99}; RotateArray(test2, 2); // Expected output: [3,99,-1,-100]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def RotateArray(nums: List[int], k: int) -> None:",
      "testCalls": [
        "RotateArray([1,2,3,4,5,6,7], 3)  # Expected: [5,6,7,1,2,3,4]",
        "RotateArray([-1,-100,3,99], 2)  # Expected: [3,99,-1,-100]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError(f'Arrays do not match. Expected: {arr2}, Got: {arr1}')"
    },
    "java": {
      "functionDeclaration": "public void RotateArray(int[] nums, int k) { return; }",
      "testCalls": [
        "m.RotateArray(new int[]{1,2,3,4,5,6,7}, 3); // should return [5,6,7,1,2,3,4]",
        "m.RotateArray(new int[]{-1,-100,3,99}, 2); // should return [3,99,-1,-100]"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "void RotateArray(int* nums, int numsSize, int k) { return; }",
      "testCalls": [
        "int nums1[] = {1,2,3,4,5,6,7}; RotateArray(nums1, 7, 3); compareArrays(nums1, (int[]){5,6,7,1,2,3,4}, 7);",
        "int nums2[] = {-1,-100,3,99}; RotateArray(nums2, 4, 2); compareArrays(nums2, (int[]){3,99,-1,-100}, 4);"
      ],
      "compareHelper": "void compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) { printf(\"Test Failed\"); exit(1); } } }"
    },
    "go": {
      "functionDeclaration": "func RotateArray(nums []int, k int) []int {}",
      "testCalls": [
        "func TestRotateArray(t *testing.T) { if !compareArrays(RotateArray([]int{1,2,3,4,5,6,7}, 3), []int{5,6,7,1,2,3,4}) { t.Error(\"Test Case 1 Failed\") } if !compareArrays(RotateArray([]int{-1,-100,3,99}, 2), []int{3,99,-1,-100}) { t.Error(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn RotateArray(nums: &mut Vec<i32>, k: i32) {}",
      "testCalls": [
        "let mut test_input1 = vec![1,2,3,4,5,6,7];\nRotateArray(&mut test_input1, 3);\nassert_eq!(test_input1, vec![5,6,7,1,2,3,4]);",
        "let mut test_input2 = vec![-1,-100,3,99];\nRotateArray(&mut test_input2, 2);\nassert_eq!(test_input2, vec![3,99,-1,-100]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) {\n    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert_eq!(a[i], b[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def RotateArray(nums, k)\nend",
      "testCalls": [
        "result = RotateArray([1,2,3,4,5,6,7], 3)\nraise 'Test Case 1 Failed' unless result == [5,6,7,1,2,3,4]",
        "result = RotateArray([-1,-100,3,99], 2)\nraise 'Test Case 2 Failed' unless result == [3,99,-1,-100]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,2,3,4,5,6,7]",
          "k": "3"
        },
        "expected": "[5,6,7,1,2,3,4]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[-1,-100,3,99]",
          "k": "2"
        },
        "expected": "[3,99,-1,-100]"
      }
    ]
  },
  "rotate-image": {
    "title": "Rotate Image",
    "content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math",
      "Matrix"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RotateImage(matrix) {}",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]])",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateImage(matrix: number[][]): void",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]]); // Expected: [[7,4,1],[8,5,2],[9,6,3]]",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]); // Expected: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "function arraysEqual(a: number[][], b: number[][]): void {\n  if (JSON.stringify(a) !== JSON.stringify(b)) {\n    throw new Error('Test Failed');\n  }\n}"
    },
    "cpp": {
      "functionDeclaration": "void RotateImage(vector<vector<int>>& matrix) {}",
      "testCalls": [
        "vector<vector<int>> matrix = {{1,2,3},{4,5,6},{7,8,9}}; RotateImage(matrix); assert(matrix == vector<vector<int>>{{7,4,1},{8,5,2},{9,6,3}});",
        "vector<vector<int>> matrix = {{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}; RotateImage(matrix); assert(matrix == vector<vector<int>>{{15,13,2,5},{14,3,4,1},{12,6,8,9},{16,7,10,11}});"
      ],
      "compareHelper": "bool compareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def RotateImage(matrix: List[List[int]]) -> None:",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]])",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public void rotateImage(int[][] matrix) {}",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); m.rotateImage(new int[][]{{1,2,3},{4,5,6},{7,8,9}}); m.compareArrays(new int[][]{{1,2,3},{4,5,6},{7,8,9}}, new int[][]{{7,4,1},{8,5,2},{9,6,3}}); }",
        "public static void main(String[] args) { Main m = new Main(); m.rotateImage(new int[][]{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}); m.compareArrays(new int[][]{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}, new int[][]{{15,13,2,5},{14,3,4,1},{12,6,8,9},{16,7,10,11}}); }"
      ],
      "compareHelper": "private void compareArrays(int[][] arr1, int[][] arr2) {\n    if (!Arrays.deepEquals(arr1, arr2)) {\n        throw new AssertionError(\"Arrays not equal: \" + Arrays.deepToString(arr1) + \" != \" + Arrays.deepToString(arr2));\n    }\n}"
    },
    "c": {
      "functionDeclaration": "void RotateImage(int** matrix, int matrixSize, int* matrixColSize)",
      "testCalls": [
        "int main() { RotateImage((int*[]){{1,2,3},{4,5,6},{7,8,9}}, 3, (int[]){3}); return 0; }",
        "int main() { RotateImage((int*[]){{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}, 4, (int[]){4}); return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RotateImage(matrix [][]int) { }",
      "testCalls": [
        "func main() { RotateImage([][]int{{1,2,3},{4,5,6},{7,8,9}}) }",
        "func main() { RotateImage([][]int{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}) }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) { }"
    },
    "rust": {
      "functionDeclaration": "fn RotateImage(matrix: &mut Vec<Vec<i32>>) {}",
      "testCalls": [
        "let mut matrix1 = vec![vec![1,2,3],vec![4,5,6],vec![7,8,9]]; RotateImage(&mut matrix1); assert_eq!(matrix1, vec![vec![7,4,1],vec![8,5,2],vec![9,6,3]]);",
        "let mut matrix2 = vec![vec![5,1,9,11],vec![2,4,8,10],vec![13,3,6,7],vec![15,14,12,16]]; RotateImage(&mut matrix2); assert_eq!(matrix2, vec![vec![15,13,2,5],vec![14,3,4,1],vec![12,6,8,9],vec![16,7,10,11]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_equal(actual: Vec<Vec<i32>>, expected: Vec<Vec<i32>>) { for (a, e) in actual.iter().zip(expected.iter()) { assert_eq!(a, e); }}"
    },
    "ruby": {
      "functionDeclaration": "def RotateImage(matrix)\nend",
      "testCalls": [
        "test_case_1 = [[1,2,3],[4,5,6],[7,8,9]]\nRotateImage(test_case_1)\nraise 'Test Case 1 Failed' unless test_case_1 == [[7,4,1],[8,5,2],[9,6,3]]",
        "test_case_2 = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nRotateImage(test_case_2)\nraise 'Test Case 2 Failed' unless test_case_2 == [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "matrix": "[[1,2,3],[4,5,6],[7,8,9]]"
        },
        "expected": "[[7,4,1],[8,5,2],[9,6,3]]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "matrix": "[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]"
        },
        "expected": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      }
    ]
  },
  "rotate-list": {
    "title": "Rotate List",
    "content": "Given the head of a linkedlist, rotate the list to the right by k places.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RotateList(head, k) { return null; }",
      "testCalls": [
        "let test1 = RotateList(buildLinkedList([1,2,3,4,5]), 2); if(JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([4,5,1,2,3])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RotateList(buildLinkedList([0,1,2]), 4); if(JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([2,0,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "typescript": {
      "functionDeclaration": "function RotateList(head: number[], k: number): number[] {}",
      "testCalls": [
        "let head1 = buildLinkedList([1,2,3,4,5]); const test1 = RotateList(head1, 2); if (JSON.stringify(linkedListToArray(test1)) !== JSON.stringify([4,5,1,2,3])) throw new Error('Test Case 1 Failed');",
        "let head2 = buildLinkedList([0,1,2]); const test2 = RotateList(head2, 4); if (JSON.stringify(linkedListToArray(test2)) !== JSON.stringify([2,0,1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
      "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
    },
    "cpp": {
      "functionDeclaration": "void RotateList(ListNode* head, int k);",
      "testCalls": [
        "int main() { RotateList(createLinkedList({1,2,3,4,5}), 2); return 0; }",
        "int main() { RotateList(createLinkedList({0,1,2}), 4); return 0; }"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }",
      "typeDefs": "struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(nullptr) {} };",
      "builders": "ListNode* createLinkedList(std::vector<int> values) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int val : values) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } \nstd::vector<int> linkedListToArray(ListNode* head) { std::vector<int> result; while (head) { result.push_back(head->val); head = head->next; } return result; }"
    },
    "python": {
      "functionDeclaration": "def RotateList(head, k):",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5])\nassert linkedListToArray(RotateList(head, 2)) == [4,5,1,2,3]",
        "head = buildLinkedList([0,1,2])\nassert linkedListToArray(RotateList(head, 4)) == [2,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 == arr2:\n        return True\n    else:\n        raise AssertionError(f'Arrays do not match. Expected: {arr2}, Got: {arr1}')",
      "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
      "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
    },
    "java": {
      "functionDeclaration": "public ListNode rotateRight(ListNode head, int k) { return null; }",
      "testCalls": [
        "public static void main(String[] args) { ListNode test1 = rotateRight(createLinkedList(new int[]{1,2,3,4,5}), 2); compareLinkedList(test1, new int[]{4,5,1,2,3}); }",
        "public static void main(String[] args) { ListNode test2 = rotateRight(createLinkedList(new int[]{0,1,2}), 4); compareLinkedList(test2, new int[]{2,0,1}); }"
      ],
      "compareHelper": "public void compareLinkedList(ListNode l1, int[] arr) { int[] l1Arr = linkedListToArray(l1); if (!Arrays.equals(l1Arr, arr)) throw new AssertionError(); }",
      "typeDefs": "public class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
      "builders": "public ListNode createLinkedList(int[] arr) { if (arr == null || arr.length == 0) return null; ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\npublic int[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "void RotateList(struct ListNode* head, int k) { return; }",
      "testCalls": [
        "int main() { RotateList(createListFromArray((int[]) {1,2,3,4,5}, 5), 2); return 0; }",
        "int main() { RotateList(createListFromArray((int[]) {0,1,2}, 3), 4); return 0; }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return 0; } return 1; }",
      "typeDefs": "struct ListNode { int val; struct ListNode* next; };",
      "builders": "struct ListNode* createListFromArray(int* arr, int size) { struct ListNode* head = NULL; struct ListNode* curr = NULL; for (int i = 0; i < size; i++) { struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); newNode->val = arr[i]; newNode->next = NULL; if (!head) { head = newNode; curr = newNode; } else { curr->next = newNode; curr = newNode; } } return head; } \nint* listToArray(struct ListNode* head, int* size) { struct ListNode* curr = head; int count = 0; while (curr) { count++; curr = curr->next; } *size = count; int* arr = (int*)malloc(count * sizeof(int)); curr = head; for (int i = 0; i < count; i++) { arr[i] = curr->val; curr = curr->next; } return arr; }"
    },
    "go": {
      "functionDeclaration": "func RotateList(head *ListNode, k int) *ListNode {}",
      "testCalls": [
        "func TestRotateList1(t *testing.T) { if result := RotateList(buildLinkedList([]int{1, 2, 3, 4, 5}), 2); !compareLinkedList(result, buildLinkedList([]int{4, 5, 1, 2, 3})) { t.Errorf(\"Test 1 failed\") } }",
        "func TestRotateList2(t *testing.T) { if result := RotateList(buildLinkedList([]int{0, 1, 2}), 4); !compareLinkedList(result, buildLinkedList([]int{2, 0, 1})) { t.Errorf(\"Test 2 failed\") } }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next; l2 = l2.Next } return l1 == nil && l2 == nil }",
      "typeDefs": "type ListNode struct {\n    Val  int\n    Next *ListNode\n}",
      "builders": "func buildLinkedList(arr []int) *ListNode {\n    if len(arr) == 0 {\n        return nil\n    }\n    head := &ListNode{Val: arr[0]}\n    curr := head\n    for i := 1; i < len(arr); i++ {\n        curr.Next = &ListNode{Val: arr[i]}\n        curr = curr.Next\n    }\n    return head\n}\n\nfunc linkedListToArray(head *ListNode) []int {\n    arr := make([]int, 0)\n    for head != nil {\n        arr = append(arr, head.Val)\n        head = head.Next\n    }\n    return arr\n}"
    },
    "rust": {
      "functionDeclaration": "fn RotateList(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let head1 = buildLinkedList(vec![1,2,3,4,5]); assert_eq!(linkedListToArray(RotateList(head1, 2)), vec![4,5,1,2,3]);",
        "let head2 = buildLinkedList(vec![0,1,2]); assert_eq!(linkedListToArray(RotateList(head2, 4)), vec![2,0,1]);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::LinkedList; use std::iter::FromIterator; #[derive(Debug, PartialEq, Eq)] pub struct ListNode { pub val: i32, pub next: Option<Box<ListNode>>, } impl ListNode { pub fn new(val: i32) -> Self { ListNode { val, next: None } } } fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> { let mut list = LinkedList::new(); for &val in arr.iter().rev() { list.push_front(ListNode::new(val)); } let mut head = None; for node in list.into_iter() { head = Some(Box::new(node)); } head } fn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> { let mut arr = Vec::new(); let mut curr = &head; while let Some(node) = curr { arr.push(node.val); curr = &node.next; } arr }",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)] pub struct ListNode { pub val: i32, pub next: Option<Box<ListNode>>, } impl ListNode { pub fn new(val: i32) -> Self { ListNode { val, next: None } } }",
      "builders": "fn buildLinkedList(arr: Vec<i32>) -> Option<Box<ListNode>> { let mut list = LinkedList::new(); for &val in arr.iter().rev() { list.push_front(ListNode::new(val)); } let mut head = None; for node in list.into_iter() { head = Some(Box::new(node)); } head } fn linkedListToArray(head: Option<Box<ListNode>>) -> Vec<i32> { let mut arr = Vec::new(); let mut curr = &head; while let Some(node) = curr { arr.push(node.val); curr = &node.next; } arr }"
    },
    "ruby": {
      "functionDeclaration": "def RotateList(head, k)\nend",
      "testCalls": [
        "head = buildLinkedList([1,2,3,4,5]); result = RotateList(head, 2); raise 'Test Case 1 Failed' unless linkedListToArray(result) == [4,5,1,2,3]",
        "head = buildLinkedList([0,1,2]); result = RotateList(head, 4); raise 'Test Case 2 Failed' unless linkedListToArray(result) == [2,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend",
      "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
      "builders": "def buildLinkedList(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linkedListToArray(head)\n  arr = []\n  while head\n    arr << head.val\n    head = head.next\n  end\n  arr\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "head": "[1,2,3,4,5]",
          "k": "2"
        },
        "expected": "[4,5,1,2,3]"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "head": "[0,1,2]",
          "k": "4"
        },
        "expected": "[2,0,1]"
      }
    ]
  },
  "same-tree": {
    "title": "Same Tree",
    "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SameTree(p, q) { return null; }",
      "testCalls": [
        "if (SameTree(buildTree([1,2,3]), buildTree([1,2,3])) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (SameTree(buildTree([1,2]), buildTree([1,null,2])) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "typescript": {
      "functionDeclaration": "function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {}",
      "testCalls": [
        "const test1 = isSameTree(buildTree([1,2,3]), buildTree([1,2,3])); if (test1 !== true) throw new Error('Test Case 1 Failed');",
        "const test2 = isSameTree(buildTree([1,2]), buildTree([1,null,2])); if (test2 !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToBinaryTree(arr: (number | null)[]): TreeNode | null {}",
      "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
      "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
    },
    "cpp": {
      "functionDeclaration": "bool IsSameTree(TreeNode* p, TreeNode* q) { return false; }",
      "testCalls": [
        "if(IsSameTree(buildTree({1,2,3}), buildTree({1,2,3})) != true) throw std::runtime_error(\"Test 1 failed\");",
        "if(IsSameTree(buildTree({1,2}), buildTree({1,INT_MIN,2})) != false) throw std::runtime_error(\"Test 2 failed\");",
        "if(IsSameTree(buildTree({1,2,1}), buildTree({1,1,2})) != false) throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": "TreeNode* BuildTree(const std::vector<int>& values) { if (values.empty()) return nullptr; TreeNode* root = new TreeNode(values[0]); std::vector<TreeNode*> nodes = {root}; for(int i = 1; i < values.size(); ++i) { if(values[i] != INT_MIN) { TreeNode* node = new TreeNode(values[i]); nodes.push_back(node); if(i % 2 == 1) nodes[(i-1)/2]->left = node; else nodes[(i-1)/2]->right = node; } } return root; }",
      "typeDefs": "struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };",
      "builders": "TreeNode* buildTree(std::vector<int> values) { if (values.empty() || values[0] == INT_MIN) return nullptr; TreeNode* root = new TreeNode(values[0]); std::queue<TreeNode*> q; q.push(root); size_t i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (values[i] != INT_MIN) { node->left = new TreeNode(values[i]); q.push(node->left); } ++i; if (i < values.size() && values[i] != INT_MIN) { node->right = new TreeNode(values[i]); q.push(node->right); } ++i; } return root; } \nstd::vector<int> treeToArray(TreeNode* root) { std::vector<int> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); q.push(node->left); q.push(node->right); } else { result.push_back(INT_MIN); } } while (!result.empty() && result.back() == INT_MIN) result.pop_back(); return result; }"
    },
    "python": {
      "functionDeclaration": "def SameTree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:",
      "testCalls": [
        "root_p = buildTree([1,2,3])\nroot_q = buildTree([1,2,3])\nassert isSameTree(root_p, root_q) == True, 'Test Case 1 Failed'",
        "root_p = buildTree([1,2])\nroot_q = buildTree([1,None,2])\nassert isSameTree(root_p, root_q) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": "def isSameTree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    return p.val == q.val and isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
      "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
      "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
    },
    "java": {
      "functionDeclaration": "public boolean SameTree(TreeNode p, TreeNode q) { return compareTrees(p, q); }",
      "testCalls": [
        "public static void main(String[] args) { if (!new Main().SameTree(new Main().createTree(new Integer[]{1,2,3}), new Main().createTree(new Integer[]{1,2,3}))) throw new AssertionError(); }",
        "public static void main(String[] args) { if (new Main().SameTree(new Main().createTree(new Integer[]{1,2}), new Main().createTree(new Integer[]{1,null,2}))) throw new AssertionError(); }",
        "public static void main(String[] args) { if (new Main().SameTree(new Main().createTree(new Integer[]{1,2,1}), new Main().createTree(new Integer[]{1,1,2}))) throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    return p.val == q.val && compareTrees(p.left, q.left) && compareTrees(p.right, q.right);\n}",
      "typeDefs": "public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }",
      "builders": "public TreeNode createTree(Integer[] arr) { if (arr == null || arr.length == 0) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode curr = queue.poll(); if (arr[i] != null) { curr.left = new TreeNode(arr[i]); queue.offer(curr.left); } i++; if (i < arr.length && arr[i] != null) { curr.right = new TreeNode(arr[i]); queue.offer(curr.right); } i++; } return root; }\npublic int[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode curr = queue.poll(); if (curr != null) { list.add(curr.val); queue.offer(curr.left); queue.offer(curr.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(Integer::intValue).toArray(); }"
    },
    "c": {
      "functionDeclaration": "bool IsSameTree(struct TreeNode* p, struct TreeNode* q)",
      "testCalls": [
        "int result0 = IsSameTree(buildTree((int[]) {1,2,3}, 3), buildTree((int[]) {1,2,3}, 3)); // Expected: true",
        "int result1 = IsSameTree(buildTree((int[]) {1,2}, 2), buildTree((int[]) {1,-1,2}, 3)); // Expected: false",
        "int result2 = IsSameTree(buildTree((int[]) {1,2,1}, 3), buildTree((int[]) {1,1,2}, 3)); // Expected: false"
      ],
      "compareHelper": "",
      "typeDefs": "struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };",
      "builders": "struct TreeNode* buildTree(int* arr, int size) { if (size == 0) return NULL; struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root->val = arr[0]; root->left = NULL; root->right = NULL; struct TreeNode* queue[size]; int front = 0, rear = 0; queue[rear++] = root; int i = 1; while (i < size && rear < size) { struct TreeNode* current = queue[front++]; if (arr[i] != -1) { struct TreeNode* leftNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); leftNode->val = arr[i]; leftNode->left = NULL; leftNode->right = NULL; current->left = leftNode; queue[rear++] = leftNode; } i++; if (i < size && arr[i] != -1) { struct TreeNode* rightNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); rightNode->val = arr[i]; rightNode->left = NULL; rightNode->right = NULL; current->right = rightNode; queue[rear++] = rightNode; } i++; } return root; } \nint* treeToArray(struct TreeNode* root, int* size) { if (!root) return NULL; int* arr = (int*)malloc(sizeof(int) * 100); struct TreeNode* queue[100]; int front = 0, rear = 0; queue[rear++] = root; int index = 0; while (front < rear) { struct TreeNode* current = queue[front++]; if (current) { arr[index++] = current->val; if (current->left) queue[rear++] = current->left; else queue[rear++] = NULL; if (current->right) queue[rear++] = current->right; else queue[rear++] = NULL; } else { arr[index++] = -1; } } *size = index; return arr; }"
    },
    "go": {
      "functionDeclaration": "func IsSameTree(p *TreeNode, q *TreeNode) bool { return false }",
      "testCalls": [
        "func test() { if !IsSameTree(buildTree([]int{1, 2, 3}), buildTree([]int{1, 2, 3})) { fmt.Println(\"Test Case 1 Failed\") } }",
        "func test() { if IsSameTree(buildTree([]int{1, 2}), buildTree([]int{1, 0, 2})) { fmt.Println(\"Test Case 2 Failed\") } }"
      ],
      "compareHelper": "func sliceToTreeNode(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n    root := &TreeNode{Val: nums[0]}\n    queue := []*TreeNode{root}\n    i := 1\n    for i < len(nums) {\n        node := queue[0]\n        queue = queue[1:]\n        if nums[i] != -1 {\n            node.Left = &TreeNode{Val: nums[i]}\n            queue = append(queue, node.Left)\n        }\n        i++\n        if i < len(nums) && nums[i] != -1 {\n            node.Right = &TreeNode{Val: nums[i]}\n            queue = append(queue, node.Right)\n        }\n        i++\n    }\n    return root\n}",
      "typeDefs": "type TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}",
      "builders": "func buildTree(arr []int) *TreeNode {\n    if len(arr) == 0 || arr[0] == -1 {\n        return nil\n    }\n    root := &TreeNode{Val: arr[0]}\n    queue := []*TreeNode{root}\n    i := 1\n    for len(queue) > 0 && i < len(arr) {\n        node := queue[0]\n        queue = queue[1:]\n        if i < len(arr) && arr[i] != -1 {\n            node.Left = &TreeNode{Val: arr[i]}\n            queue = append(queue, node.Left)\n        }\n        i++\n        if i < len(arr) && arr[i] != -1 {\n            node.Right = &TreeNode{Val: arr[i]}\n            queue = append(queue, node.Right)\n        }\n        i++\n    }\n    return root\n}\n\nfunc treeToArray(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n    result := make([]int, 0)\n    queue := []*TreeNode{root}\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        if node != nil {\n            result = append(result, node.Val)\n            queue = append(queue, node.Left, node.Right)\n        } else {\n            result = append(result, -1)\n        }\n    }\n    for result[len(result)-1] == -1 {\n        result = result[:len(result)-1]\n    }\n    return result\n}"
    },
    "rust": {
      "functionDeclaration": "fn SameTree(p: Option<Box<TreeNode>>, q: Option<Box<TreeNode>>) -> bool {}",
      "testCalls": [
        "let root1 = buildTree(vec![Some(1), Some(2), Some(3)]); let root2 = buildTree(vec![Some(1), Some(2), Some(3)]); assert_eq!(SameTree(root1, root2), true);",
        "let root3 = buildTree(vec![Some(1), Some(2), None]); let root4 = buildTree(vec![Some(1), None, Some(2)]); assert_eq!(SameTree(root3, root4), false);"
      ],
      "compareHelper": "",
      "helpers": "use std::collections::VecDeque; #[derive(Debug, PartialEq, Eq)] pub struct TreeNode { pub val: i32, pub left: Option<Box<TreeNode>>, pub right: Option<Box<TreeNode>>, } impl TreeNode { pub fn new(val: i32) -> Self { TreeNode { val, left: None, right: None } } } fn buildTree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> { if arr.is_empty() { return None; } let root = Some(Box::new(TreeNode::new(arr[0].unwrap())); let mut queue = VecDeque::new(); queue.push_back(root.as_ref().unwrap().clone()); let mut i = 1; while i < arr.len() && !queue.is_empty() { let node = queue.pop_front().unwrap(); if let Some(val) = arr[i] { node.borrow_mut().left = Some(Box::new(TreeNode::new(val))); queue.push_back(node.borrow().left.as_ref().unwrap().clone()); } i += 1; if i < arr.len() && arr[i].is_some() { node.borrow_mut().right = Some(Box::new(TreeNode::new(arr[i].unwrap()))); queue.push_back(node.borrow().right.as_ref().unwrap().clone()); } i += 1; } root } fn treeToArray(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> { let mut result = Vec::new(); let mut queue = VecDeque::new(); queue.push_back(root); while let Some(node) = queue.pop_front() { if let Some(n) = node { result.push(Some(n.val)); queue.push_back(n.left.clone()); queue.push_back(n.right.clone()); } else { result.push(None); } } while let Some(last) = result.last() { if last.is_none() { result.pop(); } else { break; } } result }",
      "typeDefs": "#[derive(Debug, PartialEq, Eq)] pub struct TreeNode { pub val: i32, pub left: Option<Box<TreeNode>>, pub right: Option<Box<TreeNode>>, } impl TreeNode { pub fn new(val: i32) -> Self { TreeNode { val, left: None, right: None } } }",
      "builders": "fn buildTree(arr: Vec<Option<i32>>) -> Option<Box<TreeNode>> { if arr.is_empty() { return None; } let root = Some(Box::new(TreeNode::new(arr[0].unwrap())); let mut queue = VecDeque::new(); queue.push_back(root.as_ref().unwrap().clone()); let mut i = 1; while i < arr.len() && !queue.is_empty() { let node = queue.pop_front().unwrap(); if let Some(val) = arr[i] { node.borrow_mut().left = Some(Box::new(TreeNode::new(val))); queue.push_back(node.borrow().left.as_ref().unwrap().clone()); } i += 1; if i < arr.len() && arr[i].is_some() { node.borrow_mut().right = Some(Box::new(TreeNode::new(arr[i].unwrap()))); queue.push_back(node.borrow().right.as_ref().unwrap().clone()); } i += 1; } root } fn treeToArray(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> { let mut result = Vec::new(); let mut queue = VecDeque::new(); queue.push_back(root); while let Some(node) = queue.pop_front() { if let Some(n) = node { result.push(Some(n.val)); queue.push_back(n.left.clone()); queue.push_back(n.right.clone()); } else { result.push(None); } } while let Some(last) = result.last() { if last.is_none() { result.pop(); } else { break; } } result }"
    },
    "ruby": {
      "functionDeclaration": "def SameTree(p, q)\nend",
      "testCalls": [
        "root = buildTree([1,2,3]); SameTree(root, buildTree([1,2,3])) == true || raise('Test Case 1 Failed')",
        "root = buildTree([1,2]); SameTree(root, buildTree([1,nil,2])) == false || raise('Test Case 2 Failed')"
      ],
      "compareHelper": "",
      "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
      "builders": "def buildTree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\n\ndef treeToArray(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result << node.val\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result << nil\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "p": "[1,2,3]",
          "q": "[1,2,3]"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "p": "[1,2]",
          "q": "[1,null,2]"
        },
        "expected": "false"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "p": "[1,2,1]",
          "q": "[1,1,2]"
        },
        "expected": "false"
      }
    ]
  },
  "search-a-2d-matrix": {
    "title": "Search a 2D Matrix",
    "content": "You are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchA2DMatrix(matrix, target) { return false; }",
      "testCalls": [
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchA2DMatrix(matrix: number[][], target: number): boolean { return false; }",
      "testCalls": [
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) !== true) throw new Error('Test Case 1 Failed');",
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "bool SearchA2DMatrix(vector<vector<int>>& matrix, int target);",
      "testCalls": [
        "int main() { if(SearchA2DMatrix({{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(SearchA2DMatrix({{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchA2DMatrix(matrix: List[List[int]], target: int) -> bool:",
      "testCalls": [
        "assert SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) == True",
        "assert SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) == False"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean SearchA2DMatrix(int[][] matrix, int target) { return false; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (!m.SearchA2DMatrix(new int[][]{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3)) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.SearchA2DMatrix(new int[][]{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13)) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool SearchA2DMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)",
      "testCalls": [
        "if (!SearchA2DMatrix((int*[]){(int[]){1,3,5,7}, (int[]){10,11,16,20}, (int[]){23,30,34,60}}, 3, (int[]){4,4,4}, 3)) { printf(\"Test 1 Failed\"); }",
        "if (SearchA2DMatrix((int*[]){(int[]){1,3,5,7}, (int[]){10,11,16,20}, (int[]){23,30,34,60}}, 3, (int[]){4,4,4}, 13)) { printf(\"Test 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchA2DMatrix(matrix [][]int, target int) bool {}",
      "testCalls": [
        "func main() {",
        "    if SearchA2DMatrix([][]int{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3) != true {panic(\"Test case 1 failed\")}",
        "    if SearchA2DMatrix([][]int{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13) != false {panic(\"Test case 2 failed\")}",
        "}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchA2DMatrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(SearchA2DMatrix(vec![vec![1,3,5,7], vec![10,11,16,20], vec![23,30,34,60]], 3), true);",
        "assert_eq!(SearchA2DMatrix(vec![vec![1,3,5,7], vec![10,11,16,20], vec![23,30,34,60]], 13), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchA2DMatrix(matrix, target)\nend",
      "testCalls": [
        "result = SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3)\nraise 'Test Case 1 Failed' unless result == true",
        "result = SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13)\nraise 'Test Case 2 Failed' unless result == false"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "matrix": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]]",
          "target": "3"
        },
        "expected": "true"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "matrix": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]]",
          "target": "13"
        },
        "expected": "false"
      }
    ]
  },
  "search-in-rotated-sorted-array": {
    "title": "Search in Rotated Sorted Array",
    "content": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by3indices and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchInRotatedSortedArray(nums, target) { return 0; }",
      "testCalls": [
        "if(SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchInRotatedSortedArray(nums: number[], target: number): number { return -1; }",
      "testCalls": [
        "if (SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int SearchInRotatedSortedArray(vector<int>& nums, int target);",
      "testCalls": [
        "int main() { assert(SearchInRotatedSortedArray({4,5,6,7,0,1,2}, 0) == 4); return 0; }",
        "int main() { assert(SearchInRotatedSortedArray({4,5,6,7,0,1,2}, 3) == -1); return 0; }",
        "int main() { assert(SearchInRotatedSortedArray({1}, 0) == -1); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchInRotatedSortedArray(nums: List[int], target: int) -> int:",
      "testCalls": [
        "assert SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) == 4",
        "assert SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) == -1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int SearchInRotatedSortedArray(int[] nums, int target) { return 0; }",
      "testCalls": [
        "if (SearchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 0) != 4) throw new AssertionError();",
        "if (SearchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 3) != -1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int SearchInRotatedSortedArray(int* nums, int numsSize, int target)",
      "testCalls": [
        "int main() { assert(SearchInRotatedSortedArray((int[]){4,5,6,7,0,1,2}, 7, 0) == 4); return 0; }",
        "int main() { assert(SearchInRotatedSortedArray((int[]){4,5,6,7,0,1,2}, 7, 3) == -1); return 0; }",
        "int main() { assert(SearchInRotatedSortedArray((int[]){1}, 1, 0) == -1); return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchInRotatedSortedArray(nums []int, target int) int {}",
      "testCalls": [
        "func main() { if SearchInRotatedSortedArray([]int{4,5,6,7,0,1,2}, 0) != 4 {panic(\"Test case 1 failed\")} }",
        "func main() { if SearchInRotatedSortedArray([]int{4,5,6,7,0,1,2}, 3) != -1 {panic(\"Test case 2 failed\")} }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchInRotatedSortedArray(nums: Vec<i32>, target: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(SearchInRotatedSortedArray(vec![4,5,6,7,0,1,2], 0), 4);",
        "assert_eq!(SearchInRotatedSortedArray(vec![4,5,6,7,0,1,2], 3), -1);",
        "assert_eq!(SearchInRotatedSortedArray(vec![1], 0), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchInRotatedSortedArray(nums, target)\n  \nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) == 4",
        "raise 'Test Case 2 Failed' unless SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) == -1"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[4,5,6,7,0,1,2]",
          "target": "0"
        },
        "expected": "4"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[4,5,6,7,0,1,2]",
          "target": "3"
        },
        "expected": "-1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1]",
          "target": "0"
        },
        "expected": "-1"
      }
    ]
  },
  "search-insert-position": {
    "title": "Search Insert Position",
    "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou mustwrite an algorithm withO(log n) runtime complexity.",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchInsertPosition(nums, target) { return 0; }",
      "testCalls": [
        "if(SearchInsertPosition([1,3,5,6], 5) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInsertPosition([1,3,5,6], 2) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchInsertPosition(nums: number[], target: number): number { return 0; }",
      "testCalls": [
        "if(SearchInsertPosition([1,3,5,6], 5) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInsertPosition([1,3,5,6], 2) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "cpp": {
      "functionDeclaration": "int SearchInsertPosition(vector<int>& nums, int target);",
      "testCalls": [
        "int main() { assert(SearchInsertPosition(vector<int>{1, 3, 5, 6}, 5) == 2); return 0; }",
        "int main() { assert(SearchInsertPosition(vector<int>{1, 3, 5, 6}, 2) == 1); return 0; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchInsertPosition(nums: List[int], target: int) -> int:",
      "testCalls": [
        "assert SearchInsertPosition([1,3,5,6], 5) == 2",
        "assert SearchInsertPosition([1,3,5,6], 2) == 1",
        "assert SearchInsertPosition([1,3,5,6], 7) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int searchInsert(int[] nums, int target) { return 0; }",
      "testCalls": [
        "public static void main(String[] args) { Main m = new Main(); if (m.searchInsert(new int[]{1,3,5,6}, 5) != 2) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.searchInsert(new int[]{1,3,5,6}, 2) != 1) throw new AssertionError(); }",
        "public static void main(String[] args) { Main m = new Main(); if (m.searchInsert(new int[]{1,3,5,6}, 7) != 4) throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int SearchInsertPosition(int* nums, int numsSize, int target)",
      "testCalls": [
        "int main() { if(SearchInsertPosition((int[]){1,3,5,6}, 4, 5) != 2) { printf(\"Test Case 1 Failed\"); } return 0; }",
        "int main() { if(SearchInsertPosition((int[]){1,3,5,6}, 4, 2) != 1) { printf(\"Test Case 2 Failed\"); } return 0; }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchInsertPosition(nums []int, target int) int {}",
      "testCalls": [
        "func main() { if SearchInsertPosition([]int{1,3,5,6}, 5) != 2 { panic(\"Test case 1 failed\") } }",
        "func main() { if SearchInsertPosition([]int{1,3,5,6}, 2) != 1 { panic(\"Test case 2 failed\") } }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchInsertPosition(nums: Vec<i32>, target: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(SearchInsertPosition(vec![1,3,5,6], 5), 2);",
        "assert_eq!(SearchInsertPosition(vec![1,3,5,6], 2), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchInsertPosition(nums, target)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless SearchInsertPosition([1,3,5,6], 5) == 2",
        "raise 'Test Case 2 Failed' unless SearchInsertPosition([1,3,5,6], 2) == 1",
        "raise 'Test Case 3 Failed' unless SearchInsertPosition([1,3,5,6], 7) == 4"
      ],
      "compareHelper": ""
    },
    "displayCases": [
      {
        "caseNumber": 1,
        "inputs": {
          "nums": "[1,3,5,6]",
          "target": "5"
        },
        "expected": "2"
      },
      {
        "caseNumber": 2,
        "inputs": {
          "nums": "[1,3,5,6]",
          "target": "2"
        },
        "expected": "1"
      },
      {
        "caseNumber": 3,
        "inputs": {
          "nums": "[1,3,5,6]",
          "target": "7"
        },
        "expected": "4"
      }
    ]
  }
}