{
    "3sum": {
      "title": "3Sum",
      "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.",
      "difficulty": "Medium",
      "hints": [
        "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
        "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
        "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
      ],
      "topicTags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "in-place": false,
      "javascript": {
        "functionDeclaration": "function ThreeSum(nums) {}",
        "testCalls": [
          "if(JSON.stringify(ThreeSum([-1,0,1,2,-1,-4])) !== JSON.stringify([[-1,-1,2],[-1,0,1]])) { throw new Error('Test Case 1 Failed'); }",
          "if(JSON.stringify(ThreeSum([0,1,1])) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
          "if(JSON.stringify(ThreeSum([0,0,0])) !== JSON.stringify([[0,0,0]])) { throw new Error('Test Case 3 Failed'); }"
        ],
        "compareHelper": ""
      },
      "typescript": {
        "functionDeclaration": "function ThreeSum(nums: number[]): number[][] {}",
        "testCalls": [
          "const test1 = ThreeSum([-1,0,1,2,-1,-4]); if (JSON.stringify(test1) !== JSON.stringify([[-1,-1,2],[-1,0,1]])) { throw new Error('Test Case 1 Failed'); }",
          "const test2 = ThreeSum([0,1,1]); if (JSON.stringify(test2) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
          "const test3 = ThreeSum([0,0,0]); if (JSON.stringify(test3) !== JSON.stringify([[0,0,0]])) { throw new Error('Test Case 3 Failed'); }"
        ],
        "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
      },
      "cpp": {
        "functionDeclaration": "vector<vector<int>> ThreeSum(vector<int>& nums);",
        "testCalls": [
          "auto result1 = ThreeSum({-1,0,1,2,-1,-4});\nif (result1 != vector<vector<int>>{{-1,-1,2},{-1,0,1}}) throw std::runtime_error(\"Test 1 failed\");",
          "auto result2 = ThreeSum({0,1,1});\nif (result2 != vector<vector<int>>{}) throw std::runtime_error(\"Test 2 failed\");",
          "auto result3 = ThreeSum({0,0,0});\nif (result3 != vector<vector<int>>{{0,0,0}}) throw std::runtime_error(\"Test 3 failed\");"
        ],
        "compareHelper": "bool compareVectors(const vector<vector<int>>& v1, const vector<vector<int>>& v2) {\n    if (v1.size() != v2.size()) return false;\n    for (int i = 0; i < v1.size(); ++i) {\n        if (v1[i] != v2[i]) return false;\n    }\n    return true;\n}"
      },
      "python": {
        "functionDeclaration": "def ThreeSum(nums):",
        "testCalls": [
          "assert ThreeSum([-1,0,1,2,-1,-4]) == [[-1,-1,2],[-1,0,1]]",
          "assert ThreeSum([0,1,1]) == []",
          "assert ThreeSum([0,0,0]) == [[0,0,0]]"
        ],
        "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
      },
      "java": {
        "functionDeclaration": "public List<List<Integer>> threeSum(int[] nums) {}",
        "testCalls": [
          "List<List<Integer>> result1 = threeSum(new int[]{-1,0,1,2,-1,-4});\nif (!compareLists(result1, Arrays.asList(Arrays.asList(-1,-1,2), Arrays.asList(-1,0,1)))) throw new AssertionError();",
          "List<List<Integer>> result2 = threeSum(new int[]{0,1,1});\nif (!compareLists(result2, Collections.emptyList())) throw new AssertionError();",
          "List<List<Integer>> result3 = threeSum(new int[]{0,0,0});\nif (!compareLists(result3, Collections.singletonList(Arrays.asList(0,0,0)))) throw new AssertionError();"
        ],
        "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) {\n    if (list1.size() != list2.size()) return false;\n    for (List<Integer> l : list1) {\n        if (!list2.contains(l)) return false;\n    }\n    return true;\n}"
      },
      "c": {
        "functionDeclaration": "int** ThreeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
        "testCalls": [
          "int returnSize1; int* returnColumnSizes1; int** result1 = ThreeSum((int[]){-1,0,1,2,-1,-4}, 6, &returnSize1, &returnColumnSizes1); if (returnSize1 == 2 && compareArrays(result1, returnSize1, 3, (int*[]){(int[]){-1,-1,2}, (int[]){-1,0,1}})) { printf(\"Test case 1 passed.\"); } else { printf(\"Test case 1 failed.\"); }",
          "int returnSize2; int* returnColumnSizes2; int** result2 = ThreeSum((int[]){0,1,1}, 3, &returnSize2, &returnColumnSizes2); if (returnSize2 == 0) { printf(\"Test case 2 passed.\"); } else { printf(\"Test case 2 failed.\"); }"
        ],
        "compareHelper": "int compareArrays(int** arr1, int size1, int size2, int** arr2) { if (size1 != size2) { return 0; } for (int i = 0; i < size1; i++) { if (memcmp(arr1[i], arr2[i], sizeof(int) * 3) != 0) { return 0; } } return 1; }"
      },
      "go": {
        "functionDeclaration": "func ThreeSum(nums []int) [][]int {}",
        "testCalls": [
          "if !compareArrays(ThreeSum([]int{-1,0,1,2,-1,-4}), [][]int{{-1,-1,2},{-1,0,1}}) { t.Error(\"Test Case 1 Failed\") }",
          "if !compareArrays(ThreeSum([]int{0,1,1}), [][]int{}))) { t.Error(\"Test Case 2 Failed\") }",
          "if !compareArrays(ThreeSum([]int{0,0,0}), [][]int{{0,0,0}}) { t.Error(\"Test Case 3 Failed\") }"
        ],
        "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if !compareArray(arr1[i], arr2[i]) { return false } } return true } func compareArray(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if arr1[i] != arr2[i] { return false } } return true }"
      },
      "ruby": {
        "functionDeclaration": "def ThreeSum(nums)\n  \nend",
        "testCalls": [
          "nums1 = [-1,0,1,2,-1,-4]\nexpected1 = [[-1,-1,2],[-1,0,1]]\nresult1 = ThreeSum(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected1",
          "nums2 = [0,1,1]\nexpected2 = []\nresult2 = ThreeSum(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected2"
        ],
        "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
      },
      "displayCases": [
        {
          "caseNumber": 1,
          "inputs": {
            "nums": "[-1,0,1,2,-1,-4]"
          },
          "expected": "[[-1,-1,2],[-1,0,1]]"
        },
        {
          "caseNumber": 2,
          "inputs": {
            "nums": "[0,1,1]"
          },
          "expected": "[]"
        },
        {
          "caseNumber": 3,
          "inputs": {
            "nums": "[0,0,0]"
          },
          "expected": "[[0,0,0]]"
        }
      ]
    },
    "add-two-numbers": {
      "title": "Add Two Numbers",
      "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sumas a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
      "difficulty": "Medium",
      "hints": [
        null
      ],
      "topicTags": [
        "Linked List",
        "Math",
        "Recursion"
      ],
      "in-place": false,
      "javascript": {
        "functionDeclaration": "function AddTwoNumbers(l1, l2) {}",
        "testCalls": [
          "let l1 = buildLinkedList([2,4,3]); let l2 = buildLinkedList([5,6,4]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l1, l2))) !== JSON.stringify([7,0,8])) throw 'Test 1 Failed';",
          "let l3 = buildLinkedList([0]); let l4 = buildLinkedList([0]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l3, l4))) !== JSON.stringify([0])) throw 'Test 2 Failed';",
          "let l5 = buildLinkedList([9,9,9,9,9,9]); let l6 = buildLinkedList([9,9,9,9]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l5, l6))) !== JSON.stringify([8,9,9,9,0,0,0,1])) throw 'Test 3 Failed';"
        ],
        "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
        "helpers": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }\nfunction buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }",
        "typeDefs": "function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; }",
        "builders": "function buildLinkedList(arr) { if (!arr.length) return null; let head = new ListNode(arr[0]); let curr = head; for (let i = 1; i < arr.length; i++) { curr.next = new ListNode(arr[i]); curr = curr.next; } return head; }\nfunction linkedListToArray(head) { let arr = []; while (head) { arr.push(head.val); head = head.next; } return arr; }"
      },
      "typescript": {
        "functionDeclaration": "function AddTwoNumbers(l1: number[], l2: number[]): number[] { }",
        "testCalls": [
          "let l1 = buildLinkedList([2,4,3]); let l2 = buildLinkedList([5,6,4]); if (JSON.stringify(linkedListToArray(AddTwoNumbers(l1, l2))) !== JSON.stringify([7,0,8])) throw 'Test 1 Failed';"
        ],
        "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
        "helpers": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}",
        "typeDefs": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}",
        "builders": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction buildLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  let head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head: ListNode | null): number[] {\n  const result: number[] = [];\n  let current = head;\n  while (current !== null) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result;\n}"
      },
      "cpp": {
        "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
        "testCalls": [
          "ListNode* result1 = AddTwoNumbers(createLinkedList({2,4,3}), createLinkedList({5,6,4})); if (!compareLinkedLists(result1, createLinkedList({7,0,8}))) throw std::runtime_error(\"Test Case 1 Failed\");",
          "ListNode* result2 = AddTwoNumbers(createLinkedList({0}), createLinkedList({0})); if (!compareLinkedLists(result2, createLinkedList({0}))) throw std::runtime_error(\"Test Case 2 Failed\");",
          "ListNode* result3 = AddTwoNumbers(createLinkedList({9,9,9,9,9,9,9}), createLinkedList({9,9,9,9})); if (!compareLinkedLists(result3, createLinkedList({8,9,9,9,0,0,0,1}))) throw std::runtime_error(\"Test Case 3 Failed\");"
        ],
        "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) {\n    while (l1 && l2) {\n        if (l1->val != l2->val) return false;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    return l1 == nullptr && l2 == nullptr;\n}",
        "helpers": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} }; ListNode* createLinkedList(std::vector<int> values) { ListNode* head = new ListNode(values[0]); ListNode* curr = head; for (int i = 1; i < values.size(); i++) { curr->next = new ListNode(values[i]); curr = curr->next; } return head; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }",
        "typeDefs": "class ListNode { public: int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} };",
        "builders": "ListNode* createLinkedList(std::vector<int> values) { ListNode* head = new ListNode(values[0]); ListNode* curr = head; for (int i = 1; i < values.size(); i++) { curr->next = new ListNode(values[i]); curr = curr->next; } return head; } std::vector<int> linkedListToArray(ListNode* head) { std::vector<int> arr; while (head) { arr.push_back(head->val); head = head->next; } return arr; }"
      },
      "python": {
        "functionDeclaration": "def AddTwoNumbers(l1, l2):",
        "testCalls": [
          "l1 = buildLinkedList([2,4,3]); l2 = buildLinkedList([5,6,4]); if linkedListToArray(AddTwoNumbers(l1, l2)) != [7,0,8]: raise Exception('Test 1 Failed')"
        ],
        "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2",
        "helpers": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr",
        "typeDefs": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next",
        "builders": "def buildLinkedList(arr):\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    curr = head\n    for i in range(1, len(arr)):\n        curr.next = ListNode(arr[i])\n        curr = curr.next\n    return head\n\ndef linkedListToArray(head):\n    arr = []\n    while head:\n        arr.append(head.val)\n        head = head.next\n    return arr"
      },
      "java": {
        "functionDeclaration": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) { }",
        "testCalls": [
          "ListNode l1 = buildLinkedList(new int[]{2,4,3}); ListNode l2 = buildLinkedList(new int[]{5,6,4}); ListNode result1 = addTwoNumbers(l1, l2); if (!Arrays.equals(linkedListToArray(result1), new int[]{7,0,8})) throw new AssertionError();",
          "ListNode l3 = buildLinkedList(new int[]{0}); ListNode l4 = buildLinkedList(new int[]{0}); ListNode result2 = addTwoNumbers(l3, l4); if (!Arrays.equals(linkedListToArray(result2), new int[]{0})) throw new AssertionError();",
          "ListNode l5 = buildLinkedList(new int[]{9,9,9,9,9,9,9}); ListNode l6 = buildLinkedList(new int[]{9,9,9,9}); ListNode result3 = addTwoNumbers(l5, l6); if (!Arrays.equals(linkedListToArray(result3), new int[]{8,9,9,9,0,0,0,1})) throw new AssertionError();"
        ],
        "compareHelper": "private void compareLinkedLists(ListNode l1, ListNode l2) {\n    while (l1 != null && l2 != null) {\n        if (l1.val != l2.val) {\n            throw new AssertionError(\"Test case failed\");\n        }\n        l1 = l1.next;\n        l2 = l2.next;\n    }\n    if (l1 != null || l2 != null) {\n        throw new AssertionError(\"Test case failed\");\n    }\n}",
        "helpers": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }\nListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }",
        "typeDefs": "class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } }",
        "builders": "ListNode buildLinkedList(int[] arr) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : arr) { curr.next = new ListNode(num); curr = curr.next; } return dummy.next; }\nint[] linkedListToArray(ListNode head) { List<Integer> list = new ArrayList<>(); while (head != null) { list.add(head.val); head = head.next; } return list.stream().mapToInt(i -> i).toArray(); }"
      },
      "c": {
        "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
        "testCalls": [
          "ListNode* result1 = AddTwoNumbers(createLinkedList((int[]){2,4,3}, 3), createLinkedList((int[]){5,6,4}, 3));\nif (!compareLinkedLists(result1, createLinkedList((int[]){7,0,8}, 3))) { printf(\"Test Case 1 Failed\"); }",
          "ListNode* result2 = AddTwoNumbers(createLinkedList((int[]){0}, 1), createLinkedList((int[]){0}, 1));\nif (!compareLinkedLists(result2, createLinkedList((int[]){0}, 1))) { printf(\"Test Case 2 Failed\"); }",
          "ListNode* result3 = AddTwoNumbers(createLinkedList((int[]){9,9,9,9,9,9,9}, 7), createLinkedList((int[]){9,9,9,9}, 4));\nif (!compareLinkedLists(result3, createLinkedList((int[]){8,9,9,9,0,0,0,1}, 8))) { printf(\"Test Case 3 Failed\"); }"
        ],
        "compareHelper": "int compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return 0; l1 = l1->next; l2 = l2->next; } return l1 == NULL && l2 == NULL; }",
        "helpers": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;\nListNode* createLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);",
        "typeDefs": "typedef struct ListNode { int val; struct ListNode* next; } ListNode;",
        "builders": "ListNode* createLinkedList(int* arr, int size);\nint* linkedListToArray(ListNode* head);"
      },
      "go": {
        "functionDeclaration": "func AddTwoNumbers(l1 []int, l2 []int) []int {}",
        "testCalls": [
          "l1 := buildLinkedList([]int{2, 4, 3}); l2 := buildLinkedList([]int{5, 6, 4}); if !compareArrays(linkedListToArray(AddTwoNumbers(l1, l2)), []int{7, 0, 8}) { t.Error(\"Test 1 Failed\") }"
        ],
        "compareHelper": "func compareArrays(arr1, arr2 []int) bool {}",
        "helpers": "type ListNode struct { Val int Next *ListNode }\nfunc buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}",
        "typeDefs": "type ListNode struct { Val int Next *ListNode }",
        "builders": "func buildLinkedList(arr []int) *ListNode {}\nfunc linkedListToArray(head *ListNode) []int {}"
      },
      "rust": {
        "functionDeclaration": "fn AddTwoNumbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
        "testCalls": [
          "let l1 = build_linked_list(&[2, 4, 3]);\nlet l2 = build_linked_list(&[5, 6, 4]);\nassert_eq!(linked_list_to_array(AddTwoNumbers(l1, l2)), vec![7, 0, 8]);"
        ],
        "compareHelper": "fn compare_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> bool { if list1.is_none() && list2.is_none() { return true; } let mut current1 = list1; let mut current2 = list2; while let (Some(node1), Some(node2)) = (current1, current2) { if node1.val != node2.val { return false; } current1 = node1.next.clone(); current2 = node2.next.clone(); } current1.is_none() && current2.is_none() }",
        "helpers": "use std::collections::LinkedList;\n\n#[derive(Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn build_linked_list(arr: &[i32]) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr {\n        *curr = Some(Box::new(ListNode::new(val)));\n        curr = &mut (*curr).as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = node.next;\n    }\n    arr\n}",
        "typeDefs": "#[derive(Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}",
        "builders": "fn build_linked_list(arr: &[i32]) -> Option<Box<ListNode>> {\n    let mut head = None;\n    let mut curr = &mut head;\n    for &val in arr {\n        *curr = Some(Box::new(ListNode::new(val)));\n        curr = &mut (*curr).as_mut().unwrap().next;\n    }\n    head\n}\n\nfn linked_list_to_array(head: Option<Box<ListNode>>) -> Vec<i32> {\n    let mut arr = Vec::new();\n    let mut curr = head;\n    while let Some(node) = curr {\n        arr.push(node.val);\n        curr = node.next;\n    }\n    arr\n}"
      },
      "ruby": {
        "functionDeclaration": "def AddTwoNumbers(l1, l2)\nend",
        "testCalls": [
          "l1 = build_linked_list([2,4,3])\nl2 = build_linked_list([5,6,4])\nif linked_list_to_array(AddTwoNumbers(l1, l2)) != [7,0,8]\n  raise 'Test 1 Failed'\nend"
        ],
        "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend",
        "helpers": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend\ndef build_linked_list(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linked_list_to_array(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend",
        "typeDefs": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, _next = nil)\n    @val = val\n    @next = _next\n  end\nend",
        "builders": "def build_linked_list(arr)\n  return nil if arr.empty?\n  head = ListNode.new(arr[0])\n  curr = head\n  (1...arr.length).each do |i|\n    curr.next = ListNode.new(arr[i])\n    curr = curr.next\n  end\n  head\nend\ndef linked_list_to_array(head)\n  arr = []\n  while head\n    arr.push(head.val)\n    head = head.next\n  end\n  arr\nend"
      },
      "displayCases": [
        {
          "caseNumber": 1,
          "inputs": {
            "l1": "[2,4,3]",
            "l2": "[5,6,4]"
          },
          "expected": "[7,0,8]"
        },
        {
          "caseNumber": 2,
          "inputs": {
            "l1": "[0]",
            "l2": "[0]"
          },
          "expected": "[0]"
        },
        {
          "caseNumber": 3,
          "inputs": {
            "l1": "[9,9,9,9,9,9,9]",
            "l2": "[9,9,9,9]"
          },
          "expected": "[8,9,9,9,0,0,0,1]"
        }
      ]
    },
    "average-of-levels-in-binary-tree": {
      "title": "Average of Levels in Binary Tree",
      "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.",
      "difficulty": "Easy",
      "hints": [
        null
      ],
      "topicTags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "in-place": false,
      "javascript": {
        "functionDeclaration": "function AverageOfLevelsInBinaryTree(root) {}",
        "testCalls": [
          "let root1 = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root1))) !== JSON.stringify([3,14.5,11])) throw 'Test 1 Failed';",
          "let root2 = buildTree([3,9,20,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root2))) !== JSON.stringify([3,14.5,11])) throw 'Test 2 Failed';"
        ],
        "compareHelper": "function arraysAreEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }",
        "helpers": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }\nfunction buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }",
        "typeDefs": "function TreeNode(val, left, right) { this.val = val === undefined ? 0 : val; this.left = left === undefined ? null : left; this.right = right === undefined ? null : right; }",
        "builders": "function buildTree(arr) { if (!arr.length || arr[0] === null) return null; let root = new TreeNode(arr[0]); let queue = [root]; let i = 1; while (queue.length && i < arr.length) { let node = queue.shift(); if (i < arr.length && arr[i] !== null) { node.left = new TreeNode(arr[i]); queue.push(node.left); } i++; if (i < arr.length && arr[i] !== null) { node.right = new TreeNode(arr[i]); queue.push(node.right); } i++; } return root; }\nfunction treeToArray(root) { if (!root) return []; let result = []; let queue = [root]; while (queue.length) { let node = queue.shift(); if (node) { result.push(node.val); queue.push(node.left); queue.push(node.right); } else { result.push(null); } } while (result[result.length-1] === null) result.pop(); return result; }"
      },
      "typescript": {
        "functionDeclaration": "function AverageOfLevelsInBinaryTree(root: TreeNode | null): number[]",
        "testCalls": [
          "let root = buildTree([3,9,20,null,null,15,7]); if (JSON.stringify(treeToArray(AverageOfLevelsInBinaryTree(root))) !== JSON.stringify([3.00000,14.50000,11.00000])) throw 'Test 1 Failed';"
        ],
        "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }",
        "helpers": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction buildTree(arr: (number | null)[]): TreeNode | null {\n  if (!arr.length || arr[0] === null) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (queue.length && i < arr.length) {\n    const node = queue.shift()!;\n    if (i < arr.length && arr[i] !== null) {\n      node.left = new TreeNode(arr[i] as number);\n      queue.push(node.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      node.right = new TreeNode(arr[i] as number);\n      queue.push(node.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) result.pop();\n  return result;\n}",
        "typeDefs": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}",
        "builders": "function buildTree(arr: (number | null)[]): TreeNode | null {\n  if (!arr.length || arr[0] === null) return null;\n  const root = new TreeNode(arr[0]);\n  const queue: TreeNode[] = [root];\n  let i = 1;\n  while (queue.length && i < arr.length) {\n    const node = queue.shift()!;\n    if (i < arr.length && arr[i] !== null) {\n      node.left = new TreeNode(arr[i] as number);\n      queue.push(node.left);\n    }\n    i++;\n    if (i < arr.length && arr[i] !== null) {\n      node.right = new TreeNode(arr[i] as number);\n      queue.push(node.right);\n    }\n    i++;\n  }\n  return root;\n}\n\nfunction treeToArray(root: TreeNode | null): (number | null)[] {\n  if (!root) return [];\n  const result: (number | null)[] = [];\n  const queue: (TreeNode | null)[] = [root];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push(null);\n    }\n  }\n  while (result[result.length - 1] === null) result.pop();\n  return result;\n}"
      },
      "cpp": {
        "functionDeclaration": "vector<double> AverageOfLevelsInBinaryTree(TreeNode* root)",
        "testCalls": [
          "auto result1 = AverageOfLevelsInBinaryTree(createTree({3,9,20,{}, {}, 15, 7})); if (!compareArrays(result1, {3.0, 14.5, 11.0})) throw std::runtime_error(\"Test Case 1 Failed\");",
          "auto result2 = AverageOfLevelsInBinaryTree(createTree({3,9,20,15,7})); if (!compareArrays(result2, {3.0, 14.5, 11.0})) throw std::runtime_error(\"Test Case 2 Failed\");"
        ],
        "compareHelper": "bool compareArrays(vector<double>& arr1, vector<double>& arr2) {\n    if (arr1.size() != arr2.size()) return false;\n    for (int i = 0; i < arr1.size(); ++i) {\n        if (abs(arr1[i] - arr2[i]) > 1e-5) return false;\n    }\n    return true;\n}",
        "helpers": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} }; TreeNode* createTree(std::vector<std::optional<int>> values) { if (values.empty() || !values[0].has_value()) return nullptr; TreeNode* root = new TreeNode(values[0].value()); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (i < values.size() && values[i].has_value()) { node->left = new TreeNode(values[i].value()); q.push(node->left); } i++; if (i < values.size() && values[i].has_value()) { node->right = new TreeNode(values[i].value()); q.push(node->right); } i++; } return root; } std::vector<std::optional<int>> treeToArray(TreeNode* root) { std::vector<std::optional<int>> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); if (node->left || node->right) { q.push(node->left); q.push(node->right); } } else { result.push_back(std::nullopt); } } while (!result.empty() && !result.back().has_value()) result.pop_back(); return result; }",
        "typeDefs": "class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int val = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), left(left), right(right) {} };",
        "builders": "TreeNode* createTree(std::vector<std::optional<int>> values) { if (values.empty() || !values[0].has_value()) return nullptr; TreeNode* root = new TreeNode(values[0].value()); std::queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty() && i < values.size()) { TreeNode* node = q.front(); q.pop(); if (i < values.size() && values[i].has_value()) { node->left = new TreeNode(values[i].value()); q.push(node->left); } i++; if (i < values.size() && values[i].has_value()) { node->right = new TreeNode(values[i].value()); q.push(node->right); } i++; } return root; } std::vector<std::optional<int>> treeToArray(TreeNode* root) { std::vector<std::optional<int>> result; std::queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); if (node) { result.push_back(node->val); if (node->left || node->right) { q.push(node->left); q.push(node->right); } } else { result.push_back(std::nullopt); } } while (!result.empty() && !result.back().has_value()) result.pop_back(); return result; }"
      },
      "python": {
        "functionDeclaration": "def AverageOfLevelsInBinaryTree(root: TreeNode) -> List[float]:",
        "testCalls": [
          "root = buildTree([3,9,20,None,None,15,7]); if treeToArray(AverageOfLevelsInBinaryTree(root)) != [3.00000,14.50000,11.00000]: raise Exception('Test 1 Failed')"
        ],
        "compareHelper": "def assertArrayEquals(arr1, arr2): assert len(arr1) == len(arr2) and all(a == b for a, b in zip(arr1, arr2)), 'Arrays not equal'",
        "helpers": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result",
        "typeDefs": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "builders": "def buildTree(arr):\n    if not arr or arr[0] is None:\n        return None\n    root = TreeNode(arr[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] is not None:\n            node.left = TreeNode(arr[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] is not None:\n            node.right = TreeNode(arr[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef treeToArray(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    while result[-1] is None:\n        result.pop()\n    return result"
      },
      "java": {
        "functionDeclaration": "public double[] AverageOfLevels(TreeNode root)",
        "testCalls": [
          "TreeNode root1 = buildTree(new Integer[]{3, 9, 20, null, null, 15, 7}); double[] result1 = AverageOfLevels(root1); assertArrayEquals(new double[]{3.00000, 14.50000, 11.00000}, result1);",
          "TreeNode root2 = buildTree(new Integer[]{3, 9, 20, 15, 7}); double[] result2 = AverageOfLevels(root2); assertArrayEquals(new double[]{3.00000, 14.50000, 11.00000}, result2);"
        ],
        "compareHelper": "private static void assertArrayEquals(double[] expected, double[] actual) {\n    if (!Arrays.equals(expected, actual)) {\n        throw new AssertionError(\"Arrays not equal: expected \" + Arrays.toString(expected) + \" but was \" + Arrays.toString(actual));\n    }\n}",
        "helpers": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }\nTreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\nint[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(i -> i).toArray(); }",
        "typeDefs": "class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } }",
        "builders": "TreeNode buildTree(Integer[] arr) { if (arr.length == 0 || arr[0] == null) return null; Queue<TreeNode> queue = new LinkedList<>(); TreeNode root = new TreeNode(arr[0]); queue.offer(root); int i = 1; while (!queue.isEmpty() && i < arr.length) { TreeNode node = queue.poll(); if (arr[i] != null) { node.left = new TreeNode(arr[i]); queue.offer(node.left); } i++; if (i < arr.length && arr[i] != null) { node.right = new TreeNode(arr[i]); queue.offer(node.right); } i++; } return root; }\nint[] treeToArray(TreeNode root) { List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node != null) { list.add(node.val); queue.offer(node.left); queue.offer(node.right); } else { list.add(null); } } while (list.get(list.size() - 1) == null) list.remove(list.size() - 1); return list.stream().mapToInt(i -> i).toArray(); }"
      },
      "c": {
        "functionDeclaration": "double* AverageOfLevelsInBinaryTree(struct TreeNode* root, int* returnSize)",
        "testCalls": [
          "double* result1 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]){3,9,20,0,0,15,7}, 7), &returnSize); assert(compareDoubleArrays(result1, 3, (double[]){3.00000,14.50000,11.00000}, 3));",
          "double* result2 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]){3,9,20,15,7}, 5), &returnSize); assert(compareDoubleArrays(result2, 3, (double[]){3.00000,14.50000,11.00000}, 3));"
        ],
        "compareHelper": "int compareDoubleArrays(double* arr1, int size1, double* arr2, int size2) { if (size1 != size2) return 0; for (int i = 0; i < size1; i++) { if (fabs(arr1[i] - arr2[i]) > 0.00001) return 0; } return 1; }",
        "helpers": "typedef struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;\nTreeNode* createTreeFromArray(int* arr, int size);\ndouble* treeToArray(TreeNode* root);",
        "typeDefs": "typedef struct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; } TreeNode;",
        "builders": "TreeNode* createTreeFromArray(int* arr, int size);\ndouble* treeToArray(TreeNode* root);"
      },
      "go": {
        "functionDeclaration": "func AverageOfLevels(root *TreeNode) []float64 {}",
        "testCalls": [
          "root := buildTree([]int{3, 9, 20, null, null, 15, 7}); if !compareFloatArrays(AverageOfLevels(root), []float64{3.00000, 14.50000, 11.00000}) { t.Error(\"Test Case 1 Failed\") }"
        ],
        "compareHelper": "func compareFloatArrays(arr1, arr2 []float64) bool {}",
        "helpers": "type TreeNode struct { Val int Left *TreeNode Right *TreeNode }\nfunc buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}",
        "typeDefs": "type TreeNode struct { Val int Left *TreeNode Right *TreeNode }",
        "builders": "func buildTree(arr []int) *TreeNode {}\nfunc treeToArray(root *TreeNode) []int {}"
      },
      "rust": {
        "functionDeclaration": "fn AverageOfLevelsInBinaryTree(root: Option<Box<TreeNode>>) -> Vec<f64> { }",
        "testCalls": [
          "let root = build_tree(&[Some(3), Some(9), Some(20), None, None, Some(15), Some(7)]);\nassert_eq!(tree_to_array(AverageOfLevelsInBinaryTree(root)), vec![Some(3), Some(14), Some(11)]);"
        ],
        "compareHelper": "",
        "helpers": "use std::collections::VecDeque;\n\n#[derive(Clone, Debug)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}\n\nfn build_tree(arr: &[Option<i32>]) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() { return None; }\n    let mut root = Some(Box::new(TreeNode { val: arr[0].unwrap(), left: None, right: None }));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_mut().unwrap());\n    let mut i = 1;\n    while !queue.is_empty() && i < arr.len() {\n        let node = queue.pop_front().unwrap();\n        if let Some(val) = arr[i] {\n            node.left = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.left.as_mut().unwrap());\n        }\n        i += 1;\n        if let Some(val) = arr[i] {\n            node.right = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.right.as_mut().unwrap());\n        }\n        i += 1;\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}",
        "typeDefs": "#[derive(Clone, Debug)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>, \n    pub right: Option<Box<TreeNode>>, \n}",
        "builders": "fn build_tree(arr: &[Option<i32>]) -> Option<Box<TreeNode>> {\n    if arr.is_empty() || arr[0].is_none() { return None; }\n    let mut root = Some(Box::new(TreeNode { val: arr[0].unwrap(), left: None, right: None }));\n    let mut queue = VecDeque::new();\n    queue.push_back(root.as_mut().unwrap());\n    let mut i = 1;\n    while !queue.is_empty() && i < arr.len() {\n        let node = queue.pop_front().unwrap();\n        if let Some(val) = arr[i] {\n            node.left = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.left.as_mut().unwrap());\n        }\n        i += 1;\n        if let Some(val) = arr[i] {\n            node.right = Some(Box::new(TreeNode { val, left: None, right: None }));\n            queue.push_back(node.right.as_mut().unwrap());\n        }\n        i += 1;\n    }\n    root\n}\n\nfn tree_to_array(root: Option<Box<TreeNode>>) -> Vec<Option<i32>> {\n    let mut result = Vec::new();\n    let mut queue = VecDeque::new();\n    queue.push_back(root);\n    while let Some(node) = queue.pop_front() {\n        if let Some(n) = node {\n            result.push(Some(n.val));\n            queue.push_back(n.left);\n            queue.push_back(n.right);\n        } else {\n            result.push(None);\n        }\n    }\n    while let Some(None) = result.last() {\n        result.pop();\n    }\n    result\n}"
      },
      "ruby": {
        "functionDeclaration": "def AverageOfLevelsInBinaryTree(root)\nend",
        "testCalls": [
          "root = build_tree([3,9,20,nil,nil,15,7])\nif tree_to_array(AverageOfLevelsInBinaryTree(root)) != [3.00000,14.50000,11.00000]\n  raise 'Test Case 1 Failed'\nend"
        ],
        "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend",
        "helpers": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend\ndef build_tree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef tree_to_array(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend",
        "typeDefs": "class TreeNode\n  attr_accessor :val, :left, :right\n  def initialize(val = 0, left = nil, right = nil)\n    @val = val\n    @left = left\n    @right = right\n  end\nend",
        "builders": "def build_tree(arr)\n  return nil if arr.empty? || arr[0].nil?\n  root = TreeNode.new(arr[0])\n  queue = [root]\n  i = 1\n  while !queue.empty? && i < arr.length\n    node = queue.shift\n    if i < arr.length && !arr[i].nil?\n      node.left = TreeNode.new(arr[i])\n      queue.push(node.left)\n    end\n    i += 1\n    if i < arr.length && !arr[i].nil?\n      node.right = TreeNode.new(arr[i])\n      queue.push(node.right)\n    end\n    i += 1\n  end\n  root\nend\ndef tree_to_array(root)\n  return [] if root.nil?\n  result = []\n  queue = [root]\n  while !queue.empty?\n    node = queue.shift\n    if node\n      result.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    else\n      result.push(nil)\n    end\n  end\n  result.pop while result.last.nil?\n  result\nend"
      },
      "displayCases": [
        {
          "caseNumber": 1,
          "inputs": {
            "root": "[3,9,20,null,null,15,7]"
          },
          "expected": "[3.00000,14.50000,11.00000]"
        },
        {
          "caseNumber": 2,
          "inputs": {
            "root": "[3,9,20,15,7]"
          },
          "expected": "[3.00000,14.50000,11.00000]"
        }
      ]
    }
}