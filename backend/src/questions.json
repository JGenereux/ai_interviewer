{
  "3sum": {
    "title": "3Sum",
    "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n\nConstraints:\n\n3 <= nums.length <= 3000\n-105 <= nums[i] <= 105\n\n",
    "difficulty": "Medium",
    "hints": [
      "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
      "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ThreeSum(nums) {}",
      "testCalls": [
        "if(JSON.stringify(ThreeSum([-1,0,1,2,-1,-4])) !== JSON.stringify([[-1,-1,2],[-1,0,1]]) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(ThreeSum([0,1,1])) !== JSON.stringify([]) { throw new Error('Test Case 2 Failed'); }",
        "if(JSON.stringify(ThreeSum([0,0,0])) !== JSON.stringify([[0,0,0]]) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ThreeSum(nums: number[]): number[][] {}",
      "testCalls": [
        "const test1 = ThreeSum([-1,0,1,2,-1,-4]); if (JSON.stringify(test1) !== JSON.stringify([[-1,-1,2],[-1,0,1]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ThreeSum([0,1,1]); if (JSON.stringify(test2) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = ThreeSum([0,0,0]); if (JSON.stringify(test3) !== JSON.stringify([[0,0,0]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> ThreeSum(vector<int>& nums);",
      "testCalls": [
        "auto result1 = ThreeSum({-1,0,1,2,-1,-4});\nif (result1 != vector<vector<int>>{{-1,-1,2},{-1,0,1}}) throw std::runtime_error(\"Test 1 failed\");",
        "auto result2 = ThreeSum({0,1,1});\nif (result2 != vector<vector<int>>{}) throw std::runtime_error(\"Test 2 failed\");",
        "auto result3 = ThreeSum({0,0,0});\nif (result3 != vector<vector<int>>{{0,0,0}}) throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": "bool compareVectors(const vector<vector<int>>& v1, const vector<vector<int>>& v2) {\n    if (v1.size() != v2.size()) return false;\n    for (int i = 0; i < v1.size(); ++i) {\n        if (v1[i] != v2[i]) return false;\n    }\n    return true;\n}"
    },
    "python": {
      "functionDeclaration": "def ThreeSum(nums):",
      "testCalls": [
        "assert ThreeSum([-1,0,1,2,-1,-4]) == [[-1,-1,2],[-1,0,1]]",
        "assert ThreeSum([0,1,1]) == []",
        "assert ThreeSum([0,0,0]) == [[0,0,0]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> threeSum(int[] nums) {}",
      "testCalls": [
        "List<List<Integer>> result1 = threeSum(new int[]{-1,0,1,2,-1,-4});\nif (!compareLists(result1, Arrays.asList(Arrays.asList(-1,-1,2), Arrays.asList(-1,0,1)))) throw new AssertionError();",
        "List<List<Integer>> result2 = threeSum(new int[]{0,1,1});\nif (!compareLists(result2, Collections.emptyList())) throw new AssertionError();",
        "List<List<Integer>> result3 = threeSum(new int[]{0,0,0});\nif (!compareLists(result3, Collections.singletonList(Arrays.asList(0,0,0)))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) {\n    if (list1.size() != list2.size()) return false;\n    for (List<Integer> l : list1) {\n        if (!list2.contains(l)) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int** ThreeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int returnSize1; int* returnColumnSizes1; int** result1 = ThreeSum((int[]){-1,0,1,2,-1,-4}, 6, &returnSize1, &returnColumnSizes1); if (returnSize1 == 2 && compareArrays(result1, returnSize1, 3, (int*[]){(int[]){-1,-1,2}, (int[]){-1,0,1}})) { printf(\"Test case 1 passed.\"); } else { printf(\"Test case 1 failed.\"); }",
        "int returnSize2; int* returnColumnSizes2; int** result2 = ThreeSum((int[]){0,1,1}, 3, &returnSize2, &returnColumnSizes2); if (returnSize2 == 0) { printf(\"Test case 2 passed.\"); } else { printf(\"Test case 2 failed.\"); }"
      ],
      "compareHelper": "int compareArrays(int** arr1, int size1, int size2, int** arr2) { if (size1 != size2) { return 0; } for (int i = 0; i < size1; i++) { if (memcmp(arr1[i], arr2[i], sizeof(int) * 3) != 0) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func ThreeSum(nums []int) [][]int {}",
      "testCalls": [
        "if !compareArrays(ThreeSum([]int{-1,0,1,2,-1,-4}), [][]int{{-1,-1,2},{-1,0,1}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(ThreeSum([]int{0,1,1}), [][]int{}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(ThreeSum([]int{0,0,0}), [][]int{{0,0,0}}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if !compareArray(arr1[i], arr2[i]) { return false } } return true } func compareArray(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := 0; i < len(arr1); i++ { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "ruby": {
      "functionDeclaration": "def ThreeSum(nums)\n  \nend",
      "testCalls": [
        "nums1 = [-1,0,1,2,-1,-4]\nexpected1 = [[-1,-1,2],[-1,0,1]]\nresult1 = ThreeSum(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected1",
        "nums2 = [0,1,1]\nexpected2 = []\nresult2 = ThreeSum(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected2"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "add-two-numbers": {
    "title": "Add Two Numbers",
    "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sumas a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nExample 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function AddTwoNumbers(l1, l2) {}",
      "testCalls": [
        "let result1 = AddTwoNumbers([2,4,3], [5,6,4]); if (JSON.stringify(result1) !== JSON.stringify([7,0,8])) { throw new Error('Test Case 1 Failed'); }",
        "let result2 = AddTwoNumbers([0], [0]); if (JSON.stringify(result2) !== JSON.stringify([0])) { throw new Error('Test Case 2 Failed'); }",
        "let result3 = AddTwoNumbers([9,9,9,9,9,9,9], [9,9,9,9]); if (JSON.stringify(result3) !== JSON.stringify([8,9,9,9,0,0,0,1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function AddTwoNumbers(l1: number[], l2: number[]): number[] { }",
      "testCalls": [
        "const test1 = AddTwoNumbers([2,4,3], [5,6,4]); if (JSON.stringify(test1) !== JSON.stringify([7,0,8])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = AddTwoNumbers([0], [0]); if (JSON.stringify(test2) !== JSON.stringify([0])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = AddTwoNumbers([9,9,9,9,9,9,9], [9,9,9,9]); if (JSON.stringify(test3) !== JSON.stringify([8,9,9,9,0,0,0,1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
      "testCalls": [
        "ListNode* result1 = AddTwoNumbers(createLinkedList({2,4,3}), createLinkedList({5,6,4}));\nif (!compareLinkedLists(result1, createLinkedList({7,0,8}))) throw std::runtime_error(\"Test Case 1 Failed\");",
        "ListNode* result2 = AddTwoNumbers(createLinkedList({0}), createLinkedList({0}));\nif (!compareLinkedLists(result2, createLinkedList({0}))) throw std::runtime_error(\"Test Case 2 Failed\");",
        "ListNode* result3 = AddTwoNumbers(createLinkedList({9,9,9,9,9,9,9}), createLinkedList({9,9,9,9}));\nif (!compareLinkedLists(result3, createLinkedList({8,9,9,9,0,0,0,1}))) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) {\n    while (l1 && l2) {\n        if (l1->val != l2->val) return false;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    return l1 == nullptr && l2 == nullptr;\n}"
    },
    "python": {
      "functionDeclaration": "def AddTwoNumbers(l1, l2):",
      "testCalls": [
        "result1 = AddTwoNumbers([2,4,3], [5,6,4]); assert result1 == [7,0,8], 'Test Case 1 Failed'",
        "result2 = AddTwoNumbers([0], [0]); assert result2 == [0], 'Test Case 2 Failed'",
        "result3 = AddTwoNumbers([9,9,9,9,9,9,9], [9,9,9,9]); assert result3 == [8,9,9,9,0,0,0,1], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) { }",
      "testCalls": [
        "ListNode result1 = addTwoNumbers(createLinkedList(new int[]{2,4,3}), createLinkedList(new int[]{5,6,4}));\ncompareLinkedLists(result1, createLinkedList(new int[]{7,0,8}));",
        "ListNode result2 = addTwoNumbers(createLinkedList(new int[]{0}), createLinkedList(new int[]{0}));\ncompareLinkedLists(result2, createLinkedList(new int[]{0}));",
        "ListNode result3 = addTwoNumbers(createLinkedList(new int[]{9,9,9,9,9,9,9}), createLinkedList(new int[]{9,9,9,9}));\ncompareLinkedLists(result3, createLinkedList(new int[]{8,9,9,9,0,0,0,1}));"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode l1, ListNode l2) {\n    while (l1 != null && l2 != null) {\n        if (l1.val != l2.val) {\n            throw new AssertionError(\"Test case failed\");\n        }\n        l1 = l1.next;\n        l2 = l2.next;\n    }\n    if (l1 != null || l2 != null) {\n        throw new AssertionError(\"Test case failed\");\n    }\n}"
    },
    "c": {
      "functionDeclaration": "ListNode* AddTwoNumbers(ListNode* l1, ListNode* l2)",
      "testCalls": [
        "ListNode* result1 = AddTwoNumbers(createLinkedList({2,4,3}), createLinkedList({5,6,4}));\nif (!compareLinkedLists(result1, createLinkedList({7,0,8}))) { printf(\"Test Case 1 Failed\"); }",
        "ListNode* result2 = AddTwoNumbers(createLinkedList({0}), createLinkedList({0}));\nif (!compareLinkedLists(result2, createLinkedList({0}))) { printf(\"Test Case 2 Failed\"); }",
        "ListNode* result3 = AddTwoNumbers(createLinkedList({9,9,9,9,9,9,9}), createLinkedList({9,9,9,9}));\nif (!compareLinkedLists(result3, createLinkedList({8,9,9,9,0,0,0,1}))) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": "int compareLinkedLists(ListNode* l1, ListNode* l2) {\n    while (l1 != NULL && l2 != NULL) {\n        if (l1->val != l2->val) return 0;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    return l1 == NULL && l2 == NULL;\n}"
    },
    "go": {
      "functionDeclaration": "func AddTwoNumbers(l1 []int, l2 []int) []int {}",
      "testCalls": [
        "result1 := AddTwoNumbers([]int{2, 4, 3}, []int{5, 6, 4}); if !compareArrays(result1, []int{7, 0, 8}) { t.Errorf(\"Test case 1 failed\") }",
        "result2 := AddTwoNumbers([]int{0}, []int{0}); if !compareArrays(result2, []int{0}) { t.Errorf(\"Test case 2 failed\") }",
        "result3 := AddTwoNumbers([]int{9, 9, 9, 9, 9, 9, 9}, []int{9, 9, 9, 9}); if !compareArrays(result3, []int{8, 9, 9, 9, 0, 0, 0, 1}) { t.Errorf(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 []int, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn AddTwoNumbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "let test1_expected = vec![7, 0, 8]; let test1_result = AddTwoNumbers(Some(Box::new(ListNode::new(2))), Some(Box::new(ListNode::new(5)))); assert_eq!(test1_result.unwrap().to_vec(), test1_expected);",
        "let test2_expected = vec![0]; let test2_result = AddTwoNumbers(Some(Box::new(ListNode::new(0))), Some(Box::new(ListNode::new(0)))); assert_eq!(test2_result.unwrap().to_vec(), test2_expected);",
        "let test3_expected = vec![8, 9, 9, 9, 0, 0, 0, 1]; let test3_result = AddTwoNumbers(Some(Box::new(ListNode::new(9))), Some(Box::new(ListNode::new(9)))); assert_eq!(test3_result.unwrap().to_vec(), test3_expected);"
      ],
      "compareHelper": "fn compare_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> bool { if list1.is_none() && list2.is_none() { return true; } let mut current1 = list1; let mut current2 = list2; while let (Some(node1), Some(node2)) = (current1, current2) { if node1.val != node2.val { return false; } current1 = node1.next.clone(); current2 = node2.next.clone(); } current1.is_none() && current2.is_none() }"
    },
    "ruby": {
      "functionDeclaration": "def AddTwoNumbers(l1, l2)\nend",
      "testCalls": [
        "result1 = AddTwoNumbers([2,4,3], [5,6,4])\nraise 'Test Case 1 Failed' unless result1 == [7,0,8]",
        "result2 = AddTwoNumbers([0], [0])\nraise 'Test Case 2 Failed' unless result2 == [0]",
        "result3 = AddTwoNumbers([9,9,9,9,9,9,9], [9,9,9,9])\nraise 'Test Case 3 Failed' unless result3 == [8,9,9,9,0,0,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "average-of-levels-in-binary-tree": {
    "title": "Average of Levels in Binary Tree",
    "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n\nExample 2:\n\n\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function AverageOfLevelsInBinaryTree(root) {}",
      "testCalls": [
        "const test1 = AverageOfLevelsInBinaryTree([3,9,20,null,null,15,7]); if(JSON.stringify(test1) !== '[3.00000,14.50000,11.00000]') { throw new Error('Test Case 1 Failed'); }",
        "const test2 = AverageOfLevelsInBinaryTree([3,9,20,15,7]); if(JSON.stringify(test2) !== '[3.00000,14.50000,11.00000]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysAreEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function AverageOfLevelsInBinaryTree(root: TreeNode | null): number[]",
      "testCalls": [
        "if(JSON.stringify(AverageOfLevelsInBinaryTree(createBinaryTree([3,9,20,null,null,15,7]))) !== JSON.stringify([3.00000,14.50000,11.00000])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(AverageOfLevelsInBinaryTree(createBinaryTree([3,9,20,15,7]))) !== JSON.stringify([3.00000,14.50000,11.00000])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<double> AverageOfLevelsInBinaryTree(TreeNode* root)",
      "testCalls": [
        "auto result1 = AverageOfLevelsInBinaryTree(createTree({3,9,20,{}, {}, 15, 7}));\nif (!compareArrays(result1, {3.0, 14.5, 11.0})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = AverageOfLevelsInBinaryTree(createTree({3,9,20,15,7}));\nif (!compareArrays(result2, {3.0, 14.5, 11.0})) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "bool compareArrays(vector<double>& arr1, vector<double>& arr2) {\n    if (arr1.size() != arr2.size()) return false;\n    for (int i = 0; i < arr1.size(); ++i) {\n        if (abs(arr1[i] - arr2[i]) > 1e-5) return false;\n    }\n    return true;\n}"
    },
    "python": {
      "functionDeclaration": "def AverageOfLevelsInBinaryTree(root: TreeNode) -> List[float]:",
      "testCalls": [
        "result1 = AverageOfLevelsInBinaryTree(deserialize('[3,9,20,null,null,15,7]')); assert result1 == [3.00000,14.50000,11.00000], 'Test Case 1 Failed'",
        "result2 = AverageOfLevelsInBinaryTree(deserialize('[3,9,20,15,7]')); assert result2 == [3.00000,14.50000,11.00000], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def assertArrayEquals(arr1, arr2): assert len(arr1) == len(arr2) and all(a == b for a, b in zip(arr1, arr2)), 'Arrays not equal'"
    },
    "java": {
      "functionDeclaration": "public double[] AverageOfLevels(TreeNode root)",
      "testCalls": [
        "assertArrayEquals(new double[]{3.00000, 14.50000, 11.00000}, AverageOfLevels(TreeNode.fromArray(new Integer[]{3, 9, 20, null, null, 15, 7})))",
        "assertArrayEquals(new double[]{3.00000, 14.50000, 11.00000}, AverageOfLevels(TreeNode.fromArray(new Integer[]{3, 9, 20, 15, 7})))"
      ],
      "compareHelper": "private static void assertArrayEquals(double[] expected, double[] actual) {\n    if (!Arrays.equals(expected, actual)) {\n        throw new AssertionError(\"Arrays not equal: expected \" + Arrays.toString(expected) + \" but was \" + Arrays.toString(actual));\n    }\n}"
    },
    "c": {
      "functionDeclaration": "double* AverageOfLevelsInBinaryTree(struct TreeNode* root, int* returnSize)",
      "testCalls": [
        "double* result1 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]) {3,9,20,0,0,15,7}, 7), &returnSize); assert(compareDoubleArrays(result1, 3, (double[]) {3.00000,14.50000,11.00000}, 3));",
        "double* result2 = AverageOfLevelsInBinaryTree(createTreeFromArray((int[]) {3,9,20,15,7}, 5), &returnSize); assert(compareDoubleArrays(result2, 3, (double[]) {3.00000,14.50000,11.00000}, 3));"
      ],
      "compareHelper": "int compareDoubleArrays(double* arr1, int size1, double* arr2, int size2) { if (size1 != size2) return 0; for (int i = 0; i < size1; i++) { if (fabs(arr1[i] - arr2[i]) > 0.00001) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func AverageOfLevels(root *TreeNode) []float64 {}",
      "testCalls": [
        "if !compareFloatArrays(AverageOfLevels(&TreeNode{Val: 3, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 7}}}), []float64{3.00000, 14.50000, 11.00000}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareFloatArrays(AverageOfLevels(&TreeNode{Val: 3, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 7}}}), []float64{3.00000, 14.50000, 11.00000}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareFloatArrays(arr1, arr2 []float64) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if math.Abs(arr1[i]-arr2[i]) > 0.00001 { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn AverageOfLevelsInBinaryTree(root: Option<Box<TreeNode>>) -> Vec<f64> { }",
      "testCalls": [
        "assert_eq!(AverageOfLevelsInBinaryTree(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 9, left: None, right: None })), right: Some(Box::new(TreeNode { val: 20, left: Some(Box::new(TreeNode { val: 15, left: None, right: None })), right: Some(Box::new(TreeNode { val: 7, left: None, right: None })) })) })), vec![3.0, 14.5, 11.0]);",
        "assert_eq!(AverageOfLevelsInBinaryTree(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 9, left: Some(Box::new(TreeNode { val: 15, left: None, right: None })), right: Some(Box::new(TreeNode { val: 7, left: None, right: None })) })), right: Some(Box::new(TreeNode { val: 20, left: None, right: None })) })), vec![3.0, 14.5, 11.0]);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def AverageOfLevelsInBinaryTree(root)\nend",
      "testCalls": [
        "test_case_1 = AverageOfLevelsInBinaryTree([3,9,20,null,null,15,7])\nraise 'Test Case 1 Failed' unless test_case_1 == [3.00000,14.50000,11.00000]",
        "test_case_2 = AverageOfLevelsInBinaryTree([3,9,20,15,7])\nraise 'Test Case 2 Failed' unless test_case_2 == [3.00000,14.50000,11.00000]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "basic-calculator": {
    "title": "Basic Calculator",
    "content": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\nExample 1:\n\nInput: s = &quot;1 + 1&quot;\nOutput: 2\n\nExample 2:\n\nInput: s = &quot; 2-1 + 2 &quot;\nOutput: 3\n\nExample 3:\n\nInput: s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\nOutput: 23\n\n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists of digits, &#39;+&#39;, &#39;-&#39;, &#39;(&#39;, &#39;)&#39;, and &#39; &#39;.\ns represents a valid expression.\n&#39;+&#39; is not used as a unary operation (i.e., &quot;+1&quot; and &quot;+(2 + 3)&quot; is invalid).\n&#39;-&#39; could be used as a unary operation (i.e., &quot;-1&quot; and &quot;-(2 + 3)&quot; is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Math",
      "String",
      "Stack",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "BasicCalculator(s)",
      "testCalls": [
        "if(BasicCalculator(\"1+1\") !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BasicCalculator(\"2-1+2\") !== 3) { throw new Error('Test Case 2 Failed'); }",
        "if(BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BasicCalculator(s: string): number {}",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") !== 2) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (BasicCalculator(\"2-1+2\") !== 3) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") !== 23) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int BasicCalculator(string s);",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") != 2) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (BasicCalculator(\"2-1+2\") != 3) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BasicCalculator(s: str) -> int:",
      "testCalls": [
        "assert BasicCalculator(\"1+1\") == 2",
        "assert BasicCalculator(\"2-1+2\") == 3",
        "assert BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") == 23"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BasicCalculator(String s) { }",
      "testCalls": [
        "if (BasicCalculator(\"1+1\") != 2) throw new AssertionError();",
        "if (BasicCalculator(\"2-1+2\") != 3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BasicCalculator(char* s)",
      "testCalls": [
        "if(BasicCalculator(\"1+1\") != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(BasicCalculator(\"2-1+2\") != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BasicCalculator(s string) int {}",
      "testCalls": [
        "if BasicCalculator(\"1+1\") != 2 { t.Error(\"Test case 1 failed\") }",
        "if BasicCalculator(\"2-1+2\") != 3 { t.Error(\"Test case 2 failed\") }",
        "if BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\") != 23 { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BasicCalculator(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(BasicCalculator(String::from(\"1+1\")), 2);",
        "assert_eq!(BasicCalculator(String::from(\"2-1+2\")), 3);",
        "assert_eq!(BasicCalculator(String::from(\"(1+(4+5+2)-3)+(6+8)\")), 23);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BasicCalculator(s)",
      "testCalls": [
        "result1 = BasicCalculator(\"1+1\"); raise 'Test Case 1 Failed' unless result1 == 2",
        "result2 = BasicCalculator(\"2-1+2\"); raise 'Test Case 2 Failed' unless result2 == 3",
        "result3 = BasicCalculator(\"(1+(4+5+2)-3)+(6+8)\"); raise 'Test Case 3 Failed' unless result3 == 23"
      ],
      "compareHelper": ""
    }
  },
  "best-time-to-buy-and-sell-stock-ii": {
    "title": "Best Time to Buy and Sell Stock II",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.\nFind and return the maximum profit you can achieve.\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\nConstraints:\n\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockII(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(BestTimeToBuyAndSellStockII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockII(prices: number[]): number {}",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (BestTimeToBuyAndSellStockII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxProfit(std::vector<int>& prices);",
      "testCalls": [
        "assert(MaxProfit({7,1,5,3,6,4}) == 7);",
        "assert(MaxProfit({1,2,3,4,5}) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockII(prices: List[int]) -> int:",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockII([7,1,5,3,6,4]) == 7",
        "assert BestTimeToBuyAndSellStockII([1,2,3,4,5]) == 4",
        "assert BestTimeToBuyAndSellStockII([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockII(int[] prices) { }",
      "testCalls": [
        "int[] testInput1 = {7, 1, 5, 3, 6, 4};\nint expectedOutput1 = 7;\nint result1 = BestTimeToBuyAndSellStockII(testInput1);\nif (result1 != expectedOutput1) { throw new AssertionError(); }",
        "int[] testInput2 = {1, 2, 3, 4, 5};\nint expectedOutput2 = 4;\nint result2 = BestTimeToBuyAndSellStockII(testInput2);\nif (result2 != expectedOutput2) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit((int[]){7,1,5,3,6,4}, 6) != 7) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfit((int[]){1,2,3,4,5}, 5) != 4) { printf(\"Test Case 2 Failed\"); }",
        "if(MaxProfit((int[]){7,6,4,3,1}, 5) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxProfit(prices []int) int {}",
      "testCalls": [
        "if MaxProfit([]int{7,1,5,3,6,4}) != 7 {panic(\"Test case 1 failed\")}",
        "if MaxProfit([]int{1,2,3,4,5}) != 4 {panic(\"Test case 2 failed\")}",
        "if MaxProfit([]int{7,6,4,3,1}) != 0 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockII(prices: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![7,1,5,3,6,4]), 7);",
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![1,2,3,4,5]), 4);",
        "assert_eq!(BestTimeToBuyAndSellStockII(vec![7,6,4,3,1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockII(prices)\nend",
      "testCalls": [
        "test_case_1 = BestTimeToBuyAndSellStockII([7,1,5,3,6,4])\nraise 'Test Case 1 Failed' unless test_case_1 == 7",
        "test_case_2 = BestTimeToBuyAndSellStockII([1,2,3,4,5])\nraise 'Test Case 2 Failed' unless test_case_2 == 4"
      ],
      "compareHelper": ""
    }
  },
  "best-time-to-buy-and-sell-stock-iii": {
    "title": "Best Time to Buy and Sell Stock III",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n\n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 105\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIII(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(BestTimeToBuyAndSellStockIII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIII(prices: number[]): number {}",
      "testCalls": [
        "if (BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BestTimeToBuyAndSellStockIII([1,2,3,4,5]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if (BestTimeToBuyAndSellStockIII([7,6,4,3,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxProfitIII(vector<int>& prices)",
      "testCalls": [
        "assert(MaxProfitIII({3,3,5,0,0,3,1,4}) == 6);",
        "assert(MaxProfitIII({1,2,3,4,5}) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIII(prices: List[int]) -> int:",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4]) == 6",
        "assert BestTimeToBuyAndSellStockIII([1,2,3,4,5]) == 4",
        "assert BestTimeToBuyAndSellStockIII([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockIII(int[] prices) {}",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIII(new int[]{3,3,5,0,0,3,1,4}) == 6;",
        "assert BestTimeToBuyAndSellStockIII(new int[]{1,2,3,4,5}) == 4;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfitIII(int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfitIII((int[]){3,3,5,0,0,3,1,4}, 8) != 6) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfitIII((int[]){1,2,3,4,5}, 5) != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BestTimeToBuyAndSellStockIII(prices []int) int {}",
      "testCalls": [
        "if BestTimeToBuyAndSellStockIII([]int{3,3,5,0,0,3,1,4}) != 6 {panic(\"Test case 1 failed\")}",
        "if BestTimeToBuyAndSellStockIII([]int{1,2,3,4,5}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockIII(prices: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockIII(vec![3,3,5,0,0,3,1,4]), 6);",
        "assert_eq!(BestTimeToBuyAndSellStockIII(vec![1,2,3,4,5]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIII(prices)\nend",
      "testCalls": [
        "result1 = BestTimeToBuyAndSellStockIII([3,3,5,0,0,3,1,4])\nraise 'Test Case 1 Failed' unless result1 == 6",
        "result2 = BestTimeToBuyAndSellStockIII([1,2,3,4,5])\nraise 'Test Case 2 Failed' unless result2 == 4"
      ],
      "compareHelper": ""
    }
  },
  "best-time-to-buy-and-sell-stock-iv": {
    "title": "Best Time to Buy and Sell Stock IV",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\nExample 2:\n\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n\nConstraints:\n\n1 <= k <= 100\n1 <= prices.length <= 1000\n0 <= prices[i] <= 1000\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIV(k, prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIV(2, [2,4,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) !== 7) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStockIV(k: number, prices: number[]): number {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStockIV(2, [2,4,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) !== 7) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxProfit(int k, vector<int>& prices);",
      "testCalls": [
        "assert(MaxProfit(2, {2,4,1}) == 2);",
        "assert(MaxProfit(2, {3,2,6,5,0,3}) == 7);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIV(k: int, prices: List[int]) -> int:",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIV(2, [2,4,1]) == 2",
        "assert BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3]) == 7"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int BestTimeToBuyAndSellStockIV(int k, int[] prices) {}",
      "testCalls": [
        "assert BestTimeToBuyAndSellStockIV(2, new int[]{2,4,1}) == 2;",
        "assert BestTimeToBuyAndSellStockIV(2, new int[]{3,2,6,5,0,3}) == 7;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int k, int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit(2, (int[]){2,4,1}, 3) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfit(2, (int[]){3,2,6,5,0,3}, 6) != 7) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BestTimeToBuyAndSellStockIV(k int, prices []int) int {}",
      "testCalls": [
        "if result := BestTimeToBuyAndSellStockIV(2, []int{2,4,1}); result != 2 { t.Errorf(\"Test 1 failed. Expected: %v, but got: %v\", 2, result) }",
        "if result := BestTimeToBuyAndSellStockIV(2, []int{3,2,6,5,0,3}); result != 7 { t.Errorf(\"Test 2 failed. Expected: %v, but got: %v\", 7, result) }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStockIV(k: i32, prices: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStockIV(2, vec![2, 4, 1]), 2);",
        "assert_eq!(BestTimeToBuyAndSellStockIV(2, vec![3, 2, 6, 5, 0, 3]), 7);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStockIV(k, prices)\nend",
      "testCalls": [
        "result1 = BestTimeToBuyAndSellStockIV(2, [2,4,1])\nraise 'Test Case 1 Failed' unless result1 == 2",
        "result2 = BestTimeToBuyAndSellStockIV(2, [3,2,6,5,0,3])\nraise 'Test Case 2 Failed' unless result2 == 7"
      ],
      "compareHelper": ""
    }
  },
  "best-time-to-buy-and-sell-stock": {
    "title": "Best Time to Buy and Sell Stock",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n\nConstraints:\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BestTimeToBuyAndSellStock(prices) {}",
      "testCalls": [
        "if(BestTimeToBuyAndSellStock([7,1,5,3,6,4]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(BestTimeToBuyAndSellStock([7,6,4,3,1]) !== 0) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxProfit(prices: number[]): number {}",
      "testCalls": [
        "if(MaxProfit([7,1,5,3,6,4]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxProfit([7,6,4,3,1]) !== 0) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxProfit(vector<int>& prices);",
      "testCalls": [
        "if(MaxProfit({7,1,5,3,6,4}) != 5) throw std::runtime_error(\"Test 1 failed\");",
        "if(MaxProfit({7,6,4,3,1}) != 0) throw std::runtime_error(\"Test 2 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BestTimeToBuyAndSellStock(prices: List[int]) -> int",
      "testCalls": [
        "assert BestTimeToBuyAndSellStock([7,1,5,3,6,4]) == 5",
        "assert BestTimeToBuyAndSellStock([7,6,4,3,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaxProfit(int[] prices) { }",
      "testCalls": [
        "if(MaxProfit(new int[]{7,1,5,3,6,4}) != 5) throw new AssertionError();",
        "if(MaxProfit(new int[]{7,6,4,3,1}) != 0) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxProfit(int* prices, int pricesSize)",
      "testCalls": [
        "if(MaxProfit((int[]) {7,1,5,3,6,4}, 6) != 5) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxProfit((int[]) {7,6,4,3,1}, 5) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxProfit(prices []int) int {}",
      "testCalls": [
        "if MaxProfit([]int{7,1,5,3,6,4}) != 5 { panic(\"Test case 1 failed\") }",
        "if MaxProfit([]int{7,6,4,3,1}) != 0 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BestTimeToBuyAndSellStock(prices: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(BestTimeToBuyAndSellStock(vec![7, 1, 5, 3, 6, 4]), 5);",
        "assert_eq!(BestTimeToBuyAndSellStock(vec![7, 6, 4, 3, 1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BestTimeToBuyAndSellStock(prices)\nend",
      "testCalls": [
        "test 'Example 1' do\n  expect(BestTimeToBuyAndSellStock([7,1,5,3,6,4])).to eq(5)\nend",
        "test 'Example 2' do\n  expect(BestTimeToBuyAndSellStock([7,6,4,3,1])).to eq(0)\nend"
      ],
      "compareHelper": ""
    }
  },
  "binary-tree-level-order-traversal": {
    "title": "Binary Tree Level Order Traversal",
    "content": "Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000\n\n",
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS."
    ],
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeLevelOrderTraversal(root) {}",
      "testCalls": [
        "const test1 = BinaryTreeLevelOrderTraversal([3,9,20,null,null,15,7]); if(JSON.stringify(test1) !== '[[3],[9,20],[15,7]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2 = BinaryTreeLevelOrderTraversal([1]); if(JSON.stringify(test2) !== '[[1]]') { throw new Error('Test Case 2 Failed'); }",
        "const test3 = BinaryTreeLevelOrderTraversal([]); if(JSON.stringify(test3) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeLevelOrderTraversal(root: TreeNode | null): number[][] {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(createTreeNode([3,9,20,null,null,15,7]))) !== '[[3],[9,20],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(createTreeNode([1]))) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeLevelOrderTraversal(null)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null {\n  // implementation here\n}\n"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> BinaryTreeLevelOrderTraversal(TreeNode* root)",
      "testCalls": [
        "assert(BinaryTreeLevelOrderTraversal(createTree({3,9,20,null,null,15,7})) == vector<vector<int>>{{3},{9,20},{15,7}});",
        "assert(BinaryTreeLevelOrderTraversal(createTree({1})) == vector<vector<int>>{{1}});",
        "assert(BinaryTreeLevelOrderTraversal(nullptr) == vector<vector<int>>{});"
      ],
      "compareHelper": "bool compareVectors(vector<vector<int>>& v1, vector<vector<int>>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeLevelOrderTraversal(root):",
      "testCalls": [
        "assert BinaryTreeLevelOrderTraversal([3,9,20,null,null,15,7]) == [[3],[9,20],[15,7]], 'Test Case 1 Failed'",
        "assert BinaryTreeLevelOrderTraversal([1]) == [[1]], 'Test Case 2 Failed'",
        "assert BinaryTreeLevelOrderTraversal([]) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> BinaryTreeLevelOrderTraversal(TreeNode root) {}",
      "testCalls": [
        "List<List<Integer>> result1 = BinaryTreeLevelOrderTraversal(TreeNode.buildTree(new Integer[]{3, 9, 20, null, null, 15, 7}));\nif (!Arrays.deepEquals(result1.toArray(), new Integer[][]{{3}, {9, 20}, {15, 7}})) throw new AssertionError();",
        "List<List<Integer>> result2 = BinaryTreeLevelOrderTraversal(TreeNode.buildTree(new Integer[]{1}));\nif (!Arrays.deepEquals(result2.toArray(), new Integer[][]{{1}})) throw new AssertionError();",
        "List<List<Integer>> result3 = BinaryTreeLevelOrderTraversal(TreeNode.buildTree(new Integer[]{}));\nif (!Arrays.deepEquals(result3.toArray(), new Integer[][]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, List<List<Integer>> arr2) {\n    return Arrays.deepEquals(arr1.toArray(), arr2.toArray());\n}"
    },
    "c": {
      "functionDeclaration": "void BinaryTreeLevelOrderTraversal(struct TreeNode* root)",
      "testCalls": [
        "BinaryTreeLevelOrderTraversal(createTree(3, 9, 20, NULL, NULL, 15, 7));",
        "BinaryTreeLevelOrderTraversal(createTree(1));",
        "BinaryTreeLevelOrderTraversal(NULL);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BinaryTreeLevelOrderTraversal(root *TreeNode) [][]int {}",
      "testCalls": [
        "if !reflect.DeepEqual(BinaryTreeLevelOrderTraversal(&TreeNode{Val: 3, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 7}}}), [][]int{{3},{9,20},{15,7}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !reflect.DeepEqual(BinaryTreeLevelOrderTraversal(&TreeNode{Val: 1}), [][]int{{1}}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { return reflect.DeepEqual(arr1, arr2) }"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeLevelOrderTraversal(root: Option<Rc<RefCell<TreeNode>>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(BinaryTreeLevelOrderTraversal(Some(Rc::new(RefCell::new(TreeNode { val: 3, left: Some(Rc::new(RefCell::new(TreeNode { val: 9, left: None, right: None })), right: Some(Rc::new(RefCell::new(TreeNode { val: 20, left: Some(Rc::new(RefCell::new(TreeNode { val: 15, left: None, right: None })), right: Some(Rc::new(RefCell::new(TreeNode { val: 7, left: None, right: None })) }))) })))), None))), vec![vec![3], vec![9, 20], vec![15, 7]])",
        "assert_eq!(BinaryTreeLevelOrderTraversal(Some(Rc::new(RefCell::new(TreeNode { val: 1, left: None, right: None }))), vec![vec![1]])",
        "assert_eq!(BinaryTreeLevelOrderTraversal(None), vec![])"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeLevelOrderTraversal(root)\nend",
      "testCalls": [
        "test_case_1 = BinaryTreeLevelOrderTraversal([3,9,20,nil,nil,15,7])\nraise 'Test Case 1 Failed' unless test_case_1 == [[3],[9,20],[15,7]]",
        "test_case_2 = BinaryTreeLevelOrderTraversal([1])\nraise 'Test Case 2 Failed' unless test_case_2 == [[1]]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "binary-tree-maximum-path-sum": {
    "title": "Binary Tree Maximum Path Sum",
    "content": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\nExample 1:\n\n\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\nExample 2:\n\n\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 3 * 104].\n-1000 <= Node.val <= 1000\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeMaximumPathSum(root) {}",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum([1,2,3]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BinaryTreeMaximumPathSum([-10,9,20,null,null,15,7]) !== 42) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeMaximumPathSum(root: TreeNode | null): number {}",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(arrayToBinaryTree([1,2,3])) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (BinaryTreeMaximumPathSum(arrayToBinaryTree([-10,9,20,null,null,15,7])) !== 42) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arrayToBinaryTree(arr: (number | null)[]): TreeNode | null {}"
    },
    "c++": {
      "functionDeclaration": "int BinaryTreeMaximumPathSum(TreeNode* root)",
      "testCalls": [
        "assert(BinaryTreeMaximumPathSum(buildTree({1,2,3})) == 6);",
        "assert(BinaryTreeMaximumPathSum(buildTree({-10,9,20,INT_MIN,INT_MIN,15,7})) == 42);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeMaximumPathSum(root):",
      "testCalls": [
        "assert BinaryTreeMaximumPathSum([1,2,3]) == 6",
        "assert BinaryTreeMaximumPathSum([-10,9,20,None,None,15,7]) == 42"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BinaryTreeMaximumPathSum(TreeNode root) { }",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(new TreeNode(1, new TreeNode(2), new TreeNode(3))) != 6) { throw new AssertionError(); }",
        "if (BinaryTreeMaximumPathSum(new TreeNode(-10, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7)))) != 42) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BinaryTreeMaximumPathSum(struct TreeNode* root)",
      "testCalls": [
        "if (BinaryTreeMaximumPathSum(createTreeFromArray((int[]) {1,2,3}, 3)) != 6) { printf(\"Test Case 1 Failed\"); }",
        "if (BinaryTreeMaximumPathSum(createTreeFromArray((int[]) {-10,9,20,INT_MIN,INT_MIN,15,7}, 7)) != 42) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BinaryTreeMaximumPathSum(root *TreeNode) int {}",
      "testCalls": [
        "if BinaryTreeMaximumPathSum(BuildTree([]int{1, 2, 3})) != 6 { t.Error(\"Test Case 1 Failed\") }",
        "if BinaryTreeMaximumPathSum(BuildTree([]int{-10, 9, 20, math.MinInt32, math.MinInt32, 15, 7})) != 42 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func BuildTree(nodes []int) *TreeNode {}"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeMaximumPathSum(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(BinaryTreeMaximumPathSum(Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: None, right: None })), right: Some(Box::new(TreeNode { val: 3, left: None, right: None }) }))), 6);",
        "assert_eq!(BinaryTreeMaximumPathSum(Some(Box::new(TreeNode { val: -10, left: Some(Box::new(TreeNode { val: 9, left: None, right: None })), right: Some(Box::new(TreeNode { val: 20, left: Some(Box::new(TreeNode { val: 15, left: None, right: None })), right: Some(Box::new(TreeNode { val: 7, left: None, right: None })) } }))), 42);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeMaximumPathSum(root)\nend",
      "testCalls": [
        "test_case_1 = BinaryTreeMaximumPathSum([1,2,3])\nraise 'Test Case 1 Failed' unless test_case_1 == 6",
        "test_case_2 = BinaryTreeMaximumPathSum([-10,9,20,nil,nil,15,7])\nraise 'Test Case 2 Failed' unless test_case_2 == 42"
      ],
      "compareHelper": ""
    }
  },
  "binary-tree-right-side-view": {
    "title": "Binary Tree Right Side View",
    "content": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\nExample 1:\n\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\nExplanation:\n\n\nExample 2:\n\nInput: root = [1,2,3,4,null,null,null,5]\nOutput: [1,3,4,5]\nExplanation:\n\n\nExample 3:\n\nInput: root = [1,null,3]\nOutput: [1,3]\n\nExample 4:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeRightSideView(root) {}",
      "testCalls": [
        "BinaryTreeRightSideView([1,2,3,null,5,null,4]) === [1,3,4] || (() => {throw new Error('Test Case 1 Failed')})()",
        "BinaryTreeRightSideView([1,2,3,4,null,null,null,5]) === [1,3,4,5] || (() => {throw new Error('Test Case 2 Failed')})()"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeRightSideView(root: TreeNode | null): number[] {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,2,3,null,5,null,4]))) !== JSON.stringify([1,3,4])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,2,3,4,null,null,null,5]))) !== JSON.stringify([1,3,4,5])) throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(createTreeNode([1,null,3]))) !== JSON.stringify([1,3])) throw new Error('Test Case 3 Failed');",
        "if(JSON.stringify(BinaryTreeRightSideView(null)) !== JSON.stringify([])) throw new Error('Test Case 4 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift(); if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }"
    },
    "c++": {
      "functionDeclaration": "vector<int> BinaryTreeRightSideView(TreeNode* root)",
      "testCalls": [
        "assert(BinaryTreeRightSideView(buildTree({1,2,3,null,5,null,4})) == vector<int>({1,3,4}));",
        "assert(BinaryTreeRightSideView(buildTree({1,2,3,4,null,null,null,5})) == vector<int>({1,3,4,5}));",
        "assert(BinaryTreeRightSideView(buildTree({1,null,3})) == vector<int>({1,3}));",
        "assert(BinaryTreeRightSideView(nullptr) == vector<int>({}));"
      ],
      "compareHelper": "bool compareVectors(vector<int>& v1, vector<int>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeRightSideView(root):",
      "testCalls": [
        "assert BinaryTreeRightSideView([1,2,3,null,5,null,4]) == [1,3,4]",
        "assert BinaryTreeRightSideView([1,2,3,4,null,null,null,5]) == [1,3,4,5]",
        "assert BinaryTreeRightSideView([1,null,3]) == [1,3]",
        "assert BinaryTreeRightSideView([]) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 == arr2:\n        return True\n    else:\n        raise AssertionError(f'Arrays not equal: {arr1} != {arr2}')"
    },
    "java": {
      "functionDeclaration": "public List<Integer> BinaryTreeRightSideView(TreeNode root) {}",
      "testCalls": [
        "assert Arrays.equals(new int[]{1,3,4}, BinaryTreeRightSideView(TreeNode.createTreeFromString(\"[1,2,3,null,5,null,4]\"))) : \"Test Case 1 Failed\";",
        "assert Arrays.equals(new int[]{1,3,4,5}, BinaryTreeRightSideView(TreeNode.createTreeFromString(\"[1,2,3,4,null,null,null,5]\"))) : \"Test Case 2 Failed\";"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "void BinaryTreeRightSideView(struct TreeNode* root)",
      "testCalls": [
        "BinaryTreeRightSideView(root); // Compare result with expected for test case 1",
        "BinaryTreeRightSideView(root); // Compare result with expected for test case 2"
      ],
      "compareHelper": "void compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { printf(\"Test Failed\"); exit(1); } } }"
    },
    "go": {
      "functionDeclaration": "func BinaryTreeRightSideView(root *TreeNode) []int {}",
      "testCalls": [
        "if fmt.Sprint(BinaryTreeRightSideView(Deserialize(\"[1,2,3,null,5,null,4]\"))) != \"[1 3 4]\" { t.Error() }",
        "if fmt.Sprint(BinaryTreeRightSideView(Deserialize(\"[1,2,3,4,null,null,null,5]\"))) != \"[1 3 4 5]\" { t.Error() }"
      ],
      "compareHelper": "func Deserialize(data string) *TreeNode {}"
    },
    "rust": {
      "functionDeclaration": "fn BinaryTreeRightSideView(root: Option<Rc<RefCell<TreeNode>>) -> Vec<i32> { }",
      "testCalls": [
        "assert_eq!(BinaryTreeRightSideView(Some(Rc::new(RefCell::new(TreeNode { val: 1, left: Some(Rc::new(RefCell::new(TreeNode { val: 2, left: None, right: Some(Rc::new(RefCell::new(TreeNode { val: 5, left: None, right: None })) })), right: Some(Rc::new(RefCell::new(TreeNode { val: 3, left: None, right: Some(Rc::new(RefCell::new(TreeNode { val: 4, left: None, right: None })) }))) })))), right: None }))), vec![1, 3, 4]);",
        "assert_eq!(BinaryTreeRightSideView(Some(Rc::new(RefCell::new(TreeNode { val: 1, left: Some(Rc::new(RefCell::new(TreeNode { val: 2, left: None, right: Some(Rc::new(RefCell::new(TreeNode { val: 4, left: None, right: None })) })), right: Some(Rc::new(RefCell::new(TreeNode { val: 3, left: None, right: Some(Rc::new(RefCell::new(TreeNode { val: 5, left: None, right: None })) }))) })))), right: None }))), vec![1, 3, 4, 5]);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeRightSideView(root)\nend",
      "testCalls": [
        "assert_equal [1,3,4], BinaryTreeRightSideView([1,2,3,nil,5,nil,4])",
        "assert_equal [1,3,4,5], BinaryTreeRightSideView([1,2,3,4,nil,nil,nil,5])",
        "assert_equal [1,3], BinaryTreeRightSideView([1,nil,3])",
        "assert_equal [], BinaryTreeRightSideView([])"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend"
    }
  },
  "binary-tree-zigzag-level-order-traversal": {
    "title": "Binary Tree Zigzag Level Order Traversal",
    "content": "Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BinaryTreeZigzagLevelOrderTraversal(root) {}",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal([3,9,20,null,null,15,7])) !== '[[3],[20,9],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal([1])) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal([])) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function BinaryTreeZigzagLevelOrderTraversal(root: TreeNode | null): number[][]",
      "testCalls": [
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(createTreeNode([3,9,20,null,null,15,7]))) !== '[[3],[20,9],[15,7]]') throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(createTreeNode([1]))) !== '[[1]]') throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(BinaryTreeZigzagLevelOrderTraversal(null)) !== '[]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createTreeNode(arr: (number | null)[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift(); if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> ZigzagLevelOrder(TreeNode* root)",
      "testCalls": [
        "assert(ZigzagLevelOrder(createTree({3,9,20,null,null,15,7})) == create2DVector({{3},{20,9},{15,7}}));",
        "assert(ZigzagLevelOrder(createTree({1})) == create2DVector({{1}}));",
        "assert(ZigzagLevelOrder(nullptr) == create2DVector({}));"
      ],
      "compareHelper": "bool compareVectors(vector<vector<int>>& v1, vector<vector<int>>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def BinaryTreeZigzagLevelOrderTraversal(root):",
      "testCalls": [
        "assert BinaryTreeZigzagLevelOrderTraversal([3,9,20,null,null,15,7]) == [[3],[20,9],[15,7]], 'Test Case 1 Failed'",
        "assert BinaryTreeZigzagLevelOrderTraversal([1]) == [[1]], 'Test Case 2 Failed'",
        "assert BinaryTreeZigzagLevelOrderTraversal([]) == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> BinaryTreeZigzagLevelOrderTraversal(TreeNode root) {}",
      "testCalls": [
        "List<List<Integer>> result1 = BinaryTreeZigzagLevelOrderTraversal(TreeNode.buildTree(new Integer[]{3, 9, 20, null, null, 15, 7}));\nif (!Arrays.deepEquals(result1.toArray(), new Integer[][]{{3}, {20, 9}, {15, 7}})) throw new AssertionError();",
        "List<List<Integer>> result2 = BinaryTreeZigzagLevelOrderTraversal(TreeNode.buildTree(new Integer[]{1}));\nif (!Arrays.deepEquals(result2.toArray(), new Integer[][]{{1}})) throw new AssertionError();",
        "List<List<Integer>> result3 = BinaryTreeZigzagLevelOrderTraversal(TreeNode.buildTree(new Integer[]{}));\nif (!Arrays.deepEquals(result3.toArray(), new Integer[][]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, List<List<Integer>> arr2) {\n    return Arrays.deepEquals(arr1.toArray(), arr2.toArray());\n}"
    },
    "c": {
      "functionDeclaration": "void BinaryTreeZigzagLevelOrderTraversal(struct TreeNode* root)",
      "testCalls": [
        "BinaryTreeZigzagLevelOrderTraversal(root); // Compare result with expected for test case 1",
        "BinaryTreeZigzagLevelOrderTraversal(root); // Compare result with expected for test case 2",
        "BinaryTreeZigzagLevelOrderTraversal(root); // Compare result with expected for test case 3"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ZigzagLevelOrderTraversal(root *TreeNode) [][]int {}",
      "testCalls": [
        "if !compareTwoDimIntArray(ZigzagLevelOrderTraversal(createTreeNodeFromString(\"[3,9,20,null,null,15,7]\")), createTwoDimIntArrayFromString(\"[[3],[20,9],[15,7]]\") { t.Error(\"Test Case 1 Failed\") }",
        "if !compareTwoDimIntArray(ZigzagLevelOrderTraversal(createTreeNodeFromString(\"[1]\")), createTwoDimIntArrayFromString(\"[[1]]\") { t.Error(\"Test Case 2 Failed\") }",
        "if !compareTwoDimIntArray(ZigzagLevelOrderTraversal(createTreeNodeFromString(\"[]\")), createTwoDimIntArrayFromString(\"[]\") { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareTwoDimIntArray(arr1, arr2 [][]int) bool {\n    if len(arr1) != len(arr2) { return false }\n    for i := 0; i < len(arr1); i++ {\n        if !reflect.DeepEqual(arr1[i], arr2[i]) { return false }\n    }\n    return true\n}"
    },
    "ruby": {
      "functionDeclaration": "def BinaryTreeZigzagLevelOrderTraversal(root)\nend",
      "testCalls": [
        "test_case_1 = BinaryTreeZigzagLevelOrderTraversal([3,9,20,null,null,15,7])\nraise 'Test Case 1 Failed' unless test_case_1 == [[3],[20,9],[15,7]]",
        "test_case_2 = BinaryTreeZigzagLevelOrderTraversal([1])\nraise 'Test Case 2 Failed' unless test_case_2 == [[1]]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "bitwise-and-of-numbers-range": {
    "title": "Bitwise AND of Numbers Range",
    "content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n\n\nConstraints:\n\n0 <= left <= right <= 231 - 1\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function BitwiseAndOfNumbersRange(left, right) {}",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(BitwiseAndOfNumbersRange(0, 0) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function BitwiseAndOfNumbersRange(left: number, right: number): number {}",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(BitwiseAndOfNumbersRange(0, 0) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int BitwiseAndOfNumbersRange(int left, int right);",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) != 4) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(0, 0) != 0) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def BitwiseAndOfNumbersRange(left: int, right: int) -> int:",
      "testCalls": [
        "assert BitwiseAndOfNumbersRange(5, 7) == 4, 'Test Case 1 Failed'",
        "assert BitwiseAndOfNumbersRange(0, 0) == 0, 'Test Case 2 Failed'",
        "assert BitwiseAndOfNumbersRange(1, 2147483647) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int BitwiseAndOfNumbersRange(int left, int right) { }",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) != 4) throw new AssertionError();",
        "if(BitwiseAndOfNumbersRange(0, 0) != 0) throw new AssertionError();",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int BitwiseAndOfNumbersRange(int left, int right);",
      "testCalls": [
        "if(BitwiseAndOfNumbersRange(5, 7) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(0, 0) != 0) { printf(\"Test Case 2 Failed\"); }",
        "if(BitwiseAndOfNumbersRange(1, 2147483647) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func BitwiseAndOfNumbersRange(left int, right int) int {}",
      "testCalls": [
        "if result := BitwiseAndOfNumbersRange(5, 7); result != 4 { t.Errorf(\"Test 1 failed, expected: %v, got: %v\", 4, result) }",
        "if result := BitwiseAndOfNumbersRange(0, 0); result != 0 { t.Errorf(\"Test 2 failed, expected: %v, got: %v\", 0, result) }",
        "if result := BitwiseAndOfNumbersRange(1, 2147483647); result != 0 { t.Errorf(\"Test 3 failed, expected: %v, got: %v\", 0, result) }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn BitwiseAndOfNumbersRange(left: i32, right: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(BitwiseAndOfNumbersRange(5, 7), 4);",
        "assert_eq!(BitwiseAndOfNumbersRange(0, 0), 0);",
        "assert_eq!(BitwiseAndOfNumbersRange(1, 2147483647), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def BitwiseAndOfNumbersRange(left, right)\nend",
      "testCalls": [
        "result = BitwiseAndOfNumbersRange(5, 7)\nraise 'Test Case 1 Failed' unless result == 4",
        "result = BitwiseAndOfNumbersRange(0, 0)\nraise 'Test Case 2 Failed' unless result == 0",
        "result = BitwiseAndOfNumbersRange(1, 2147483647)\nraise 'Test Case 3 Failed' unless result == 0"
      ],
      "compareHelper": ""
    }
  },
  "candy": {
    "title": "Candy",
    "content": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n\nConstraints:\n\nn == ratings.length\n1 <= n <= 2 * 104\n0 <= ratings[i] <= 2 * 104\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Candy(ratings) {}",
      "testCalls": [
        "if(Candy([1,0,2]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(Candy([1,2,2]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function Candy(ratings: number[]): number {}",
      "testCalls": [
        "if (Candy([1,0,2]) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if (Candy([1,2,2]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int Candy(vector<int>& ratings);",
      "testCalls": [
        "if (Candy({1,0,2}) != 5) throw std::runtime_error(\"Test 1 failed!\");",
        "if (Candy({1,2,2}) != 4) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def Candy(ratings: List[int]) -> int",
      "testCalls": [
        "assert Candy([1,0,2]) == 5",
        "assert Candy([1,2,2]) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int Candy(int[] ratings) {}",
      "testCalls": [
        "assert Candy(new int[]{1,0,2}) == 5;",
        "assert Candy(new int[]{1,2,2}) == 4;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int Candy(int* ratings, int ratingsSize)",
      "testCalls": [
        "if (Candy((int[]) {1,0,2}, 3) != 5) { printf(\"Test Case 1 Failed\"); }",
        "if (Candy((int[]) {1,2,2}, 3) != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func Candy(ratings []int) int {}",
      "testCalls": [
        "if Candy([]int{1,0,2}) != 5 {panic(\"Test case 1 failed\")}",
        "if Candy([]int{1,2,2}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn Candy(ratings: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(Candy(vec![1, 0, 2]), 5);",
        "assert_eq!(Candy(vec![1, 2, 2]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def Candy(ratings)\nend",
      "testCalls": [
        "result = Candy([1,0,2])\nputs(result == 5 ? 'Test case 1 passed' : 'Test case 1 failed')",
        "result = Candy([1,2,2])\nputs(result == 4 ? 'Test case 2 passed' : 'Test case 2 failed')"
      ],
      "compareHelper": ""
    }
  },
  "climbing-stairs": {
    "title": "Climbing Stairs",
    "content": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\nConstraints:\n\n1 <= n <= 45\n\n",
    "difficulty": "Easy",
    "hints": [
      "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
    ],
    "topicTags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ClimbingStairs(n) {}",
      "testCalls": [
        "if (ClimbingStairs(2) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (ClimbingStairs(3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ClimbingStairs(n: number): number {}",
      "testCalls": [
        "if (ClimbingStairs(2) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (ClimbingStairs(3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int ClimbStairs(int n);",
      "testCalls": [
        "if (ClimbStairs(2) != 2) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if (ClimbStairs(3) != 3) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ClimbingStairs(n: int) -> int:",
      "testCalls": [
        "assert ClimbingStairs(2) == 2",
        "assert ClimbingStairs(3) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int ClimbingStairs(int n) { }",
      "testCalls": [
        "if(ClimbingStairs(2) != 2) throw new AssertionError();",
        "if(ClimbingStairs(3) != 3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int ClimbingStairs(int n);",
      "testCalls": [
        "if (ClimbingStairs(2) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if (ClimbingStairs(3) != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ClimbStairs(n int) int {}",
      "testCalls": [
        "if ClimbStairs(2) != 2 { t.Errorf(\"Test case 1 failed\") }",
        "if ClimbStairs(3) != 3 { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ClimbingStairs(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(ClimbingStairs(2), 2);",
        "assert_eq!(ClimbingStairs(3), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ClimbingStairs(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ClimbingStairs(2) == 2",
        "raise 'Test Case 2 Failed' unless ClimbingStairs(3) == 3"
      ],
      "compareHelper": ""
    }
  },
  "clone-graph": {
    "title": "Clone Graph",
    "content": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\nTest case format:\nFor simplicity, each node value is the same as the node index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\nExample 1:\n\n\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1) neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2) neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3) neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4) neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\nExample 2:\n\n\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\nExample 3:\n\nInput: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.\n\n\nConstraints:\n\nThe number of nodes in the graph is in the range [0, 100].\n1 <= Node.val <= 100\nNode.val is unique for each node.\nThere are no repeated edges and no self-loops in the graph.\nThe Graph is connected and all nodes can be visited starting from the given node.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CloneGraph(adjList) {}",
      "testCalls": [
        "const test1 = CloneGraph([[2,4],[1,3],[2,4],[1,3]]); if(JSON.stringify(test1) !== '[[2,4],[1,3],[2,4],[1,3]]') throw new Error('Test Case 1 Failed');",
        "const test2 = CloneGraph([[]]); if(JSON.stringify(test2) !== '[[]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function CloneGraph(node: Node | null): Node | null",
      "testCalls": [
        "const testInput1 = [[2,4],[1,3],[2,4],[1,3]]; const result1 = CloneGraph(testInput1); if(JSON.stringify(result1) !== '[[2,4],[1,3],[2,4],[1,3]]') throw new Error('Test Case 1 Failed');",
        "const testInput2 = [[]]; const result2 = CloneGraph(testInput2); if(JSON.stringify(result2) !== '[[]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "c++": {
      "functionDeclaration": "Node* CloneGraph(Node* node)",
      "testCalls": [
        "assert(compareGraph(CloneGraph(createGraph([[2,4],[1,3],[2,4],[1,3]])), createGraph([[2,4],[1,3],[2,4],[1,3]]));",
        "assert(compareGraph(CloneGraph(createGraph([[]])), createGraph([[]]));",
        "assert(compareGraph(CloneGraph(createGraph([])), createGraph([]));"
      ],
      "compareHelper": "bool compareGraph(Node* node1, Node* node2) { /* Comparison logic for graph nodes */ }"
    },
    "python": {
      "functionDeclaration": "def CloneGraph(adjList: List[List[int]]) -> List[List[int]]:",
      "testCalls": [
        "result1 = CloneGraph([[2,4],[1,3],[2,4],[1,3]])\nif result1 != [[2,4],[1,3],[2,4],[1,3]]:\n    raise AssertionError('Test Case 1 Failed')",
        "result2 = CloneGraph([[]])\nif result2 != [[]]:\n    raise AssertionError('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public Node cloneGraph(Node node)",
      "testCalls": [
        "Node test1 = cloneGraph(createGraph(new int[][]{{2,4},{1,3},{2,4},{1,3}}));\nif (!compareGraph(test1, createGraph(new int[][]{{2,4},{1,3},{2,4},{1,3}}))) throw new AssertionError();",
        "Node test2 = cloneGraph(createGraph(new int[][]{{}}));\nif (!compareGraph(test2, createGraph(new int[][]{{}}))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareGraph(Node node1, Node node2) {\n    // Implement comparison logic here\n}"
    },
    "c": {
      "functionDeclaration": "Node* CloneGraph(Node* node)",
      "testCalls": [
        "Node* test1 = CloneGraph(node1); if(!compareGraph(test1, expectedResult1)) { printf(\"Test Case 1 Failed\"); }",
        "Node* test2 = CloneGraph(node2); if(!compareGraph(test2, expectedResult2)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareGraph(Node* graph1, Node* graph2) { // Comparison logic here }"
    },
    "go": {
      "functionDeclaration": "func CloneGraph(node *Node) *Node",
      "testCalls": [
        "if result := CloneGraph(buildGraph([[2,4],[1,3],[2,4],[1,3]])); !reflect.DeepEqual(result, buildGraph([[2,4],[1,3],[2,4],[1,3]])) { t.Errorf(\"Test Case 1 Failed\") }",
        "if result := CloneGraph(buildGraph([[]])); !reflect.DeepEqual(result, buildGraph([[]])) { t.Errorf(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func buildGraph(adjList [][]int) *Node {\n    // Build the graph from the adjacency list\n}"
    },
    "rust": {
      "functionDeclaration": "fn CloneGraph(adj_list: Vec<Vec<i32>>) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let test_case_1 = CloneGraph(vec![vec![2, 4], vec![1, 3], vec![2, 4], vec![1, 3]]); assert_eq!(test_case_1, vec![vec![2, 4], vec![1, 3], vec![2, 4], vec![1, 3]]);",
        "let test_case_2 = CloneGraph(vec![vec![]]); assert_eq!(test_case_2, vec![vec![]]);",
        "let test_case_3 = CloneGraph(vec![]); assert_eq!(test_case_3, vec![]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: &Vec<Vec<i32>>, arr2: &Vec<Vec<i32>>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def CloneGraph(node)",
      "testCalls": [
        "node1 = Node.new(1); node2 = Node.new(2); node3 = Node.new(3); node4 = Node.new(4); node1.neighbors = [node2, node4]; node2.neighbors = [node1, node3]; node3.neighbors = [node2, node4]; node4.neighbors = [node1, node3]; result1 = CloneGraph(node1); raise 'Test Case 1 Failed' unless result1.neighbors[0].val == 2 && result1.neighbors[1].val == 4",
        "node1 = Node.new(1); result2 = CloneGraph(node1); raise 'Test Case 2 Failed' unless result2.neighbors.empty?",
        "node = nil; result3 = CloneGraph(node); raise 'Test Case 3 Failed' unless result3.nil?"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "coin-change": {
    "title": "Coin Change",
    "content": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\n\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\n\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0\n\n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CoinChange(coins, amount) {}",
      "testCalls": [
        "if(CoinChange([1,2,5], 11) !== 3) throw new Error('Test Case 1 Failed');",
        "if(CoinChange([2], 3) !== -1) throw new Error('Test Case 2 Failed');",
        "if(CoinChange([1], 0) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function CoinChange(coins: number[], amount: number): number {}",
      "testCalls": [
        "if (CoinChange([1,2,5], 11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (CoinChange([2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }",
        "if (CoinChange([1], 0) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int CoinChange(vector<int>& coins, int amount);",
      "testCalls": [
        "assert(CoinChange({1,2,5}, 11) == 3);",
        "assert(CoinChange({2}, 3) == -1);",
        "assert(CoinChange({1}, 0) == 0);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def CoinChange(coins: List[int], amount: int) -> int:",
      "testCalls": [
        "assert CoinChange([1,2,5], 11) == 3, 'Test Case 1 Failed'",
        "assert CoinChange([2], 3) == -1, 'Test Case 2 Failed'",
        "assert CoinChange([1], 0) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int coinChange(int[] coins, int amount) {}",
      "testCalls": [
        "assert coinChange(new int[]{1,2,5}, 11) == 3 : \"Test Case 1 Failed\";",
        "assert coinChange(new int[]{2}, 3) == -1 : \"Test Case 2 Failed\";",
        "assert coinChange(new int[]{1}, 0) == 0 : \"Test Case 3 Failed\";"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int CoinChange(int* coins, int coinsSize, int amount)",
      "testCalls": [
        "if (CoinChange((int[]) {1, 2, 5}, 3, 11) != 3) { printf(\"Test case 1 failed\"); }",
        "if (CoinChange((int[]) {2}, 1, 3) != -1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func CoinChange(coins []int, amount int) int {}",
      "testCalls": [
        "if CoinChange([]int{1,2,5}, 11) != 3 { panic(\"Test case 1 failed\") }",
        "if CoinChange([]int{2}, 3) != -1 { panic(\"Test case 2 failed\") }",
        "if CoinChange([]int{1}, 0) != 0 { panic(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn CoinChange(coins: Vec<i32>, amount: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(CoinChange(vec![1, 2, 5], 11), 3);",
        "assert_eq!(CoinChange(vec![2], 3), -1);",
        "assert_eq!(CoinChange(vec![1], 0), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def CoinChange(coins, amount)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless CoinChange([1,2,5], 11) == 3",
        "raise 'Test Case 2 Failed' unless CoinChange([2], 3) == -1",
        "raise 'Test Case 3 Failed' unless CoinChange([1], 0) == 0"
      ],
      "compareHelper": ""
    }
  },
  "combination-sum": {
    "title": "Combination Sum",
    "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n\n\nConstraints:\n\n1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CombinationSum(candidates, target) {}",
      "testCalls": [
        "const testOutput1 = CombinationSum([2,3,6,7], 7); if(JSON.stringify(testOutput1) !== '[[2,2,3],[7]]') { throw new Error('Test Case 1 Failed'); }",
        "const testOutput2 = CombinationSum([2,3,5], 8); if(JSON.stringify(testOutput2) !== '[[2,2,2,2],[2,3,3],[3,5]]') { throw new Error('Test Case 2 Failed'); }",
        "const testOutput3 = CombinationSum([2], 1); if(JSON.stringify(testOutput3) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function CombinationSum(candidates: number[], target: number): number[][] { }",
      "testCalls": [
        "if (JSON.stringify(CombinationSum([2,3,6,7], 7)) !== '[[2,2,3],[7]]') { throw new Error('Test Case 1 Failed'); }",
        "if (JSON.stringify(CombinationSum([2,3,5], 8)) !== '[[2,2,2,2],[2,3,3],[3,5]]') { throw new Error('Test Case 2 Failed'); }",
        "if (JSON.stringify(CombinationSum([2], 1)) !== '[]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> CombinationSum(vector<int>& candidates, int target);",
      "testCalls": [
        "auto result1 = CombinationSum({2,3,6,7}, 7); if (result1 != vector<vector<int>>{{2,2,3},{7}}) throw std::runtime_error(\"Test 1 Failed!\");",
        "auto result2 = CombinationSum({2,3,5}, 8); if (result2 != vector<vector<int>>{{2,2,2,2},{2,3,3},{3,5}}) throw std::runtime_error(\"Test 2 Failed!\");",
        "auto result3 = CombinationSum({2}, 1); if (result3 != vector<vector<int>>{}) throw std::runtime_error(\"Test 3 Failed!\");"
      ],
      "compareHelper": "bool CompareArrays(const vector<vector<int>>& arr1, const vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def CombinationSum(candidates: List[int], target: int) -> List[List[int]]:",
      "testCalls": [
        "result1 = CombinationSum([2,3,6,7], 7)\nassert result1 == [[2,2,3],[7]], f'Expected [[2,2,3],[7]], but got {result1}'",
        "result2 = CombinationSum([2,3,5], 8)\nassert result2 == [[2,2,2,2],[2,3,3],[3,5]], f'Expected [[2,2,2,2],[2,3,3],[3,5]], but got {result2}'",
        "result3 = CombinationSum([2], 1)\nassert result3 == [], f'Expected [], but got {result3}'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> combinationSum(int[] candidates, int target) {}",
      "testCalls": [
        "List<List<Integer>> result1 = combinationSum(new int[]{2,3,6,7}, 7); if (!Arrays.deepEquals(result1.toArray(), new int[][]{{2,2,3},{7}})) throw new AssertionError();",
        "List<List<Integer>> result2 = combinationSum(new int[]{2,3,5}, 8); if (!Arrays.deepEquals(result2.toArray(), new int[][]{{2,2,2,2},{2,3,3},{3,5}})) throw new AssertionError();",
        "List<List<Integer>> result3 = combinationSum(new int[]{2}, 1); if (!Arrays.deepEquals(result3.toArray(), new int[][]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, int[][] arr2) { return Arrays.deepEquals(arr1.toArray(), arr2); }"
    },
    "c": {
      "functionDeclaration": "void CombinationSum(int* candidates, int candidatesSize, int target)",
      "testCalls": [
        "CombinationSum((int[]){2,3,6,7}, 4, 7); // [[2,2,3],[7]]",
        "CombinationSum((int[]){2,3,5}, 3, 8); // [[2,2,2,2],[2,3,3],[3,5]]",
        "CombinationSum((int[]){2}, 1, 1); // []"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n  if(size1 != size2) return 0;\n  for(int i = 0; i < size1; i++) {\n    if(arr1[i] != arr2[i]) return 0;\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func CombinationSum(candidates []int, target int) [][]int {}",
      "testCalls": [
        "result1 := CombinationSum([]int{2,3,6,7}, 7); if !compareArrays(result1, [][]int{{2,2,3},{7}}) {panic(\"Test case 1 failed\")}",
        "result2 := CombinationSum([]int{2,3,5}, 8); if !compareArrays(result2, [][]int{{2,2,2,2},{2,3,3},{3,5}}) {panic(\"Test case 2 failed\")}",
        "result3 := CombinationSum([]int{2}, 1); if !compareArrays(result3, [][]int{}) {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false }; for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn CombinationSum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = CombinationSum(vec![2,3,6,7], 7); assert_eq!(result1, vec![vec![2,2,3], vec![7]]);",
        "let result2 = CombinationSum(vec![2,3,5], 8); assert_eq!(result2, vec![vec![2,2,2,2], vec![2,3,3], vec![3,5]]);",
        "let result3 = CombinationSum(vec![2], 1); assert_eq!(result3, vec![]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) -> bool { arr1.len() == arr2.len() && arr1.iter().all(|x| arr2.contains(x)) }"
    }
  },
  "combinations": {
    "title": "Combinations",
    "content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\n\nExample 1:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\n\n\nConstraints:\n\n1 <= n <= 20\n1 <= k <= n\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Combinations(n, k) {}",
      "testCalls": [
        "const test1 = Combinations(4, 2); if(JSON.stringify(test1) !== '[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Combinations(1, 1); if(JSON.stringify(test2) !== '[[1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function Combinations(n: number, k: number): number[][] {}",
      "testCalls": [
        "const test1 = Combinations(4, 2); if(JSON.stringify(test1) !== '[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Combinations(1, 1); if(JSON.stringify(test2) !== '[[1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> Combinations(int n, int k);",
      "testCalls": [
        "auto result1 = Combinations(4, 2); assert(result1 == vector<vector<int>>{{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}});",
        "auto result2 = Combinations(1, 1); assert(result2 == vector<vector<int>>{{1}});"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def Combinations(n: int, k: int) -> List[List[int]]:",
      "testCalls": [
        "assert Combinations(4, 2) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]], 'Test Case 1 Failed'",
        "assert Combinations(1, 1) == [[1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> Combinations(int n, int k) {}",
      "testCalls": [
        "List<List<Integer>> result1 = Combinations(4, 2); if (!compareLists(result1, Arrays.asList(Arrays.asList(1,2), Arrays.asList(1,3), Arrays.asList(1,4), Arrays.asList(2,3), Arrays.asList(2,4), Arrays.asList(3,4)))) throw new AssertionError();",
        "List<List<Integer>> result2 = Combinations(1, 1); if (!compareLists(result2, Arrays.asList(Arrays.asList(1)))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareLists(List<List<Integer>> list1, List<List<Integer>> list2) { return list1.containsAll(list2) && list2.containsAll(list1); }"
    },
    "c": {
      "functionDeclaration": "int** Combinations(int n, int k)",
      "testCalls": [
        "int** result1 = Combinations(4, 2);",
        "int** result2 = Combinations(1, 1);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n    for (int i = 0; i < size; i++) {\n        if (arr1[i] != arr2[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func Combinations(n int, k int) [][]int {}",
      "testCalls": [
        "if !compareArrays(Combinations(4, 2), [][]int{{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}}) { t.Errorf(\"Test case 1 failed\") }",
        "if !compareArrays(Combinations(1, 1), [][]int{{1}}) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 [][]int, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn Combinations(n: i32, k: i32) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(Combinations(4, 2), vec![vec![1, 2], vec![1, 3], vec![1, 4], vec![2, 3], vec![2, 4], vec![3, 4]]);",
        "assert_eq!(Combinations(1, 1), vec![vec![1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: &Vec<Vec<i32>>, arr2: &Vec<Vec<i32>>) { assert_eq!(arr1.len(), arr2.len()); for i in 0..arr1.len() { assert_eq!(arr1[i], arr2[i]); }}"
    },
    "ruby": {
      "functionDeclaration": "def Combinations(n, k)\nend",
      "testCalls": [
        "test_case_1 = Combinations(4, 2)\nraise 'Test Case 1 Failed' unless test_case_1 == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
        "test_case_2 = Combinations(1, 1)\nraise 'Test Case 2 Failed' unless test_case_2 == [[1]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "construct-binary-tree-from-inorder-and-postorder-traversal": {
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "content": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nExample 1:\n\n\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n\n\nConstraints:\n\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder) {}",
      "testCalls": [
        "const test1 = ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3]); if(JSON.stringify(test1) !== JSON.stringify([3,9,20,null,null,15,7])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1]); if(JSON.stringify(test2) !== JSON.stringify([-1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function BuildTree(inorder: number[], postorder: number[]): TreeNode | null",
      "testCalls": [
        "const test1 = BuildTree([9,3,15,20,7], [9,15,7,20,3]); if (!compareTrees(test1, [3,9,20,null,null,15,7])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = BuildTree([-1], [-1]); if (!compareTrees(test2, [-1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareTrees(tree1: TreeNode | null, tree2: number[]): boolean { if (!tree1 && !tree2) { return true; } if (!tree1 || !tree2) { return false; } return tree1.val === tree2[0] && compareTrees(tree1.left, tree2[1]) && compareTrees(tree1.right, tree2[2]); }"
    },
    "c++": {
      "functionDeclaration": "TreeNode* BuildTreeFromInorderAndPostorder(vector<int>& inorder, vector<int>& postorder)",
      "testCalls": [
        "assert(compareTrees(BuildTreeFromInorderAndPostorder({9,3,15,20,7}, {9,15,7,20,3}), createTree({3,9,20,null,null,15,7})));",
        "assert(compareTrees(BuildTreeFromInorderAndPostorder({-1}, {-1}), createTree({-1})));"
      ],
      "compareHelper": "bool compareTrees(TreeNode* tree1, TreeNode* tree2) { if (!tree1 && !tree2) return true; if (!tree1 || !tree2) return false; return tree1->val == tree2->val && compareTrees(tree1->left, tree2->left) && compareTrees(tree1->right, tree2->right); }"
    },
    "python": {
      "functionDeclaration": "def ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:",
      "testCalls": [
        "assert ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3]) == [3,9,20,None,None,15,7], 'Test Case 1 Failed'",
        "assert ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1]) == [-1], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public TreeNode buildTree(int[] inorder, int[] postorder) {}",
      "testCalls": [
        "TreeNode result1 = buildTree(new int[]{9,3,15,20,7}, new int[]{9,15,7,20,3});\nif (!compareTrees(result1, new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7))))) throw new AssertionError();",
        "TreeNode result2 = buildTree(new int[]{-1}, new int[]{-1});\nif (!compareTrees(result2, new TreeNode(-1))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}"
    },
    "c": {
      "functionDeclaration": "TreeNode* BuildTree(int* inorder, int inorderSize, int* postorder, int postorderSize)",
      "testCalls": [
        "TreeNode* result1 = BuildTree((int[]){9,3,15,20,7}, 5, (int[]){9,15,7,20,3}, 5); compareArrays(result1, (int[]){3,9,20,NULL,NULL,15,7}, 7);",
        "TreeNode* result2 = BuildTree((int[]){-1}, 1, (int[]){-1}, 1); compareArrays(result2, (int[]){-1}, 1);"
      ],
      "compareHelper": "void compareArrays(TreeNode* result, int* expected, int size) {\n  for (int i = 0; i < size; i++) {\n    if (result[i] != expected[i]) {\n      printf(\"Test case failed\");\n      exit(1);\n    }\n  }\n}"
    },
    "go": {
      "functionDeclaration": "func BuildTree(inorder []int, postorder []int) *TreeNode",
      "testCalls": [
        "if result := BuildTree([]int{9,3,15,20,7}, []int{9,15,7,20,3}); !compareTrees(result, createTreeFromSlice([]int{3,9,20,-1,-1,15,7})) { t.Errorf(\"Test case 1 failed\") }",
        "if result := BuildTree([]int{-1}, []int{-1}); !compareTrees(result, createTreeFromSlice([]int{-1})) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareTrees(tree1 *TreeNode, tree2 *TreeNode) bool { if tree1 == nil && tree2 == nil { return true } if tree1 == nil || tree2 == nil { return false } return tree1.Val == tree2.Val && compareTrees(tree1.Left, tree2.Left) && compareTrees(tree1.Right, tree2.Right) }"
    },
    "rust": {
      "functionDeclaration": "fn ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Box<TreeNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 9, left: None, right: None })), right: Some(Box::new(TreeNode { val: 20, left: Some(Box::new(TreeNode { val: 15, left: None, right: None })), right: Some(Box::new(TreeNode { val: 7, left: None, right: None })) })) }), ConstructBinaryTreeFromInorderAndPostorderTraversal(vec![9,3,15,20,7], vec![9,15,7,20,3]).as_ref());",
        "assert_eq!(Some(Box::new(TreeNode { val: -1, left: None, right: None })), ConstructBinaryTreeFromInorderAndPostorderTraversal(vec![-1], vec![-1]).as_ref());"
      ],
      "compareHelper": "fn compare_trees(tree1: Option<Box<TreeNode>>, tree2: Option<Box<TreeNode>>) -> bool { if let (Some(node1), Some(node2)) = (tree1, tree2) { node1.val == node2.val && compare_trees(node1.left.clone(), node2.left.clone()) && compare_trees(node1.right.clone(), node2.right.clone()) } else { tree1.is_none() && tree2.is_none() } }"
    },
    "ruby": {
      "functionDeclaration": "def ConstructBinaryTreeFromInorderAndPostorderTraversal(inorder, postorder)\nend",
      "testCalls": [
        "result1 = ConstructBinaryTreeFromInorderAndPostorderTraversal([9,3,15,20,7], [9,15,7,20,3])\nraise 'Test Case 1 Failed' unless result1 == [3,9,20,nil,nil,15,7]",
        "result2 = ConstructBinaryTreeFromInorderAndPostorderTraversal([-1], [-1])\nraise 'Test Case 2 Failed' unless result2 == [-1]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "content": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\nExample 1:\n\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\n\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n\n\nConstraints:\n\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder) {}",
      "testCalls": [
        "const test1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7]); if(JSON.stringify(test1) !== JSON.stringify([3,9,20,null,null,15,7])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1]); if(JSON.stringify(test2) !== JSON.stringify([-1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder: number[], inorder: number[]): TreeNode | null {}",
      "testCalls": [
        "if(JSON.stringify(ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7])) !== JSON.stringify([3,9,20,null,null,15,7])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1])) !== JSON.stringify([-1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "c++": {
      "functionDeclaration": "TreeNode* ConstructBinaryTreeFromPreorderAndInorderTraversal(vector<int>& preorder, vector<int>& inorder)",
      "testCalls": [
        "assert(TreeNodeToString(ConstructBinaryTreeFromPreorderAndInorderTraversal({3,9,20,15,7}, {9,3,15,20,7})) == \"[3,9,20,null,null,15,7]\");",
        "assert(TreeNodeToString(ConstructBinaryTreeFromPreorderAndInorderTraversal({-1}, {-1})) == \"[-1]\");"
      ],
      "compareHelper": "string TreeNodeToString(TreeNode* root) { ... }"
    },
    "python": {
      "functionDeclaration": "def ConstructBinaryTreeFromPreorderAndInorder(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:",
      "testCalls": [
        "assert ConstructBinaryTreeFromPreorderAndInorder([3,9,20,15,7], [9,3,15,20,7]) == [3,9,20,null,null,15,7], 'Test Case 1 Failed'",
        "assert ConstructBinaryTreeFromPreorderAndInorder([-1], [-1]) == [-1], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public TreeNode buildTree(int[] preorder, int[] inorder) { }",
      "testCalls": [
        "TreeNode result1 = buildTree(new int[]{3,9,20,15,7}, new int[]{9,3,15,20,7});\nif (!compareTrees(result1, new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7))))) throw new AssertionError();",
        "TreeNode result2 = buildTree(new int[]{-1}, new int[]{-1});\nif (!compareTrees(result2, new TreeNode(-1))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}"
    },
    "c": {
      "functionDeclaration": "TreeNode* BuildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)",
      "testCalls": [
        "TreeNode* result1 = BuildTree((int[]){3,9,20,15,7}, 5, (int[]){9,3,15,20,7}, 5);",
        "if (!CompareTrees(result1, CreateTree((int[]){3,9,20,-1,-1,15,7}, 7))) { printf(\"Test case 1 failed\"); }",
        "TreeNode* result2 = BuildTree((int[]){-1}, 1, (int[]){-1}, 1);",
        "if (!CompareTrees(result2, CreateTree((int[]){-1}, 1))) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "bool CompareTrees(TreeNode* tree1, TreeNode* tree2) { if (!tree1 && !tree2) return true; if (!tree1 || !tree2) return false; return tree1->val == tree2->val && CompareTrees(tree1->left, tree2->left) && CompareTrees(tree1->right, tree2->right); }"
    },
    "go": {
      "functionDeclaration": "ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder []int, inorder []int) *TreeNode",
      "testCalls": [
        "if result := ConstructBinaryTreeFromPreorderAndInorderTraversal([]int{3,9,20,15,7}, []int{9,3,15,20,7}); !compareBinaryTrees(result, NewTreeNode(3, NewTreeNode(9, nil, nil), NewTreeNode(20, NewTreeNode(15, nil, nil), NewTreeNode(7, nil, nil)))) { t.Errorf(\"Test 1 Failed\") }",
        "if result := ConstructBinaryTreeFromPreorderAndInorderTraversal([]int{-1}, []int{-1}); !compareBinaryTrees(result, NewTreeNode(-1, nil, nil)) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareBinaryTrees(tree1 *TreeNode, tree2 *TreeNode) bool {\n    if tree1 == nil && tree2 == nil {\n        return true\n    }\n    if tree1 == nil || tree2 == nil {\n        return false\n    }\n    return tree1.Val == tree2.Val && compareBinaryTrees(tree1.Left, tree2.Left) && compareBinaryTrees(tree1.Right, tree2.Right)\n}"
    },
    "rust": {
      "functionDeclaration": "fn ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {}",
      "testCalls": [
        "assert_eq!(ConstructBinaryTreeFromPreorderAndInorderTraversal(vec![3, 9, 20, 15, 7], vec![9, 3, 15, 20, 7]), Some(Rc::new(RefCell::new(TreeNode { val: 3, left: Some(Rc::new(RefCell::new(TreeNode { val: 9, left: None, right: None })), right: Some(Rc::new(RefCell::new(TreeNode { val: 20, left: Some(Rc::new(RefCell::new(TreeNode { val: 15, left: None, right: None })), right: Some(Rc::new(RefCell::new(TreeNode { val: 7, left: None, right: None })) })), right: None) })))));",
        "assert_eq!(ConstructBinaryTreeFromPreorderAndInorderTraversal(vec![-1], vec![-1]), Some(Rc::new(RefCell::new(TreeNode { val: -1, left: None, right: None })));"
      ],
      "compareHelper": "fn compare_trees(a: Option<Rc<RefCell<TreeNode>>>, b: Option<Rc<RefCell<TreeNode>>>) -> bool { if a.is_none() && b.is_none() { return true; } if a.is_none() || b.is_none() { return false; } let a = a.unwrap(); let b = b.unwrap(); a.borrow().val == b.borrow().val && compare_trees(a.borrow().left.clone(), b.borrow().left.clone()) && compare_trees(a.borrow().right.clone(), b.borrow().right.clone()) }"
    },
    "ruby": {
      "functionDeclaration": "def ConstructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder)\nend",
      "testCalls": [
        "result1 = ConstructBinaryTreeFromPreorderAndInorderTraversal([3,9,20,15,7], [9,3,15,20,7])\nraise 'Test Case 1 Failed' unless result1 == [3,9,20,nil,nil,15,7]",
        "result2 = ConstructBinaryTreeFromPreorderAndInorderTraversal([-1], [-1])\nraise 'Test Case 2 Failed' unless result2 == [-1]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "construct-quad-tree": {
    "title": "Construct Quad Tree",
    "content": "Given a n * n matrix grid of 0 and 1 only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1 or False if the node represents a grid of 0. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1 or all 0) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don&#39;t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nExample 1:\n\n\nInput: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n\n\nExample 2:\n\n\nInput: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:\n\n\n\nConstraints:\n\nn == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "ConstructQuadTree(grid)",
      "testCalls": [
        "const testOutput1 = ConstructQuadTree([[0,1],[1,0]]); if(JSON.stringify(testOutput1) !== '[[0,1],[1,0],[1,1],[1,1],[1,0]]') throw new Error('Test Case 1 Failed');",
        "const testOutput2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if(JSON.stringify(testOutput2) !== '[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function ConstructQuadTree(grid: number[][]): Node | null {}",
      "testCalls": [
        "const test1 = ConstructQuadTree([[0,1],[1,0]]); if(JSON.stringify(test1) !== JSON.stringify([[0,1],[1,0],[1,1],[1,1],[1,0]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]); if(JSON.stringify(test2) !== JSON.stringify([[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "Node* ConstructQuadTree(vector<vector<int>>& grid)",
      "testCalls": [
        "auto result1 = ConstructQuadTree({{0,1},{1,0}});",
        "auto result2 = ConstructQuadTree({{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0}});",
        "compareNodes(result1, expectedResult1);",
        "compareNodes(result2, expectedResult2);"
      ],
      "compareHelper": "void compareNodes(Node* node, vector<vector<int>> expected) { if (!node && expected.empty()) return; if (!node || expected.empty() || node->val != expected[0][0] || node->isLeaf != expected[0][1]) throw runtime_error(\"Test Failed\"); compareNodes(node->topLeft, vector<vector<int>>(expected.begin() + 1, expected.begin() + expected.size() / 4 + 1)); compareNodes(node->topRight, vector<vector<int>>(expected.begin() + expected.size() / 4 + 1, expected.begin() + expected.size() / 2 + 1)); compareNodes(node->bottomLeft, vector<vector<int>>(expected.begin() + expected.size() / 2 + 1, expected.begin() + expected.size() * 3 / 4 + 1)); compareNodes(node->bottomRight, vector<vector<int>>(expected.begin() + expected.size() * 3 / 4 + 1, expected.end())); }"
    },
    "python": {
      "functionDeclaration": "def ConstructQuadTree(grid: List[List[int]]) -> 'Node':",
      "testCalls": [
        "assert ConstructQuadTree([[0,1],[1,0]]).val == False",
        "assert ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]).val == False"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "Node constructQuadTree(int[][] grid)",
      "testCalls": [
        "Node result1 = constructQuadTree(new int[][]{{0,1},{1,0}}); if(!Arrays.deepEquals(result1, new int[][]{{0,1},{1,0},{1,1},{1,1},{1,0}})) throw new AssertionError();",
        "Node result2 = constructQuadTree(new int[][]{{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0}}); if(!Arrays.deepEquals(result2, new int[][]{{0,1},{1,1},{0,1},{1,1},{1,0},null,null,null,null,{1,0},{1,0},{1,1},{1,1}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareQuadTree(Node node1, Node node2) {\n    if (node1 == null && node2 == null) return true;\n    if (node1 == null || node2 == null) return false;\n    return node1.val == node2.val && node1.isLeaf == node2.isLeaf && compareQuadTree(node1.topLeft, node2.topLeft) && compareQuadTree(node1.topRight, node2.topRight) && compareQuadTree(node1.bottomLeft, node2.bottomLeft) && compareQuadTree(node1.bottomRight, node2.bottomRight);\n}"
    },
    "c": {
      "functionDeclaration": "Node* ConstructQuadTree(int** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "Node* result1 = ConstructQuadTree(grid1, 2, gridColSize1);",
        "Node* result2 = ConstructQuadTree(grid2, 8, gridColSize2);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "ConstructQuadTree(grid [][]int) *Node",
      "testCalls": [
        "if result := ConstructQuadTree([][]int{{0,1},{1,0}}); !reflect.DeepEqual(result, &Node{Val: false, IsLeaf: false, TopLeft: &Node{Val: false, IsLeaf: true}, TopRight: &Node{Val: true, IsLeaf: true}, BottomLeft: &Node{Val: true, IsLeaf: true}, BottomRight: &Node{Val: false, IsLeaf: true}}) { t.Errorf(\"Test 1 Failed\") }",
        "if result := ConstructQuadTree([][]int{{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0},{1,1,1,1,0,0,0,0}}); !reflect.DeepEqual(result, &Node{Val: false, IsLeaf: false, TopLeft: &Node{Val: false, IsLeaf: true}, TopRight: &Node{Val: true, IsLeaf: true}, BottomLeft: &Node{Val: true, IsLeaf: true}, BottomRight: nil}) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareNodes(n1, n2 *Node) bool { if n1 == nil && n2 == nil { return true } if n1 == nil || n2 == nil { return false } return n1.Val == n2.Val && n1.IsLeaf == n2.IsLeaf && compareNodes(n1.TopLeft, n2.TopLeft) && compareNodes(n1.TopRight, n2.TopRight) && compareNodes(n1.BottomLeft, n2.BottomLeft) && compareNodes(n1.BottomRight, n2.BottomRight) }"
    },
    "rust": {
      "functionDeclaration": "fn ConstructQuadTree(grid: Vec<Vec<i32>>) -> Option<Box<Node>> { }",
      "testCalls": [
        "let test_input1 = vec![vec![0, 1], vec![1, 0]]; let result1 = ConstructQuadTree(test_input1); assert_eq!(result1, Some(Box::new(Node { val: false, isLeaf: false, topLeft: Some(Box::new(Node { val: false, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), topRight: Some(Box::new(Node { val: true, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), bottomLeft: Some(Box::new(Node { val: true, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), bottomRight: Some(Box::new(Node { val: true, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })) }));",
        "let test_input2 = vec![vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 1, 1, 1, 1], vec![1, 1, 1, 1, 1, 1, 1, 1], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0], vec![1, 1, 1, 1, 0, 0, 0, 0]]; let result2 = ConstructQuadTree(test_input2); assert_eq!(result2, Some(Box::new(Node { val: false, isLeaf: false, topLeft: Some(Box::new(Node { val: false, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), topRight: Some(Box::new(Node { val: true, isLeaf: false, topLeft: Some(Box::new(Node { val: false, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), topRight: Some(Box::new(Node { val: true, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), bottomLeft: Some(Box::new(Node { val: true, isLeaf: true, topLeft: None, topRight: None, bottomLeft: None, bottomRight: None })), bottomRight: None })) }));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ConstructQuadTree(grid)\nend",
      "testCalls": [
        "test1 = ConstructQuadTree([[0,1],[1,0]])\nraise 'Test Case 1 Failed' unless test1.to_s == [[0,1],[1,0],[1,1],[1,1],[1,0]].to_s",
        "test2 = ConstructQuadTree([[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]])\nraise 'Test Case 2 Failed' unless test2.to_s == [[0,1],[1,1],[0,1],[1,1],[1,0],nil,nil,nil,nil,[1,0],[1,0],[1,1],[1,1]].to_s"
      ],
      "compareHelper": "empty string"
    }
  },
  "container-with-most-water": {
    "title": "Container With Most Water",
    "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n\nExample 1:\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\nConstraints:\n\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      "If you simulate the problem, it will be O(n^2) which is not efficient.",
      "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
      "How can you calculate the amount of water at each step?"
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ContainerWithMostWater(height) {}",
      "testCalls": [
        "if(ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) !== 49) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainerWithMostWater([1,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ContainerWithMostWater(height: number[]): number { }",
      "testCalls": [
        "if(ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) !== 49) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainerWithMostWater([1,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxArea(vector<int>& height)",
      "testCalls": [
        "if(MaxArea({1,8,6,2,5,4,8,3,7}) != 49) throw runtime_error(\"Test 1 failed\");",
        "if(MaxArea({1,1}) != 1) throw runtime_error(\"Test 2 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "ContainerWithMostWater(height: List[int]) -> int",
      "testCalls": [
        "assert ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) == 49",
        "assert ContainerWithMostWater([1,1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int maxArea(int[] height) {}",
      "testCalls": [
        "if (maxArea(new int[]{1,8,6,2,5,4,8,3,7}) != 49) throw new AssertionError();",
        "if (maxArea(new int[]{1,1}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxArea(int* height, int heightSize)",
      "testCalls": [
        "if(MaxArea((int[]){1,8,6,2,5,4,8,3,7}, 9) != 49) { printf(\"Test case 1 failed\"); }",
        "if(MaxArea((int[]){1,1}, 2) != 1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxArea(height []int) int {}",
      "testCalls": [
        "if MaxArea([]int{1,8,6,2,5,4,8,3,7}) != 49 {panic(\"Test case 1 failed\")}",
        "if MaxArea([]int{1,1}) != 1 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ContainerWithMostWater(height: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(ContainerWithMostWater(vec![1,8,6,2,5,4,8,3,7]), 49);",
        "assert_eq!(ContainerWithMostWater(vec![1,1]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ContainerWithMostWater(height)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ContainerWithMostWater([1,8,6,2,5,4,8,3,7]) == 49",
        "raise 'Test Case 2 Failed' unless ContainerWithMostWater([1,1]) == 1"
      ],
      "compareHelper": ""
    }
  },
  "contains-duplicate-ii": {
    "title": "Contains Duplicate II",
    "content": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\n\nExample 1:\n\nInput: nums = [1,2,3,1], k = 3\nOutput: true\n\nExample 2:\n\nInput: nums = [1,0,1,1], k = 1\nOutput: true\n\nExample 3:\n\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\n\n\nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n0 <= k <= 105\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ContainsDuplicateII(nums, k) { }",
      "testCalls": [
        "if(ContainsDuplicateII([1,2,3,1], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(ContainsDuplicateII([1,0,1,1], 1) !== true) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ContainsDuplicateII(nums: number[], k: number): boolean {}",
      "testCalls": [
        "if (ContainsDuplicateII([1,2,3,1], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (ContainsDuplicateII([1,0,1,1], 1) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (ContainsDuplicateII([1,2,3,1,2,3], 2) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool ContainsDuplicateII(vector<int>& nums, int k);",
      "testCalls": [
        "if (ContainsDuplicateII({1,2,3,1}, 3) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (ContainsDuplicateII({1,0,1,1}, 1) != true) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ContainsDuplicateII(nums: List[int], k: int) -> bool:",
      "testCalls": [
        "assert ContainsDuplicateII([1,2,3,1], 3) == True",
        "assert ContainsDuplicateII([1,0,1,1], 1) == True"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean ContainsDuplicateII(int[] nums, int k) { }",
      "testCalls": [
        "if (!ContainsDuplicateII(new int[]{1,2,3,1}, 3)) { throw new AssertionError(); }",
        "if (!ContainsDuplicateII(new int[]{1,0,1,1}, 1)) { throw new AssertionError(); }"
      ],
      "compareHelper": "Arrays.equals(expectedArray, actualArray)"
    },
    "c": {
      "functionDeclaration": "bool ContainsDuplicateII(int* nums, int numsSize, int k)",
      "testCalls": [
        "if (!ContainsDuplicateII((int[]){1,2,3,1}, 4, 3)) { printf(\"Test Case 1 Failed\"); }",
        "if (!ContainsDuplicateII((int[]){1,0,1,1}, 4, 1)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ContainsNearbyDuplicate(nums []int, k int) bool {}",
      "testCalls": [
        "if !ContainsNearbyDuplicate([]int{1,2,3,1}, 3) {panic(\"Test case 1 failed\")}",
        "if !ContainsNearbyDuplicate([]int{1,0,1,1}, 1) {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ContainsDuplicateII(nums: Vec<i32>, k: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(ContainsDuplicateII(vec![1, 2, 3, 1], 3), true);",
        "assert_eq!(ContainsDuplicateII(vec![1, 0, 1, 1], 1), true); assert_eq!(ContainsDuplicateII(vec![1, 2, 3, 1, 2, 3], 2), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ContainsDuplicateII(nums, k)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless ContainsDuplicateII([1,2,3,1], 3) == true",
        "raise 'Test Case 2 Failed' unless ContainsDuplicateII([1,0,1,1], 1) == true",
        "raise 'Test Case 3 Failed' unless ContainsDuplicateII([1,2,3,1,2,3], 2) == false"
      ],
      "compareHelper": ""
    }
  },
  "convert-sorted-array-to-binary-search-tree": {
    "title": "Convert Sorted Array to Binary Search Tree",
    "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n\nExample 1:\n\n\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\n\n\nExample 2:\n\n\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in a strictly increasing order.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SortedArrayToBinarySearchTree(nums) {}",
      "testCalls": [
        "if(JSON.stringify(SortedArrayToBinarySearchTree([-10,-3,0,5,9])) !== JSON.stringify([0,-3,9,-10,null,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(SortedArrayToBinarySearchTree([1,3])) !== JSON.stringify([3,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function SortedArrayToBinarySearchTree(nums: number[]): TreeNode | null {}",
      "testCalls": [
        "if(JSON.stringify(ConvertSortedArrayToBinarySearchTree([-10,-3,0,5,9])) !== JSON.stringify([0,-3,9,-10,null,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(ConvertSortedArrayToBinarySearchTree([1,3])) !== JSON.stringify([3,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "c++": {
      "functionDeclaration": "TreeNode* SortedArrayToBST(vector<int>& nums)",
      "testCalls": [
        "assert(TreeNodeToString(SortedArrayToBST({-10,-3,0,5,9})) == \"[0,-3,9,-10,null,5]\");",
        "assert(TreeNodeToString(SortedArrayToBST({1,3})) == \"[3,1]\");"
      ],
      "compareHelper": "string TreeNodeToString(TreeNode* root) { ... }"
    },
    "python": {
      "functionDeclaration": "def ConvertSortedArrayToBinarySearchTree(nums: List[int]) -> TreeNode:",
      "testCalls": [
        "result1 = ConvertSortedArrayToBinarySearchTree([-10,-3,0,5,9]); assert result1 == [0,-3,9,-10,null,5]",
        "result2 = ConvertSortedArrayToBinarySearchTree([1,3]); assert result2 == [3,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2): return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public TreeNode sortedArrayToBST(int[] nums) {}",
      "testCalls": [
        "assert Arrays.equals(TreeNode.toArray(sortedArrayToBST(new int[]{-10,-3,0,5,9})), TreeNode.toArray(TreeNode.fromArray(new Integer[]{0,-3,9,-10,null,5}));",
        "assert Arrays.equals(TreeNode.toArray(sortedArrayToBST(new int[]{1,3})), TreeNode.toArray(TreeNode.fromArray(new Integer[]{3,1}));"
      ],
      "compareHelper": "private static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } static Integer[] toArray(TreeNode root) { if (root == null) return new Integer[0]; List<Integer> list = new ArrayList<>(); Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node == null) { list.add(null); } else { list.add(node.val); queue.add(node.left); queue.add(node.right); } } while (list.get(list.size() - 1) == null) { list.remove(list.size() - 1); } return list.toArray(new Integer[0]); } static TreeNode fromArray(Integer[] arr) { if (arr.length == 0) return null; TreeNode[] nodes = new TreeNode[arr.length]; for (int i = 0; i < arr.length; i++) { if (arr[i] != null) { nodes[i] = new TreeNode(arr[i]); } } TreeNode root = nodes[0]; for (int i = 0; i < arr.length; i++) { if (nodes[i] != null) { int leftIndex = 2 * i + 1; int rightIndex = 2 * i + 2; if (leftIndex < arr.length) nodes[i].left = nodes[leftIndex]; if (rightIndex < arr.length) nodes[i].right = nodes[rightIndex]; } } return root; } }"
    },
    "c": {
      "functionDeclaration": "TreeNode* SortedArrayToBST(int* nums, int numsSize)",
      "testCalls": [
        "assert(strcmp(TreeNodeToString(SortedArrayToBST((int[]){-10,-3,0,5,9}, 5)), \"[0,-3,9,-10,null,5]\") == 0;",
        "assert(strcmp(TreeNodeToString(SortedArrayToBST((int[]){1,3}, 2)), \"[3,1]\") == 0;"
      ],
      "compareHelper": "char* TreeNodeToString(TreeNode* root) { /* Helper function implementation for converting TreeNode to string */ }"
    },
    "go": {
      "functionDeclaration": "func SortedArrayToBST(nums []int) *TreeNode {}",
      "testCalls": [
        "if result := SortedArrayToBST([]int{-10,-3,0,5,9}); !compareTrees(result, createTree([]int{0,-3,9,-10,0,5})) { t.Errorf(\"Test case 1 failed\") }",
        "if result := SortedArrayToBST([]int{1,3}); !compareTrees(result, createTree([]int{3,1})) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareTrees(tree1 *TreeNode, tree2 *TreeNode) bool {}"
    },
    "rust": {
      "functionDeclaration": "pub fn ConvertSortedArrayToBinarySearchTree(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {}",
      "testCalls": [
        "assert_eq!(ConvertSortedArrayToBinarySearchTree(vec![-10,-3,0,5,9]), Some(Rc::new(RefCell::new(TreeNode { val: 0, left: Some(Rc::new(RefCell::new(TreeNode { val: -3, left: Some(Rc::new(RefCell::new(TreeNode { val: -10, left: None, right: None }))), right: Some(Rc::new(RefCell::new(TreeNode { val: 5, left: None, right: Some(Rc::new(RefCell::new(TreeNode { val: 9, left: None, right: None }))) }))) }))), right: None })))",
        "assert_eq!(ConvertSortedArrayToBinarySearchTree(vec![1,3]), Some(Rc::new(RefCell::new(TreeNode { val: 3, left: Some(Rc::new(RefCell::new(TreeNode { val: 1, left: None, right: None }))), right: None })))"
      ],
      "compareHelper": "fn compare_trees(tree1: Option<Rc<RefCell<TreeNode>>>, tree2: Option<Rc<RefCell<TreeNode>>>) -> bool { if tree1.is_none() && tree2.is_none() { return true; } if tree1.is_none() || tree2.is_none() { return false; } let tree1_val = tree1.as_ref().unwrap().borrow().val; let tree2_val = tree2.as_ref().unwrap().borrow().val; let left_result = compare_trees(tree1.as_ref().unwrap().borrow().left.clone(), tree2.as_ref().unwrap().borrow().left.clone()); let right_result = compare_trees(tree1.as_ref().unwrap().borrow().right.clone(), tree2.as_ref().unwrap().borrow().right.clone()); return tree1_val == tree2_val && left_result && right_result; }"
    },
    "ruby": {
      "functionDeclaration": "def ConvertSortedArrayToBinarySearchTree(nums)\nend",
      "testCalls": [
        "test_case_1 = ConvertSortedArrayToBinarySearchTree([-10,-3,0,5,9])\nraise 'Test Case 1 Failed' unless test_case_1 == [0,-3,9,-10,nil,5]",
        "test_case_2 = ConvertSortedArrayToBinarySearchTree([1,3])\nraise 'Test Case 2 Failed' unless test_case_2 == [3,1]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "copy-list-with-random-pointer": {
    "title": "Copy List with Random Pointer",
    "content": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\n\nYour code will only be given the head of the original linked list.\n\nExample 1:\n\n\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nExample 2:\n\n\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n\nExample 3:\n\n\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n\n\nConstraints:\n\n0 <= n <= 1000\n-104 <= Node.val <= 104\nNode.random is null or is pointing to some node in the linked list.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.",
      "You may want to use extra space to keep old_node ---> new_node mapping to prevent creating multiple copies of the same node.",
      "We can avoid using extra space for old_node ---> new_node mapping by tweaking the original linked list. Simply interweave the nodes of the old and copied list. For example:\r\nOld List: A --> B --> C --> D\r\nInterWeaved List: A --> A' --> B --> B' --> C --> C' --> D --> D'",
      "The interweaving is done using next</b> pointers and we can make use of interweaved structure to get the correct reference nodes for random</b> pointers."
    ],
    "topicTags": [
      "Hash Table",
      "Linked List"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "CopyListWithRandomPointer(head)",
      "testCalls": [
        "const test1 = CopyListWithRandomPointer([[7,null],[13,0],[11,4],[10,2],[1,0]]); if(JSON.stringify(test1) !== JSON.stringify([[7,null],[13,0],[11,4],[10,2],[1,0]])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = CopyListWithRandomPointer([[1,1],[2,1]]); if(JSON.stringify(test2) !== JSON.stringify([[1,1],[2,1]])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = CopyListWithRandomPointer([[3,null],[3,0],[3,null]]); if(JSON.stringify(test3) !== JSON.stringify([[3,null],[3,0],[3,null]])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "CopyListWithRandomPointer(head: number[][]): number[][]",
      "testCalls": [
        "const test1 = CopyListWithRandomPointer([[7,null],[13,0],[11,4],[10,2],[1,0]]); if(JSON.stringify(test1) !== JSON.stringify([[7,null],[13,0],[11,4],[10,2],[1,0]])) throw new Error('Test Case 1 Failed');",
        "const test2 = CopyListWithRandomPointer([[1,1],[2,1]]); if(JSON.stringify(test2) !== JSON.stringify([[1,1],[2,1]])) throw new Error('Test Case 2 Failed');",
        "const test3 = CopyListWithRandomPointer([[3,null],[3,0],[3,null]]); if(JSON.stringify(test3) !== JSON.stringify([[3,null],[3,0],[3,null]])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function compareArrays(arr1: any[], arr2: any[]): boolean { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "c++": {
      "functionDeclaration": "CopyListWithRandomPointer(Node* head)",
      "testCalls": [
        "assert(compareLists(CopyListWithRandomPointer(parseList(\"[[7,null],[13,0],[11,4],[10,2],[1,0]]\")), parseList(\"[[7,null],[13,0],[11,4],[10,2],[1,0]]\")));",
        "assert(compareLists(CopyListWithRandomPointer(parseList(\"[[1,1],[2,1]]\")), parseList(\"[[1,1],[2,1]]\")));",
        "assert(compareLists(CopyListWithRandomPointer(parseList(\"[[3,null],[3,0],[3,null]]\")), parseList(\"[[3,null],[3,0],[3,null]]\")));"
      ],
      "compareHelper": "bool compareLists(Node* list1, Node* list2) { while (list1 && list2) { if (list1->val != list2->val || (list1->random && !list2->random) || (!list1->random && list2->random) || (list1->random && list2->random && list1->random->val != list2->random->val)) return false; list1 = list1->next; list2 = list2->next; } return !list1 && !list2; }"
    },
    "python": {
      "functionDeclaration": "def CopyListWithRandomPointer(head: List[List[int]]) -> List[List[int]]:",
      "testCalls": [
        "result1 = CopyListWithRandomPointer([[7,null],[13,0],[11,4],[10,2],[1,0]])\nassert result1 == [[7,null],[13,0],[11,4],[10,2],[1,0]], 'Test Case 1 Failed'",
        "result2 = CopyListWithRandomPointer([[1,1],[2,1]])\nassert result2 == [[1,1],[2,1]], 'Test Case 2 Failed'",
        "result3 = CopyListWithRandomPointer([[3,null],[3,0],[3,null]])\nassert result3 == [[3,null],[3,0],[3,null]], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if len(list1) != len(list2):\n        return False\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public Node copyRandomList(Node head)",
      "testCalls": [
        "Node test1 = copyRandomList(new Node(new int[][]{{7, null}, {13, 0}, {11, 4}, {10, 2}, {1, 0}}));\nif (!compareNodes(test1, new Node(new int[][]{{7, null}, {13, 0}, {11, 4}, {10, 2}, {1, 0}}))) throw new AssertionError();",
        "Node test2 = copyRandomList(new Node(new int[][]{{1, 1}, {2, 1}}));\nif (!compareNodes(test2, new Node(new int[][]{{1, 1}, {2, 1}}))) throw new AssertionError();",
        "Node test3 = copyRandomList(new Node(new int[][]{{3, null}, {3, 0}, {3, null}}));\nif (!compareNodes(test3, new Node(new int[][]{{3, null}, {3, 0}, {3, null}}))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareNodes(Node node1, Node node2) {\n    // Implement comparison logic here\n}"
    },
    "c": {
      "functionDeclaration": "Node* CopyListWithRandomPointer(Node* head)",
      "testCalls": [
        "Node* head1 = CreateList([[7,null],[13,0],[11,4],[10,2],[1,0]]); Node* expected1 = CreateList([[7,null],[13,0],[11,4],[10,2],[1,0]]); Node* result1 = CopyListWithRandomPointer(head1); compareLists(expected1, result1);",
        "Node* head2 = CreateList([[1,1],[2,1]]); Node* expected2 = CreateList([[1,1],[2,1]]); Node* result2 = CopyListWithRandomPointer(head2); compareLists(expected2, result2);",
        "Node* head3 = CreateList([[3,null],[3,0],[3,null]]); Node* expected3 = CreateList([[3,null],[3,0],[3,null]]); Node* result3 = CopyListWithRandomPointer(head3); compareLists(expected3, result3);"
      ],
      "compareHelper": "void compareLists(Node* expected, Node* result) { while(expected != NULL && result != NULL) { if(expected->val != result->val || (expected->random != NULL && result->random == NULL) || (expected->random == NULL && result->random != NULL) || (expected->random != NULL && result->random != NULL && expected->random->val != result->random->val)) { printf(\"Test Failed\"); exit(1); } expected = expected->next; result = result->next; } if(expected != NULL || result != NULL) { printf(\"Test Failed\"); exit(1); } }"
    },
    "go": {
      "functionDeclaration": "func CopyListWithRandomPointer(head *Node) *Node {}",
      "testCalls": [
        "if result := CopyListWithRandomPointer(BuildList([][]int{{7, -1}, {13, 0}, {11, 4}, {10, 2}, {1, 0}})); !CompareLists(result, BuildList([][]int{{7, -1}, {13, 0}, {11, 4}, {10, 2}, {1, 0}})) { t.Errorf(\"Test 1 Failed\") }",
        "if result := CopyListWithRandomPointer(BuildList([][]int{{1, 1}, {2, 1}})); !CompareLists(result, BuildList([][]int{{1, 1}, {2, 1}})) { t.Errorf(\"Test 2 Failed\") }",
        "if result := CopyListWithRandomPointer(BuildList([][]int{{3, -1}, {3, 0}, {3, -1}})); !CompareLists(result, BuildList([][]int{{3, -1}, {3, 0}, {3, -1}})) { t.Errorf(\"Test 3 Failed\") }"
      ],
      "compareHelper": "func CompareLists(list1, list2 *Node) bool { for list1 != nil && list2 != nil { if list1.Val != list2.Val || (list1.Random != nil && list2.Random == nil) || (list1.Random == nil && list2.Random != nil) || (list1.Random != nil && list2.Random != nil && list1.Random.Val != list2.Random.Val) { return false } list1 = list1.Next list2 = list2.Next } return list1 == nil && list2 == nil }"
    },
    "ruby": {
      "functionDeclaration": "def CopyListWithRandomPointer(head)\n  # code here\nend",
      "testCalls": [
        "test_case_1 = CopyListWithRandomPointer([[7,null],[13,0],[11,4],[10,2],[1,0]])\nraise 'Test Case 1 Failed' unless test_case_1 == [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "test_case_2 = CopyListWithRandomPointer([[1,1],[2,1]])\nraise 'Test Case 2 Failed' unless test_case_2 == [[1,1],[2,1]]",
        "test_case_3 = CopyListWithRandomPointer([[3,null],[3,0],[3,null]])\nraise 'Test Case 3 Failed' unless test_case_3 == [[3,null],[3,0],[3,null]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "count-complete-tree-nodes": {
    "title": "Count Complete Tree Nodes",
    "content": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less thanO(n)time complexity.\n\nExample 1:\n\n\nInput: root = [1,2,3,4,5,6]\nOutput: 6\n\nExample 2:\n\nInput: root = []\nOutput: 0\n\nExample 3:\n\nInput: root = [1]\nOutput: 1\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5 * 104].\n0 <= Node.val <= 5 * 104\nThe tree is guaranteed to be complete.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Binary Search",
      "Bit Manipulation",
      "Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CountCompleteTreeNodes(root) {}",
      "testCalls": [
        "if(CountCompleteTreeNodes([1,2,3,4,5,6]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(CountCompleteTreeNodes([]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(CountCompleteTreeNodes([1]) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function CountCompleteTreeNodes(root: number[]): number {}",
      "testCalls": [
        "if(CountCompleteTreeNodes([1,2,3,4,5,6]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(CountCompleteTreeNodes([]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(CountCompleteTreeNodes([1]) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int CountCompleteTreeNodes(TreeNode* root)",
      "testCalls": [
        "assert(CountCompleteTreeNodes(createTree({1,2,3,4,5,6})) == 6);",
        "assert(CountCompleteTreeNodes(nullptr) == 0);",
        "assert(CountCompleteTreeNodes(createTree({1})) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def CountCompleteTreeNodes(root: List[int]) -> int",
      "testCalls": [
        "assert CountCompleteTreeNodes([1,2,3,4,5,6]) == 6",
        "assert CountCompleteTreeNodes([]) == 0",
        "assert CountCompleteTreeNodes([1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int countCompleteTreeNodes(TreeNode root)",
      "testCalls": [
        "assertEquals(6, countCompleteTreeNodes(TreeNode.build(new Integer[]{1,2,3,4,5,6})));",
        "assertEquals(0, countCompleteTreeNodes(null));",
        "assertEquals(1, countCompleteTreeNodes(TreeNode.build(new Integer[]{1})));"
      ],
      "compareHelper": "private static void assertEquals(int expected, int actual) {\n    if (expected != actual) {\n        throw new AssertionError(\"Expected: \" + expected + \", but was: \" + actual);\n    }\n}"
    },
    "c": {
      "functionDeclaration": "int CountCompleteTreeNodes(struct TreeNode* root)",
      "testCalls": [
        "assert(CountCompleteTreeNodes(createTreeFromArray((int[]){1, 2, 3, 4, 5, 6}, 6)) == 6);",
        "assert(CountCompleteTreeNodes(NULL) == 0);",
        "assert(CountCompleteTreeNodes(createTreeFromArray((int[]){1}, 1)) == 1);"
      ],
      "compareHelper": "int* createTreeFromArray(int arr[], int size) { /* implementation here */ }"
    },
    "go": {
      "functionDeclaration": "func CountCompleteTreeNodes(root *TreeNode) int {}",
      "testCalls": [
        "if CountCompleteTreeNodes(&TreeNode{Val: 1, Left: &TreeNode{Val: 2}, Right: &TreeNode{Val: 3, Left: &TreeNode{Val: 4}, Right: &TreeNode{Val: 5, Left: &TreeNode{Val: 6}}}}) != 6 {panic(\"Test case 1 failed\")}",
        "if CountCompleteTreeNodes(nil) != 0 {panic(\"Test case 2 failed\")}",
        "if CountCompleteTreeNodes(&TreeNode{Val: 1}) != 1 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn CountCompleteTreeNodes(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(CountCompleteTreeNodes(Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 4, left: None, right: None })), right: Some(Box::new(TreeNode { val: 5, left: None, right: None })) })), right: Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: None })) }))), 6);",
        "assert_eq!(CountCompleteTreeNodes(None), 0);",
        "assert_eq!(CountCompleteTreeNodes(Some(Box::new(TreeNode { val: 1, left: None, right: None }))), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def CountCompleteTreeNodes(root)\nend",
      "testCalls": [
        "assert_equal(6, CountCompleteTreeNodes([1,2,3,4,5,6]))",
        "assert_equal(0, CountCompleteTreeNodes([]))",
        "assert_equal(1, CountCompleteTreeNodes([1]))"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend"
    }
  },
  "course-schedule-ii": {
    "title": "Course Schedule II",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nai != bi\nAll the pairs [ai, bi] are distinct.\n\n",
    "difficulty": "Medium",
    "hints": [
      "This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
      "<a href=\"https://www.youtube.com/watch?v=ozso3xxkVGU\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.",
      "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
    ],
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CourseScheduleII(numCourses, prerequisites) {}",
      "testCalls": [
        "const testOutput1 = CourseScheduleII(2, [[1,0]]); if(JSON.stringify(testOutput1) !== '[0,1]') { throw new Error('Test Case 1 Failed'); }",
        "const testOutput2 = CourseScheduleII(4, [[1,0],[2,0],[3,1],[3,2]]); if(JSON.stringify(testOutput2) !== '[0,2,1,3]') { throw new Error('Test Case 2 Failed'); }",
        "const testOutput3 = CourseScheduleII(1, []); if(JSON.stringify(testOutput3) !== '[0]') { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function CourseScheduleII(numCourses: number, prerequisites: number[][]): number[]",
      "testCalls": [
        "if(JSON.stringify(CourseScheduleII(2, [[1,0]])) !== JSON.stringify([0,1])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(CourseScheduleII(4, [[1,0],[2,0],[3,1],[3,2]])) !== JSON.stringify([0,2,1,3])) { throw new Error('Test Case 2 Failed'); }",
        "if(JSON.stringify(CourseScheduleII(1, [])) !== JSON.stringify([0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<int> CourseScheduleII(int numCourses, vector<vector<int>>& prerequisites);",
      "testCalls": [
        "assert(CourseScheduleII(2, {{1,0}}) == vector<int>({0,1}));",
        "assert(CourseScheduleII(4, {{1,0},{2,0},{3,1},{3,2}}) == vector<int>({0,2,1,3}));",
        "assert(CourseScheduleII(1, {}) == vector<int>({0}));"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def CourseScheduleII(numCourses, prerequisites):",
      "testCalls": [
        "assert CourseScheduleII(2, [[1,0]]) == [0,1], 'Test Case 1 Failed'",
        "assert CourseScheduleII(4, [[1,0],[2,0],[3,1],[3,2]]) == [0,2,1,3], 'Test Case 2 Failed'",
        "assert CourseScheduleII(1, []) == [0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public int[] CourseScheduleII(int numCourses, int[][] prerequisites) {}",
      "testCalls": [
        "assert Arrays.equals(new int[]{0, 1}, CourseScheduleII(2, new int[][]{{1,0}}));",
        "assert Arrays.equals(new int[]{0, 2, 1, 3}, CourseScheduleII(4, new int[][]{{1,0},{2,0},{3,1},{3,2}}));",
        "assert Arrays.equals(new int[]{0}, CourseScheduleII(1, new int[][]{}));"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int* CourseScheduleII(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize)",
      "testCalls": [
        "int numCourses1 = 2; int prerequisites1[][2] = {{1,0}}; int* result1 = CourseScheduleII(numCourses1, prerequisites1, 1, (int[]){2}); if (compareArrays(result1, (int[]){0,1}, 2) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int numCourses2 = 4; int prerequisites2[][2] = {{1,0},{2,0},{3,1},{3,2}}; int* result2 = CourseScheduleII(numCourses2, prerequisites2, 4, (int[]){2,2,2,2}); if (compareArrays(result2, (int[]){0,2,1,3}, 4) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return -1; } } return 0; }"
    },
    "go": {
      "functionDeclaration": "func CourseScheduleII(numCourses int, prerequisites [][]int) []int {}",
      "testCalls": [
        "if !compareArrays(CourseScheduleII(2, [][]int{{1,0}}), []int{0,1}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(CourseScheduleII(4, [][]int{{1,0},{2,0},{3,1},{3,2}}), []int{0,2,1,3}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(CourseScheduleII(1, [][]int{}), []int{0}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn CourseScheduleII(numCourses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(CourseScheduleII(2, vec![vec![1, 0]]), vec![0, 1]);",
        "assert_eq!(CourseScheduleII(4, vec![vec![1, 0], vec![2, 0], vec![3, 1], vec![3, 2]]), vec![0, 2, 1, 3]); assert_eq!(CourseScheduleII(1, vec![]), vec![0]);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def CourseScheduleII(numCourses, prerequisites)\n  \nend",
      "testCalls": [
        "test_case_1 = CourseScheduleII(2, [[1,0]])\nraise 'Test Case 1 Failed' unless test_case_1 == [0,1]",
        "test_case_2 = CourseScheduleII(4, [[1,0],[2,0],[3,1],[3,2]])\nraise 'Test Case 2 Failed' unless test_case_2 == [0,2,1,3]"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "course-schedule": {
    "title": "Course Schedule",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\nExample 2:\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.\n\n",
    "difficulty": "Medium",
    "hints": [
      "This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
      "<a href=\"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf\" target=\"_blank\">Topological Sort via DFS</a> - A great tutorial explaining the basic concepts of Topological Sort.",
      "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
    ],
    "topicTags": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function CourseSchedule(numCourses, prerequisites) {}",
      "testCalls": [
        "if (CourseSchedule(2, [[1,0]]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (CourseSchedule(2, [[1,0],[0,1]]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function CourseSchedule(numCourses: number, prerequisites: number[][]): boolean {}",
      "testCalls": [
        "if (CourseSchedule(2, [[1,0]]) !== true) throw new Error('Test Case 1 Failed');",
        "if (CourseSchedule(2, [[1,0],[0,1]]) !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "bool CourseSchedule(int numCourses, vector<vector<int>>& prerequisites);",
      "testCalls": [
        "if (CourseSchedule(2, {{1,0}}) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (CourseSchedule(2, {{1,0},{0,1}}) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def CourseSchedule(numCourses, prerequisites):",
      "testCalls": [
        "assert CourseSchedule(2, [[1,0]]) == True, 'Test Case 1 Failed'",
        "assert CourseSchedule(2, [[1,0],[0,1]]) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean CourseSchedule(int numCourses, int[][] prerequisites) {}",
      "testCalls": [
        "if (!CourseSchedule(2, new int[][]{{1,0}})) throw new AssertionError();",
        "if (CourseSchedule(2, new int[][]{{1,0},{0,1}})) throw new AssertionError();"
      ],
      "compareHelper": "Arrays.deepEquals(expectedArray, actualArray)"
    },
    "c": {
      "functionDeclaration": "bool CourseSchedule(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize)",
      "testCalls": [
        "if (!CourseSchedule(2, (int*[]){(int[]){1, 0}}, 1, (int[]){2})) { printf(\"Test Case 1 Failed\"); }",
        "if (CourseSchedule(2, (int*[]){(int[]){1, 0}, (int[]){0, 1}}, 2, (int[]){2, 2})) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func CourseSchedule(numCourses int, prerequisites [][]int) bool {}",
      "testCalls": [
        "if CourseSchedule(2, [][]int{{1,0}}) != true {panic(\"Test case 1 failed\")}",
        "if CourseSchedule(2, [][]int{{1,0},{0,1}}) != false {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn CourseSchedule(numCourses: i32, prerequisites: Vec<Vec<i32>>) -> bool {}",
      "testCalls": [
        "assert_eq!(CourseSchedule(2, vec![vec![1, 0]]), true);",
        "assert_eq!(CourseSchedule(2, vec![vec![1, 0], vec![0, 1]]), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def CourseSchedule(numCourses, prerequisites)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless CourseSchedule(2, [[1,0]]) == true",
        "raise 'Test Case 2 Failed' unless CourseSchedule(2, [[1,0],[0,1]]) == false"
      ],
      "compareHelper": ""
    }
  },
  "edit-distance": {
    "title": "Edit Distance",
    "content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n\n\nExample 1:\n\nInput: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\nOutput: 3\nExplanation: \nhorse -> rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -> rose (remove &#39;r&#39;)\nrose -> ros (remove &#39;e&#39;)\n\nExample 2:\n\nInput: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\nOutput: 5\nExplanation: \nintention -> inention (remove &#39;t&#39;)\ninention -> enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -> exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -> exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -> execution (insert &#39;u&#39;)\n\n\nConstraints:\n\n0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EditDistance(word1, word2) {}",
      "testCalls": [
        "if(EditDistance('horse', 'ros') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(EditDistance('intention', 'execution') !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function EditDistance(word1: string, word2: string): number {}",
      "testCalls": [
        "if (EditDistance('horse', 'ros') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (EditDistance('intention', 'execution') !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int EditDistance(string word1, string word2);",
      "testCalls": [
        "if (EditDistance(\"horse\", \"ros\") != 3) throw std::runtime_error(\"Test 1 failed!\");",
        "if (EditDistance(\"intention\", \"execution\") != 5) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def EditDistance(word1: str, word2: str) -> int:",
      "testCalls": [
        "assert EditDistance(\"horse\", \"ros\") == 3",
        "assert EditDistance(\"intention\", \"execution\") == 5"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int EditDistance(String word1, String word2) { }",
      "testCalls": [
        "if (EditDistance(\"horse\", \"ros\") != 3) { throw new AssertionError(); }",
        "if (EditDistance(\"intention\", \"execution\") != 5) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int EditDistance(char* word1, char* word2)",
      "testCalls": [
        "EditDistance(\"horse\", \"ros\")",
        "EditDistance(\"intention\", \"execution\")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func EditDistance(word1 string, word2 string) int {}",
      "testCalls": [
        "if EditDistance(\"horse\", \"ros\") != 3 { t.Error(\"Test Case 1 Failed\") }",
        "if EditDistance(\"intention\", \"execution\") != 5 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn EditDistance(word1: String, word2: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(EditDistance(String::from(\"horse\"), String::from(\"ros\")), 3);",
        "assert_eq!(EditDistance(String::from(\"intention\"), String::from(\"execution\")), 5);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EditDistance(word1, word2)\nend",
      "testCalls": [
        "test1 = EditDistance(\"horse\", \"ros\")\nraise 'Test Case 1 Failed' unless test1 == 3",
        "test2 = EditDistance(\"intention\", \"execution\")\nraise 'Test Case 2 Failed' unless test2 == 5"
      ],
      "compareHelper": ""
    }
  },
  "evaluate-division": {
    "title": "Evaluate Division",
    "content": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote:The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\nExample 1:\n\nInput: equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\nExplanation: \nGiven: a / b = 2.0, b / c = 3.0\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\nExample 2:\n\nInput: equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\nOutput: [3.75000,0.40000,5.00000,0.20000]\n\nExample 3:\n\nInput: equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\n\n\nConstraints:\n\n1 <= equations.length <= 20\nequations[i].length == 2\n1 <= Ai.length, Bi.length <= 5\nvalues.length == equations.length\n0.0 < values[i] <= 20.0\n1 <= queries.length <= 20\nqueries[i].length == 2\n1 <= Cj.length, Dj.length <= 5\nAi, Bi, Cj, Dj consist of lower case English letters and digits.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Do you recognize this as a graph problem?"
    ],
    "topicTags": [
      "Array",
      "String",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph",
      "Shortest Path"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EvaluateDivision(equations, values, queries) {}",
      "testCalls": [
        "const testOutput1 = EvaluateDivision([[\"a\",\"b\"],[\"b\",\"c\"]], [2.0,3.0], [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]); if(JSON.stringify(testOutput1) !== \"[6.00000,0.50000,-1.00000,1.00000,-1.00000]\") throw new Error(\"Test Case 1 Failed\");",
        "const testOutput2 = EvaluateDivision([[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], [1.5,2.5,5.0], [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]); if(JSON.stringify(testOutput2) !== \"[3.75000,0.40000,5.00000,0.20000]\") throw new Error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function EvaluateDivision(equations: string[][], values: number[], queries: string[][]): number[] {}",
      "testCalls": [
        "const test1 = EvaluateDivision([['a','b'],['b','c']], [2.0,3.0], [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]);\nif(JSON.stringify(test1) !== '[6.00000,0.50000,-1.00000,1.00000,-1.00000]') throw new Error('Test Case 1 Failed');",
        "const test2 = EvaluateDivision([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0], [['a','c'],['c','b'],['bc','cd'],['cd','bc']]);\nif(JSON.stringify(test2) !== '[3.75000,0.40000,5.00000,0.20000]') throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "const compareArrays = (arr1: any[], arr2: any[]): boolean => JSON.stringify(arr1) === JSON.stringify(arr2);"
    },
    "c++": {
      "functionDeclaration": "vector<double> EvaluateDivision(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries)",
      "testCalls": [
        "auto result1 = EvaluateDivision({{\"a\",\"b\"},{\"b\",\"c\"}}, {2.0,3.0}, {\"a\",\"c\"},{\"b\",\"a\"},{\"a\",\"e\"},{\"a\",\"a\"},{\"x\",\"x\"}); assert(result1 == vector<double>{6.00000,0.50000,-1.00000,1.00000,-1.00000});",
        "auto result2 = EvaluateDivision({{\"a\",\"b\"},{\"b\",\"c\"},{\"bc\",\"cd\"}}, {1.5,2.5,5.0}, {\"a\",\"c\"},{\"c\",\"b\"},{\"bc\",\"cd\"},{\"cd\",\"bc\"}); assert(result2 == vector<double>{3.75000,0.40000,5.00000,0.20000});",
        "auto result3 = EvaluateDivision({{\"a\",\"b\"}}, {0.5}, {\"a\",\"b\"},{\"b\",\"a\"},{\"a\",\"c\"},{\"x\",\"y\"}); assert(result3 == vector<double>{0.50000,2.00000,-1.00000,-1.00000});"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def EvaluateDivision(equations, values, queries):",
      "testCalls": [
        "assert EvaluateDivision([['a','b'],['b','c']], [2.0,3.0], [['a','c'],['b','a'],['a','e'],['a','a'],['x','x']]) == [6.00000,0.50000,-1.00000,1.00000,-1.00000]",
        "assert EvaluateDivision([['a','b'],['b','c'],['bc','cd']], [1.5,2.5,5.0], [['a','c'],['c','b'],['bc','cd'],['cd','bc']]) == [3.75000,0.40000,5.00000,0.20000]",
        "assert EvaluateDivision([['a','b']], [0.5], [['a','b'],['b','a'],['a','c'],['x','y']]) == [0.50000,2.00000,-1.00000,-1.00000]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if abs(arr1[i] - arr2[i]) > 0.00001:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public double[] EvaluateDivision(String[][] equations, double[] values, String[][] queries) {}",
      "testCalls": [
        "double[] result1 = EvaluateDivision(new String[][]{{\"a\",\"b\"},{\"b\",\"c\"}}, new double[]{2.0,3.0}, new String[][]{{\"a\",\"c\"},{\"b\",\"a\"},{\"a\",\"e\"},{\"a\",\"a\"},{\"x\",\"x\"}}); assert Arrays.equals(result1, new double[]{6.00000,0.50000,-1.00000,1.00000,-1.00000});",
        "double[] result2 = EvaluateDivision(new String[][]{{\"a\",\"b\"},{\"b\",\"c\"},{\"bc\",\"cd\"}}, new double[]{1.5,2.5,5.0}, new String[][]{{\"a\",\"c\"},{\"c\",\"b\"},{\"bc\",\"cd\"},{\"cd\",\"bc\"}}); assert Arrays.equals(result2, new double[]{3.75000,0.40000,5.00000,0.20000});",
        "double[] result3 = EvaluateDivision(new String[][]{{\"a\",\"b\"}}, new double[]{0.5}, new String[][]{{\"a\",\"b\"},{\"b\",\"a\"},{\"a\",\"c\"},{\"x\",\"y\"}}); assert Arrays.equals(result3, new double[]{0.50000,2.00000,-1.00000,-1.00000});"
      ],
      "compareHelper": "private boolean arraysEqual(double[] arr1, double[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "double* EvaluateDivision(char*** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char*** queries, int queriesSize, int* queriesColSize)",
      "testCalls": [
        "double* result1 = EvaluateDivision((char***)[[\"a\",\"b\"],[\"b\",\"c\"]], 2, (int[]){2, 2}, (double[]){2.0, 3.0}, 2, (char***)[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]], 5, (int[]){2, 2});\nif (memcmp(result1, (double[]){6.0, 0.5, -1.0, 1.0, -1.0}, 5 * sizeof(double)) != 0) { printf(\"Test case 1 failed\"); }",
        "double* result2 = EvaluateDivision((char***)[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], 3, (int[]){2, 2, 2}, (double[]){1.5, 2.5, 5.0}, 3, (char***)[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]], 4, (int[]){2, 2});\nif (memcmp(result2, (double[]){3.75, 0.4, 5.0, 0.2}, 4 * sizeof(double)) != 0) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "int compareArrays(double* arr1, double* arr2, int size) {\n  for (int i = 0; i < size; i++) {\n    if (arr1[i] != arr2[i]) return 0;\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func CalcEquation(equations [][]string, values []float64, queries [][]string) []float64 {}",
      "testCalls": [
        "result := CalcEquation([][]string{{\"a\",\"b\"},{\"b\",\"c\"}}, []float64{2.0,3.0}, [][]string{{\"a\",\"c\"},{\"b\",\"a\"},{\"a\",\"e\"},{\"a\",\"a\"},{\"x\",\"x\"}})\nexpected := []float64{6.00000,0.50000,-1.00000,1.00000,-1.00000}\nif !compareFloatArrays(result, expected) { t.Errorf(\"Test 1 Failed\") }",
        "result := CalcEquation([][]string{{\"a\",\"b\"},{\"b\",\"c\"},{\"bc\",\"cd\"}}, []float64{1.5,2.5,5.0}, [][]string{{\"a\",\"c\"},{\"c\",\"b\"},{\"bc\",\"cd\"},{\"cd\",\"bc\"}})\nexpected := []float64{3.75000,0.40000,5.00000,0.20000}\nif !compareFloatArrays(result, expected) { t.Errorf(\"Test 2 Failed\") }",
        "result := CalcEquation([][]string{{\"a\",\"b\"}}, []float64{0.5}, [][]string{{\"a\",\"b\"},{\"b\",\"a\"},{\"a\",\"c\"},{\"x\",\"y\"}})\nexpected := []float64{0.50000,2.00000,-1.00000,-1.00000}\nif !compareFloatArrays(result, expected) { t.Errorf(\"Test 3 Failed\") }"
      ],
      "compareHelper": "func compareFloatArrays(arr1, arr2 []float64) bool {\n  if len(arr1) != len(arr2) { return false }\n  for i := range arr1 {\n    if math.Abs(arr1[i]-arr2[i]) > 0.00001 { return false }\n  }\n  return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn EvaluateDivision(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> { }",
      "testCalls": [
        "let result1 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"c\".to_string()]], vec![2.0, 3.0], vec![vec![\"a\".to_string(), \"c\".to_string()], vec![\"b\".to_string(), \"a\".to_string()], vec![\"a\".to_string(), \"e\".to_string()], vec![\"a\".to_string(), \"a\".to_string()], vec![\"x\".to_string(), \"x\".to_string()]);\nassert_eq!(result1, vec![6.0, 0.5, -1.0, 1.0, -1.0]);",
        "let result2 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"c\".to_string()], vec![\"bc\".to_string(), \"cd\".to_string()]], vec![1.5, 2.5, 5.0], vec![vec![\"a\".to_string(), \"c\".to_string()], vec![\"c\".to_string(), \"b\".to_string()], vec![\"bc\".to_string(), \"cd\".to_string()], vec![\"cd\".to_string(), \"bc\".to_string()]]);\nassert_eq!(result2, vec![3.75, 0.4, 5.0, 0.2]);",
        "let result3 = EvaluateDivision(vec![vec![\"a\".to_string(), \"b\".to_string()]], vec![0.5], vec![vec![\"a\".to_string(), \"b\".to_string()], vec![\"b\".to_string(), \"a\".to_string()], vec![\"a\".to_string(), \"c\".to_string()], vec![\"x\".to_string(), \"y\".to_string()]]);\nassert_eq!(result3, vec![0.5, 2.0, -1.0, -1.0]);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EvaluateDivision(equations, values, queries)\n  # Function body goes here\nend",
      "testCalls": [
        "result1 = EvaluateDivision([[\"a\",\"b\"],[\"b\",\"c\"]], [2.0,3.0], [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]])\nraise 'Test Case 1 Failed' unless result1 == [6.00000,0.50000,-1.00000,1.00000,-1.00000]",
        "result2 = EvaluateDivision([[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], [1.5,2.5,5.0], [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]])\nraise 'Test Case 2 Failed' unless result2 == [3.75000,0.40000,5.00000,0.20000]",
        "result3 = EvaluateDivision([[\"a\",\"b\"]], [0.5], [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]])\nraise 'Test Case 3 Failed' unless result3 == [0.50000,2.00000,-1.00000,-1.00000]"
      ],
      "compareHelper": ""
    }
  },
  "evaluate-reverse-polish-notation": {
    "title": "Evaluate Reverse Polish Notation",
    "content": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\nThe valid operators are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, and &#39;/&#39;.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.\n\n\nExample 1:\n\nInput: tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\n\nInput: tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\n\nInput: tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n\nConstraints:\n\n1 <= tokens.length <= 104\ntokens[i] is either an operator: &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, or &quot;/&quot;, or an integer in the range [-200, 200].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math",
      "Stack"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function EvaluateReversePolishNotation(tokens) {}",
      "testCalls": [
        "if (EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]) !== 9) { throw new Error('Test Case 1 Failed'); }",
        "if (EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]) !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function EvaluateReversePolishNotation(tokens: string[]): number {}",
      "testCalls": [
        "const result1 = EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]); if (result1 !== 9) { throw new Error('Test Case 1 Failed'); }",
        "const result2 = EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]); if (result2 !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int EvaluateReversePolishNotation(vector<string>& tokens)",
      "testCalls": [
        "assert(EvaluateReversePolishNotation({\"2\",\"1\",\"+\",\"3\",\"*\"}) == 9);",
        "assert(EvaluateReversePolishNotation({\"4\",\"13\",\"5\",\"/\",\"+\"}) == 6);",
        "assert(EvaluateReversePolishNotation({\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"}) == 22);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def EvaluateReversePolishNotation(tokens: List[str]) -> int:",
      "testCalls": [
        "assert EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"]) == 9",
        "assert EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"]) == 6",
        "assert EvaluateReversePolishNotation([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]) == 22"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int evaluateReversePolishNotation(String[] tokens) {}",
      "testCalls": [
        "int result1 = evaluateReversePolishNotation(new String[]{\"2\",\"1\",\"+\",\"3\",\"*\"});\nif (result1 != 9) throw new AssertionError();",
        "int result2 = evaluateReversePolishNotation(new String[]{\"4\",\"13\",\"5\",\"/\",\"+\"});\nif (result2 != 6) throw new AssertionError();",
        "int result3 = evaluateReversePolishNotation(new String[]{\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"});\nif (result3 != 22) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int EvaluateReversePolishNotation(char **tokens, int tokensSize)",
      "testCalls": [
        "if (EvaluateReversePolishNotation((char*[]) {\"2\",\"1\",\"+\",\"3\",\"*\"}, 5) != 9) { printf(\"Test case 1 failed\"); }",
        "if (EvaluateReversePolishNotation((char*[]) {\"4\",\"13\",\"5\",\"/\",\"+\"}, 5) != 6) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func EvaluateReversePolishNotation(tokens []string) int {}",
      "testCalls": [
        "if EvaluateReversePolishNotation([]string{\"2\",\"1\",\"+\",\"3\",\"*\"}) != 9 {panic(\"Test case 1 failed\")}",
        "if EvaluateReversePolishNotation([]string{\"4\",\"13\",\"5\",\"/\",\"+\"}) != 6 {panic(\"Test case 2 failed\")}",
        "if EvaluateReversePolishNotation([]string{\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"}) != 22 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn EvaluateReversePolishNotation(tokens: Vec<String>) -> i32 {}",
      "testCalls": [
        "assert_eq!(EvaluateReversePolishNotation(vec![\"2\".to_string(), \"1\".to_string(), \"+\".to_string(), \"3\".to_string(), \"*\".to_string()]), 9);",
        "assert_eq!(EvaluateReversePolishNotation(vec![\"4\".to_string(), \"13\".to_string(), \"5\".to_string(), \"/\".to_string(), \"+\".to_string()]), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def EvaluateReversePolishNotation(tokens)\nend",
      "testCalls": [
        "result = EvaluateReversePolishNotation([\"2\",\"1\",\"+\",\"3\",\"*\"])\nraise 'Test Case 1 Failed' unless result == 9",
        "result = EvaluateReversePolishNotation([\"4\",\"13\",\"5\",\"/\",\"+\"])\nraise 'Test Case 2 Failed' unless result == 6"
      ],
      "compareHelper": ""
    }
  },
  "factorial-trailing-zeroes": {
    "title": "Factorial Trailing Zeroes",
    "content": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\nExample 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\n\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\n\nExample 3:\n\nInput: n = 0\nOutput: 0\n\n\nConstraints:\n\n0 <= n <= 104\n\n\nFollow up: Could you write a solution that works in logarithmic time complexity?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FactorialTrailingZeroes(n) {}",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if(FactorialTrailingZeroes(5) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FactorialTrailingZeroes(n: number): number {}",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) !== 0) throw new Error('Test Case 1 Failed');",
        "if(FactorialTrailingZeroes(5) !== 1) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int FactorialTrailingZeroes(int n);",
      "testCalls": [
        "if (FactorialTrailingZeroes(3) != 0) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if (FactorialTrailingZeroes(5) != 1) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FactorialTrailingZeroes(n: int) -> int:",
      "testCalls": [
        "assert FactorialTrailingZeroes(3) == 0, 'Test Case 1 Failed'",
        "assert FactorialTrailingZeroes(5) == 1, 'Test Case 2 Failed'",
        "assert FactorialTrailingZeroes(0) == 0, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int FactorialTrailingZeroes(int n) { }",
      "testCalls": [
        "if(FactorialTrailingZeroes(3) != 0) throw new AssertionError();",
        "if(FactorialTrailingZeroes(5) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FactorialTrailingZeroes(int n);",
      "testCalls": [
        "if (FactorialTrailingZeroes(3) != 0) { printf(\"Test Case 1 Failed\"); }",
        "if (FactorialTrailingZeroes(5) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FactorialTrailingZeroes(n int) int {}",
      "testCalls": [
        "if FactorialTrailingZeroes(3) != 0 { t.Errorf(\"Test case 1 failed\") }",
        "if FactorialTrailingZeroes(5) != 1 { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FactorialTrailingZeroes(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(FactorialTrailingZeroes(3), 0);",
        "assert_eq!(FactorialTrailingZeroes(5), 1);",
        "assert_eq!(FactorialTrailingZeroes(0), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FactorialTrailingZeroes(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless FactorialTrailingZeroes(3) == 0",
        "raise 'Test Case 2 Failed' unless FactorialTrailingZeroes(5) == 1"
      ],
      "compareHelper": ""
    }
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
    "title": "Find First and Last Position of Element in Sorted Array",
    "content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou mustwrite an algorithm withO(log n) runtime complexity.\n\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n\nConstraints:\n\n0 <= nums.length <= 105\n-109<= nums[i]<= 109\nnums is a non-decreasing array.\n-109<= target<= 109\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindFirstAndLastPositionOfElementInSortedArray(nums, target) {}",
      "testCalls": [
        "const test1 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8); if(JSON.stringify(test1) !== '[3,4]') throw new Error('Test Case 1 Failed');",
        "const test2 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6); if(JSON.stringify(test2) !== '[-1,-1]') throw new Error('Test Case 2 Failed');",
        "const test3 = FindFirstAndLastPositionOfElementInSortedArray([], 0); if(JSON.stringify(test3) !== '[-1,-1]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FindFirstAndLastPositionOfElementInSortedArray(nums: number[], target: number): number[]",
      "testCalls": [
        "const test1 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8); if (JSON.stringify(test1) !== JSON.stringify([3,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6); if (JSON.stringify(test2) !== JSON.stringify([-1,-1])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = FindFirstAndLastPositionOfElementInSortedArray([], 0); if (JSON.stringify(test3) !== JSON.stringify([-1,-1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<int> FindFirstAndLastPositionOfElementInSortedArray(vector<int>& nums, int target);",
      "testCalls": [
        "auto result1 = FindFirstAndLastPositionOfElementInSortedArray({5,7,7,8,8,10}, 8); assert(result1 == vector<int>({3,4}));",
        "auto result2 = FindFirstAndLastPositionOfElementInSortedArray({5,7,7,8,8,10}, 6); assert(result2 == vector<int>({-1,-1}));",
        "auto result3 = FindFirstAndLastPositionOfElementInSortedArray({}, 0); assert(result3 == vector<int>({-1,-1}));"
      ],
      "compareHelper": "bool CompareVectors(const vector<int>& v1, const vector<int>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def FindFirstAndLastPositionOfElementInSortedArray(nums: List[int], target: int) -> List[int]:",
      "testCalls": [
        "assert FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8) == [3, 4]",
        "assert FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6) == [-1, -1]",
        "assert FindFirstAndLastPositionOfElementInSortedArray([], 0) == [-1, -1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public int[] FindFirstAndLastPositionOfElementInSortedArray(int[] nums, int target) {}",
      "testCalls": [
        "assert Arrays.equals(FindFirstAndLastPositionOfElementInSortedArray(new int[]{5,7,7,8,8,10}, 8), new int[]{3,4});",
        "assert Arrays.equals(FindFirstAndLastPositionOfElementInSortedArray(new int[]{5,7,7,8,8,10}, 6), new int[]{-1,-1});",
        "assert Arrays.equals(FindFirstAndLastPositionOfElementInSortedArray(new int[]{}, 0), new int[]{-1,-1});"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) {return Arrays.equals(arr1, arr2);}"
    },
    "c": {
      "functionDeclaration": "int* FindFirstAndLastPositionOfElementInSortedArray(int* nums, int numsSize, int target)",
      "testCalls": [
        "int nums1[] = {5,7,7,8,8,10}; int target1 = 8; int* result1 = FindFirstAndLastPositionOfElementInSortedArray(nums1, 6, target1); if (result1[0] != 3 || result1[1] != 4) { printf(\"Test Case 1 Failed\"); }",
        "int nums2[] = {5,7,7,8,8,10}; int target2 = 6; int* result2 = FindFirstAndLastPositionOfElementInSortedArray(nums2, 6, target2); if (result2[0] != -1 || result2[1] != -1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func SearchRange(nums []int, target int) []int {}",
      "testCalls": [
        "if !compareArrays(SearchRange([]int{5,7,7,8,8,10}, 8), []int{3,4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(SearchRange([]int{5,7,7,8,8,10}, 6), []int{-1,-1}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(SearchRange([]int{}, 0), []int{-1,-1}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn FindFirstAndLastPositionOfElementInSortedArray(nums: Vec<i32>, target: i32) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![5,7,7,8,8,10], 8), vec![3, 4]);",
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![5,7,7,8,8,10], 6), vec![-1, -1]);",
        "assert_eq!(FindFirstAndLastPositionOfElementInSortedArray(vec![], 0), vec![-1, -1]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def FindFirstAndLastPositionOfElementInSortedArray(nums, target)\nend",
      "testCalls": [
        "result = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 8)\nraise 'Test Case 1 Failed' unless result == [3,4]",
        "result = FindFirstAndLastPositionOfElementInSortedArray([5,7,7,8,8,10], 6)\nraise 'Test Case 2 Failed' unless result == [-1,-1]",
        "result = FindFirstAndLastPositionOfElementInSortedArray([], 0)\nraise 'Test Case 3 Failed' unless result == [-1,-1]"
      ],
      "compareHelper": "def arrays_equal(a, b)\na == b\nend"
    }
  },
  "find-k-pairs-with-smallest-sums": {
    "title": "Find K Pairs with Smallest Sums",
    "content": "You are given two integer arrays nums1 and nums2 sorted in non-decreasingorder and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\n\nExample 1:\n\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\nExample 2:\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 105\n-109 <= nums1[i], nums2[i] <= 109\nnums1 and nums2 both are sorted in non-decreasing order.\n1 <= k <= 104\nk <=nums1.length *nums2.length\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Heap (Priority Queue)"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindKPairsWithSmallestSums(nums1, nums2, k) { }",
      "testCalls": [
        "const test1 = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3); if(JSON.stringify(test1) !== '[[1,2],[1,4],[1,6]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2 = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2); if(JSON.stringify(test2) !== '[[1,1],[1,1]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FindKPairsWithSmallestSums(nums1: number[], nums2: number[], k: number): number[][] {}",
      "testCalls": [
        "const test1Result = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3); if(JSON.stringify(test1Result) !== '[[1,2],[1,4],[1,6]]') { throw new Error('Test Case 1 Failed'); }",
        "const test2Result = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2); if(JSON.stringify(test2Result) !== '[[1,1],[1,1]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> FindKPairsWithSmallestSums(vector<int>& nums1, vector<int>& nums2, int k)",
      "testCalls": [
        "auto result1 = FindKPairsWithSmallestSums({1,7,11}, {2,4,6}, 3); assert(result1 == vector<vector<int>>{{1,2},{1,4},{1,6}});",
        "auto result2 = FindKPairsWithSmallestSums({1,1,2}, {1,2,3}, 2); assert(result2 == vector<vector<int>>{{1,1},{1,1}});"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def FindKPairsWithSmallestSums(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:",
      "testCalls": [
        "assert FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3) == [[1,2],[1,4],[1,6]], 'Test Case 1 Failed'",
        "assert FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2) == [[1,1],[1,1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> FindKPairsWithSmallestSums(int[] nums1, int[] nums2, int k) {}",
      "testCalls": [
        "List<List<Integer>> result1 = FindKPairsWithSmallestSums(new int[]{1, 7, 11}, new int[]{2, 4, 6}, 3); compareArrays(result1, new int[][]{{1, 2}, {1, 4}, {1, 6}});",
        "List<List<Integer>> result2 = FindKPairsWithSmallestSums(new int[]{1, 1, 2}, new int[]{1, 2, 3}, 2); compareArrays(result2, new int[][]{{1, 1}, {1, 1}});"
      ],
      "compareHelper": "private void compareArrays(List<List<Integer>> result, int[][] expected) {\n    for (int i = 0; i < result.size(); i++) {\n        List<Integer> pair = result.get(i);\n        if (pair.get(0) != expected[i][0] || pair.get(1) != expected[i][1]) {\n            throw new AssertionError(\"Test case failed\");\n        }\n    }\n}"
    },
    "c": {
      "functionDeclaration": "int** FindKPairsWithSmallestSums(int* nums1, int nums1Size, int* nums2, int nums2Size, int k)",
      "testCalls": [
        "int** result1 = FindKPairsWithSmallestSums((int[]){1,7,11}, 3, (int[]){2,4,6}, 3, 3); if (!CompareArrays(result1, (int*[]){(int[]){1,2}, (int[]){1,4}, (int[]){1,6}}, 3)) { printf(\"Test case 1 failed\"); }",
        "int** result2 = FindKPairsWithSmallestSums((int[]){1,1,2}, 3, (int[]){1,2,3}, 3, 2); if (!CompareArrays(result2, (int*[]){(int[]){1,1}, (int[]){1,1}}, 2)) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": "int CompareArrays(int** arr1, int** arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i][0] != arr2[i][0] || arr1[i][1] != arr2[i][1]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func FindKPairsWithSmallestSums(nums1 []int, nums2 []int, k int) [][]int {}",
      "testCalls": [
        "if !reflect.DeepEqual(FindKPairsWithSmallestSums([]int{1,7,11}, []int{2,4,6}, 3), [][]int{{1,2},{1,4},{1,6}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !reflect.DeepEqual(FindKPairsWithSmallestSums([]int{1,1,2}, []int{1,2,3}, 2), [][]int{{1,1},{1,1}}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 [][]int, arr2 [][]int) bool { return reflect.DeepEqual(arr1, arr2) }"
    },
    "rust": {
      "functionDeclaration": "fn FindKPairsWithSmallestSums(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = FindKPairsWithSmallestSums(vec![1, 7, 11], vec![2, 4, 6], 3); assert_eq!(result1, vec![vec![1, 2], vec![1, 4], vec![1, 6]]);",
        "let result2 = FindKPairsWithSmallestSums(vec![1, 1, 2], vec![1, 2, 3], 2); assert_eq!(result2, vec![vec![1, 1], vec![1, 1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def FindKPairsWithSmallestSums(nums1, nums2, k)\n  # Function body goes here\nend",
      "testCalls": [
        "result1 = FindKPairsWithSmallestSums([1,7,11], [2,4,6], 3)\nraise 'Test Case 1 Failed' unless result1 == [[1,2],[1,4],[1,6]]",
        "result2 = FindKPairsWithSmallestSums([1,1,2], [1,2,3], 2)\nraise 'Test Case 2 Failed' unless result2 == [[1,1],[1,1]]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "find-minimum-in-rotated-sorted-array": {
    "title": "Find Minimum in Rotated Sorted Array",
    "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\n\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs inO(log n) time.\n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2].",
      "You can divide the search space into two and see which direction to go.\r\nCan you think of an algorithm which has O(logN) search complexity?",
      "<ol>\r\n<li>All the elements to the left of inflection point > first element of the array.</li>\r\n<li>All the elements to the right of inflection point < first element of the array.</li>\r\n<ol>"
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindMinimumInRotatedSortedArray(nums) {}",
      "testCalls": [
        "if(FindMinimumInRotatedSortedArray([3,4,5,1,2]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if(FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if(FindMinimumInRotatedSortedArray([11,13,15,17]) !== 11) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindMinimumInRotatedSortedArray(nums: number[]): number {}",
      "testCalls": [
        "if (FindMinimumInRotatedSortedArray([3,4,5,1,2]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) !== 0) { throw new Error('Test Case 2 Failed'); }",
        "if (FindMinimumInRotatedSortedArray([11,13,15,17]) !== 11) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int FindMinimumInRotatedSortedArray(vector<int>& nums)",
      "testCalls": [
        "assert(FindMinimumInRotatedSortedArray({3,4,5,1,2}) == 1);",
        "assert(FindMinimumInRotatedSortedArray({4,5,6,7,0,1,2}) == 0);",
        "assert(FindMinimumInRotatedSortedArray({11,13,15,17}) == 11);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FindMinimumInRotatedSortedArray(nums: List[int]) -> int:",
      "testCalls": [
        "assert FindMinimumInRotatedSortedArray([3,4,5,1,2]) == 1",
        "assert FindMinimumInRotatedSortedArray([4,5,6,7,0,1,2]) == 0",
        "assert FindMinimumInRotatedSortedArray([11,13,15,17]) == 11"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int findMinimumInRotatedSortedArray(int[] nums)",
      "testCalls": [
        "if (findMinimumInRotatedSortedArray(new int[]{3,4,5,1,2}) != 1) { throw new AssertionError(); }",
        "if (findMinimumInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}) != 0) { throw new AssertionError(); }",
        "if (findMinimumInRotatedSortedArray(new int[]{11,13,15,17}) != 11) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindMinimumInRotatedSortedArray(int* nums, int numsSize)",
      "testCalls": [
        "if (FindMinimumInRotatedSortedArray((int[]) {3,4,5,1,2}, 5) != 1) { printf(\"Test Case 1 Failed\"); }",
        "if (FindMinimumInRotatedSortedArray((int[]) {4,5,6,7,0,1,2}, 7) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindMinimumInRotatedSortedArray(nums []int) int {}",
      "testCalls": [
        "if FindMinimumInRotatedSortedArray([]int{3,4,5,1,2}) != 1 {panic(\"Test case 1 failed\")}",
        "if FindMinimumInRotatedSortedArray([]int{4,5,6,7,0,1,2}) != 0 {panic(\"Test case 2 failed\")}",
        "if FindMinimumInRotatedSortedArray([]int{11,13,15,17}) != 11 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindMinimumInRotatedSortedArray(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![3,4,5,1,2]), 1);",
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![4,5,6,7,0,1,2]), 0);",
        "assert_eq!(FindMinimumInRotatedSortedArray(vec![11,13,15,17]), 11);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindMinimumInRotatedSortedArray(nums)\nend",
      "testCalls": [
        "nums1 = [3,4,5,1,2]\nputs FindMinimumInRotatedSortedArray(nums1) == 1 || raise('Test Case 1 Failed')",
        "nums2 = [4,5,6,7,0,1,2]\nputs FindMinimumInRotatedSortedArray(nums2) == 0 || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    }
  },
  "find-peak-element": {
    "title": "Find Peak Element",
    "content": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -&infin;. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\nConstraints:\n\n1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function FindPeakElement(nums) {}",
      "testCalls": [
        "if (FindPeakElement([1,2,3,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (FindPeakElement([1,2,1,3,5,6,4]) !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindPeakElement(nums: number[]): number {}",
      "testCalls": [
        "if (FindPeakElement([1,2,3,1]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (FindPeakElement([1,2,1,3,5,6,4]) !== 5) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int FindPeakElement(vector<int>& nums)",
      "testCalls": [
        "if(FindPeakElement({1,2,3,1}) != 2) throw std::runtime_error(\"Test 1 failed!\");",
        "if(FindPeakElement({1,2,1,3,5,6,4}) != 5) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FindPeakElement(nums: List[int]) -> int",
      "testCalls": [
        "assert FindPeakElement([1,2,3,1]) == 2",
        "assert FindPeakElement([1,2,1,3,5,6,4]) == 5"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int FindPeakElement(int[] nums) { }",
      "testCalls": [
        "if (FindPeakElement(new int[]{1,2,3,1}) != 2) throw new AssertionError();",
        "if (FindPeakElement(new int[]{1,2,1,3,5,6,4}) != 5) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindPeakElement(int* nums, int numsSize)",
      "testCalls": [
        "assert(FindPeakElement((int[]){1,2,3,1}, 4) == 2);",
        "assert(FindPeakElement((int[]){1,2,1,3,5,6,4}, 7) == 5);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindPeakElement(nums []int) int {}",
      "testCalls": [
        "if FindPeakElement([]int{1,2,3,1}) != 2 {panic(\"Test case 1 failed\")}",
        "if FindPeakElement([]int{1,2,1,3,5,6,4}) != 5 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindPeakElement(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindPeakElement(vec![1,2,3,1]), 2);",
        "assert!(FindPeakElement(vec![1,2,1,3,5,6,4]) == 1 || FindPeakElement(vec![1,2,1,3,5,6,4]) == 5);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindPeakElement(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless FindPeakElement([1,2,3,1]) == 2",
        "raise 'Test Case 2 Failed' unless FindPeakElement([1,2,1,3,5,6,4]) == 5"
      ],
      "compareHelper": ""
    }
  },
  "find-the-index-of-the-first-occurrence-in-a-string": {
    "title": "Find the Index of the First Occurrence in a String",
    "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\n\nInput: haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\nOutput: 0\nExplanation: &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\nExample 2:\n\nInput: haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\nOutput: -1\nExplanation: &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n\n\nConstraints:\n\n1 <= haystack.length, needle.length <= 104\nhaystack and needle consist of only lowercase English characters.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Two Pointers",
      "String",
      "String Matching"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "FindIndexOfTheFirstOccurrenceInAString(haystack, needle) {}",
      "testCalls": [
        "if (FindIndexOfTheFirstOccurrenceInAString('sadbutsad', 'sad') !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if (FindIndexOfTheFirstOccurrenceInAString('leetcode', 'leeto') !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindIndexOfFirstOccurrence(haystack: string, needle: string): number {}",
      "testCalls": [
        "if (FindIndexOfFirstOccurrence('sadbutsad', 'sad') !== 0) { throw new Error('Test Case 1 Failed'); }",
        "if (FindIndexOfFirstOccurrence('leetcode', 'leeto') !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int FindIndexOfFirstOccurrenceInString(string haystack, string needle);",
      "testCalls": [
        "if (FindIndexOfFirstOccurrenceInString(\"sadbutsad\", \"sad\") != 0) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (FindIndexOfFirstOccurrenceInString(\"leetcode\", \"leeto\") != -1) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def FindTheIndexOfTheFirstOccurrenceInAString(haystack: str, needle: str) -> int:",
      "testCalls": [
        "assert FindTheIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\") == 0, 'Test Case 1 Failed'",
        "assert FindTheIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\") == -1, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int FindIndexOfFirstOccurrence(String haystack, String needle) { }",
      "testCalls": [
        "if (FindIndexOfFirstOccurrence(\"sadbutsad\", \"sad\") != 0) throw new AssertionError();",
        "if (FindIndexOfFirstOccurrence(\"leetcode\", \"leeto\") != -1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int FindIndexOfFirstOccurrenceInString(char* haystack, char* needle)",
      "testCalls": [
        "if (FindIndexOfFirstOccurrenceInString(\"sadbutsad\", \"sad\") != 0) { printf(\"Test case 1 failed\"); }",
        "if (FindIndexOfFirstOccurrenceInString(\"leetcode\", \"leeto\") != -1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func StrStr(haystack string, needle string) int {}",
      "testCalls": [
        "if StrStr(\"sadbutsad\", \"sad\") != 0 { fmt.Println(\"Test case 1 failed\") }",
        "if StrStr(\"leetcode\", \"leeto\") != -1 { fmt.Println(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn FindIndexOfTheFirstOccurrenceInAString(haystack: &str, needle: &str) -> i32 { }",
      "testCalls": [
        "assert_eq!(FindIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\"), 0);",
        "assert_eq!(FindIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\"), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def FindTheIndexOfTheFirstOccurrenceInAString(haystack, needle)\nend",
      "testCalls": [
        "result = FindTheIndexOfTheFirstOccurrenceInAString(\"sadbutsad\", \"sad\")\nraise 'Test Case 1 Failed' unless result == 0",
        "result = FindTheIndexOfTheFirstOccurrenceInAString(\"leetcode\", \"leeto\")\nraise 'Test Case 2 Failed' unless result == -1"
      ],
      "compareHelper": ""
    }
  },
  "flatten-binary-tree-to-linked-list": {
    "title": "Flatten Binary Tree to Linked List",
    "content": "Given the root of a binary tree, flatten the tree into a &quot;linked list&quot;:\n\nThe &quot;linked list&quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\nThe &quot;linked list&quot; should be in the same order as a pre-order traversal of the binary tree.\n\n\nExample 1:\n\n\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [0]\nOutput: [0]\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100\n\n\nFollow up: Can you flatten the tree in-place (with O(1) extra space)?",
    "difficulty": "Medium",
    "hints": [
      "If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal."
    ],
    "topicTags": [
      "Linked List",
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function FlattenBinaryTreeToLinkedList(root) {}",
      "testCalls": [
        "if(JSON.stringify(FlattenBinaryTreeToLinkedList([1,2,5,3,4,null,6])) !== JSON.stringify([1,null,2,null,3,null,4,null,5,null,6])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(FlattenBinaryTreeToLinkedList([])) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function FlattenBinaryTreeToLinkedList(root: TreeNode | null): void",
      "testCalls": [
        "FlattenBinaryTreeToLinkedList([1,2,5,3,4,null,6]); if(JSON.stringify(root) !== '[1,null,2,null,3,null,4,null,5,null,6]') throw new Error('Test Case 1 Failed');",
        "FlattenBinaryTreeToLinkedList([]); if(JSON.stringify(root) !== '[]') throw new Error('Test Case 2 Failed');",
        "FlattenBinaryTreeToLinkedList([0]); if(JSON.stringify(root) !== '[0]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "void FlattenBinaryTreeToLinkedList(TreeNode* root)",
      "testCalls": [
        "FlattenBinaryTreeToLinkedList(buildTree({1,2,5,3,4,null,6})); // compareArrays(root, {1,null,2,null,3,null,4,null,5,null,6});",
        "FlattenBinaryTreeToLinkedList(buildTree({})); // compareArrays(root, {});",
        "FlattenBinaryTreeToLinkedList(buildTree({0})); // compareArrays(root, {0});"
      ],
      "compareHelper": "void compareArrays(TreeNode* root, vector<int> expected) { /* Comparison logic here */ }"
    },
    "python": {
      "functionDeclaration": "def FlattenBinaryTreeToLinkedList(root):",
      "testCalls": [
        "assert FlattenBinaryTreeToLinkedList([1,2,5,3,4,None,6]) == [1,None,2,None,3,None,4,None,5,None,6]",
        "assert FlattenBinaryTreeToLinkedList([]) == []",
        "assert FlattenBinaryTreeToLinkedList([0]) == [0]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public void flattenBinaryTreeToLinkedList(TreeNode root) {}",
      "testCalls": [
        "flattenBinaryTreeToLinkedList(new TreeNode(1, new TreeNode(2, new TreeNode(3), new TreeNode(4)), new TreeNode(5, null, new TreeNode(6)))); // compare result with [1,null,2,null,3,null,4,null,5,null,6]",
        "flattenBinaryTreeToLinkedList(null); // compare result with []",
        "flattenBinaryTreeToLinkedList(new TreeNode(0)); // compare result with [0]"
      ],
      "compareHelper": "Arrays.equals(expectedResult, actualResult)"
    },
    "c": {
      "functionDeclaration": "void FlattenBinaryTreeToLinkedList(struct TreeNode* root)",
      "testCalls": [
        "FlattenBinaryTreeToLinkedList(root); // Compare result with expected for test case 1",
        "FlattenBinaryTreeToLinkedList(root); // Compare result with expected for test case 2",
        "FlattenBinaryTreeToLinkedList(root); // Compare result with expected for test case 3"
      ],
      "compareHelper": "You can implement a helper function to compare arrays if needed, or use built-in functions for comparison"
    },
    "go": {
      "functionDeclaration": "func FlattenBinaryTreeToLinkedList(root *TreeNode) { }",
      "testCalls": [
        "if result := FlattenBinaryTreeToLinkedList(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}, Right: &TreeNode{Val: 4}}, Right: &TreeNode{Val: 5, Right: &TreeNode{Val: 6}}}); !reflect.DeepEqual(result, &TreeNode{Val: 1, Right: &TreeNode{Val: 2, Right: &TreeNode{Val: 3, Right: &TreeNode{Val: 4, Right: &TreeNode{Val: 5, Right: &TreeNode{Val: 6}}}}}) { t.Errorf(\"Test 1 Failed\") }",
        "if result := FlattenBinaryTreeToLinkedList(nil); !reflect.DeepEqual(result, nil) { t.Errorf(\"Test 2 Failed\") }",
        "if result := FlattenBinaryTreeToLinkedList(&TreeNode{Val: 0}); !reflect.DeepEqual(result, &TreeNode{Val: 0}) { t.Errorf(\"Test 3 Failed\") }"
      ],
      "compareHelper": "func compareTrees(t1, t2 *TreeNode) bool { }"
    },
    "rust": {
      "functionDeclaration": "fn FlattenBinaryTreeToLinkedList(root: Option<Box<TreeNode>>) {}",
      "testCalls": [
        "let test1_root = Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 3, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })), right: Some(Box::new(TreeNode { val: 5, left: None, right: Some(Box::new(TreeNode { val: 6, left: None, right: None })) })) }));\nFlattenBinaryTreeToLinkedList(test1_root);",
        "let test2_root = None;\nFlattenBinaryTreeToLinkedList(test2_root);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<i32>, arr2: Vec<i32>) {\n    if arr1 != arr2 {\n        panic!(\"Arrays are not equal\");\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def FlattenBinaryTreeToLinkedList(root)\nend",
      "testCalls": [
        "test_case_1 = FlattenBinaryTreeToLinkedList([1,2,5,3,4,nil,6])\nraise 'Test Case 1 Failed' unless test_case_1 == [1,nil,2,nil,3,nil,4,nil,5,nil,6]",
        "test_case_2 = FlattenBinaryTreeToLinkedList([])\nraise 'Test Case 2 Failed' unless test_case_2 == []",
        "test_case_3 = FlattenBinaryTreeToLinkedList([0])\nraise 'Test Case 3 Failed' unless test_case_3 == [0]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "game-of-life": {
    "title": "Game of Life",
    "content": "According to Wikipedia article: &quot;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.\n\nExample 1:\n\n\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\nExample 2:\n\n\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n\n\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1.\n\n\nFollow up:\n\nCould you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "GameOfLife(board)",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])",
        "GameOfLife([[1,1],[1,0]])"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function GameOfLife(board: number[][]): void",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]]); if(JSON.stringify(board) !== JSON.stringify([[0,0,0],[1,0,1],[0,1,1],[0,1,0]])) throw new Error('Test Case 1 Failed');",
        "GameOfLife([[1,1],[1,0]]); if(JSON.stringify(board) !== JSON.stringify([[1,1],[1,1]])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: number[][], b: number[][]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "void GameOfLife(vector<vector<int>>& board)",
      "testCalls": [
        "GameOfLife({{0,1,0},{0,0,1},{1,1,1},{0,0,0}}); // compareArrays(board, {{0,0,0},{1,0,1},{0,1,1},{0,1,0}})",
        "GameOfLife({{1,1},{1,0}}); // compareArrays(board, {{1,1},{1,1}})"
      ],
      "compareHelper": "void compareArrays(vector<vector<int>>& arr1, vector<vector<int>> arr2) { for(int i=0; i<arr1.size(); i++) { for(int j=0; j<arr1[i].size(); j++) { if(arr1[i][j] != arr2[i][j]) { throw std::runtime_error(\"Test Failed\"); } } } }"
    },
    "python": {
      "functionDeclaration": "def GameOfLife(board: List[List[int]]) -> None:",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])\nassert board == [[0,0,0],[1,0,1],[0,1,1],[0,1,0]], 'Test Case 1 Failed'",
        "GameOfLife([[1,1],[1,0]])\nassert board == [[1,1],[1,1]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2) or any(arr1[i] != arr2[i] for i in range(len(arr1))):\n        raise AssertionError('Arrays are not equal')"
    },
    "java": {
      "functionDeclaration": "public void GameOfLife(int[][] board)",
      "testCalls": [
        "GameOfLife(new int[][]{{0,1,0},{0,0,1},{1,1,1},{0,0,0}}); // Check board state after applying rules",
        "GameOfLife(new int[][]{{1,1},{1,0}}); // Check board state after applying rules"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n        if (!Arrays.equals(arr1[i], arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "void GameOfLife(int** board, int boardSize, int* boardColSize)",
      "testCalls": [
        "GameOfLife((int*[]){{0,1,0},{0,0,1},{1,1,1},{0,0,0}}, 4, (int[]){3}); // Expected: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
        "GameOfLife((int*[]){{1,1},{1,0}}, 2, (int[]){2}); // Expected: [[1,1],[1,1]]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func GameOfLife(board [][]int)",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])",
        "GameOfLife([[1,1],[1,0]])"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) {\n  if !reflect.DeepEqual(arr1, arr2) {\n    panic(\"Test failed: Expected \" + fmt.Sprint(arr2) + \", but got \" + fmt.Sprint(arr1))\n  }\n}"
    },
    "rust": {
      "functionDeclaration": "fn GameOfLife(board: &mut Vec<Vec<i32>>) {}",
      "testCalls": [
        "let mut board1 = vec![vec![0,1,0],vec![0,0,1],vec![1,1,1],vec![0,0,0]]; GameOfLife(&mut board1); assert_eq!(board1, vec![vec![0,0,0],vec![1,0,1],vec![0,1,1],vec![0,1,0]]);",
        "let mut board2 = vec![vec![1,1],vec![1,0]]; GameOfLife(&mut board2); assert_eq!(board2, vec![vec![1,1],vec![1,1]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_equal(actual: &Vec<Vec<i32>>, expected: &Vec<Vec<i32>>) { for i in 0..actual.len() { assert_eq!(actual[i], expected[i]); }}"
    },
    "ruby": {
      "functionDeclaration": "def GameOfLife(board)",
      "testCalls": [
        "GameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])",
        "GameOfLife([[1,1],[1,0]])"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  raise 'Test Failed' unless arr1 == arr2\nend"
    }
  },
  "gas-station": {
    "title": "Gas Station",
    "content": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.\n\nExample 1:\n\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\nExample 2:\n\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n\n\nConstraints:\n\nn == gas.length == cost.length\n1 <= n <= 105\n0 <= gas[i], cost[i] <= 104\nThe input is generated such that the answer is unique.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function GasStation(gas, cost) {}",
      "testCalls": [
        "if(GasStation([1,2,3,4,5], [3,4,5,1,2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(GasStation([2,3,4], [3,4,3]) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function GasStation(gas: number[], cost: number[]): number {}",
      "testCalls": [
        "if (GasStation([1,2,3,4,5], [3,4,5,1,2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (GasStation([2,3,4], [3,4,3]) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "const arraysEqual = (a: any[], b: any[]) => JSON.stringify(a) === JSON.stringify(b);"
    },
    "c++": {
      "functionDeclaration": "int CanCompleteCircuit(vector<int>& gas, vector<int>& cost)",
      "testCalls": [
        "assert(CanCompleteCircuit({1,2,3,4,5}, {3,4,5,1,2}) == 3);",
        "assert(CanCompleteCircuit({2,3,4}, {3,4,3}) == -1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def GasStation(gas: List[int], cost: List[int]) -> int:",
      "testCalls": [
        "assert GasStation([1,2,3,4,5], [3,4,5,1,2]) == 3",
        "assert GasStation([2,3,4], [3,4,3]) == -1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int GasStation(int[] gas, int[] cost)",
      "testCalls": [
        "int result1 = GasStation(new int[]{1,2,3,4,5}, new int[]{3,4,5,1,2});\nif (result1 != 3) throw new AssertionError();",
        "int result2 = GasStation(new int[]{2,3,4}, new int[]{3,4,3});\nif (result2 != -1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int GasStation(int* gas, int gasSize, int* cost, int costSize)",
      "testCalls": [
        "if (GasStation((int[]) {1,2,3,4,5}, 5, (int[]) {3,4,5,1,2}, 5) != 3) { printf(\"Test case 1 failed\"); }",
        "if (GasStation((int[]) {2,3,4}, 3, (int[]) {3,4,3}, 3) != -1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GasStation(gas []int, cost []int) int {}",
      "testCalls": [
        "if result := GasStation([]int{1,2,3,4,5}, []int{3,4,5,1,2}); result != 3 {panic(result)}",
        "if result := GasStation([]int{2,3,4}, []int{3,4,3}); result != -1 {panic(result)}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn GasStation(gas: Vec<i32>, cost: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(GasStation(vec![1,2,3,4,5], vec![3,4,5,1,2]), 3);",
        "assert_eq!(GasStation(vec![2,3,4], vec![3,4,3]), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def GasStation(gas, cost)\nend",
      "testCalls": [
        "result = GasStation([1,2,3,4,5], [3,4,5,1,2])\nraise 'Test Case 1 Failed' unless result == 3",
        "result = GasStation([2,3,4], [3,4,3])\nraise 'Test Case 2 Failed' unless result == -1"
      ],
      "compareHelper": ""
    }
  },
  "group-anagrams": {
    "title": "Group Anagrams",
    "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nExample 1:\n\nInput: strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]\nOutput: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]\nExplanation:\n\nThere is no string in strs that can be rearranged to form &quot;bat&quot;.\nThe strings &quot;nat&quot; and &quot;tan&quot; are anagrams as they can be rearranged to form each other.\nThe strings &quot;ate&quot;, &quot;eat&quot;, and &quot;tea&quot; are anagrams as they can be rearranged to form each other.\n\n\nExample 2:\n\nInput: strs = [&quot;&quot;]\nOutput: [[&quot;&quot;]]\n\nExample 3:\n\nInput: strs = [&quot;a&quot;]\nOutput: [[&quot;a&quot;]]\n\n\nConstraints:\n\n1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function GroupAnagrams(strs) {}",
      "testCalls": [
        "GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]) === [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "GroupAnagrams([\"\"]) === [[\"\"]]",
        "GroupAnagrams([\"a\"]) === [[\"a\"]]"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function GroupAnagrams(strs: string[][]): string[][][] {}",
      "testCalls": [
        "const test1 = GroupAnagrams([['eat','tea','tan','ate','nat','bat']]); if(JSON.stringify(test1) !== '[[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]]') throw new Error('Test Case 1 Failed');",
        "const test2 = GroupAnagrams([['']]); if(JSON.stringify(test2) !== '[[[\"\"]]]') throw new Error('Test Case 2 Failed');",
        "const test3 = GroupAnagrams([['a']]); if(JSON.stringify(test3) !== '[[[\"a\"]]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<string>> GroupAnagrams(vector<string>& strs);",
      "testCalls": [
        "auto result1 = GroupAnagrams({\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"});\nif(result1 != vector<vector<string>>{{\"bat\"},{\"nat\",\"tan\"},{\"ate\",\"eat\",\"tea\"}}) { throw std::runtime_error(\"Test 1 Failed\"); }",
        "auto result2 = GroupAnagrams({\"\"});\nif(result2 != vector<vector<string>>{{\"\"}}) { throw std::runtime_error(\"Test 2 Failed\"); }",
        "auto result3 = GroupAnagrams({\"a\"});\nif(result3 != vector<vector<string>>{{\"a\"}}) { throw std::runtime_error(\"Test 3 Failed\"); }"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<string>>& arr1, vector<vector<string>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def GroupAnagrams(strs: List[str]) -> List[List[str]]",
      "testCalls": [
        "assert GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]) == [['bat'],['nat','tan'],['ate','eat','tea']]",
        "assert GroupAnagrams(['']) == [['']]",
        "assert GroupAnagrams(['a']) == [['a']]"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if sorted(list1) != sorted(list2):\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public List<List<String>> groupAnagrams(String[] strs) {}",
      "testCalls": [
        "List<List<String>> result1 = groupAnagrams(new String[]{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"});\nif (!Arrays.deepEquals(result1.toArray(), new String[][]{{\"bat\"},{\"nat\",\"tan\"},{\"ate\",\"eat\",\"tea\"}})) throw new AssertionError();",
        "List<List<String>> result2 = groupAnagrams(new String[]{\"\"});\nif (!Arrays.deepEquals(result2.toArray(), new String[][]{{\"\"}})) throw new AssertionError();",
        "List<List<String>> result3 = groupAnagrams(new String[]{\"a\"});\nif (!Arrays.deepEquals(result3.toArray(), new String[][]{{\"a\"}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<String>> arr1, List<List<String>> arr2) {\n    return Arrays.deepEquals(arr1.toArray(), arr2.toArray());\n}"
    },
    "c": {
      "functionDeclaration": "void GroupAnagrams(char** strs, int strsSize)",
      "testCalls": [
        "GroupAnagrams((char*[]) {\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}, 6);",
        "GroupAnagrams((char*[]) {\"\"}, 1);",
        "GroupAnagrams((char*[]) {\"a\"}, 1);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GroupAnagrams(strs []string) [][]string {}",
      "testCalls": [
        "if !reflect.DeepEqual(GroupAnagrams([]string{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}), [][]string{{\"bat\"},{\"nat\",\"tan\"},{\"ate\",\"eat\",\"tea\"}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !reflect.DeepEqual(GroupAnagrams([]string{\"\"}), [][]string{{\"\"}}) { t.Error(\"Test Case 2 Failed\") }",
        "if !reflect.DeepEqual(GroupAnagrams([]string{\"a\"}), [][]string{{\"a\"}}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]string) bool { return reflect.DeepEqual(arr1, arr2) }"
    },
    "rust": {
      "functionDeclaration": "fn GroupAnagrams(strs: Vec<String>) -> Vec<Vec<String>> { }",
      "testCalls": [
        "assert_eq!(GroupAnagrams(vec![\"eat\".to_string(), \"tea\".to_string(), \"tan\".to_string(), \"ate\".to_string(), \"nat\".to_string(), \"bat\".to_string()]), vec![vec![\"bat\".to_string()], vec![\"nat\".to_string(), \"tan\".to_string()], vec![\"ate\".to_string(), \"eat\".to_string(), \"tea\".to_string()]]);",
        "assert_eq!(GroupAnagrams(vec![\"\".to_string()]), vec![vec![\"\".to_string()]]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<Vec<String>>, b: Vec<Vec<String>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i].len(), b[i].len()); for j in 0..a[i].len() { assert_eq!(a[i][j], b[i][j]); } } }"
    },
    "ruby": {
      "functionDeclaration": "def GroupAnagrams(strs)\n  \nend",
      "testCalls": [
        "result1 = GroupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\nraise 'Test Case 1 Failed' unless result1 == [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "result2 = GroupAnagrams([\"\"])\nraise 'Test Case 2 Failed' unless result2 == [[\"\"]]",
        "result3 = GroupAnagrams([\"a\"])\nraise 'Test Case 3 Failed' unless result3 == [[\"a\"]]"
      ],
      "compareHelper": "def arrays_equal(a, b)\n  a.sort == b.sort\nend"
    }
  },
  "h-index": {
    "title": "H-Index",
    "content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n\n\nConstraints:\n\nn == citations.length\n1 <= n <= 5000\n0 <= citations[i] <= 1000\n\n",
    "difficulty": "Medium",
    "hints": [
      "An easy approach is to sort the array first.",
      "What are the possible values of h-index?",
      "A faster approach is to use extra space."
    ],
    "topicTags": [
      "Array",
      "Sorting",
      "Counting Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HIndex(citations) {}",
      "testCalls": [
        "if (HIndex([3,0,6,1,5]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (HIndex([1,3,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HIndex(citations: number[]): number { }",
      "testCalls": [
        "if (HIndex([3,0,6,1,5]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (HIndex([1,3,1]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "int HIndex(vector<int>& citations);",
      "testCalls": [
        "assert(HIndex({3,0,6,1,5}) == 3);",
        "assert(HIndex({1,3,1}) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def HIndex(citations: List[int]) -> int",
      "testCalls": [
        "assert HIndex([3,0,6,1,5]) == 3",
        "assert HIndex([1,3,1]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int HIndex(int[] citations)",
      "testCalls": [
        "if (HIndex(new int[]{3,0,6,1,5}) != 3) throw new AssertionError();",
        "if (HIndex(new int[]{1,3,1}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int HIndex(int* citations, int citationsSize)",
      "testCalls": [
        "if (HIndex((int[]){3,0,6,1,5}, 5) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (HIndex((int[]){1,3,1}, 3) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HIndex(citations []int) int {}",
      "testCalls": [
        "if HIndex([]int{3,0,6,1,5}) != 3 { panic(\"Test case 1 failed\") }",
        "if HIndex([]int{1,3,1}) != 1 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HIndex(citations: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(HIndex(vec![3, 0, 6, 1, 5]), 3);",
        "assert_eq!(HIndex(vec![1, 3, 1]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HIndex(citations)\nend",
      "testCalls": [
        "result = HIndex([3,0,6,1,5])\nraise 'Test Case 1 Failed' unless result == 3",
        "result = HIndex([1,3,1])\nraise 'Test Case 2 Failed' unless result == 1"
      ],
      "compareHelper": ""
    }
  },
  "happy-number": {
    "title": "Happy Number",
    "content": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\n\nReturn true if n is a happy number, and false if not.\n\nExample 1:\n\nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\nExample 2:\n\nInput: n = 2\nOutput: false\n\n\nConstraints:\n\n1 <= n <= 231 - 1\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HappyNumber(n) {}",
      "testCalls": [
        "if (HappyNumber(19) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (HappyNumber(2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HappyNumber(n: number): boolean {}",
      "testCalls": [
        "if (HappyNumber(19) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (HappyNumber(2) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool HappyNumber(int n);",
      "testCalls": [
        "if (HappyNumber(19) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (HappyNumber(2) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def HappyNumber(n: int) -> bool:",
      "testCalls": [
        "assert HappyNumber(19) == True, 'Test Case 1 Failed'",
        "assert HappyNumber(2) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean HappyNumber(int n) {}",
      "testCalls": [
        "if (HappyNumber(19) != true) throw new AssertionError();",
        "if (HappyNumber(2) != false) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool HappyNumber(int n)",
      "testCalls": [
        "if (!HappyNumber(19)) { printf(\"Test Case 1 Failed\"); }",
        "if (HappyNumber(2)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HappyNumber(n int) bool {}",
      "testCalls": [
        "if HappyNumber(19) != true { t.Error(\"Test case 1 failed\") }",
        "if HappyNumber(2) != false { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HappyNumber(n: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(HappyNumber(19), true);",
        "assert_eq!(HappyNumber(2), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HappyNumber(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless HappyNumber(19) == true",
        "raise 'Test Case 2 Failed' unless HappyNumber(2) == false"
      ],
      "compareHelper": ""
    }
  },
  "house-robber": {
    "title": "House Robber",
    "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nExample 2:\n\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function HouseRobber(nums) {}",
      "testCalls": [
        "if (HouseRobber([1,2,3,1]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (HouseRobber([2,7,9,3,1]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function HouseRobber(nums: number[]): number {}",
      "testCalls": [
        "if (HouseRobber([1,2,3,1]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (HouseRobber([2,7,9,3,1]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int HouseRobber(vector<int>& nums);",
      "testCalls": [
        "if(HouseRobber({1,2,3,1}) != 4) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(HouseRobber({2,7,9,3,1}) != 12) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def HouseRobber(nums: List[int]) -> int",
      "testCalls": [
        "assert HouseRobber([1,2,3,1]) == 4",
        "assert HouseRobber([2,7,9,3,1]) == 12"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int HouseRobber(int[] nums) {}",
      "testCalls": [
        "if (HouseRobber(new int[]{1,2,3,1}) != 4) throw new AssertionError();",
        "if (HouseRobber(new int[]{2,7,9,3,1}) != 12) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int HouseRobber(int* nums, int numsSize)",
      "testCalls": [
        "if(HouseRobber((int[]){1,2,3,1}, 4) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(HouseRobber((int[]){2,7,9,3,1}, 5) != 12) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HouseRobber(nums []int) int {}",
      "testCalls": [
        "if HouseRobber([]int{1,2,3,1}) != 4 { panic(\"Test case 1 failed\") }",
        "if HouseRobber([]int{2,7,9,3,1}) != 12 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn HouseRobber(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(HouseRobber(vec![1,2,3,1]), 4);",
        "assert_eq!(HouseRobber(vec![2,7,9,3,1]), 12);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def HouseRobber(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless HouseRobber([1,2,3,1]) == 4",
        "raise 'Test Case 2 Failed' unless HouseRobber([2,7,9,3,1]) == 12"
      ],
      "compareHelper": ""
    }
  },
  "insert-interval": {
    "title": "Insert Interval",
    "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don&#39;t need to modify intervals in-place. You can make a new array and return it.\n\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n\nConstraints:\n\n0 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 105\nintervals is sorted by starti in ascending order.\nnewInterval.length == 2\n0 <= start <= end <= 105\n\n",
    "difficulty": "Medium",
    "hints": [
      "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
      "Can you try merging the overlapping intervals while inserting the new interval?",
      "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
    ],
    "topicTags": [
      "Array"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function InsertInterval(intervals, newInterval) {}",
      "testCalls": [
        "InsertInterval([[1,3],[6,9]], [2,5]) === [[1,5],[6,9]] || throwError()",
        "InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) === [[1,2],[3,10],[12,16]] || throwError()"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); } function throwError() { throw new Error('Test Failed!'); }"
    },
    "typescript": {
      "functionDeclaration": "function InsertInterval(intervals: number[][], newInterval: number[]): number[][] {}",
      "testCalls": [
        "if (JSON.stringify(InsertInterval([[1,3],[6,9]], [2,5])) !== '[[1,5],[6,9]]') { throw new Error('Test Case 1 Failed'); }",
        "if (JSON.stringify(InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])) !== '[[1,2],[3,10],[12,16]]') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> InsertInterval(vector<vector<int>>& intervals, vector<int>& newInterval)",
      "testCalls": [
        "auto result1 = InsertInterval({{1,3},{6,9}}, {2,5}); assert(result1 == vector<vector<int>>{{1,5},{6,9}});",
        "auto result2 = InsertInterval({{1,2},{3,5},{6,7},{8,10},{12,16}}, {4,8}); assert(result2 == vector<vector<int>>{{1,2},{3,10},{12,16}});"
      ],
      "compareHelper": "bool compareVectors(vector<vector<int>>& v1, vector<vector<int>>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def InsertInterval(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:",
      "testCalls": [
        "assert InsertInterval([[1,3],[6,9]], [2,5]) == [[1,5],[6,9]], 'Test Case 1 Failed'",
        "assert InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) == [[1,2],[3,10],[12,16]], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public int[][] InsertInterval(int[][] intervals, int[] newInterval) {}",
      "testCalls": [
        "assert Arrays.deepEquals(InsertInterval(new int[][]{{1,3},{6,9}}, new int[]{2,5}), new int[][]{{1,5},{6,9}});",
        "assert Arrays.deepEquals(InsertInterval(new int[][]{{1,2},{3,5},{6,7},{8,10},{12,16}}, new int[]{4,8}), new int[][]{{1,2},{3,10},{12,16}});"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) {\n    return Arrays.deepEquals(arr1, arr2);\n}"
    },
    "c": {
      "functionDeclaration": "intervalsInsert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int** returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int** intervals1 = (int*[]){{1,3},{6,9}}; int intervalsSize1 = 2; int intervalsColSize1 = 2; int newInterval1[] = {2,5}; int newIntervalSize1 = 2; int* returnSize1; int* returnColumnSizes1; int** result1 = intervalsInsert(intervals1, intervalsSize1, &intervalsColSize1, newInterval1, newIntervalSize1, &returnSize1, &returnColumnSizes1); if (!compareArrays(result1, returnSize1, returnColumnSizes1, (int*[]{{1,5},{6,9}}), 2, 2)) { printf(\"Test Case 1 Failed\"); }",
        "int** intervals2 = (int*[]){{1,2},{3,5},{6,7},{8,10},{12,16}}; int intervalsSize2 = 5; int intervalsColSize2 = 2; int newInterval2[] = {4,8}; int newIntervalSize2 = 2; int* returnSize2; int* returnColumnSizes2; int** result2 = intervalsInsert(intervals2, intervalsSize2, &intervalsColSize2, newInterval2, newIntervalSize2, &returnSize2, &returnColumnSizes2); if (!compareArrays(result2, returnSize2, returnColumnSizes2, (int*[]{{1,2},{3,10},{12,16}}), 3, 2)) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int** arr1, int* size1, int* colSize1, int** arr2, int size2, int colSize2) { if (*size1 != size2 || *colSize1 != colSize2) { return 0; } for (int i = 0; i < size2; i++) { for (int j = 0; j < colSize2; j++) { if (arr1[i][j] != arr2[i][j]) { return 0; } } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func InsertInterval(intervals [][]int, newInterval []int) [][]int {}",
      "testCalls": [
        "if !compareArrays(InsertInterval([][]int{{1,3},{6,9}}, []int{2,5}), [][]int{{1,5},{6,9}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(InsertInterval([][]int{{1,2},{3,5},{6,7},{8,10},{12,16}}, []int{4,8}), [][]int{{1,2},{3,10},{12,16}}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1 [][]int, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn InsertInterval(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(InsertInterval(vec![vec![1,3], vec![6,9]], vec![2,5]), vec![vec![1,5], vec![6,9]]);",
        "assert_eq!(InsertInterval(vec![vec![1,2], vec![3,5], vec![6,7], vec![8,10], vec![12,16]], vec![4,8]), vec![vec![1,2], vec![3,10], vec![12,16]]);"
      ],
      "compareHelper": "fn assert_2d_vec_eq(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i], b[i]); } }"
    },
    "ruby": {
      "functionDeclaration": "def InsertInterval(intervals, newInterval)\nend",
      "testCalls": [
        "test_case_1 = InsertInterval([[1,3],[6,9]], [2,5])\nraise 'Test Case 1 Failed' unless test_case_1 == [[1,5],[6,9]]",
        "test_case_2 = InsertInterval([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\nraise 'Test Case 2 Failed' unless test_case_2 == [[1,2],[3,10],[12,16]]"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "integer-to-roman": {
    "title": "Integer to Roman",
    "content": "Seven different symbols represent Roman numerals with the following values:\n\n\n\nSymbol\nValue\n\n\n\n\nI\n1\n\n\nV\n5\n\n\nX\n10\n\n\nL\n50\n\n\nC\n100\n\n\nD\n500\n\n\nM\n1000\n\n\n\nRoman numerals are formed by appendingthe conversions ofdecimal place valuesfrom highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\nIf the value does not start with 4 or9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\nIf the value starts with 4 or 9 use thesubtractive formrepresentingone symbol subtracted from the following symbol, for example,4 is 1 (I) less than 5 (V): IVand 9 is 1 (I) less than 10 (X): IX.Only the following subtractive forms are used: 4 (IV), 9 (IX),40 (XL), 90 (XC), 400 (CD) and 900 (CM).\nOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5(V), 50 (L), or 500 (D) multiple times. If you need to append a symbol4 timesuse the subtractive form.\n\nGiven an integer, convert it to a Roman numeral.\n\nExample 1:\n\nInput: num = 3749\nOutput: &quot;MMMDCCXLIX&quot;\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\nExample 2:\n\nInput: num = 58\nOutput: &quot;LVIII&quot;\nExplanation:\n\n50 = L\n 8 = VIII\n\n\nExample 3:\n\nInput: num = 1994\nOutput: &quot;MCMXCIV&quot;\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\nConstraints:\n\n1 <= num <= 3999\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "IntegerToRoman(num)",
      "testCalls": [
        "if (IntegerToRoman(3749) !== \"MMMDCCXLIX\") { throw new Error(\"Test Case 1 Failed\"); }",
        "if (IntegerToRoman(58) !== \"LVIII\") { throw new Error(\"Test Case 2 Failed\"); }",
        "if (IntegerToRoman(1994) !== \"MCMXCIV\") { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IntegerToRoman(num: number): string {}",
      "testCalls": [
        "if (IntegerToRoman(3749) !== 'MMMDCCXLIX') throw new Error('Test Case 1 Failed');",
        "if (IntegerToRoman(58) !== 'LVIII') throw new Error('Test Case 2 Failed');",
        "if (IntegerToRoman(1994) !== 'MCMXCIV') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "string IntegerToRoman(int num)",
      "testCalls": [
        "if(IntegerToRoman(3749) != \"MMMDCCXLIX\") throw std::runtime_error(\"Test 1 failed\");",
        "if(IntegerToRoman(58) != \"LVIII\") throw std::runtime_error(\"Test 2 failed\");",
        "if(IntegerToRoman(1994) != \"MCMXCIV\") throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IntegerToRoman(num: int) -> str:",
      "testCalls": [
        "assert IntegerToRoman(3749) == 'MMMDCCXLIX', 'Test Case 1 Failed'",
        "assert IntegerToRoman(58) == 'LVIII', 'Test Case 2 Failed'",
        "assert IntegerToRoman(1994) == 'MCMXCIV', 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String IntegerToRoman(int num) {}",
      "testCalls": [
        "assertEquals(\"MMMDCCXLIX\", IntegerToRoman(3749));",
        "assertEquals(\"LVIII\", IntegerToRoman(58));",
        "assertEquals(\"MCMXCIV\", IntegerToRoman(1994));"
      ],
      "compareHelper": "private void assertEquals(String expected, String actual) { if (!expected.equals(actual)) { throw new AssertionError(\"Expected: \" + expected + \", but was: \" + actual); }}"
    },
    "c": {
      "functionDeclaration": "char* IntegerToRoman(int num)",
      "testCalls": [
        "IntegerToRoman(3749)",
        "IntegerToRoman(58)",
        "IntegerToRoman(1994)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IntegerToRoman(num int) string",
      "testCalls": [
        "if IntegerToRoman(3749) != \"MMMDCCXLIX\" { t.Error(\"Test Case 1 Failed\") }",
        "if IntegerToRoman(58) != \"LVIII\" { t.Error(\"Test Case 2 Failed\") }",
        "if IntegerToRoman(1994) != \"MCMXCIV\" { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn IntegerToRoman(num: i32) -> String { }",
      "testCalls": [
        "assert_eq!(IntegerToRoman(3749), \"MMMDCCXLIX\");",
        "assert_eq!(IntegerToRoman(58), \"LVIII\"); assert_eq!(IntegerToRoman(1994), \"MCMXCIV\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def IntegerToRoman(num)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless IntegerToRoman(3749) == 'MMMDCCXLIX'",
        "raise 'Test Case 2 Failed' unless IntegerToRoman(58) == 'LVIII'"
      ],
      "compareHelper": ""
    }
  },
  "interleaving-string": {
    "title": "Interleaving String",
    "content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| <= 1\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.\n\nExample 1:\n\n\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\nExample 2:\n\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\nExample 3:\n\nInput: s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\nOutput: true\n\n\nConstraints:\n\n0 <= s1.length, s2.length <= 100\n0 <= s3.length <= 200\ns1, s2, and s3 consist of lowercase English letters.\n\n\nFollow up: Could you solve it using only O(s2.length) additional memory space?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function InterleavingString(s1, s2, s3) {}",
      "testCalls": [
        "if(InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if(InterleavingString('', '', '') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function InterleavingString(s1: string, s2: string, s3: string): boolean {}",
      "testCalls": [
        "if (InterleavingString('aabcc', 'dbbca', 'aadbbcbcac') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (InterleavingString('aabcc', 'dbbca', 'aadbbbaccc') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if (InterleavingString('', '', '') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool InterleavingString(string s1, string s2, string s3)",
      "testCalls": [
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if(InterleavingString(\"\", \"\", \"\") != true) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def InterleavingString(s1: str, s2: str, s3: str) -> bool:",
      "testCalls": [
        "assert InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") == True, 'Test Case 1 Failed'",
        "assert InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") == False, 'Test Case 2 Failed'",
        "assert InterleavingString(\"\", \"\", \"\") == True, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean InterleavingString(String s1, String s2, String s3) {}",
      "testCalls": [
        "if (!InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\")) throw new AssertionError();",
        "if (InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\")) throw new AssertionError();",
        "if (!InterleavingString(\"\", \"\", \"\")) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool InterleavingString(char *s1, char *s2, char *s3)",
      "testCalls": [
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true) { printf(\"Test Case 1 Failed\"); }",
        "if(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false) { printf(\"Test Case 2 Failed\"); }",
        "if(InterleavingString(\"\", \"\", \"\") != true) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsInterleave(s1 string, s2 string, s3 string) bool {}",
      "testCalls": [
        "if IsInterleave(\"aabcc\", \"dbbca\", \"aadbbcbcac\") != true { t.Error(\"Test case 1 failed\") }",
        "if IsInterleave(\"aabcc\", \"dbbca\", \"aadbbbaccc\") != false { t.Error(\"Test case 2 failed\") }",
        "if IsInterleave(\"\", \"\", \"\") != true { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn InterleavingString(s1: &str, s2: &str, s3: &str) -> bool {}",
      "testCalls": [
        "assert_eq!(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbcbcac\"), true);",
        "assert_eq!(InterleavingString(\"aabcc\", \"dbbca\", \"aadbbbaccc\"), false);",
        "assert_eq!(InterleavingString(\"\", \"\", \"\"), true);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def InterleavingString(s1, s2, s3)\nend",
      "testCalls": [
        "result1 = InterleavingString('aabcc', 'dbbca', 'aadbbcbcac')\nraise 'Test Case 1 Failed' unless result1 == true",
        "result2 = InterleavingString('aabcc', 'dbbca', 'aadbbbaccc')\nraise 'Test Case 2 Failed' unless result2 == false",
        "result3 = InterleavingString('', '', '')\nraise 'Test Case 3 Failed' unless result3 == true"
      ],
      "compareHelper": ""
    }
  },
  "invert-binary-tree": {
    "title": "Invert Binary Tree",
    "content": "Given the root of a binary tree, invert the tree, and return its root.\n\nExample 1:\n\n\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nExample 2:\n\n\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\nExample 3:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function InvertBinaryTree(root) {}",
      "testCalls": [
        "if(JSON.stringify(InvertBinaryTree([4,2,7,1,3,6,9])) !== JSON.stringify([4,7,2,9,6,3,1])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(InvertBinaryTree([2,1,3])) !== JSON.stringify([2,3,1])) { throw new Error('Test Case 2 Failed'); }",
        "if(JSON.stringify(InvertBinaryTree([])) !== JSON.stringify([])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function InvertBinaryTree(root: TreeNode | null): TreeNode | null",
      "testCalls": [
        "if(JSON.stringify(InvertBinaryTree(createBinaryTree([4,2,7,1,3,6,9]))) !== JSON.stringify(createBinaryTree([4,7,2,9,6,3,1]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(InvertBinaryTree(createBinaryTree([2,1,3]))) !== JSON.stringify(createBinaryTree([2,3,1]))) throw new Error('Test Case 2 Failed');",
        "if(JSON.stringify(InvertBinaryTree(createBinaryTree([]))) !== JSON.stringify(createBinaryTree([]))) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function createBinaryTree(arr: number[]): TreeNode | null { if (arr.length === 0) return null; const root = new TreeNode(arr[0]); const queue = [root]; let i = 1; while (i < arr.length) { const current = queue.shift()!; if (arr[i] !== null) { current.left = new TreeNode(arr[i]); queue.push(current.left); } i++; if (i < arr.length && arr[i] !== null) { current.right = new TreeNode(arr[i]); queue.push(current.right); } i++; } return root; }"
    },
    "c++": {
      "functionDeclaration": "TreeNode* InvertBinaryTree(TreeNode* root)",
      "testCalls": [
        "assert(compareArrays(inorderTraversal(InvertBinaryTree(createTree({4,2,7,1,3,6,9}))), {4,7,2,9,6,3,1}));",
        "assert(compareArrays(inorderTraversal(InvertBinaryTree(createTree({2,1,3}))), {2,3,1}));",
        "assert(compareArrays(inorderTraversal(InvertBinaryTree(createTree({}))), {});"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if (arr1.size() != arr2.size()) return false; for (int i = 0; i < arr1.size(); i++) { if (arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def InvertBinaryTree(root):",
      "testCalls": [
        "assert InvertBinaryTree([4,2,7,1,3,6,9]) == [4,7,2,9,6,3,1]",
        "assert InvertBinaryTree([2,1,3]) == [2,3,1]",
        "assert InvertBinaryTree([]) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public TreeNode invertBinaryTree(TreeNode root) { }",
      "testCalls": [
        "TreeNode test1 = invertBinaryTree(createTree(new Integer[]{4,2,7,1,3,6,9})); compareTrees(test1, createTree(new Integer[]{4,7,2,9,6,3,1}));",
        "TreeNode test2 = invertBinaryTree(createTree(new Integer[]{2,1,3})); compareTrees(test2, createTree(new Integer[]{2,3,1}));",
        "TreeNode test3 = invertBinaryTree(createTree(new Integer[]{})); compareTrees(test3, createTree(new Integer[]{}));"
      ],
      "compareHelper": "private void compareTrees(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return; if (t1 == null || t2 == null || t1.val != t2.val) throw new AssertionError(); compareTrees(t1.left, t2.left); compareTrees(t1.right, t2.right); }"
    },
    "c": {
      "functionDeclaration": "struct TreeNode* InvertBinaryTree(struct TreeNode* root);",
      "testCalls": [
        "assert(compareArrays(InvertBinaryTree(createTreeFromArray((int[]) {4, 2, 7, 1, 3, 6, 9}, 7)), createTreeFromArray((int[]) {4, 7, 2, 9, 6, 3, 1}, 7));",
        "assert(compareArrays(InvertBinaryTree(createTreeFromArray((int[]) {2, 1, 3}, 3)), createTreeFromArray((int[]) {2, 3, 1}, 3));",
        "assert(compareArrays(InvertBinaryTree(NULL), NULL);"
      ],
      "compareHelper": "int compareArrays(struct TreeNode* arr1, struct TreeNode* arr2) {\n  if (arr1 == NULL && arr2 == NULL) return 1;\n  if (arr1 == NULL || arr2 == NULL) return 0;\n  if (arr1->val != arr2->val) return 0;\n  return compareArrays(arr1->left, arr2->left) && compareArrays(arr1->right, arr2->right);\n}"
    },
    "go": {
      "functionDeclaration": "func InvertBinaryTree(root *TreeNode) *TreeNode {}",
      "testCalls": [
        "if result := InvertBinaryTree(&TreeNode{Val: 4, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 1}, Right: &TreeNode{Val: 3}}, Right: &TreeNode{Val: 7, Left: &TreeNode{Val: 6}, Right: &TreeNode{Val: 9}}}); !reflect.DeepEqual(result, &TreeNode{Val: 4, Left: &TreeNode{Val: 7, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 6}}, Right: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}, Right: &TreeNode{Val: 1}}}) { t.Errorf(\"Test case 1 failed\") }",
        "if result := InvertBinaryTree(&TreeNode{Val: 2, Left: &TreeNode{Val: 1}, Right: &TreeNode{Val: 3}}); !reflect.DeepEqual(result, &TreeNode{Val: 2, Left: &TreeNode{Val: 3}, Right: &TreeNode{Val: 1}}) { t.Errorf(\"Test case 2 failed\") }",
        "if result := InvertBinaryTree(nil); !reflect.DeepEqual(result, nil) { t.Errorf(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareTrees(t1 *TreeNode, t2 *TreeNode) bool { if t1 == nil && t2 == nil { return true } if t1 == nil || t2 == nil { return false } return t1.Val == t2.Val && compareTrees(t1.Left, t2.Left) && compareTrees(t1.Right, t2.Right) }"
    },
    "rust": {
      "functionDeclaration": "fn InvertBinaryTree(root: Option<Box<TreeNode>>) -> Option<Box<TreeNode>> { }",
      "testCalls": [
        "assert_eq!(InvertBinaryTree(Some(Box::new(TreeNode::new(4))), Some(Box::new(TreeNode::new(7)))), \"Test case 1 failed\");",
        "assert_eq!(InvertBinaryTree(Some(Box::new(TreeNode::new(2))), Some(Box::new(TreeNode::new(3)))), \"Test case 2 failed\");"
      ],
      "compareHelper": "fn assert_tree_eq(tree1: Option<Box<TreeNode>>, tree2: Option<Box<TreeNode>>) { }"
    },
    "ruby": {
      "functionDeclaration": "def InvertBinaryTree(root)\nend",
      "testCalls": [
        "test_case_1 = InvertBinaryTree([4,2,7,1,3,6,9])\nraise 'Test Case 1 Failed' unless test_case_1 == [4,7,2,9,6,3,1]",
        "test_case_2 = InvertBinaryTree([2,1,3])\nraise 'Test Case 2 Failed' unless test_case_2 == [2,3,1]",
        "test_case_3 = InvertBinaryTree([])\nraise 'Test Case 3 Failed' unless test_case_3 == []"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "ipo": {
    "title": "IPO",
    "content": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\nExample 1:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\nExample 2:\n\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\n\n\nConstraints:\n\n1 <= k <= 105\n0 <= w <= 109\nn == profits.length\nn == capital.length\n1 <= n <= 105\n0 <= profits[i] <= 104\n0 <= capital[i] <= 109\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "IPO(k, w, profits, capital)",
      "testCalls": [
        "if (IPO(2, 0, [1,2,3], [0,1,1]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (IPO(3, 0, [1,2,3], [0,1,2]) !== 6) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IPO(k: number, w: number, profits: number[], capital: number[]): number {}",
      "testCalls": [
        "if (IPO(2, 0, [1,2,3], [0,1,1]) !== 4) throw new Error('Test Case 1 Failed');",
        "if (IPO(3, 0, [1,2,3], [0,1,2]) !== 6) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int FindMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital)",
      "testCalls": [
        "assert(FindMaximizedCapital(2, 0, {1,2,3}, {0,1,1}) == 4);",
        "assert(FindMaximizedCapital(3, 0, {1,2,3}, {0,1,2}) == 6);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IPO(k: int, w: int, profits: List[int], capital: List[int]) -> int:",
      "testCalls": [
        "assert IPO(2, 0, [1,2,3], [0,1,1]) == 4",
        "assert IPO(3, 0, [1,2,3], [0,1,2]) == 6"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int IPO(int k, int w, int[] profits, int[] capital)",
      "testCalls": [
        "if (IPO(2, 0, new int[]{1,2,3}, new int[]{0,1,1}) != 4) throw new AssertionError();",
        "if (IPO(3, 0, new int[]{1,2,3}, new int[]{0,1,2}) != 6) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int IPO(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize)",
      "testCalls": [
        "if(IPO(2, 0, (int[]){1,2,3}, 3, (int[]){0,1,1}, 3) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(IPO(3, 0, (int[]){1,2,3}, 3, (int[]){0,1,2}, 3) != 6) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IPO(k int, w int, profits []int, capital []int) int { }",
      "testCalls": [
        "if IPO(2, 0, []int{1,2,3}, []int{0,1,1}) != 4 { panic(\"Test case 1 failed\") }",
        "if IPO(3, 0, []int{1,2,3}, []int{0,1,2}) != 6 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn Ipo(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(Ipo(2, 0, vec![1, 2, 3], vec![0, 1, 1]), 4);",
        "assert_eq!(Ipo(3, 0, vec![1, 2, 3], vec![0, 1, 2]), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def Ipo(k, w, profits, capital)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless Ipo(2, 0, [1,2,3], [0,1,1]) == 4",
        "raise 'Test Case 2 Failed' unless Ipo(3, 0, [1,2,3], [0,1,2]) == 6"
      ],
      "compareHelper": ""
    }
  },
  "isomorphic-strings": {
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\nExample 1:\n\nInput: s = &quot;egg&quot;, t = &quot;add&quot;\nOutput: true\nExplanation:\nThe strings s and t can be made identical by:\n\nMapping &#39;e&#39; to &#39;a&#39;.\nMapping &#39;g&#39; to &#39;d&#39;.\n\n\nExample 2:\n\nInput: s = &quot;foo&quot;, t = &quot;bar&quot;\nOutput: false\nExplanation:\nThe strings s and t can not be made identical as &#39;o&#39; needs to be mapped to both &#39;a&#39; and &#39;r&#39;.\n\nExample 3:\n\nInput: s = &quot;paper&quot;, t = &quot;title&quot;\nOutput: true\n\n\nConstraints:\n\n1 <= s.length <= 5 * 104\nt.length == s.length\ns and t consist of any valid ascii character.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function IsomorphicStrings(s, t) {}",
      "testCalls": [
        "if(IsomorphicStrings('egg', 'add') !== true) { throw new Error('Test Case 1 Failed'); }",
        "if(IsomorphicStrings('foo', 'bar') !== false) { throw new Error('Test Case 2 Failed'); }",
        "if(IsomorphicStrings('paper', 'title') !== true) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IsomorphicStrings(s: string, t: string): boolean {}",
      "testCalls": [
        "if(IsomorphicStrings('egg', 'add') !== true) throw new Error('Test Case 1 Failed');",
        "if(IsomorphicStrings('foo', 'bar') !== false) throw new Error('Test Case 2 Failed');",
        "if(IsomorphicStrings('paper', 'title') !== true) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool IsomorphicStrings(string s, string t);",
      "testCalls": [
        "if(IsomorphicStrings(\"egg\", \"add\") != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(IsomorphicStrings(\"foo\", \"bar\") != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if(IsomorphicStrings(\"paper\", \"title\") != true) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def IsomorphicStrings(s: str, t: str) -> bool:",
      "testCalls": [
        "assert IsomorphicStrings(\"egg\", \"add\") == True, 'Test Case 1 Failed'",
        "assert IsomorphicStrings(\"foo\", \"bar\") == False, 'Test Case 2 Failed'",
        "assert IsomorphicStrings(\"paper\", \"title\") == True, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean IsomorphicStrings(String s, String t) { }",
      "testCalls": [
        "if(!IsomorphicStrings(\"egg\", \"add\")) throw new AssertionError();",
        "if(IsomorphicStrings(\"foo\", \"bar\")) throw new AssertionError();",
        "if(!IsomorphicStrings(\"paper\", \"title\")) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool IsomorphicStrings(char* s, char* t)",
      "testCalls": [
        "if(IsomorphicStrings(\"egg\", \"add\") != true) { printf(\"Test Case 1 Failed\"); }",
        "if(IsomorphicStrings(\"foo\", \"bar\") != false) { printf(\"Test Case 2 Failed\"); }",
        "if(IsomorphicStrings(\"paper\", \"title\") != true) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsomorphicStrings(s string, t string) bool {}",
      "testCalls": [
        "if IsomorphicStrings(\"egg\", \"add\") != true {panic(\"Test case 1 failed\")}",
        "if IsomorphicStrings(\"foo\", \"bar\") != false {panic(\"Test case 2 failed\")}",
        "if IsomorphicStrings(\"paper\", \"title\") != true {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn IsomorphicStrings(s: String, t: String) -> bool {}",
      "testCalls": [
        "assert_eq!(IsomorphicStrings(String::from(\"egg\"), String::from(\"add\")), true);",
        "assert_eq!(IsomorphicStrings(String::from(\"foo\"), String::from(\"bar\")), false);",
        "assert_eq!(IsomorphicStrings(String::from(\"paper\"), String::from(\"title\")), true);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def IsomorphicStrings(s, t)\nend",
      "testCalls": [
        "puts(IsomorphicStrings('egg', 'add')) == true || raise('Test Case 1 Failed')",
        "puts(IsomorphicStrings('foo', 'bar')) == false || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    }
  },
  "jump-game-ii": {
    "title": "Jump Game II",
    "content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned atindex 0.\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j)where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach indexn - 1.\n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 1000\nIt guaranteed that you can reach nums[n - 1].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function JumpGameII(nums) {}",
      "testCalls": [
        "if(JumpGameII([2,3,1,1,4]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(JumpGameII([2,3,0,1,4]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function JumpGameII(nums: number[]): number {}",
      "testCalls": [
        "if (JumpGameII([2,3,1,1,4]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGameII([2,3,0,1,4]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int JumpGameII(std::vector<int>& nums);",
      "testCalls": [
        "assert(JumpGameII({2,3,1,1,4}) == 2);",
        "assert(JumpGameII({2,3,0,1,4}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def JumpGameII(nums: List[int]) -> int:",
      "testCalls": [
        "assert JumpGameII([2,3,1,1,4]) == 2",
        "assert JumpGameII([2,3,0,1,4]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int JumpGameII(int[] nums) {}",
      "testCalls": [
        "assert JumpGameII(new int[]{2, 3, 1, 1, 4}) == 2;",
        "assert JumpGameII(new int[]{2, 3, 0, 1, 4}) == 2;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int JumpGameII(int* nums, int numsSize)",
      "testCalls": [
        "if(JumpGameII((int[]){2,3,1,1,4}, 5) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(JumpGameII((int[]){2,3,0,1,4}, 5) != 2) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func JumpGameII(nums []int) int {}",
      "testCalls": [
        "if JumpGameII([]int{2,3,1,1,4}) != 2 {panic(\"Test case 1 failed\")}",
        "if JumpGameII([]int{2,3,0,1,4}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn JumpGameIi(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(JumpGameIi(vec![2,3,1,1,4]), 2);",
        "assert_eq!(JumpGameIi(vec![2,3,0,1,4]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def JumpGameII(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless JumpGameII([2,3,1,1,4]) == 2",
        "raise 'Test Case 2 Failed' unless JumpGameII([2,3,0,1,4]) == 2"
      ],
      "compareHelper": ""
    }
  },
  "jump-game": {
    "title": "Jump Game",
    "content": "You are given an integer array nums. You are initially positioned at the array first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 105\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function JumpGame(nums) {}",
      "testCalls": [
        "if (JumpGame([2,3,1,1,4]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGame([3,2,1,0,4]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function JumpGame(nums: number[]): boolean {}",
      "testCalls": [
        "if (JumpGame([2,3,1,1,4]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (JumpGame([3,2,1,0,4]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool JumpGame(std::vector<int>& nums);",
      "testCalls": [
        "if (JumpGame({2,3,1,1,4}) != true) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if (JumpGame({3,2,1,0,4}) != false) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def JumpGame(nums: List[int]) -> bool:",
      "testCalls": [
        "assert JumpGame([2,3,1,1,4]) == True, 'Test Case 1 Failed'",
        "assert JumpGame([3,2,1,0,4]) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean JumpGame(int[] nums) {}",
      "testCalls": [
        "if (JumpGame(new int[]{2,3,1,1,4}) != true) throw new AssertionError();",
        "if (JumpGame(new int[]{3,2,1,0,4}) != false) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool CanJump(int* nums, int numsSize)",
      "testCalls": [
        "if (CanJump((int[]){2,3,1,1,4}, 5) != true) { printf(\"Test Case 1 Failed\"); }",
        "if (CanJump((int[]){3,2,1,0,4}, 5) != false) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func JumpGame(nums []int) bool {}",
      "testCalls": [
        "if JumpGame([]int{2,3,1,1,4}) != true { panic(\"Test case 1 failed\") }",
        "if JumpGame([]int{3,2,1,0,4}) != false { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn JumpGame(nums: Vec<i32>) -> bool {}",
      "testCalls": [
        "assert_eq!(JumpGame(vec![2,3,1,1,4]), true);",
        "assert_eq!(JumpGame(vec![3,2,1,0,4]), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def JumpGame(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless JumpGame([2,3,1,1,4]) == true",
        "raise 'Test Case 2 Failed' unless JumpGame([3,2,1,0,4]) == false"
      ],
      "compareHelper": ""
    }
  },
  "kth-largest-element-in-an-array": {
    "title": "Kth Largest Element in an Array",
    "content": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\n\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n\n\nConstraints:\n\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function KthLargestElementInAnArray(nums, k) {}",
      "testCalls": [
        "if(KthLargestElementInAnArray([3,2,1,5,6,4], 2) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function KthLargestElementInAnArray(nums: number[], k: number): number {}",
      "testCalls": [
        "if (KthLargestElementInAnArray([3,2,1,5,6,4], 2) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if (KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "KthLargestElementInAnArray(std::vector<int>& nums, int k)",
      "testCalls": [
        "assert(KthLargestElementInAnArray({3, 2, 1, 5, 6, 4}, 2) == 5);",
        "assert(KthLargestElementInAnArray({3, 2, 3, 1, 2, 4, 5, 5, 6}, 4) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def KthLargestElementInArray(nums: List[int], k: int) -> int:",
      "testCalls": [
        "assert KthLargestElementInArray([3,2,1,5,6,4], 2) == 5",
        "assert KthLargestElementInArray([3,2,3,1,2,4,5,5,6], 4) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int KthLargestElementInArray(int[] nums, int k) { }",
      "testCalls": [
        "if (KthLargestElementInArray(new int[]{3,2,1,5,6,4}, 2) != 5) throw new AssertionError();",
        "if (KthLargestElementInArray(new int[]{3,2,3,1,2,4,5,5,6}, 4) != 4) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "KthLargestElementInAnArray(int* nums, int numsSize, int k)",
      "testCalls": [
        "KthLargestElementInAnArray((int[]){3,2,1,5,6,4}, 6, 2); // Expected: 5",
        "KthLargestElementInAnArray((int[]){3,2,3,1,2,4,5,5,6}, 9, 4); // Expected: 4"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindKthLargest(nums []int, k int) int {}",
      "testCalls": [
        "if FindKthLargest([]int{3,2,1,5,6,4}, 2) != 5 { panic(\"Test case 1 failed\") }",
        "if FindKthLargest([]int{3,2,3,1,2,4,5,5,6}, 4) != 4 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn KthLargestElementInAnArray(nums: Vec<i32>, k: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(KthLargestElementInAnArray(vec![3,2,1,5,6,4], 2), 5);",
        "assert_eq!(KthLargestElementInAnArray(vec![3,2,3,1,2,4,5,5,6], 4), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def KthLargestElementInAnArray(nums, k)\n  \nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless KthLargestElementInAnArray([3,2,1,5,6,4], 2) == 5",
        "raise 'Test Case 2 Failed' unless KthLargestElementInAnArray([3,2,3,1,2,4,5,5,6], 4) == 4"
      ],
      "compareHelper": ""
    }
  },
  "kth-smallest-element-in-a-bst": {
    "title": "Kth Smallest Element in a BST",
    "content": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\nExample 1:\n\n\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nExample 2:\n\n\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n\n\nConstraints:\n\nThe number of nodes in the tree is n.\n1 <= k <= n <= 104\n0 <= Node.val <= 104\n\n\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\n",
    "difficulty": "Medium",
    "hints": [
      "Try to utilize the property of a BST.",
      "Try in-order traversal. (Credits to @chan13)",
      "What if you could modify the BST node's structure?",
      "The optimal runtime complexity is O(height of BST)."
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function KthSmallestElementInABST(root, k) {}",
      "testCalls": [
        "if (KthSmallestElementInABST([3,1,4,null,2], 1) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (KthSmallestElementInABST([5,3,6,2,4,null,null,1], 3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function KthSmallestElementInBST(root: TreeNode | null, k: number): number { }",
      "testCalls": [
        "if (KthSmallestElementInBST(TreeNode.fromArray([3,1,4,null,2]), 1) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (KthSmallestElementInBST(TreeNode.fromArray([5,3,6,2,4,null,null,1]), 3) !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "int KthSmallestElementInABST(TreeNode* root, int k);",
      "testCalls": [
        "if (KthSmallestElementInABST(createTree({3,1,4,null,2}), 1) != 1) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (KthSmallestElementInABST(createTree({5,3,6,2,4,null,null,1}), 3) != 3) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "std::vector<int> createTree(std::vector<int> values) { /* Helper function to create a binary tree from values */ }"
    },
    "python": {
      "functionDeclaration": "def KthSmallestElementInABST(root, k):",
      "testCalls": [
        "assert KthSmallestElementInABST([3,1,4,null,2], 1) == 1, 'Test Case 1 Failed'",
        "assert KthSmallestElementInABST([5,3,6,2,4,null,null,1], 3) == 3, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int KthSmallestElementInBST(TreeNode root, int k) { }",
      "testCalls": [
        "if(KthSmallestElementInBST(TreeNode.buildTree(new Integer[]{3,1,4,null,2}), 1) != 1) throw new AssertionError();",
        "if(KthSmallestElementInBST(TreeNode.buildTree(new Integer[]{5,3,6,2,4,null,null,1}), 3) != 3) throw new AssertionError();"
      ],
      "compareHelper": "public static class TreeNode { static TreeNode buildTree(Integer[] values) { } }"
    },
    "c": {
      "functionDeclaration": "int KthSmallestElementInBST(struct TreeNode* root, int k)",
      "testCalls": [
        "if(KthSmallestElementInBST(createTreeFromString(\"3,1,4,null,2\"), 1) != 1) { printf(\"Test Case 1 Failed\"); }",
        "if(KthSmallestElementInBST(createTreeFromString(\"5,3,6,2,4,null,null,1\"), 3) != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "struct TreeNode* createTreeFromString(char* str) { /* implementation to create tree from string */ }"
    },
    "go": {
      "functionDeclaration": "func KthSmallestElementInBST(root *TreeNode, k int) int {}",
      "testCalls": [
        "if KthSmallestElementInBST(&TreeNode{Val: 3, Left: &TreeNode{Val: 1}, Right: &TreeNode{Val: 4, Right: &TreeNode{Val: 2}}}, 1) != 1 {panic(\"Test case 1 failed\")}",
        "if KthSmallestElementInBST(&TreeNode{Val: 5, Left: &TreeNode{Val: 3, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 1}}, Right: &TreeNode{Val: 4}}, Right: &TreeNode{Val: 6}}, 3) != 3 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn KthSmallestElementInBST(root: Option<Box<TreeNode>>, k: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(KthSmallestElementInBST(Some(Box::new(TreeNode::new(3))), 1), 1);",
        "assert_eq!(KthSmallestElementInBST(Some(Box::new(TreeNode::new(5))), 3), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def KthSmallestElementInABST(root, k)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless KthSmallestElementInABST([3,1,4,null,2], 1) == 1",
        "raise 'Test Case 2 Failed' unless KthSmallestElementInABST([5,3,6,2,4,null,null,1], 3) == 3"
      ],
      "compareHelper": ""
    }
  },
  "length-of-last-word": {
    "title": "Length of Last Word",
    "content": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\n\nExample 1:\n\nInput: s = &quot;Hello World&quot;\nOutput: 5\nExplanation: The last word is &quot;World&quot; with length 5.\n\nExample 2:\n\nInput: s = &quot;   fly me   to   the moon  &quot;\nOutput: 4\nExplanation: The last word is &quot;moon&quot; with length 4.\n\nExample 3:\n\nInput: s = &quot;luffy is still joyboy&quot;\nOutput: 6\nExplanation: The last word is &quot;joyboy&quot; with length 6.\n\n\nConstraints:\n\n1 <= s.length <= 104\ns consists of only English letters and spaces &#39; &#39;.\nThere will be at least one word in s.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LengthOfLastWord(s) {}",
      "testCalls": [
        "if(LengthOfLastWord(&quot;Hello World&quot;) !== 5) { throw new Error('Test Case 1 Failed'); }",
        "if(LengthOfLastWord(&quot;   fly me   to   the moon  &quot;) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LengthOfLastWord(s: string): number {}",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") !== 5) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") !== 4) { throw new Error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int LengthOfLastWord(string s);",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") != 5) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LengthOfLastWord(s: str) -> int:",
      "testCalls": [
        "assert LengthOfLastWord(\"Hello World\") == 5",
        "assert LengthOfLastWord(\"   fly me   to   the moon  \") == 4",
        "assert LengthOfLastWord(\"luffy is still joyboy\") == 6"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LengthOfLastWord(String s) { }",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") != 5) { throw new AssertionError(); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LengthOfLastWord(char *s)",
      "testCalls": [
        "if (LengthOfLastWord(\"Hello World\") != 5) { printf(\"Test Case 1 Failed\"); }",
        "if (LengthOfLastWord(\"   fly me   to   the moon  \") != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LengthOfLastWord(s string) int {}",
      "testCalls": [
        "if LengthOfLastWord(\"Hello World\") != 5 {panic(\"Test case 1 failed\")}",
        "if LengthOfLastWord(\"   fly me   to   the moon  \") != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LengthOfLastWord(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(LengthOfLastWord(String::from(\"Hello World\")), 5);",
        "assert_eq!(LengthOfLastWord(String::from(\"   fly me   to   the moon  \")), 4);",
        "assert_eq!(LengthOfLastWord(String::from(\"luffy is still joyboy\")), 6);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LengthOfLastWord(s)",
      "testCalls": [
        "if LengthOfLastWord(\"Hello World\") != 5\n  raise 'Test Case 1 Failed'\nend",
        "if LengthOfLastWord(\"   fly me   to   the moon  \") != 4\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": ""
    }
  },
  "letter-combinations-of-a-phone-number": {
    "title": "Letter Combinations of a Phone Number",
    "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\nExample 1:\n\nInput: digits = &quot;23&quot;\nOutput: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n\nExample 2:\n\nInput: digits = &quot;2&quot;\nOutput: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n\n\nConstraints:\n\n1 <= digits.length <= 4\ndigits[i] is a digit in the range [&#39;2&#39;, &#39;9&#39;].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LetterCombinationsOfAPhoneNumber(digits) {}",
      "testCalls": [
        "if(JSON.stringify(LetterCombinationsOfAPhoneNumber('23')) !== JSON.stringify(['ad','ae','af','bd','be','bf','cd','ce','cf'])) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(LetterCombinationsOfAPhoneNumber('2')) !== JSON.stringify(['a','b','c'])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function LetterCombinations(digits: string): string[] {}",
      "testCalls": [
        "const test1 = LetterCombinations(\"23\"); if (JSON.stringify(test1) !== JSON.stringify([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])) { throw new Error(\"Test Case 1 Failed\"); }",
        "const test2 = LetterCombinations(\"2\"); if (JSON.stringify(test2) !== JSON.stringify([\"a\",\"b\",\"c\"])) { throw new Error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<string> LetterCombinationsOfAPhoneNumber(string digits)",
      "testCalls": [
        "auto result1 = LetterCombinationsOfAPhoneNumber(\"23\"); assert(result1 == vector<string>{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"});",
        "auto result2 = LetterCombinationsOfAPhoneNumber(\"2\"); assert(result2 == vector<string>{\"a\",\"b\",\"c\"});"
      ],
      "compareHelper": "bool compareVectors(const vector<string>& v1, const vector<string>& v2) { return v1 == v2; }"
    },
    "python": {
      "functionDeclaration": "def LetterCombinations(digits: str) -> List[str]:",
      "testCalls": [
        "assert LetterCombinations(\"23\") == [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "assert LetterCombinations(\"2\") == [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": "def compareLists(list1, list2):\n    if len(list1) != len(list2):\n        raise AssertionError\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            raise AssertionError"
    },
    "java": {
      "functionDeclaration": "public List<String> letterCombinations(String digits) {}",
      "testCalls": [
        "List<String> result1 = letterCombinations(\"23\");\nif (!Arrays.equals(result1.toArray(), new String[]{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"})) throw new AssertionError();",
        "List<String> result2 = letterCombinations(\"2\");\nif (!Arrays.equals(result2.toArray(), new String[]{\"a\",\"b\",\"c\"})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean arraysEqual(String[] arr1, String[] arr2) {\n    return Arrays.equals(arr1, arr2);\n}"
    },
    "c": {
      "functionDeclaration": "void LetterCombinationsOfAPhoneNumber(char* digits)",
      "testCalls": [
        "LetterCombinationsOfAPhoneNumber(\"23\"); // Expected output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "LetterCombinationsOfAPhoneNumber(\"2\"); // Expected output: [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LetterCombinations(digits string) []string {}",
      "testCalls": [
        "if !compareArrays(LetterCombinations(\"23\"), []string{\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"}) { t.Error(\"Test case 1 failed\") }",
        "if !compareArrays(LetterCombinations(\"2\"), []string{\"a\",\"b\",\"c\"}) { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []string) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn LetterCombinations(digits: &str) -> Vec<String> {}",
      "testCalls": [
        "let result1 = LetterCombinations(\"23\"); assert_eq!(result1, vec![\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]);",
        "let result2 = LetterCombinations(\"2\"); assert_eq!(result2, vec![\"a\",\"b\",\"c\"]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<String>, arr2: Vec<String>) { assert_eq!(arr1, arr2); }"
    },
    "ruby": {
      "functionDeclaration": "def LetterCombinations(digits)\n  # code here\nend",
      "testCalls": [
        "result1 = LetterCombinations(\"23\")\nraise 'Test Case 1 Failed' unless result1 == [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "result2 = LetterCombinations(\"2\")\nraise 'Test Case 2 Failed' unless result2 == [\"a\",\"b\",\"c\"]"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "linked-list-cycle": {
    "title": "Linked List Cycle",
    "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following thenextpointer. Internally, posis used to denote the index of the node thattailnextpointer is connected to.Note thatposis not passed as a parameter.\nReturntrue if there is a cycle in the linked list. Otherwise, return false.\n\nExample 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\nExample 3:\n\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n\n\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\n\n\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LinkedListCycle(head, pos) {}",
      "testCalls": [
        "if (LinkedListCycle([3,2,0,-4], 1) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (LinkedListCycle([1,2], 0) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (LinkedListCycle([1], -1) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LinkedListCycle(head: ListNode | null): boolean {}",
      "testCalls": [
        "if (LinkedListCycle(createLinkedList([3,2,0,-4], 1)) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (LinkedListCycle(createLinkedList([1,2], 0)) !== true) { throw new Error('Test Case 2 Failed'); }",
        "if (LinkedListCycle(createLinkedList([1], -1)) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function createLinkedList(arr: number[], pos: number): ListNode | null {}"
    },
    "c++": {
      "functionDeclaration": "bool HasCycle(ListNode* head)",
      "testCalls": [
        "assert(HasCycle(createLinkedList({3,2,0,-4}, 1)) == true);",
        "assert(HasCycle(createLinkedList({1,2}, 0)) == true);",
        "assert(HasCycle(createLinkedList({1}, -1)) == false);"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }"
    },
    "python": {
      "functionDeclaration": "LinkedListCycle(head: ListNode) -> bool:",
      "testCalls": [
        "assert LinkedListCycle([3,2,0,-4], 1) == True",
        "assert LinkedListCycle([1,2], 0) == True",
        "assert LinkedListCycle([1], -1) == False"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean LinkedListCycle(ListNode head)",
      "testCalls": [
        "assert LinkedListCycle(createLinkedList(new int[]{3, 2, 0, -4}, 1)) == true;",
        "assert LinkedListCycle(createLinkedList(new int[]{1, 2}, 0)) == true;"
      ],
      "compareHelper": "private boolean compareLinkedList(ListNode expected, ListNode actual) {\n    while (expected != null && actual != null) {\n        if (expected.val != actual.val) {\n            return false;\n        }\n        expected = expected.next;\n        actual = actual.next;\n    }\n    return expected == null && actual == null;\n}"
    },
    "c": {
      "functionDeclaration": "bool HasCycle(struct ListNode* head)",
      "testCalls": [
        "HasCycle(createLinkedListFromArray((int[]) {3, 2, 0, -4}, 4), 1)",
        "HasCycle(createLinkedListFromArray((int[]) {1, 2}, 2), 0)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func HasCycle(head *ListNode) bool",
      "testCalls": [
        "if result := HasCycle(NewLinkedList([]int{3, 2, 0, -4}, 1)); result != true { t.Errorf(\"Test 1 Failed: expected true, got %v\", result) }",
        "if result := HasCycle(NewLinkedList([]int{1, 2}, 0)); result != true { t.Errorf(\"Test 2 Failed: expected true, got %v\", result) }",
        "if result := HasCycle(NewLinkedList([]int{1}, -1)); result != false { t.Errorf(\"Test 3 Failed: expected false, got %v\", result) }"
      ],
      "compareHelper": "func NewLinkedList(values []int, pos int) *ListNode {\n\thead := &ListNode{Val: values[0]}\n\tprev := head\n\tposNode := &ListNode{}\n\tif pos == 0 {\n\t\tposNode = head\n\t}\n\tfor i := 1; i < len(values); i++ {\n\t\tnode := &ListNode{Val: values[i]}\n\t\tprev.Next = node\n\t\tprev = node\n\t\tif i == pos {\n\t\t\tposNode = node\n\t\t}\n\t}\n\tprev.Next = posNode\n\treturn head\n}\n\nfunc (l *ListNode) HasCycle() bool {\n\tslow, fast := l, l\n\tfor fast != nil && fast.Next != nil {\n\t\tslow = slow.Next\n\t\tfast = fast.Next.Next\n\t\tif slow == fast {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
    },
    "rust": {
      "functionDeclaration": "fn LinkedListCycle(head: Option<Box<ListNode>>) -> bool {}",
      "testCalls": [
        "assert_eq!(LinkedListCycle(Solution::create_linked_list_from_vec(vec![3, 2, 0, -4], 1)), true);",
        "assert_eq!(LinkedListCycle(Solution::create_linked_list_from_vec(vec![1, 2], 0)), true);",
        "assert_eq!(LinkedListCycle(Solution::create_linked_list_from_vec(vec![1], -1)), false);"
      ],
      "compareHelper": "impl Solution { pub fn create_linked_list_from_vec(values: Vec<i32>, pos: i32) -> Option<Box<ListNode>> { let mut head = None; let mut tail = &mut head; let mut cycle_node = None; for val in values { let new_node = Some(Box::new(ListNode { val, next: None })); if let Some(ref mut node) = tail { node.next = new_node.clone(); } if pos >= 0 && values.iter().position(|&x| x == val).unwrap() == pos as usize { cycle_node = tail; } tail = &mut tail.as_mut().unwrap().next; } if let Some(ref mut node) = tail { node.next = cycle_node; } head } }"
    },
    "ruby": {
      "functionDeclaration": "def LinkedListCycle(head, pos)\nend",
      "testCalls": [
        "result1 = LinkedListCycle([3,2,0,-4], 1)\nraise 'Test Case 1 Failed' unless result1 == true",
        "result2 = LinkedListCycle([1,2], 0)\nraise 'Test Case 2 Failed' unless result2 == true",
        "result3 = LinkedListCycle([1], -1)\nraise 'Test Case 3 Failed' unless result3 == false"
      ],
      "compareHelper": ""
    }
  },
  "longest-common-prefix": {
    "title": "Longest Common Prefix",
    "content": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.\n\nExample 1:\n\nInput: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\nOutput: &quot;fl&quot;\n\nExample 2:\n\nInput: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\nOutput: &quot;&quot;\nExplanation: There is no common prefix among the input strings.\n\n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "String",
      "Trie"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestCommonPrefix(strs) {}",
      "testCalls": [
        "if(LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) !== \"fl\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) !== \"\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestCommonPrefix(strs: string[]): string {}",
      "testCalls": [
        "if(LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) !== \"fl\") { throw new Error('Test Case 1 Failed'); }",
        "if(LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) !== \"\") { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "string LongestCommonPrefix(vector<string>& strs)",
      "testCalls": [
        "assert(LongestCommonPrefix({\"flower\",\"flow\",\"flight\"}) == \"fl\");",
        "assert(LongestCommonPrefix({\"dog\",\"racecar\",\"car\"}) == \"\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestCommonPrefix(strs: List[str]) -> str:",
      "testCalls": [
        "assert LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"",
        "assert LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String LongestCommonPrefix(String[] strs) {}",
      "testCalls": [
        "assert LongestCommonPrefix(new String[]{\"flower\",\"flow\",\"flight\"}).equals(\"fl\");",
        "assert LongestCommonPrefix(new String[]{\"dog\",\"racecar\",\"car\"}).equals(\"\");"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* LongestCommonPrefix(char** strs, int strsSize)",
      "testCalls": [
        "LongestCommonPrefix((char*[]) {\"flower\",\"flow\",\"flight\"}, 3)",
        "LongestCommonPrefix((char*[]) {\"dog\",\"racecar\",\"car\"}, 3)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestCommonPrefix(strs []string) string {}",
      "testCalls": [
        "if LongestCommonPrefix([]string{\"flower\",\"flow\",\"flight\"}) != \"fl\" {panic(\"Test case 1 failed\")}",
        "if LongestCommonPrefix([]string{\"dog\",\"racecar\",\"car\"}) != \"\" {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestCommonPrefix(strs: Vec<String>) -> String {}",
      "testCalls": [
        "assert_eq!(LongestCommonPrefix(vec![String::from(\"flower\"), String::from(\"flow\"), String::from(\"flight\")]), \"fl\");",
        "assert_eq!(LongestCommonPrefix(vec![String::from(\"dog\"), String::from(\"racecar\"), String::from(\"car\")]), \"\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestCommonPrefix(strs)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"",
        "raise 'Test Case 2 Failed' unless LongestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\""
      ],
      "compareHelper": ""
    }
  },
  "longest-consecutive-sequence": {
    "title": "Longest Consecutive Sequence",
    "content": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs inO(n)time.\n\nExample 1:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\nExample 2:\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n\nExample 3:\n\nInput: nums = [1,0,1,2]\nOutput: 3\n\n\nConstraints:\n\n0 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestConsecutiveSequence(nums) {}",
      "testCalls": [
        "if(LongestConsecutiveSequence([100,4,200,1,3,2]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) !== 9) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestConsecutiveSequence([1,0,1,2]) !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function LongestConsecutiveSequence(nums: number[]): number {}",
      "testCalls": [
        "if(LongestConsecutiveSequence([100,4,200,1,3,2]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) !== 9) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestConsecutiveSequence([1,0,1,2]) !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "const arraysEqual = (a: number[], b: number[]) => JSON.stringify(a) === JSON.stringify(b);"
    },
    "c++": {
      "functionDeclaration": "int LongestConsecutiveSequence(vector<int>& nums);",
      "testCalls": [
        "if(LongestConsecutiveSequence({100,4,200,1,3,2}) != 4) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(LongestConsecutiveSequence({0,3,7,2,5,8,4,6,0,1}) != 9) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "bool compareArrays(const vector<int>& arr1, const vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "LongestConsecutiveSequence(nums: List[int]) -> int",
      "testCalls": [
        "assert LongestConsecutiveSequence([100,4,200,1,3,2]) == 4",
        "assert LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) == 9",
        "assert LongestConsecutiveSequence([1,0,1,2]) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestConsecutiveSequence(int[] nums) { }",
      "testCalls": [
        "if(LongestConsecutiveSequence(new int[]{100,4,200,1,3,2}) != 4) throw new AssertionError();",
        "if(LongestConsecutiveSequence(new int[]{0,3,7,2,5,8,4,6,0,1}) != 9) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int LongestConsecutiveSequence(int* nums, int numsSize)",
      "testCalls": [
        "if(LongestConsecutiveSequence((int[]){100,4,200,1,3,2}, 6) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(LongestConsecutiveSequence((int[]){0,3,7,2,5,8,4,6,0,1}, 10) != 9) { printf(\"Test Case 2 Failed\"); }",
        "if(LongestConsecutiveSequence((int[]){1,0,1,2}, 4) != 3) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestConsecutiveSequence(nums []int) int {}",
      "testCalls": [
        "if LongestConsecutiveSequence([]int{100,4,200,1,3,2}) != 4 {panic(\"Test case 1 failed\")}",
        "if LongestConsecutiveSequence([]int{0,3,7,2,5,8,4,6,0,1}) != 9 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestConsecutiveSequence(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestConsecutiveSequence(vec![100, 4, 200, 1, 3, 2]), 4);",
        "assert_eq!(LongestConsecutiveSequence(vec![0, 3, 7, 2, 5, 8, 4, 6, 0, 1]), 9);",
        "assert_eq!(LongestConsecutiveSequence(vec![1, 0, 1, 2]), 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestConsecutiveSequence(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestConsecutiveSequence([100,4,200,1,3,2]) == 4",
        "raise 'Test Case 2 Failed' unless LongestConsecutiveSequence([0,3,7,2,5,8,4,6,0,1]) == 9",
        "raise 'Test Case 3 Failed' unless LongestConsecutiveSequence([1,0,1,2]) == 3"
      ],
      "compareHelper": ""
    }
  },
  "longest-increasing-subsequence": {
    "title": "Longest Increasing Subsequence",
    "content": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nExample 1:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\nExample 2:\n\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n\nExample 3:\n\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n\n\nConstraints:\n\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n\nFollow up:Can you come up with an algorithm that runs inO(n log(n)) time complexity?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestIncreasingSubsequence(nums) {}",
      "testCalls": [
        "if(LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestIncreasingSubsequence([0,1,0,3,2,3]) !== 4) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestIncreasingSubsequence([7,7,7,7,7,7,7]) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestIncreasingSubsequence(nums: number[]): number { }",
      "testCalls": [
        "if(LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(LongestIncreasingSubsequence([0,1,0,3,2,3]) !== 4) throw new Error('Test Case 2 Failed');",
        "if(LongestIncreasingSubsequence([7,7,7,7,7,7,7]) !== 1) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int LongestIncreasingSubsequence(vector<int>& nums);",
      "testCalls": [
        "if(LongestIncreasingSubsequence({10,9,2,5,3,7,101,18}) != 4) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(LongestIncreasingSubsequence({0,1,0,3,2,3}) != 4) throw std::runtime_error(\"Test Case 2 Failed\");",
        "if(LongestIncreasingSubsequence({7,7,7,7,7,7,7}) != 1) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestIncreasingSubsequence(nums: List[int]) -> int",
      "testCalls": [
        "assert LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) == 4",
        "assert LongestIncreasingSubsequence([0,1,0,3,2,3]) == 4",
        "assert LongestIncreasingSubsequence([7,7,7,7,7,7,7]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestIncreasingSubsequence(int[] nums) {}",
      "testCalls": [
        "if(LongestIncreasingSubsequence(new int[]{10,9,2,5,3,7,101,18}) != 4) throw new AssertionError();",
        "if(LongestIncreasingSubsequence(new int[]{0,1,0,3,2,3}) != 4) throw new AssertionError();",
        "if(LongestIncreasingSubsequence(new int[]{7,7,7,7,7,7,7}) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LongestIncreasingSubsequence(int* nums, int numsSize)",
      "testCalls": [
        "if(LongestIncreasingSubsequence((int[]){10,9,2,5,3,7,101,18}, 8) != 4) { printf(\"Test Case 1 Failed\"); }",
        "if(LongestIncreasingSubsequence((int[]){0,1,0,3,2,3}, 6) != 4) { printf(\"Test Case 2 Failed\"); }",
        "if(LongestIncreasingSubsequence((int[]){7,7,7,7,7,7,7}, 7) != 1) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestIncreasingSubsequence(nums []int) int {}",
      "testCalls": [
        "if LongestIncreasingSubsequence([]int{10,9,2,5,3,7,101,18}) != 4 { panic(\"Test case 1 failed\") }",
        "if LongestIncreasingSubsequence([]int{0,1,0,3,2,3}) != 4 { panic(\"Test case 2 failed\") }",
        "if LongestIncreasingSubsequence([]int{7,7,7,7,7,7,7}) != 1 { panic(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestIncreasingSubsequence(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestIncreasingSubsequence(vec![10,9,2,5,3,7,101,18]), 4);",
        "assert_eq!(LongestIncreasingSubsequence(vec![0,1,0,3,2,3]), 4);",
        "assert_eq!(LongestIncreasingSubsequence(vec![7,7,7,7,7,7,7]), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestIncreasingSubsequence(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestIncreasingSubsequence([10,9,2,5,3,7,101,18]) == 4",
        "raise 'Test Case 2 Failed' unless LongestIncreasingSubsequence([0,1,0,3,2,3]) == 4",
        "raise 'Test Case 3 Failed' unless LongestIncreasingSubsequence([7,7,7,7,7,7,7]) == 1"
      ],
      "compareHelper": ""
    }
  },
  "longest-palindromic-substring": {
    "title": "Longest Palindromic Substring",
    "content": "Given a string s, return the longest palindromic substring in s.\n\nExample 1:\n\nInput: s = &quot;babad&quot;\nOutput: &quot;bab&quot;\nExplanation: &quot;aba&quot; is also a valid answer.\n\nExample 2:\n\nInput: s = &quot;cbbd&quot;\nOutput: &quot;bb&quot;\n\n\nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n\n",
    "difficulty": "Medium",
    "hints": [
      "How can we reuse a previously computed palindrome to compute a larger palindrome?",
      "If aba is a palindrome, is xabax a palindrome? Similarly is xabay a palindrome?",
      "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
    ],
    "topicTags": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestPalindromicSubstring(s) {}",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) !== &quot;bab&quot;) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) !== &quot;bb&quot;) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestPalindromicSubstring(s: string): string {}",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) !== &quot;bab&quot;) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) !== &quot;bb&quot;) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "string LongestPalindromicSubstring(string s)",
      "testCalls": [
        "if(LongestPalindromicSubstring(&quot;babad&quot;) != &quot;bab&quot;) throw std::runtime_error(&quot;Test 1 failed&quot;);",
        "if(LongestPalindromicSubstring(&quot;cbbd&quot;) != &quot;bb&quot;) throw std::runtime_error(&quot;Test 2 failed&quot;);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestPalindromicSubstring(s: str) -> str:",
      "testCalls": [
        "assert LongestPalindromicSubstring('babad') == 'bab', 'Test Case 1 Failed'",
        "assert LongestPalindromicSubstring('cbbd') == 'bb', 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String LongestPalindromicSubstring(String s) { }",
      "testCalls": [
        "if (!LongestPalindromicSubstring(\"babad\").equals(\"bab\")) { throw new AssertionError(); }",
        "if (!LongestPalindromicSubstring(\"cbbd\").equals(\"bb\")) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "LongestPalindromicSubstring(char* s)",
      "testCalls": [
        "LongestPalindromicSubstring(\"babad\")",
        "LongestPalindromicSubstring(\"cbbd\")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestPalindromicSubstring(s string) string {}",
      "testCalls": [
        "if LongestPalindromicSubstring(\"babad\") != \"bab\" {panic(\"Test case 1 failed\")}",
        "if LongestPalindromicSubstring(\"cbbd\") != \"bb\" {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestPalindromicSubstring(s: &str) -> String { }",
      "testCalls": [
        "assert_eq!(LongestPalindromicSubstring(\"babad\"), \"bab\");",
        "assert_eq!(LongestPalindromicSubstring(\"cbbd\"), \"bb\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestPalindromicSubstring(s)\nend",
      "testCalls": [
        "result = LongestPalindromicSubstring(&quot;babad&quot;)\nraise 'Test Case 1 Failed' unless result == &quot;bab&quot;",
        "result = LongestPalindromicSubstring(&quot;cbbd&quot;)\nraise 'Test Case 2 Failed' unless result == &quot;bb&quot;"
      ],
      "compareHelper": ""
    }
  },
  "longest-substring-without-repeating-characters": {
    "title": "Longest Substring Without Repeating Characters",
    "content": "Given a string s, find the length of the longest substring without duplicate characters.\n\nExample 1:\n\nInput: s = &quot;abcabcbb&quot;\nOutput: 3\nExplanation: The answer is &quot;abc&quot;, with the length of 3. Note that &quot;bca&quot; and &quot;cab&quot; are also correct answers.\n\nExample 2:\n\nInput: s = &quot;bbbbb&quot;\nOutput: 1\nExplanation: The answer is &quot;b&quot;, with the length of 1.\n\nExample 3:\n\nInput: s = &quot;pwwkew&quot;\nOutput: 3\nExplanation: The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n\n\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n\n",
    "difficulty": "Medium",
    "hints": [
      "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LongestSubstringWithoutRepeatingCharacters(s) {}",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters('abcabcbb') !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters('bbbbb') !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters('pwwkew') !== 3) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LongestSubstringWithoutRepeatingCharacters(s: string): number {}",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(&quot;abcabcbb&quot;) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(LongestSubstringWithoutRepeatingCharacters(&quot;bbbbb&quot;) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int LongestSubstringWithoutRepeatingCharacters(string s);",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def LongestSubstringWithoutRepeatingCharacters(s: str) -> int:",
      "testCalls": [
        "assert LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") == 3",
        "assert LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") == 1",
        "assert LongestSubstringWithoutRepeatingCharacters(\"pwwkew\") == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int LongestSubstringWithoutRepeatingCharacters(String s) { }",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) throw new AssertionError();",
        "if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int LongestSubstringWithoutRepeatingCharacters(char* s)",
      "testCalls": [
        "if(LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3) { printf(\"Test Case 1 Failed\"); }",
        "if(LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LongestSubstringWithoutRepeatingCharacters(s string) int {}",
      "testCalls": [
        "if LongestSubstringWithoutRepeatingCharacters(\"abcabcbb\") != 3 { t.Error(\"Test Case 1 Failed\") }",
        "if LongestSubstringWithoutRepeatingCharacters(\"bbbbb\") != 1 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn LongestSubstringWithoutRepeatingCharacters(s: &str) -> i32 {}",
      "testCalls": [
        "assert_eq!(LongestSubstringWithoutRepeatingCharacters(&\"abcabcbb\"), 3);",
        "assert_eq!(LongestSubstringWithoutRepeatingCharacters(&\"bbbbb\"), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LongestSubstringWithoutRepeatingCharacters(s)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless LongestSubstringWithoutRepeatingCharacters(&quot;abcabcbb&quot;) == 3",
        "raise 'Test Case 2 Failed' unless LongestSubstringWithoutRepeatingCharacters(&quot;bbbbb&quot;) == 1"
      ],
      "compareHelper": ""
    }
  },
  "lowest-common-ancestor-of-a-binary-tree": {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;\n\nExample 1:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\nExample 2:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\n\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q will exist in the tree.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function LowestCommonAncestor(root, p, q) {}",
      "testCalls": [
        "if (LowestCommonAncestor([3,5,1,6,2,0,8,null,null,7,4], 5, 1) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (LowestCommonAncestor([3,5,1,6,2,0,8,null,null,7,4], 5, 4) !== 5) { throw new Error('Test Case 2 Failed'); }",
        "if (LowestCommonAncestor([1,2], 1, 2) !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function LowestCommonAncestor(root: TreeNode | null, p: number, q: number): TreeNode | null {}",
      "testCalls": [
        "if (LowestCommonAncestor(TreeNode.fromArray([3,5,1,6,2,0,8,null,null,7,4]), 5, 1)?.val !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (LowestCommonAncestor(TreeNode.fromArray([3,5,1,6,2,0,8,null,null,7,4]), 5, 4)?.val !== 5) { throw new Error('Test Case 2 Failed'); }",
        "if (LowestCommonAncestor(TreeNode.fromArray([1,2]), 1, 2)?.val !== 1) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "c++": {
      "functionDeclaration": "int LowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);",
      "testCalls": [
        "assert(LowestCommonAncestor(createTree({3,5,1,6,2,0,8,INT_MIN,INT_MIN,7,4}), new TreeNode(5), new TreeNode(1)) == 3);",
        "assert(LowestCommonAncestor(createTree({3,5,1,6,2,0,8,INT_MIN,INT_MIN,7,4}), new TreeNode(5), new TreeNode(4)) == 5);",
        "assert(LowestCommonAncestor(createTree({1,2}), new TreeNode(1), new TreeNode(2)) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); ++i) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def LowestCommonAncestor(root, p, q):",
      "testCalls": [
        "assert LowestCommonAncestor([3,5,1,6,2,0,8,None,None,7,4], 5, 1) == 3",
        "assert LowestCommonAncestor([3,5,1,6,2,0,8,None,None,7,4], 5, 4) == 5",
        "assert LowestCommonAncestor([1,2], 1, 2) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { }",
      "testCalls": [
        "TreeNode root1 = createTree(new Integer[]{3,5,1,6,2,0,8,null,null,7,4});\nTreeNode p1 = new TreeNode(5);\nTreeNode q1 = new TreeNode(1);\nassert lowestCommonAncestor(root1, p1, q1).val == 3 : \"Test Case 1 Failed\";",
        "TreeNode root2 = createTree(new Integer[]{3,5,1,6,2,0,8,null,null,7,4});\nTreeNode p2 = new TreeNode(5);\nTreeNode q2 = new TreeNode(4);\nassert lowestCommonAncestor(root2, p2, q2).val == 5 : \"Test Case 2 Failed\";",
        "TreeNode root3 = createTree(new Integer[]{1,2});\nTreeNode p3 = new TreeNode(1);\nTreeNode q3 = new TreeNode(2);\nassert lowestCommonAncestor(root3, p3, q3).val == 1 : \"Test Case 3 Failed\";"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && compareTrees(t1.left, t2.left) && compareTrees(t1.right, t2.right);\n}"
    },
    "c": {
      "functionDeclaration": "int LowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)",
      "testCalls": [
        "LowestCommonAncestor(root1, p1, q1); // Expected: 3",
        "LowestCommonAncestor(root2, p2, q2); // Expected: 5",
        "LowestCommonAncestor(root3, p3, q3); // Expected: 1"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func LowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode {}",
      "testCalls": [
        "if LowestCommonAncestor(BuildTree([]int{3,5,1,6,2,0,8,0,0,7,4}), &TreeNode{Val: 5}, &TreeNode{Val: 1}) != &TreeNode{Val: 3} { t.Error(\"Test Case 1 Failed\") }",
        "if LowestCommonAncestor(BuildTree([]int{3,5,1,6,2,0,8,0,0,7,4}), &TreeNode{Val: 5}, &TreeNode{Val: 4}) != &TreeNode{Val: 5} { t.Error(\"Test Case 2 Failed\") }",
        "if LowestCommonAncestor(BuildTree([]int{1,2}), &TreeNode{Val: 1}, &TreeNode{Val: 2}) != &TreeNode{Val: 1} { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func BuildTree(arr []int) *TreeNode {}"
    },
    "rust": {
      "functionDeclaration": "fn LowestCommonAncestor(root: Option<Box<TreeNode>>, p: i32, q: i32) -> Option<Box<TreeNode>> {}",
      "testCalls": [
        "assert_eq!(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) })), right: Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 0, left: None, right: None })), right: Some(Box::new(TreeNode { val: 8, left: None, right: None })) }))), LowestCommonAncestor(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) })), right: Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 0, left: None, right: None })), right: Some(Box::new(TreeNode { val: 8, left: None, right: None })) })), 5, 1).unwrap())",
        "assert_eq!(Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) }), LowestCommonAncestor(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 6, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: None })) })) })), right: Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 0, left: None, right: None })), right: Some(Box::new(TreeNode { val: 8, left: None, right: None })) })), 5, 4).unwrap())"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def LowestCommonAncestor(root, p, q)\n  \nend",
      "testCalls": [
        "assert_equal(3, LowestCommonAncestor([3,5,1,6,2,0,8,nil,nil,7,4], 5, 1))",
        "assert_equal(5, LowestCommonAncestor([3,5,1,6,2,0,8,nil,nil,7,4], 5, 4))",
        "assert_equal(1, LowestCommonAncestor([1,2], 1, 2))"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test case failed' unless expected == actual\nend"
    }
  },
  "majority-element": {
    "title": "Majority Element",
    "content": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than &lfloor;n / 2&rfloor; times. You may assume that the majority element always exists in the array.\n\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 104\n-109 <= nums[i] <= 109\nThe input is generated such that a majority element will exist in the array.\n\n\nFollow-up: Could you solve the problem in linear time and in O(1) space?",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Counting"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function MajorityElement(nums) {}",
      "testCalls": [
        "if (MajorityElement([3,2,3]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if (MajorityElement([2,2,1,1,1,2,2]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MajorityElement(nums: number[]): number { }",
      "testCalls": [
        "const test1 = MajorityElement([3,2,3]); if (test1 !== 3) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MajorityElement([2,2,1,1,1,2,2]); if (test2 !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MajorityElement(vector<int>& nums);",
      "testCalls": [
        "assert(MajorityElement({3,2,3}) == 3);",
        "assert(MajorityElement({2,2,1,1,1,2,2}) == 2);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MajorityElement(nums: List[int]) -> int:",
      "testCalls": [
        "assert MajorityElement([3,2,3]) == 3",
        "assert MajorityElement([2,2,1,1,1,2,2]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MajorityElement(int[] nums) { }",
      "testCalls": [
        "assert MajorityElement(new int[]{3,2,3}) == 3;",
        "assert MajorityElement(new int[]{2,2,1,1,1,2,2}) == 2;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MajorityElement(int* nums, int numsSize)",
      "testCalls": [
        "if (MajorityElement((int[]){3,2,3}, 3) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (MajorityElement((int[]){2,2,1,1,1,2,2}, 7) != 2) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MajorityElement(nums []int) int {}",
      "testCalls": [
        "if MajorityElement([]int{3,2,3}) != 3 {panic(\"Test case 1 failed\")}",
        "if MajorityElement([]int{2,2,1,1,1,2,2}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MajorityElement(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MajorityElement(vec![3,2,3]), 3);",
        "assert_eq!(MajorityElement(vec![2,2,1,1,1,2,2]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MajorityElement(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MajorityElement([3,2,3]) == 3",
        "raise 'Test Case 2 Failed' unless MajorityElement([2,2,1,1,1,2,2]) == 2"
      ],
      "compareHelper": ""
    }
  },
  "max-points-on-a-line": {
    "title": "Max Points on a Line",
    "content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\nExample 1:\n\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\nExample 2:\n\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\n\n\nConstraints:\n\n1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaxPointsOnALine(points) {}",
      "testCalls": [
        "if(MaxPointsOnALine([[1,1],[2,2],[3,3]]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxPointsOnALine(points: number[][]): number { }",
      "testCalls": [
        "const test1 = MaxPointsOnALine([[1,1],[2,2],[3,3]]); if(test1 !== 3) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]); if(test2 !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxPointsOnALine(vector<vector<int>>& points)",
      "testCalls": [
        "assert(MaxPointsOnALine({{1,1},{2,2},{3,3}}) == 3);",
        "assert(MaxPointsOnALine({{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}) == 4);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaxPointsOnALine(points: List[List[int]]) -> int",
      "testCalls": [
        "assert MaxPointsOnALine([[1,1],[2,2],[3,3]]) == 3",
        "assert MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public int MaxPointsOnALine(int[][] points) {}",
      "testCalls": [
        "int[][] test1 = {{1,1},{2,2},{3,3}}; int result1 = MaxPointsOnALine(test1); if (result1 != 3) { throw new AssertionError(); }",
        "int[][] test2 = {{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}; int result2 = MaxPointsOnALine(test2); if (result2 != 4) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxPointsOnALine(int** points, int pointsSize, int* pointsColSize)",
      "testCalls": [
        "if(MaxPointsOnALine((int*[]){{1,1},{2,2},{3,3}}, 3, (int[]){2, 2}) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxPointsOnALine((int*[]){{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}, 6, (int[]){2, 2}) != 4) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxPointsOnALine(points [][]int) int {}",
      "testCalls": [
        "if MaxPointsOnALine([][]int{{1,1},{2,2},{3,3}}) != 3 {panic(\"Test case 1 failed\")}",
        "if MaxPointsOnALine([][]int{{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaxPointsOnALine(points: Vec<Vec<i32>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MaxPointsOnALine(vec![vec![1,1],vec![2,2],vec![3,3]]), 3);",
        "assert_eq!(MaxPointsOnALine(vec![vec![1,1],vec![3,2],vec![5,3],vec![4,1],vec![2,3],vec![1,4]]), 4);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaxPointsOnALine(points)\nend",
      "testCalls": [
        "test_case_1 = MaxPointsOnALine([[1,1],[2,2],[3,3]])\nraise 'Test Case 1 Failed' unless test_case_1 == 3",
        "test_case_2 = MaxPointsOnALine([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]])\nraise 'Test Case 2 Failed' unless test_case_2 == 4"
      ],
      "compareHelper": ""
    }
  },
  "maximal-square": {
    "title": "Maximal Square",
    "content": "Given an m x n binary matrix filled with 0 and 1, find the largest square containing only 1 and return its area.\n\nExample 1:\n\n\nInput: matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\nOutput: 4\n\nExample 2:\n\n\nInput: matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]\nOutput: 1\n\nExample 3:\n\nInput: matrix = [[&quot;0&quot;]]\nOutput: 0\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 300\nmatrix[i][j] is &#39;0&#39; or &#39;1&#39;.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximalSquare(matrix) {}",
      "testCalls": [
        "if(MaximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(MaximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]]) !== 1) throw new Error('Test Case 2 Failed');",
        "if(MaximalSquare([[\"0\"]]) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximalSquare(matrix: string[][]): number { }",
      "testCalls": [
        "if(MaximalSquare([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) !== 4) throw new Error('Test Case 1 Failed');",
        "if(MaximalSquare([['0','1'],['1','0']]) !== 1) throw new Error('Test Case 2 Failed');",
        "if(MaximalSquare([['0']]) !== 0) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaximalSquare(std::vector<std::vector<char>>& matrix)",
      "testCalls": [
        "if(MaximalSquare({{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}) != 4) throw std::runtime_error(\"Test 1 failed!\");",
        "if(MaximalSquare({{'0','1'},{'1','0'}}) != 1) throw std::runtime_error(\"Test 2 failed!\");",
        "if(MaximalSquare({{'0'}}) != 0) throw std::runtime_error(\"Test 3 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximalSquare(matrix: List[List[str]]) -> int",
      "testCalls": [
        "assert MaximalSquare([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) == 4",
        "assert MaximalSquare([['0','1'],['1','0']]) == 1",
        "assert MaximalSquare([['0']]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximalSquare(char[][] matrix) { }",
      "testCalls": [
        "int result1 = MaximalSquare(new char[][]{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}); if (result1 != 4) throw new AssertionError();",
        "int result2 = MaximalSquare(new char[][]{{'0','1'},{'1','0'}}); if (result2 != 1) throw new AssertionError();",
        "int result3 = MaximalSquare(new char[][]{{'0'}}); if (result3 != 0) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaximalSquare(char** matrix, int matrixSize, int* matrixColSize)",
      "testCalls": [
        "MaximalSquare((char*[]) {\"1\",\"0\",\"1\",\"0\",\"0\"}, 4, (int[]) {5}) == 4 ? printf(\"Test case 1 passed\\n\") : printf(\"Test case 1 failed\\n\");",
        "MaximalSquare((char*[]) {\"0\",\"1\",\"1\",\"0\"}, 2, (int[]) {2}) == 1 ? printf(\"Test case 2 passed\\n\") : printf(\"Test case 2 failed\\n\");",
        "MaximalSquare((char*[]) {\"0\"}, 1, (int[]) {1}) == 0 ? printf(\"Test case 3 passed\\n\") : printf(\"Test case 3 failed\\n\");"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaximalSquare(matrix [][]string) int {}",
      "testCalls": [
        "if MaximalSquare([][]string{{\"1\",\"0\",\"1\",\"0\",\"0\"},{\"1\",\"0\",\"1\",\"1\",\"1\"},{\"1\",\"1\",\"1\",\"1\",\"1\"},{\"1\",\"0\",\"0\",\"1\",\"0\"}}) != 4 { t.Error(\"Test Case 1 Failed\") }",
        "if MaximalSquare([][]string{{\"0\",\"1\"},{\"1\",\"0\"}}) != 1 { t.Error(\"Test Case 2 Failed\") }",
        "if MaximalSquare([][]string{{\"0\"}}) != 0 { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximalSquare(matrix: Vec<Vec<char>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaximalSquare(vec![vec![&'1', &'0', &'1', &'0', &'0'], vec![&'1', &'0', &'1', &'1', &'1'], vec![&'1', &'1', &'1', &'1', &'1'], vec![&'1', &'0', &'0', &'1', &'0']]), 4);",
        "assert_eq!(MaximalSquare(vec![vec![&'0', &'1'], vec![&'1', &'0']]), 1);",
        "assert_eq!(MaximalSquare(vec![vec![&'0']]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximalSquare(matrix)\nend",
      "testCalls": [
        "test1 = MaximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])\nraise 'Test Case 1 Failed' unless test1 == 4",
        "test2 = MaximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]])\nraise 'Test Case 2 Failed' unless test2 == 1",
        "test3 = MaximalSquare([[\"0\"]])\nraise 'Test Case 3 Failed' unless test3 == 0"
      ],
      "compareHelper": ""
    }
  },
  "maximum-depth-of-binary-tree": {
    "title": "Maximum Depth of Binary Tree",
    "content": "Given the root of a binary tree, return its maximum depth.\nA binary tree maximum depthis the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nExample 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\n\nInput: root = [1,null,2]\nOutput: 2\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaxDepthOfBinaryTree(root) {}",
      "testCalls": [
        "if(MaxDepthOfBinaryTree([3,9,20,null,null,15,7]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxDepthOfBinaryTree([1,null,2]) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaxDepthOfBinaryTree(root: TreeNode | null): number { }",
      "testCalls": [
        "if(MaxDepthOfBinaryTree(createBinaryTree([3,9,20,null,null,15,7])) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaxDepthOfBinaryTree(createBinaryTree([1,null,2])) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function createBinaryTree(arr: Array<number | null>): TreeNode | null { }"
    },
    "c++": {
      "functionDeclaration": "int MaxDepth(TreeNode* root)",
      "testCalls": [
        "assert(MaxDepth(createTree({3,9,20,INT_MIN,INT_MIN,15,7})) == 3);",
        "assert(MaxDepth(createTree({1,INT_MIN,2})) == 2);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MaximumDepthOfBinaryTree(root: TreeNode) -> int",
      "testCalls": [
        "assert MaximumDepthOfBinaryTree(buildTree([3,9,20,null,null,15,7])) == 3",
        "assert MaximumDepthOfBinaryTree(buildTree([1,null,2])) == 2"
      ],
      "compareHelper": "def buildTree(nodes): pass"
    },
    "java": {
      "functionDeclaration": "public int maxDepth(TreeNode root) { }",
      "testCalls": [
        "if (maxDepth(TreeNode.buildTree(new Integer[]{3,9,20,null,null,15,7})) != 3) { throw new AssertionError(); }",
        "if (maxDepth(TreeNode.buildTree(new Integer[]{1,null,2})) != 2) { throw new AssertionError(); }"
      ],
      "compareHelper": "public static boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int MaxDepth(struct TreeNode* root)",
      "testCalls": [
        "assert(MaxDepth(createTreeFromArray((int[]) {3,9,20,-1,-1,15,7}, 7)) == 3);",
        "assert(MaxDepth(createTreeFromArray((int[]) {1,-1,2}, 3)) == 2);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n    for (int i = 0; i < size; i++) {\n        if (arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MaxDepth(root *TreeNode) int {}",
      "testCalls": [
        "if MaxDepth(&TreeNode{Val: 3, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 7}}}) != 3 {panic(\"Test case 1 failed\")}",
        "if MaxDepth(&TreeNode{Val: 1, Right: &TreeNode{Val: 2}}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaxDepth(root: Option<Box<TreeNode>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaxDepth(Some(Box::new(TreeNode { val: 3, left: Some(Box::new(TreeNode { val: 9, left: None, right: None })), right: Some(Box::new(TreeNode { val: 20, left: Some(Box::new(TreeNode { val: 15, left: None, right: None })), right: Some(Box::new(TreeNode { val: 7, left: None, right: None })) })) })), 3);",
        "assert_eq!(MaxDepth(Some(Box::new(TreeNode { val: 1, left: None, right: Some(Box::new(TreeNode { val: 2, left: None, right: None })) })), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumDepthOfBinaryTree(root)\nend",
      "testCalls": [
        "test_case_1 = MaximumDepthOfBinaryTree([3,9,20,nil,nil,15,7])\nraise 'Test Case 1 Failed' unless test_case_1 == 3",
        "test_case_2 = MaximumDepthOfBinaryTree([1,nil,2])\nraise 'Test Case 2 Failed' unless test_case_2 == 2"
      ],
      "compareHelper": ""
    }
  },
  "maximum-subarray": {
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximumSubarray(nums) {}",
      "testCalls": [
        "if(MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSubarray([1]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(MaximumSubarray([5,4,-1,7,8]) !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximumSubarray(nums: number[]): number {}",
      "testCalls": [
        "if (MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) !== 6) { throw new Error('Test Case 1 Failed'); }",
        "if (MaximumSubarray([1]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if (MaximumSubarray([5,4,-1,7,8]) !== 23) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MaxSubarray(std::vector<int>& nums);",
      "testCalls": [
        "if(MaxSubarray({-2,1,-3,4,-1,2,1,-5,4}) != 6) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(MaxSubarray({1}) != 1) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximumSubarray(nums: List[int]) -> int",
      "testCalls": [
        "assert MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) == 6",
        "assert MaximumSubarray([1]) == 1",
        "assert MaximumSubarray([5,4,-1,7,8]) == 23"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximumSubarray(int[] nums) {}",
      "testCalls": [
        "if(MaximumSubarray(new int[]{-2,1,-3,4,-1,2,1,-5,4}) != 6) throw new AssertionError();",
        "if(MaximumSubarray(new int[]{1}) != 1) throw new AssertionError();",
        "if(MaximumSubarray(new int[]{5,4,-1,7,8}) != 23) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaxSubarray(int* nums, int numsSize)",
      "testCalls": [
        "if(MaxSubarray((int[]){-2,1,-3,4,-1,2,1,-5,4}, 9) != 6) { printf(\"Test Case 1 Failed\"); }",
        "if(MaxSubarray((int[]){1}, 1) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaxSubarray(nums []int) int {}",
      "testCalls": [
        "if MaxSubarray([]int{-2,1,-3,4,-1,2,1,-5,4}) != 6 { panic(\"Test case 1 failed\") }",
        "if MaxSubarray([]int{1}) != 1 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximumSubarray(nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MaximumSubarray(vec![-2,1,-3,4,-1,2,1,-5,4]), 6);",
        "assert_eq!(MaximumSubarray(vec![1]), 1);",
        "assert_eq!(MaximumSubarray(vec![5,4,-1,7,8]), 23);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumSubarray(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MaximumSubarray([-2,1,-3,4,-1,2,1,-5,4]) == 6",
        "raise 'Test Case 2 Failed' unless MaximumSubarray([1]) == 1",
        "raise 'Test Case 3 Failed' unless MaximumSubarray([5,4,-1,7,8]) == 23"
      ],
      "compareHelper": ""
    }
  },
  "maximum-sum-circular-subarray": {
    "title": "Maximum Sum Circular Subarray",
    "content": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n\nExample 1:\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\n\nExample 2:\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\n\nExample 3:\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\n\n",
    "difficulty": "Medium",
    "hints": [
      "For those of you who are familiar with the Kadane's algorithm, think in terms of that. For the newbies, Kadane's algorithm is used to finding the maximum sum subarray from a given array. This problem is a twist on that idea and it is advisable to read up on that algorithm first before starting this problem. Unless you already have a great algorithm brewing up in your mind in which case, go right ahead!",
      "What is an alternate way of representing a circular array so that it appears to be a straight array?\r\nEssentially, there are two cases of this problem that we need to take care of. Let's look at the figure below to understand those two cases:\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/circular_subarray_hint_1.png\" width=\"700\"/>",
      "The first case can be handled by the good old Kadane's algorithm. However, is there a smarter way of going about handling the second case as well?"
    ],
    "topicTags": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming",
      "Queue",
      "Monotonic Queue"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MaximumSumCircularSubarray(nums) {}",
      "testCalls": [
        "if(MaximumSumCircularSubarray([1,-2,3,-2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSumCircularSubarray([5,-3,5]) !== 10) { throw new Error('Test Case 2 Failed'); }",
        "if(MaximumSumCircularSubarray([-3,-2,-3]) !== -2) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MaximumSumCircularSubarray(nums: number[]): number {}",
      "testCalls": [
        "if(MaximumSumCircularSubarray([1,-2,3,-2]) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(MaximumSumCircularSubarray([5,-3,5]) !== 10) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "MaximumSumCircularSubarray(vector<int>& nums)",
      "testCalls": [
        "if(MaximumSumCircularSubarray({1,-2,3,-2}) != 3) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(MaximumSumCircularSubarray({5,-3,5}) != 10) throw std::runtime_error(\"Test Case 2 Failed\");",
        "if(MaximumSumCircularSubarray({-3,-2,-3}) != -2) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MaximumSumCircularSubarray(nums: List[int]) -> int:",
      "testCalls": [
        "assert MaximumSumCircularSubarray([1,-2,3,-2]) == 3, 'Test Case 1 Failed'",
        "assert MaximumSumCircularSubarray([5,-3,5]) == 10, 'Test Case 2 Failed'",
        "assert MaximumSumCircularSubarray([-3,-2,-3]) == -2, 'Test Case 3 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MaximumSumCircularSubarray(int[] nums) {}",
      "testCalls": [
        "if (MaximumSumCircularSubarray(new int[]{1,-2,3,-2}) != 3) throw new AssertionError();",
        "if (MaximumSumCircularSubarray(new int[]{5,-3,5}) != 10) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MaximumSumCircularSubarray(int* nums, int numsSize)",
      "testCalls": [
        "if(MaximumSumCircularSubarray((int[]){1,-2,3,-2}, 4) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if(MaximumSumCircularSubarray((int[]){5,-3,5}, 3) != 10) { printf(\"Test Case 2 Failed\"); }",
        "if(MaximumSumCircularSubarray((int[]){-3,-2,-3}, 3) != -2) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MaximumSumCircularSubarray(nums []int) int {}",
      "testCalls": [
        "if MaximumSumCircularSubarray([]int{1,-2,3,-2}) != 3 {panic(\"Test case 1 failed\")}",
        "if MaximumSumCircularSubarray([]int{5,-3,5}) != 10 {panic(\"Test case 2 failed\")}",
        "if MaximumSumCircularSubarray([]int{-3,-2,-3}) != -2 {panic(\"Test case 3 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MaximumSumCircularSubarray(nums: Vec<i32>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MaximumSumCircularSubarray(vec![1, -2, 3, -2]), 3);",
        "assert_eq!(MaximumSumCircularSubarray(vec![5, -3, 5]), 10);",
        "assert_eq!(MaximumSumCircularSubarray(vec![-3, -2, -3]), -2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MaximumSumCircularSubarray(nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MaximumSumCircularSubarray([1,-2,3,-2]) == 3",
        "raise 'Test Case 2 Failed' unless MaximumSumCircularSubarray([5,-3,5]) == 10"
      ],
      "compareHelper": ""
    }
  },
  "median-of-two-sorted-arrays": {
    "title": "Median of Two Sorted Arrays",
    "content": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MedianOfTwoSortedArrays(nums1, nums2) {}",
      "testCalls": [
        "if (MedianOfTwoSortedArrays([1,3], [2]) !== 2.00000) { throw new Error('Test Case 1 Failed'); }",
        "if (MedianOfTwoSortedArrays([1,2], [3,4]) !== 2.50000) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function FindMedianSortedArrays(nums1: number[], nums2: number[]): number[]",
      "testCalls": [
        "const test1Result = FindMedianSortedArrays([1,3], [2]); if (test1Result !== 2.00000) { throw new Error('Test Case 1 Failed'); }",
        "const test2Result = FindMedianSortedArrays([1,2], [3,4]); if (test2Result !== 2.50000) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "double FindMedianSortedArrays(vector<int>& nums1, vector<int>& nums2)",
      "testCalls": [
        "assert(FindMedianSortedArrays({1,3}, {2}) == 2.00000);",
        "assert(FindMedianSortedArrays({1,2}, {3,4}) == 2.50000);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MedianOfTwoSortedArrays(nums1, nums2):",
      "testCalls": [
        "result1 = MedianOfTwoSortedArrays([1,3], [2])\nif result1 != 2.00000:\n    raise AssertionError",
        "result2 = MedianOfTwoSortedArrays([1,2], [3,4])\nif result2 != 2.50000:\n    raise AssertionError"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public double FindMedianSortedArrays(int[] nums1, int[] nums2) {}",
      "testCalls": [
        "if (FindMedianSortedArrays(new int[]{1,3}, new int[]{2}) != 2.00000) throw new AssertionError();",
        "if (FindMedianSortedArrays(new int[]{1,2}, new int[]{3,4}) != 2.50000) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "double FindMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size)",
      "testCalls": [
        "if (FindMedianSortedArrays((int[]){1,3}, 2, (int[]){2}, 1) != 2.00000) { printf(\"Test case 1 failed\"); }",
        "if (FindMedianSortedArrays((int[]){1,2}, 2, (int[]){3,4}, 2) != 2.50000) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func FindMedianSortedArrays(nums1 []int, nums2 []int) float64 {}",
      "testCalls": [
        "if FindMedianSortedArrays([]int{1,3}, []int{2}) != 2.00000 { t.Error() }",
        "if FindMedianSortedArrays([]int{1,2}, []int{3,4}) != 2.50000 { t.Error() }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MedianOfTwoSortedArrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {}",
      "testCalls": [
        "assert_eq!(MedianOfTwoSortedArrays(vec![1, 3], vec![2]), 2.00000);",
        "assert_eq!(MedianOfTwoSortedArrays(vec![1, 2], vec![3, 4]), 2.50000);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MedianOfTwoSortedArrays(nums1, nums2)\nend",
      "testCalls": [
        "result1 = MedianOfTwoSortedArrays([1,3], [2])\nraise 'Test Case 1 Failed' unless result1 == 2.00000",
        "result2 = MedianOfTwoSortedArrays([1,2], [3,4])\nraise 'Test Case 2 Failed' unless result2 == 2.50000"
      ],
      "compareHelper": ""
    }
  },
  "merge-intervals": {
    "title": "Merge Intervals",
    "content": "Given an arrayof intervalswhere intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\nExample 3:\n\nInput: intervals = [[4,7],[1,4]]\nOutput: [[1,7]]\nExplanation: Intervals [1,4] and [4,7] are considered overlapping.\n\n\nConstraints:\n\n1 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeIntervals(intervals) {}",
      "testCalls": [
        "const test1 = MergeIntervals([[1,3],[2,6],[8,10],[15,18]]); if(JSON.stringify(test1) !== '[[1,6],[8,10],[15,18]]') throw new Error('Test Case 1 Failed');",
        "const test2 = MergeIntervals([[1,4],[4,5]]); if(JSON.stringify(test2) !== '[[1,5]]') throw new Error('Test Case 2 Failed');",
        "const test3 = MergeIntervals([[4,7],[1,4]]); if(JSON.stringify(test3) !== '[[1,7]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeIntervals(intervals: number[][]): number[][] {}",
      "testCalls": [
        "const test1 = MergeIntervals([[1,3],[2,6],[8,10],[15,18]]); if (JSON.stringify(test1) !== '[[1,6],[8,10],[15,18]]') throw new Error('Test Case 1 Failed');",
        "const test2 = MergeIntervals([[1,4],[4,5]]); if (JSON.stringify(test2) !== '[[1,5]]') throw new Error('Test Case 2 Failed');",
        "const test3 = MergeIntervals([[4,7],[1,4]]); if (JSON.stringify(test3) !== '[[1,7]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> MergeIntervals(vector<vector<int>>& intervals);",
      "testCalls": [
        "auto res1 = MergeIntervals({{1,3},{2,6},{8,10},{15,18}}); assert(res1 == vector<vector<int>>{{1,6},{8,10},{15,18}});",
        "auto res2 = MergeIntervals({{1,4},{4,5}}); assert(res2 == vector<vector<int>>{{1,5}});",
        "auto res3 = MergeIntervals({{4,7},{1,4}}); assert(res3 == vector<vector<int>>{{1,7}});"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MergeIntervals(intervals: List[List[int]]) -> List[List[int]]",
      "testCalls": [
        "assert MergeIntervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]",
        "assert MergeIntervals([[1,4],[4,5]]) == [[1,5]]",
        "assert MergeIntervals([[4,7],[1,4]]) == [[1,7]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public int[][] MergeIntervals(int[][] intervals) { }",
      "testCalls": [
        "int[][] test1 = MergeIntervals(new int[][]{{1,3},{2,6},{8,10},{15,18}}); if (!Arrays.deepEquals(test1, new int[][]{{1,6},{8,10},{15,18}})) throw new AssertionError();",
        "int[][] test2 = MergeIntervals(new int[][]{{1,4},{4,5}}); if (!Arrays.deepEquals(test2, new int[][]{{1,5}})) throw new AssertionError();",
        "int[][] test3 = MergeIntervals(new int[][]{{4,7},{1,4}}); if (!Arrays.deepEquals(test3, new int[][]{{1,7}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(int[][] arr1, int[][] arr2) { return Arrays.deepEquals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int** MergeIntervals(int** intervals, int intervalsSize, int* intervalsColSize)",
      "testCalls": [
        "MergeIntervals((int*[]){{1,3},{2,6},{8,10},{15,18}}, 4, (int[]){2, 2}); // Expected: [[1,6],[8,10],[15,18]]",
        "MergeIntervals((int*[]){{1,4},{4,5}}, 2, (int[]){2, 2}); // Expected: [[1,5]]",
        "MergeIntervals((int*[]){{4,7},{1,4}}, 2, (int[]){2, 2}); // Expected: [[1,7]]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n    if(size1 != size2) return 0;\n    for(int i = 0; i < size1; i++) {\n        if(arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MergeIntervals(intervals [][]int) [][]int {}",
      "testCalls": [
        "result1 := MergeIntervals([][]int{{1,3},{2,6},{8,10},{15,18}}); if !compareArrays(result1, [][]int{{1,6},{8,10},{15,18}}) { t.Error(\"Test case 1 failed\") }",
        "result2 := MergeIntervals([][]int{{1,4},{4,5}}); if !compareArrays(result2, [][]int{{1,5}}) { t.Error(\"Test case 2 failed\") }",
        "result3 := MergeIntervals([][]int{{4,7},{1,4}}); if !compareArrays(result3, [][]int{{1,7}}) { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i][0] != arr2[i][0] || arr1[i][1] != arr2[i][1] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeIntervals(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> { }",
      "testCalls": [
        "let result1 = MergeIntervals(vec![vec![1,3], vec![2,6], vec![8,10], vec![15,18]]); assert_eq!(result1, vec![vec![1,6], vec![8,10], vec![15,18]]);",
        "let result2 = MergeIntervals(vec![vec![1,4], vec![4,5]]); assert_eq!(result2, vec![vec![1,5]]);",
        "let result3 = MergeIntervals(vec![vec![4,7], vec![1,4]]); assert_eq!(result3, vec![vec![1,7]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_eq(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) { assert_eq!(a.len(), b.len()); for i in 0..a.len() { assert_eq!(a[i], b[i]); } }"
    },
    "ruby": {
      "functionDeclaration": "def MergeIntervals(intervals)\n  \nend",
      "testCalls": [
        "intervals1 = [[1,3],[2,6],[8,10],[15,18]]\nexpected_result1 = [[1,6],[8,10],[15,18]]\nresult1 = MergeIntervals(intervals1)\nraise 'Test Case 1 Failed' unless result1 == expected_result1",
        "intervals2 = [[1,4],[4,5]]\nexpected_result2 = [[1,5]]\nresult2 = MergeIntervals(intervals2)\nraise 'Test Case 2 Failed' unless result2 == expected_result2"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "merge-k-sorted-lists": {
    "title": "Merge k Sorted Lists",
    "content": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\nExample 2:\n\nInput: lists = []\nOutput: []\n\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n\n\nConstraints:\n\nk == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeKSortedLists(lists) {}",
      "testCalls": [
        "const test1 = MergeKSortedLists([[1,4,5],[1,3,4],[2,6]]); if(JSON.stringify(test1) !== JSON.stringify([1,1,2,3,4,4,5,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = MergeKSortedLists([]); if(JSON.stringify(test2) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');",
        "const test3 = MergeKSortedLists([[]]); if(JSON.stringify(test3) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeKSortedLists(lists: number[][]): number[] | null {}",
      "testCalls": [
        "const test1 = MergeKSortedLists([[1,4,5],[1,3,4],[2,6]]); if(JSON.stringify(test1) !== JSON.stringify([1,1,2,3,4,4,5,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = MergeKSortedLists([]); if(JSON.stringify(test2) !== JSON.stringify([])) throw new Error('Test Case 2 Failed');",
        "const test3 = MergeKSortedLists([[]]); if(JSON.stringify(test3) !== JSON.stringify([])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "ListNode* MergeKSortedLists(vector<ListNode*>& lists)",
      "testCalls": [
        "assert(compareLinkedLists(MergeKSortedLists({createLinkedList({1,4,5}), createLinkedList({1,3,4}), createLinkedList({2,6})}), createLinkedList({1,1,2,3,4,4,5,6})));",
        "assert(compareLinkedLists(MergeKSortedLists({})), nullptr);",
        "assert(compareLinkedLists(MergeKSortedLists({nullptr})), nullptr);"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }"
    },
    "python": {
      "functionDeclaration": "def MergeKSortedLists(lists: List[List[int]]) -> List[int]:",
      "testCalls": [
        "result1 = MergeKSortedLists([[1,4,5],[1,3,4],[2,6]])\nassert result1 == [1,1,2,3,4,4,5,6], 'Test Case 1 Failed'",
        "result2 = MergeKSortedLists([])\nassert result2 == [], 'Test Case 2 Failed'",
        "result3 = MergeKSortedLists([[]])\nassert result3 == [], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public ListNode mergeKSortedLists(ListNode[] lists)",
      "testCalls": [
        "ListNode[] testInput1 = {createLinkedList(new int[]{1,4,5}), createLinkedList(new int[]{1,3,4}), createLinkedList(new int[]{2,6})};\nListNode expectedResult1 = createLinkedList(new int[]{1,1,2,3,4,4,5,6});\ncompareLinkedLists(expectedResult1, mergeKSortedLists(testInput1));",
        "ListNode[] testInput2 = {};\nListNode expectedResult2 = null;\ncompareLinkedLists(expectedResult2, mergeKSortedLists(testInput2));",
        "ListNode[] testInput3 = {createLinkedList(new int[]{})};\nListNode expectedResult3 = null;\ncompareLinkedLists(expectedResult3, mergeKSortedLists(testInput3));"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode expected, ListNode actual) {\n    while (expected != null && actual != null) {\n        if (expected.val != actual.val) {\n            throw new AssertionError(\"Mismatch in linked list values\");\n        }\n        expected = expected.next;\n        actual = actual.next;\n    }\n    if (expected != null || actual != null) {\n        throw new AssertionError(\"Linked lists are of different lengths\");\n    }\n}"
    },
    "c": {
      "functionDeclaration": "MergeKSortedLists(int** lists, int listsSize, int* listsColSize)",
      "testCalls": [
        "MergeKSortedLists((int*[]){(int[]){1,4,5}, (int[]){1,3,4}, (int[]){2,6}}, 3, (int[]){3, 3})",
        "MergeKSortedLists(NULL, 0, NULL)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MergeKSortedLists(lists [][]int) []int {}",
      "testCalls": [
        "result1 := MergeKSortedLists([][]int{{1,4,5},{1,3,4},{2,6}}); if !compareArrays(result1, []int{1,1,2,3,4,4,5,6}) { t.Error(\"Test case 1 failed\") }",
        "result2 := MergeKSortedLists([][]int{}); if !compareArrays(result2, []int{}) { t.Error(\"Test case 2 failed\") }",
        "result3 := MergeKSortedLists([][]int{{}}); if !compareArrays(result3, []int{}) { t.Error(\"Test case 3 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeKSortedLists(lists: Vec<Vec<i32>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode::from(vec![1, 1, 2, 3, 4, 4, 5, 6]))), MergeKSortedLists(vec![vec![1, 4, 5], vec![1, 3, 4], vec![2, 6]]));",
        "assert_eq!(None, MergeKSortedLists(vec![]));",
        "assert_eq!(None, MergeKSortedLists(vec![vec![]]));"
      ],
      "compareHelper": "fn compare_linked_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) { }"
    },
    "ruby": {
      "functionDeclaration": "def MergeKSortedLists(lists)\nend",
      "testCalls": [
        "result1 = MergeKSortedLists([[1,4,5],[1,3,4],[2,6]])\nraise 'Test Case 1 Failed' unless result1 == [1,1,2,3,4,4,5,6]",
        "result2 = MergeKSortedLists([])\nraise 'Test Case 2 Failed' unless result2 == []",
        "result3 = MergeKSortedLists([[]])\nraise 'Test Case 3 Failed' unless result3 == []"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "merge-sorted-array": {
    "title": "Merge Sorted Array",
    "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\nExample 1:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n\nExample 2:\n\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\nExample 3:\n\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\nConstraints:\n\nnums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-109 <= nums1[i], nums2[j] <= 109\n\n\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?\n",
    "difficulty": "Easy",
    "hints": [
      "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
      "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
    ],
    "topicTags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeSortedArray(nums1, m, nums2, n) {}",
      "testCalls": [
        "MergeSortedArray([1,2,3,0,0,0], 3, [2,5,6], 3);",
        "MergeSortedArray([1], 1, [], 0);",
        "MergeSortedArray([0], 0, [1], 1);"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeSortedArray(nums1: number[], m: number, nums2: number[], n: number): void {}",
      "testCalls": [
        "MergeSortedArray([1,2,3,0,0,0], 3, [2,5,6], 3); if (JSON.stringify(nums1) !== JSON.stringify([1,2,2,3,5,6])) throw new Error('Test Case 1 Failed');",
        "MergeSortedArray([1], 1, [], 0); if (JSON.stringify(nums1) !== JSON.stringify([1])) throw new Error('Test Case 2 Failed');",
        "MergeSortedArray([0], 0, [1], 1); if (JSON.stringify(nums1) !== JSON.stringify([1])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "void MergeSortedArray(vector<int>& nums1, int m, vector<int>& nums2, int n)",
      "testCalls": [
        "MergeSortedArray({1,2,3,0,0,0}, 3, {2,5,6}, 3);",
        "MergeSortedArray({1}, 1, {}, 0);",
        "MergeSortedArray({0}, 0, {1}, 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def MergeSortedArray(nums1, m, nums2, n):",
      "testCalls": [
        "result1 = [1,2,3,0,0,0]\nMergeSortedArray(result1, 3, [2,5,6], 3)\nassert result1 == [1,2,2,3,5,6]",
        "result2 = [1]\nMergeSortedArray(result2, 1, [], 0)\nassert result2 == [1]",
        "result3 = [0]\nMergeSortedArray(result3, 0, [1], 1)\nassert result3 == [1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public void MergeSortedArray(int[] nums1, int m, int[] nums2, int n) {}",
      "testCalls": [
        "MergeSortedArray(new int[]{1,2,3,0,0,0}, 3, new int[]{2,5,6}, 3); // compareArrays(nums1, new int[]{1,2,2,3,5,6});",
        "MergeSortedArray(new int[]{1}, 1, new int[]{}, 0); // compareArrays(nums1, new int[]{1});",
        "MergeSortedArray(new int[]{0}, 0, new int[]{1}, 1); // compareArrays(nums1, new int[]{1});"
      ],
      "compareHelper": "private void compareArrays(int[] arr1, int[] arr2) { for (int i = 0; i < arr1.length; i++) { if (arr1[i] != arr2[i]) { throw new AssertionError(\"Arrays differ at index \" + i); } } }"
    },
    "c": {
      "functionDeclaration": "void MergeSortedArray(int* nums1, int m, int* nums2, int n)",
      "testCalls": [
        "MergeSortedArray((int[]){1,2,3,0,0,0}, 3, (int[]){2,5,6}, 3);",
        "MergeSortedArray((int[]){1}, 1, (int[]){}, 0);",
        "MergeSortedArray((int[]){0}, 0, (int[]){1}, 1);"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) {\n  for (int i = 0; i < size; i++) {\n    if (arr1[i] != arr2[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func MergeSortedArray(nums1 []int, m int, nums2 []int, n int) {}",
      "testCalls": [
        "if !compareArrays(MergeSortedArray([]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3), []int{1, 2, 2, 3, 5, 6}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(MergeSortedArray([]int{1}, 1, []int{}, 0), []int{1}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(MergeSortedArray([]int{0}, 0, []int{1}, 1), []int{1}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn MergeSortedArray(nums1: &mut Vec<i32>, m: i32, nums2: &Vec<i32>, n: i32) {}",
      "testCalls": [
        "let mut test1_nums1 = vec![1, 2, 3, 0, 0, 0];\nlet test1_nums2 = vec![2, 5, 6];\nMergeSortedArray(&mut test1_nums1, 3, &test1_nums2, 3);\nassert_eq!(test1_nums1, vec![1, 2, 2, 3, 5, 6]);",
        "let mut test2_nums1 = vec![1];\nlet test2_nums2 = vec![];\nMergeSortedArray(&mut test2_nums1, 1, &test2_nums2, 0);\nassert_eq!(test2_nums1, vec![1]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: &Vec<i32>, b: &Vec<i32>) {\n    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert_eq!(a[i], b[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def MergeSortedArray(nums1, m, nums2, n)\nend",
      "testCalls": [
        "nums1 = [1,2,3,0,0,0]\nm = 3\nnums2 = [2,5,6]\nn = 3\nMergeSortedArray(nums1, m, nums2, n)\nraise 'Test Case 1 Failed' unless nums1 == [1,2,2,3,5,6]",
        "nums1 = [1]\nm = 1\nnums2 = []\nn = 0\nMergeSortedArray(nums1, m, nums2, n)\nraise 'Test Case 2 Failed' unless nums1 == [1]"
      ],
      "compareHelper": ""
    }
  },
  "merge-two-sorted-lists": {
    "title": "Merge Two Sorted Lists",
    "content": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\n\nExample 1:\n\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n\nConstraints:\n\nThe number of nodes in both lists is in the range [0, 50].\n-100 <= Node.val <= 100\nBoth list1 and list2 are sorted in non-decreasing order.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MergeTwoSortedLists(list1, list2) {}",
      "testCalls": [
        "const test1 = MergeTwoSortedLists([1,2,4], [1,3,4]); if(JSON.stringify(test1) !== JSON.stringify([1,1,2,3,4,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MergeTwoSortedLists([], []); if(JSON.stringify(test2) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = MergeTwoSortedLists([], [0]); if(JSON.stringify(test3) !== JSON.stringify([0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function MergeTwoSortedLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {}",
      "testCalls": [
        "const test1Result = MergeTwoSortedLists(createList([1,2,4]), createList([1,3,4])); compareLinkedLists(test1Result, createList([1,1,2,3,4,4]));",
        "const test2Result = MergeTwoSortedLists(null, null); compareLinkedLists(test2Result, null);",
        "const test3Result = MergeTwoSortedLists(null, createList([0])); compareLinkedLists(test3Result, createList([0]));"
      ],
      "compareHelper": "function compareLinkedLists(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); } }"
    },
    "c++": {
      "functionDeclaration": "ListNode* MergeTwoSortedLists(ListNode* list1, ListNode* list2)",
      "testCalls": [
        "assert(compareLinkedLists(MergeTwoSortedLists(createLinkedList({1,2,4}), createLinkedList({1,3,4})), createLinkedList({1,1,2,3,4,4}));",
        "assert(compareLinkedLists(MergeTwoSortedLists(createLinkedList({}), createLinkedList({})), createLinkedList({}));",
        "assert(compareLinkedLists(MergeTwoSortedLists(createLinkedList({}), createLinkedList({0})), createLinkedList({0}));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }"
    },
    "python": {
      "functionDeclaration": "def MergeTwoSortedLists(list1, list2):",
      "testCalls": [
        "result1 = MergeTwoSortedLists([1,2,4], [1,3,4]); assert result1 == [1,1,2,3,4,4], 'Test Case 1 Failed'",
        "result2 = MergeTwoSortedLists([], []); assert result2 == [], 'Test Case 2 Failed'",
        "result3 = MergeTwoSortedLists([], [0]); assert result3 == [0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public ListNode mergeTwoSortedLists(ListNode list1, ListNode list2) { }",
      "testCalls": [
        "ListNode expected1 = createLinkedList(new int[]{1, 1, 2, 3, 4, 4}); ListNode result1 = mergeTwoSortedLists(createLinkedList(new int[]{1, 2, 4}), createLinkedList(new int[]{1, 3, 4})); assertLinkedListEquals(expected1, result1);",
        "ListNode expected2 = createLinkedList(new int[]{}); ListNode result2 = mergeTwoSortedLists(createLinkedList(new int[]{}), createLinkedList(new int[]{})); assertLinkedListEquals(expected2, result2);",
        "ListNode expected3 = createLinkedList(new int[]{0}); ListNode result3 = mergeTwoSortedLists(createLinkedList(new int[]{}), createLinkedList(new int[]{0})); assertLinkedListEquals(expected3, result3);"
      ],
      "compareHelper": "private void assertLinkedListEquals(ListNode expected, ListNode actual) { while (expected != null && actual != null) { if (expected.val != actual.val) { throw new AssertionError(\"Value mismatch: expected=\" + expected.val + \", actual=\" + actual.val); } expected = expected.next; actual = actual.next; } if (expected != null || actual != null) { throw new AssertionError(\"Length mismatch\"); } }"
    },
    "c": {
      "functionDeclaration": "struct ListNode* MergeTwoSortedLists(struct ListNode* list1, struct ListNode* list2)",
      "testCalls": [
        "assert(compareArrays(MergeTwoSortedLists(createListFromArray((int[]) {1, 2, 4}, 3), createListFromArray((int[]) {1, 3, 4}, 3)), createListFromArray((int[]) {1, 1, 2, 3, 4, 4}, 6));",
        "assert(compareArrays(MergeTwoSortedLists(NULL, NULL), NULL);",
        "assert(compareArrays(MergeTwoSortedLists(NULL, createListFromArray((int[]) {0}, 1)), createListFromArray((int[]) {0}, 1));"
      ],
      "compareHelper": "bool compareArrays(struct ListNode* l1, struct ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == NULL && l2 == NULL; }"
    },
    "go": {
      "functionDeclaration": "func MergeTwoSortedLists(list1 *ListNode, list2 *ListNode) *ListNode {}",
      "testCalls": [
        "if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{1, 2, 4}), sliceToListNode([]int{1, 3, 4})), sliceToListNode([]int{1, 1, 2, 3, 4, 4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{}), sliceToListNode([]int{})), sliceToListNode([]int{})) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareLinkedList(MergeTwoSortedLists(sliceToListNode([]int{}), sliceToListNode([]int{0})), sliceToListNode([]int{0})) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }"
    },
    "rust": {
      "functionDeclaration": "fn MergeTwoSortedLists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 4, next: None) } } } } } } } } } } } } } })), MergeTwoSortedLists(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 4, next: None) } } } })), Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: None) } } } })))).unwrap());",
        "assert_eq!(None, MergeTwoSortedLists(None, None));",
        "assert_eq!(Some(Box::new(ListNode { val: 0, next: None })), MergeTwoSortedLists(None, Some(Box::new(ListNode { val: 0, next: None })));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MergeTwoSortedLists(list1, list2)\nend",
      "testCalls": [
        "test_case_1 = MergeTwoSortedLists([1,2,4], [1,3,4])\nraise 'Test Case 1 Failed' unless test_case_1 == [1,1,2,3,4,4]",
        "test_case_2 = MergeTwoSortedLists([], [])\nraise 'Test Case 2 Failed' unless test_case_2 == []",
        "test_case_3 = MergeTwoSortedLists([], [0])\nraise 'Test Case 3 Failed' unless test_case_3 == [0]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "minimum-absolute-difference-in-bst": {
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\n\nExample 1:\n\n\nInput: root = [4,2,6,1,3]\nOutput: 1\n\nExample 2:\n\n\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 104].\n0 <= Node.val <= 105\n\n\nNote: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumAbsoluteDifferenceInBST(root) {}",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST([4,2,6,1,3]) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumAbsoluteDifferenceInBST([1,0,48,null,null,12,49]) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumAbsoluteDifferenceInBST(root: TreeNode | null): number {}",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(createTreeNode([4,2,6,1,3])) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumAbsoluteDifferenceInBST(createTreeNode([1,0,48,null,null,12,49])) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function createTreeNode(arr: Array<number | null>): TreeNode | null {}"
    },
    "c++": {
      "functionDeclaration": "int MinDiffInBST(TreeNode* root)",
      "testCalls": [
        "assert(MinDiffInBST(createTree({4,2,6,1,3})) == 1);",
        "assert(MinDiffInBST(createTree({1,0,48,INT_MIN,INT_MIN,12,49})) == 1);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MinimumAbsoluteDifferenceInBST(root):",
      "testCalls": [
        "assert MinimumAbsoluteDifferenceInBST([4,2,6,1,3]) == 1",
        "assert MinimumAbsoluteDifferenceInBST([1,0,48,None,None,12,49]) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int MinimumAbsoluteDifferenceInBST(TreeNode root) { }",
      "testCalls": [
        "if (MinimumAbsoluteDifferenceInBST(TreeNode.buildTree(new Integer[]{4,2,6,1,3})) != 1) { throw new AssertionError(); }",
        "if (MinimumAbsoluteDifferenceInBST(TreeNode.buildTree(new Integer[]{1,0,48,null,null,12,49})) != 1) { throw new AssertionError(); }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int GetMinimumDifference(struct TreeNode* root)",
      "testCalls": [
        "if(GetMinimumDifference(createTreeFromArray((int[]){4,2,6,1,3}, 5)) != 1) { printf(\"Test Case 1 Failed\"); }",
        "if(GetMinimumDifference(createTreeFromArray((int[]){1,0,48,INT_MIN,INT_MIN,12,49}, 7)) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func GetMinimumDifference(root *TreeNode) int {}",
      "testCalls": [
        "if GetMinimumDifference(&TreeNode{Val: 4, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 1}, Right: &TreeNode{Val: 3}}, Right: &TreeNode{Val: 6}}) != 1 { t.Error(\"Test case 1 failed\") }",
        "if GetMinimumDifference(&TreeNode{Val: 1, Left: &TreeNode{Val: 0}, Right: &TreeNode{Val: 48, Left: &TreeNode{Val: 12}, Right: &TreeNode{Val: 49}}}) != 1 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumAbsoluteDifferenceInBST(root: Option<Rc<RefCell<TreeNode>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MinimumAbsoluteDifferenceInBST(Some(Rc::new(RefCell::new(TreeNode { val: 4, left: Some(Rc::new(RefCell::new(TreeNode { val: 2, left: Some(Rc::new(RefCell::new(TreeNode { val: 1, left: None, right: None }))), right: Some(Rc::new(RefCell::new(TreeNode { val: 3, left: None, right: None })) }))), right: Some(Rc::new(RefCell::new(TreeNode { val: 6, left: None, right: None })) })))), 1);",
        "assert_eq!(MinimumAbsoluteDifferenceInBST(Some(Rc::new(RefCell::new(TreeNode { val: 1, left: Some(Rc::new(RefCell::new(TreeNode { val: 0, left: None, right: None }))), right: Some(Rc::new(RefCell::new(TreeNode { val: 48, left: Some(Rc::new(RefCell::new(TreeNode { val: 12, left: None, right: None }))), right: Some(Rc::new(RefCell::new(TreeNode { val: 49, left: None, right: None })) }))) }))), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumAbsoluteDifferenceInBst(root)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MinimumAbsoluteDifferenceInBst([4,2,6,1,3]) == 1",
        "raise 'Test Case 2 Failed' unless MinimumAbsoluteDifferenceInBst([1,0,48,nil,nil,12,49]) == 1"
      ],
      "compareHelper": ""
    }
  },
  "minimum-genetic-mutation": {
    "title": "Minimum Genetic Mutation",
    "content": "A gene string can be represented by an 8-character long string, with choices from &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\nFor example, &quot;AACCGGTT&quot; --> &quot;AACCGGTA&quot; is one mutation.\n\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\n\nExample 1:\n\nInput: startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]\nOutput: 1\n\nExample 2:\n\nInput: startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]\nOutput: 2\n\n\nConstraints:\n\n0 <= bank.length <= 10\nstartGene.length == endGene.length == bank[i].length == 8\nstartGene, endGene, and bank[i] consist of only the characters [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;].\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Breadth-First Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumGeneticMutation(startGene, endGene, bank) {}",
      "testCalls": [
        "const test1 = MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA']);\nif (test1 !== 1) { throw new Error('Test case 1 failed'); }",
        "const test2 = MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA']);\nif (test2 !== 2) { throw new Error('Test case 2 failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumGeneticMutation(startGene: string, endGene: string, bank: string[]): number {}",
      "testCalls": [
        "if (MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA']) !== 1) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA']) !== 2) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MinGeneticMutation(string startGene, string endGene, vector<string>& bank)",
      "testCalls": [
        "assert(MinGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", {\"AACCGGTA\"}) == 1);",
        "assert(MinGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", {\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumGeneticMutation(startGene: str, endGene: str, bank: List[str]) -> int:",
      "testCalls": [
        "assert MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", [\"AACCGGTA\"]) == 1",
        "assert MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int minMutation(String startGene, String endGene, String[] bank)",
      "testCalls": [
        "if (minMutation(\"AACCGGTT\", \"AACCGGTA\", new String[]{\"AACCGGTA\"}) != 1) { throw new AssertionError(); }",
        "if (minMutation(\"AACCGGTT\", \"AAACGGTA\", new String[]{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) != 2) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinimumGeneticMutation(char *startGene, char *endGene, char **bank, int bankSize)",
      "testCalls": [
        "TEST_CASE(\"Example 1\") { REQUIRE(MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", (char*[]){\"AACCGGTA\"}, 1) == 1); }",
        "TEST_CASE(\"Example 2\") { REQUIRE(MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", (char*[]){\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"}, 3) == 2); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumGeneticMutation(startGene string, endGene string, bank []string) int {}",
      "testCalls": [
        "if MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", []string{\"AACCGGTA\"}) != 1 {panic(\"Test case 1 failed\")}",
        "if MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", []string{\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"}) != 2 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumGeneticMutation(start_gene: &str, end_gene: &str, bank: Vec<&str>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumGeneticMutation(\"AACCGGTT\", \"AACCGGTA\", vec![\"AACCGGTA\"]), 1);",
        "assert_eq!(MinimumGeneticMutation(\"AACCGGTT\", \"AAACGGTA\", vec![\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumGeneticMutation(start_gene, end_gene, bank)\n  \nend",
      "testCalls": [
        "result1 = MinimumGeneticMutation('AACCGGTT', 'AACCGGTA', ['AACCGGTA'])\nraise 'Test Case 1 Failed' unless result1 == 1",
        "result2 = MinimumGeneticMutation('AACCGGTT', 'AAACGGTA', ['AACCGGTA','AACCGCTA','AAACGGTA'])\nraise 'Test Case 2 Failed' unless result2 == 2"
      ],
      "compareHelper": ""
    }
  },
  "minimum-number-of-arrows-to-burst-balloons": {
    "title": "Minimum Number of Arrows to Burst Balloons",
    "content": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\n\nExample 1:\n\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n\nExample 2:\n\nInput: points = [[1,2],[3,4],[5,6],[7,8]]\nOutput: 4\nExplanation: One arrow needs to be shot for each balloon for a total of 4 arrows.\n\nExample 3:\n\nInput: points = [[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n\n\nConstraints:\n\n1 <= points.length <= 105\npoints[i].length == 2\n-231 <= xstart < xend <= 231 - 1\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumNumberOfArrowsToBurstBalloons(points) {}",
      "testCalls": [
        "const test1 = MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]); if(test1 !== 2) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]); if(test2 !== 4) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = MinimumNumberOfArrowsToBurstBalloons([[1,2],[2,3],[3,4],[4,5]]); if(test3 !== 2) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function MinimumNumberOfArrowsToBurstBalloons(points: number[][]): number {}",
      "testCalls": [
        "if (MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]) !== 4) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int FindMinArrowShots(vector<vector<int>>& points)",
      "testCalls": [
        "assert(FindMinArrowShots({{10,16},{2,8},{1,6},{7,12}}) == 2);",
        "assert(FindMinArrowShots({{1,2},{3,4},{5,6},{7,8}}) == 4);",
        "assert(FindMinArrowShots({{1,2},{2,3},{3,4},{4,5}}) == 2);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumNumberOfArrowsToBurstBalloons(points: List[List[int]]) -> int:",
      "testCalls": [
        "assert MinimumNumberOfArrowsToBurstBalloons([[10,16],[2,8],[1,6],[7,12]]) == 2",
        "assert MinimumNumberOfArrowsToBurstBalloons([[1,2],[3,4],[5,6],[7,8]]) == 4",
        "assert MinimumNumberOfArrowsToBurstBalloons([[1,2],[2,3],[3,4],[4,5]]) == 2"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "int findMinArrowShots(int[][] points)",
      "testCalls": [
        "int[][] points1 = {{10,16},{2,8},{1,6},{7,12}};\nint expected1 = 2;\nint result1 = findMinArrowShots(points1);\nif(result1 != expected1) throw new AssertionError();",
        "int[][] points2 = {{1,2},{3,4},{5,6},{7,8}};\nint expected2 = 4;\nint result2 = findMinArrowShots(points2);\nif(result2 != expected2) throw new AssertionError();",
        "int[][] points3 = {{1,2},{2,3},{3,4},{4,5}};\nint expected3 = 2;\nint result3 = findMinArrowShots(points3);\nif(result3 != expected3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinimumNumberOfArrowsToBurstBalloons(int** points, int pointsSize, int* pointsColSize)",
      "testCalls": [
        "int** points1 = (int*[]){{10,16},{2,8},{1,6},{7,12}}; int pointsSize1 = 4; int pointsColSize1 = 2; int result1 = MinimumNumberOfArrowsToBurstBalloons(points1, pointsSize1, &pointsColSize1); if(result1 != 2) { printf(\"Test Case 1 Failed\"); }",
        "int** points2 = (int*[]){{1,2},{3,4},{5,6},{7,8}}; int pointsSize2 = 4; int pointsColSize2 = 2; int result2 = MinimumNumberOfArrowsToBurstBalloons(points2, pointsSize2, &pointsColSize2); if(result2 != 4) { printf(\"Test Case 2 Failed\"); }",
        "int** points3 = (int*[]){{1,2},{2,3},{3,4},{4,5}}; int pointsSize3 = 4; int pointsColSize3 = 2; int result3 = MinimumNumberOfArrowsToBurstBalloons(points3, pointsSize3, &pointsColSize3); if(result3 != 2) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumNumberOfArrowsToBurstBalloons(points [][]int) int {}",
      "testCalls": [
        "if MinimumNumberOfArrowsToBurstBalloons([][]int{{10,16},{2,8},{1,6},{7,12}}) != 2 {panic(\"Test case 1 failed\")}",
        "if MinimumNumberOfArrowsToBurstBalloons([][]int{{1,2},{3,4},{5,6},{7,8}}) != 4 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumNumberOfArrowsToBurstBalloons(points: Vec<Vec<i32>>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![10,16],vec![2,8],vec![1,6],vec![7,12]]), 2);",
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![1,2],vec![3,4],vec![5,6],vec![7,8]]), 4);",
        "assert_eq!(MinimumNumberOfArrowsToBurstBalloons(vec![vec![1,2],vec![2,3],vec![3,4],vec![4,5]]), 2);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumNumberOfArrowsToBurstBalloons(points)\nend",
      "testCalls": [
        "points1 = [[10,16],[2,8],[1,6],[7,12]]\nputs(MinimumNumberOfArrowsToBurstBalloons(points1) == 2)",
        "points2 = [[1,2],[3,4],[5,6],[7,8]]\nputs(MinimumNumberOfArrowsToBurstBalloons(points2) == 4)"
      ],
      "compareHelper": ""
    }
  },
  "minimum-path-sum": {
    "title": "Minimum Path Sum",
    "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n\nExample 1:\n\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 200\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumPathSum(grid) {}",
      "testCalls": [
        "if (MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumPathSum([[1,2,3],[4,5,6]]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumPathSum(grid: number[][]): number {}",
      "testCalls": [
        "if (MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) !== 7) { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumPathSum([[1,2,3],[4,5,6]]) !== 12) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MinPathSum(vector<vector<int>>& grid)",
      "testCalls": [
        "assert(MinPathSum({{1,3,1},{1,5,1},{4,2,1}}) == 7);",
        "assert(MinPathSum({{1,2,3},{4,5,6}}) == 12);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumPathSum(grid: List[List[int]]) -> int:",
      "testCalls": [
        "assert MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7",
        "assert MinimumPathSum([[1,2,3],[4,5,6]]) == 12"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minPathSum(int[][] grid)",
      "testCalls": [
        "if (minPathSum(new int[][]{{1,3,1},{1,5,1},{4,2,1}}) != 7) throw new AssertionError();",
        "if (minPathSum(new int[][]{{1,2,3},{4,5,6}}) != 12) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinPathSum(int** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "assert(MinPathSum((int*[]){(int[]){1,3,1}, (int[]){1,5,1}, (int[]){4,2,1}}, 3, (int[]){3, 3}) == 7)",
        "assert(MinPathSum((int*[]){(int[]){1,2,3}, (int[]){4,5,6}}, 2, (int[]){3, 3}) == 12)"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinPathSum(grid [][]int) int {}",
      "testCalls": [
        "if MinPathSum([][]int{{1,3,1},{1,5,1},{4,2,1}}) != 7 { t.Error(\"Test case 1 failed\") }",
        "if MinPathSum([][]int{{1,2,3},{4,5,6}}) != 12 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumPathSum(grid: Vec<Vec<i32>>) -> i32 {}",
      "testCalls": [
        "assert_eq!(MinimumPathSum(vec![vec![1,3,1], vec![1,5,1], vec![4,2,1]]), 7);",
        "assert_eq!(MinimumPathSum(vec![vec![1,2,3], vec![4,5,6]]), 12);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumPathSum(grid)\nend",
      "testCalls": [
        "test1 = MinimumPathSum([[1,3,1],[1,5,1],[4,2,1]])\nraise 'Test Case 1 Failed' unless test1 == 7",
        "test2 = MinimumPathSum([[1,2,3],[4,5,6]])\nraise 'Test Case 2 Failed' unless test2 == 12"
      ],
      "compareHelper": ""
    }
  },
  "minimum-size-subarray-sum": {
    "title": "Minimum Size Subarray Sum",
    "content": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\nExample 1:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n\nExample 2:\n\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n\nExample 3:\n\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n\n\nConstraints:\n\n1 <= target <= 109\n1 <= nums.length <= 105\n1 <= nums[i] <= 104\n\n\nFollow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Sliding Window",
      "Prefix Sum"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumSizeSubarraySum(target, nums) {}",
      "testCalls": [
        "if(MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(MinimumSizeSubarraySum(4, [1,4,4]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinSizeSubarraySum(target: number, nums: number[]): number {}",
      "testCalls": [
        "if (MinSizeSubarraySum(7, [2,3,1,2,4,3]) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (MinSizeSubarraySum(4, [1,4,4]) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if (MinSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) !== 0) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int MinSizeSubarraySum(int target, vector<int>& nums);",
      "testCalls": [
        "assert(MinSizeSubarraySum(7, {2,3,1,2,4,3}) == 2);",
        "assert(MinSizeSubarraySum(4, {1,4,4}) == 1);",
        "assert(MinSizeSubarraySum(11, {1,1,1,1,1,1,1,1}) == 0);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def MinimumSizeSubarraySum(target: int, nums: List[int]) -> int:",
      "testCalls": [
        "assert MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) == 2",
        "assert MinimumSizeSubarraySum(4, [1,4,4]) == 1",
        "assert MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) == 0"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int minSubArrayLen(int target, int[] nums) { }",
      "testCalls": [
        "if (minSubArrayLen(7, new int[]{2,3,1,2,4,3}) != 2) { throw new AssertionError(); }",
        "if (minSubArrayLen(4, new int[]{1,4,4}) != 1) { throw new AssertionError(); }",
        "if (minSubArrayLen(11, new int[]{1,1,1,1,1,1,1,1}) != 0) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int MinSubarraySum(int target, int* nums, int numsSize)",
      "testCalls": [
        "if(MinSubarraySum(7, (int[]){2,3,1,2,4,3}, 6) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(MinSubarraySum(4, (int[]){1,4,4}, 3) != 1) { printf(\"Test Case 2 Failed\"); }",
        "if(MinSubarraySum(11, (int[]){1,1,1,1,1,1,1,1}, 8) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinSubArrayLen(target int, nums []int) int {}",
      "testCalls": [
        "if got := MinSubArrayLen(7, []int{2,3,1,2,4,3}); got != 2 { t.Errorf(\"Expected: %v, Got: %v\", 2, got) }",
        "if got := MinSubArrayLen(4, []int{1,4,4}); got != 1 { t.Errorf(\"Expected: %v, Got: %v\", 1, got) }",
        "if got := MinSubArrayLen(11, []int{1,1,1,1,1,1,1,1}); got != 0 { t.Errorf(\"Expected: %v, Got: %v\", 0, got) }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumSizeSubarraySum(target: i32, nums: Vec<i32>) -> i32 { }",
      "testCalls": [
        "assert_eq!(MinimumSizeSubarraySum(7, vec![2,3,1,2,4,3]), 2);",
        "assert_eq!(MinimumSizeSubarraySum(4, vec![1,4,4]), 1);",
        "assert_eq!(MinimumSizeSubarraySum(11, vec![1,1,1,1,1,1,1,1]), 0);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumSizeSubarraySum(target, nums)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless MinimumSizeSubarraySum(7, [2,3,1,2,4,3]) == 2",
        "raise 'Test Case 2 Failed' unless MinimumSizeSubarraySum(4, [1,4,4]) == 1",
        "raise 'Test Case 3 Failed' unless MinimumSizeSubarraySum(11, [1,1,1,1,1,1,1,1]) == 0"
      ],
      "compareHelper": ""
    }
  },
  "minimum-window-substring": {
    "title": "Minimum Window Substring",
    "content": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &quot;&quot;.\nThe testcases will be generated such that the answer is unique.\n\nExample 1:\n\nInput: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\nOutput: &quot;BANC&quot;\nExplanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n\nExample 2:\n\nInput: s = &quot;a&quot;, t = &quot;a&quot;\nOutput: &quot;a&quot;\nExplanation: The entire string s is the minimum window.\n\nExample 3:\n\nInput: s = &quot;a&quot;, t = &quot;aa&quot;\nOutput: &quot;&quot;\nExplanation: Both &#39;a from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n\n\nConstraints:\n\nm == s.length\nn == t.length\n1 <= m, n <= 105\ns and t consist of uppercase and lowercase English letters.\n\n\nFollow up: Could you find an algorithm that runs in O(m + n) time?\n",
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to create a window of letters in s, which would have all the characters from t.",
      "Expand the right pointer until all the characters of t are covered.",
      "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
      "Continue expanding the right and left pointers until you reach the end of s."
    ],
    "topicTags": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function MinimumWindowSubstring(s, t) {}",
      "testCalls": [
        "if (MinimumWindowSubstring('ADOBECODEBANC', 'ABC') !== 'BANC') { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumWindowSubstring('a', 'a') !== 'a') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function MinimumWindowSubstring(s: string, t: string): string {}",
      "testCalls": [
        "if (MinimumWindowSubstring('ADOBECODEBANC', 'ABC') !== 'BANC') { throw new Error('Test Case 1 Failed'); }",
        "if (MinimumWindowSubstring('a', 'a') !== 'a') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "string MinimumWindowSubstring(string s, string t)",
      "testCalls": [
        "assert(MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\");",
        "assert(MinimumWindowSubstring(\"a\", \"a\") == \"a\"); assert(MinimumWindowSubstring(\"a\", \"aa\") == \"\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def MinimumWindowSubstring(s: str, t: str) -> str:",
      "testCalls": [
        "assert MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"",
        "assert MinimumWindowSubstring(\"a\", \"a\") == \"a\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String MinimumWindowSubstring(String s, String t) { }",
      "testCalls": [
        "assert MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\").equals(\"BANC\");",
        "assert MinimumWindowSubstring(\"a\", \"a\").equals(\"a\");"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* MinimumWindowSubstring(char* s, char* t)",
      "testCalls": [
        "MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\")",
        "MinimumWindowSubstring(\"a\", \"a\")",
        "MinimumWindowSubstring(\"a\", \"aa\")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func MinimumWindowSubstring(s string, t string) string {}",
      "testCalls": [
        "if MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\") != \"BANC\" { panic(\"Test case 1 failed\") }",
        "if MinimumWindowSubstring(\"a\", \"a\") != \"a\" { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn MinimumWindowSubstring(s: String, t: String) -> String {}",
      "testCalls": [
        "assert_eq!(MinimumWindowSubstring(String::from(\"ADOBECODEBANC\"), String::from(\"ABC\")), String::from(\"BANC\"));",
        "assert_eq!(MinimumWindowSubstring(String::from(\"a\"), String::from(\"a\")), String::from(\"a\")); assert_eq!(MinimumWindowSubstring(String::from(\"a\"), String::from(\"aa\")), String::from(\"\"));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def MinimumWindowSubstring(s, t)\nend",
      "testCalls": [
        "assert_equal(\"BANC\", MinimumWindowSubstring(\"ADOBECODEBANC\", \"ABC\"))",
        "assert_equal(\"a\", MinimumWindowSubstring(\"a\", \"a\"))",
        "assert_equal(\"\", MinimumWindowSubstring(\"a\", \"aa\"))"
      ],
      "compareHelper": "def assert_equal(expected, result)\n  raise 'Test Case Failed' unless expected == result\nend"
    }
  },
  "n-queens-ii": {
    "title": "N-Queens II",
    "content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to then-queens puzzle.\n\nExample 1:\n\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n\nConstraints:\n\n1 <= n <= 9\n\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NQueensII(n) {}",
      "testCalls": [
        "if(NQueensII(4) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(NQueensII(1) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function TotalNQueens(n: number): number {}",
      "testCalls": [
        "if (TotalNQueens(4) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if (TotalNQueens(1) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int TotalNQueens(int n);",
      "testCalls": [
        "if(TotalNQueens(4) != 2) throw std::runtime_error(\"Test 1 failed!\");",
        "if(TotalNQueens(1) != 1) throw std::runtime_error(\"Test 2 failed!\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NQueensII(n: int) -> int:",
      "testCalls": [
        "assert NQueensII(4) == 2",
        "assert NQueensII(1) == 1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int TotalNQueens(int n)",
      "testCalls": [
        "if(TotalNQueens(4) != 2) throw new AssertionError();",
        "if(TotalNQueens(1) != 1) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int TotalNQueens(int n);",
      "testCalls": [
        "if (TotalNQueens(4) != 2) { printf(\"Test case 1 failed\"); }",
        "if (TotalNQueens(1) != 1) { printf(\"Test case 2 failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func TotalNQueens(n int) int {}",
      "testCalls": [
        "if TotalNQueens(4) != 2 { t.Error(\"Test case 1 failed\") }",
        "if TotalNQueens(1) != 1 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NQueensII(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(NQueensII(4), 2);",
        "assert_eq!(NQueensII(1), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NQueensII(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless NQueensII(4) == 2",
        "raise 'Test Case 2 Failed' unless NQueensII(1) == 1"
      ],
      "compareHelper": ""
    }
  },
  "number-of-1-bits": {
    "title": "Number of 1 Bits",
    "content": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).\n\nExample 1:\n\nInput: n = 11\nOutput: 3\nExplanation:\nThe input binary string 1011 has a total of three set bits.\n\nExample 2:\n\nInput: n = 128\nOutput: 1\nExplanation:\nThe input binary string 10000000 has a total of one set bit.\n\nExample 3:\n\nInput: n = 2147483645\nOutput: 30\nExplanation:\nThe input binary string 1111111111111111111111111111101 has a total of thirty set bits.\n\n\nConstraints:\n\n1 <= n <= 231 - 1\n\n\nFollow up: If this function is called many times, how would you optimize it?",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NumberOf1Bits(n) {}",
      "testCalls": [
        "if(NumberOf1Bits(11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(NumberOf1Bits(128) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(NumberOf1Bits(2147483645) !== 30) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function NumberOf1Bits(n: number): number {}",
      "testCalls": [
        "if(NumberOf1Bits(11) !== 3) { throw new Error('Test Case 1 Failed'); }",
        "if(NumberOf1Bits(128) !== 1) { throw new Error('Test Case 2 Failed'); }",
        "if(NumberOf1Bits(2147483645) !== 30) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int NumberOf1Bits(int n);",
      "testCalls": [
        "if (NumberOf1Bits(11) != 3) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (NumberOf1Bits(128) != 1) { throw std::runtime_error(\"Test Case 2 Failed\"); }",
        "if (NumberOf1Bits(2147483645) != 30) { throw std::runtime_error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NumberOf1Bits(n: int) -> int",
      "testCalls": [
        "assert NumberOf1Bits(11) == 3",
        "assert NumberOf1Bits(128) == 1",
        "assert NumberOf1Bits(2147483645) == 30"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int NumberOf1Bits(int n) {}",
      "testCalls": [
        "if(NumberOf1Bits(11) != 3) throw new AssertionError();",
        "if(NumberOf1Bits(128) != 1) throw new AssertionError();",
        "if(NumberOf1Bits(2147483645) != 30) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int NumberOf1Bits(int n);",
      "testCalls": [
        "if (NumberOf1Bits(11) != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (NumberOf1Bits(128) != 1) { printf(\"Test Case 2 Failed\"); }",
        "if (NumberOf1Bits(2147483645) != 30) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func NumberOf1Bits(n uint32) int { }",
      "testCalls": [
        "if NumberOf1Bits(11) != 3 { t.Errorf(\"Test case 1 failed\") }",
        "if NumberOf1Bits(128) != 1 { t.Errorf(\"Test case 2 failed\") }",
        "if NumberOf1Bits(2147483645) != 30 { t.Errorf(\"Test case 3 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NumberOf1Bits(n: u32) -> i32 {}",
      "testCalls": [
        "assert_eq!(NumberOf1Bits(11), 3);",
        "assert_eq!(NumberOf1Bits(128), 1);",
        "assert_eq!(NumberOf1Bits(2147483645), 30);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NumberOf1Bits(n)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless NumberOf1Bits(11) == 3",
        "raise 'Test Case 2 Failed' unless NumberOf1Bits(128) == 1",
        "raise 'Test Case 3 Failed' unless NumberOf1Bits(2147483645) == 30"
      ],
      "compareHelper": ""
    }
  },
  "number-of-islands": {
    "title": "Number of Islands",
    "content": "Given an m x n 2D binary grid grid which represents a map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n\nInput: grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\nOutput: 1\n\nExample 2:\n\nInput: grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\nOutput: 3\n\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] is &#39;0&#39; or &#39;1&#39;.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function NumberOfIslands(grid) {}",
      "testCalls": [
        "const test1 = NumberOfIslands([['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]); if(test1 !== 1) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = NumberOfIslands([['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]); if(test2 !== 3) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function NumberOfIslands(grid: string[][]): number {}",
      "testCalls": [
        "if(NumberOfIslands([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]) !== 1) throw new Error('Test Case 1 Failed');",
        "if(NumberOfIslands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]) !== 3) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int NumIslands(vector<vector<char>>& grid)",
      "testCalls": [
        "assert(NumIslands({{'1','1','1','1','0'},{'1','1','0','1','0'},{'1','1','0','0','0'},{'0','0','0','0','0'}}) == 1);",
        "assert(NumIslands({{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}}) == 3);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def NumberOfIslands(grid: List[List[str]]) -> int:",
      "testCalls": [
        "assert NumberOfIslands([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]) == 1",
        "assert NumberOfIslands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]) == 3"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int NumberOfIslands(char[][] grid) {}",
      "testCalls": [
        "int result1 = NumberOfIslands(new char[][]{{'1','1','1','1','0'},{'1','1','0','1','0'},{'1','1','0','0','0'},{'0','0','0','0','0'}}); if(result1 != 1) throw new AssertionError();",
        "int result2 = NumberOfIslands(new char[][]{{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}}); if(result2 != 3) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int NumberOfIslands(char** grid, int gridSize, int* gridColSize)",
      "testCalls": [
        "int result1 = NumberOfIslands(grid1, 4, gridColSize1); if(result1 != 1) { printf(\"Test Case 1 Failed\"); }",
        "int result2 = NumberOfIslands(grid2, 4, gridColSize2); if(result2 != 3) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func NumIslands(grid [][]string) int {}",
      "testCalls": [
        "if NumIslands([][]string{{\"1\",\"1\",\"1\",\"1\",\"0\"},{\"1\",\"1\",\"0\",\"1\",\"0\"},{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"0\",\"0\",\"0\",\"0\",\"0\"}}) != 1 { t.Error(\"Test case 1 failed\") }",
        "if NumIslands([][]string{{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"1\",\"1\",\"0\",\"0\",\"0\"},{\"0\",\"0\",\"1\",\"0\",\"0\"},{\"0\",\"0\",\"0\",\"1\",\"1\"}}) != 3 { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn NumberOfIslands(grid: Vec<Vec<char>>) -> i32 { }",
      "testCalls": [
        "let result1 = NumberOfIslands(vec![vec!['1', '1', '1', '1', '0'], vec!['1', '1', '0', '1', '0'], vec!['1', '1', '0', '0', '0'], vec!['0', '0', '0', '0', '0']]);\nassert_eq!(result1, 1);",
        "let result2 = NumberOfIslands(vec![vec!['1', '1', '0', '0', '0'], vec!['1', '1', '0', '0', '0'], vec!['0', '0', '1', '0', '0'], vec!['0', '0', '0', '1', '1']]);\nassert_eq!(result2, 3);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def NumberOfIslands(grid)\nend",
      "testCalls": [
        "grid1 = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]\nputs NumberOfIslands(grid1) == 1 || raise('Test Case 1 Failed')",
        "grid2 = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]\nputs NumberOfIslands(grid2) == 3 || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    }
  },
  "palindrome-number": {
    "title": "Palindrome Number",
    "content": "Given an integer x, return true if x is a palindrome, and false otherwise.\n\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\nConstraints:\n\n-231<= x <= 231- 1\n\n\nFollow up: Could you solve it without converting the integer to a string?",
    "difficulty": "Easy",
    "hints": [
      "Beware of overflow when you reverse the integer."
    ],
    "topicTags": [
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PalindromeNumber(x) {}",
      "testCalls": [
        "if (PalindromeNumber(121) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PalindromeNumber(-121) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function IsPalindrome(x: number): boolean {}",
      "testCalls": [
        "if (IsPalindrome(121) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (IsPalindrome(-121) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool PalindromeNumber(int x);",
      "testCalls": [
        "if (PalindromeNumber(121) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (PalindromeNumber(-121) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def PalindromeNumber(x: int) -> bool:",
      "testCalls": [
        "assert PalindromeNumber(121) == True, 'Test Case 1 Failed'",
        "assert PalindromeNumber(-121) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean PalindromeNumber(int x) {}",
      "testCalls": [
        "if (!PalindromeNumber(121)) throw new AssertionError();",
        "if (PalindromeNumber(-121)) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool IsPalindrome(int x)",
      "testCalls": [
        "if(IsPalindrome(121) != true) { printf(\"Test Case 1 Failed\"); }",
        "if(IsPalindrome(-121) != false) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsPalindrome(x int) bool {}",
      "testCalls": [
        "if IsPalindrome(121) != true { t.Error(\"Test case 1 failed\") }",
        "if IsPalindrome(-121) != false { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn PalindromeNumber(x: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(PalindromeNumber(121), true);",
        "assert_eq!(PalindromeNumber(-121), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def PalindromeNumber(x)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless PalindromeNumber(121) == true",
        "raise 'Test Case 2 Failed' unless PalindromeNumber(-121) == false"
      ],
      "compareHelper": ""
    }
  },
  "partition-list": {
    "title": "Partition List",
    "content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\nExample 1:\n\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\nExample 2:\n\nInput: head = [2,1], x = 2\nOutput: [1,2]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 200].\n-100 <= Node.val <= 100\n-200 <= x <= 200\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PartitionList(head, x) {}",
      "testCalls": [
        "const test1 = PartitionList([1,4,3,2,5,2], 3); if(JSON.stringify(test1) !== JSON.stringify([1,2,2,4,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = PartitionList([2,1], 2); if(JSON.stringify(test2) !== JSON.stringify([1,2])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function PartitionList(head: ListNode | null, x: number): ListNode | null {}",
      "testCalls": [
        "if(JSON.stringify(PartitionList(arrayToLinkedList([1,4,3,2,5,2]), 3)) !== JSON.stringify(arrayToLinkedList([1,2,2,4,3,5]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(PartitionList(arrayToLinkedList([2,1]), 2)) !== JSON.stringify(arrayToLinkedList([1,2]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToLinkedList(arr: number[]): ListNode | null { if(arr.length === 0) return null; const head = new ListNode(arr[0]); let current = head; for(let i = 1; i < arr.length; i++) { current.next = new ListNode(arr[i]); current = current.next; } return head; }"
    },
    "c++": {
      "functionDeclaration": "void PartitionList(ListNode* head, int x);",
      "testCalls": [
        "PartitionList(createLinkedList({1,4,3,2,5,2}), 3); // Expected: [1,2,2,4,3,5]",
        "PartitionList(createLinkedList({2,1}), 2); // Expected: [1,2]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def PartitionList(head, x):",
      "testCalls": [
        "assert PartitionList([1,4,3,2,5,2], 3) == [1,2,2,4,3,5], 'Test Case 1 Failed'",
        "assert PartitionList([2,1], 2) == [1,2], 'Test Case 2 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public ListNode partition(ListNode head, int x) {}",
      "testCalls": [
        "ListNode head1 = createLinkedList(new int[]{1,4,3,2,5,2}); ListNode expected1 = createLinkedList(new int[]{1,2,2,4,3,5}); partition(head1, 3); compareLinkedLists(head1, expected1);",
        "ListNode head2 = createLinkedList(new int[]{2,1}); ListNode expected2 = createLinkedList(new int[]{1,2}); partition(head2, 2); compareLinkedLists(head2, expected2);"
      ],
      "compareHelper": "private void compareLinkedLists(ListNode head1, ListNode head2) {\n    while (head1 != null && head2 != null) {\n        if (head1.val != head2.val) {\n            throw new AssertionError(\"LinkedLists are not equal\");\n        }\n        head1 = head1.next;\n        head2 = head2.next;\n    }\n    if (head1 != null || head2 != null) {\n        throw new AssertionError(\"LinkedLists are not equal\");\n    }\n}"
    },
    "c": {
      "functionDeclaration": "void PartitionList(struct ListNode* head, int x);",
      "testCalls": [
        "PartitionList(createLinkedList((int[]){1,4,3,2,5,2}, 6), 3); // Expected: [1,2,2,4,3,5]",
        "PartitionList(createLinkedList((int[]){2,1}, 2), 2); // Expected: [1,2]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func PartitionList(head *ListNode, x int) *ListNode {}",
      "testCalls": [
        "if result := PartitionList(sliceToList([]int{1,4,3,2,5,2}), 3); !compareLinkedLists(result, sliceToList([]int{1,2,2,4,3,5})) { t.Errorf(\"Test case 1 failed\") }",
        "if result := PartitionList(sliceToList([]int{2,1}), 2); !compareLinkedLists(result, sliceToList([]int{1,2})) { t.Errorf(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareLinkedLists(l1, l2 *ListNode) bool {\n    for l1 != nil && l2 != nil {\n        if l1.Val != l2.Val {\n            return false\n        }\n        l1 = l1.Next\n        l2 = l2.Next\n    }\n    return l1 == nil && l2 == nil\n}"
    },
    "rust": {
      "functionDeclaration": "fn PartitionList(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(PartitionList(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 5, next: Some(Box::new(ListNode { val: 2, next: None })) })) })) })) })) })), 3), Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })) })) }))",
        "assert_eq!(PartitionList(Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 1, next: None })) })), 2), Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: None })) }))"
      ],
      "compareHelper": "fn compare_linked_lists(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) { }"
    },
    "ruby": {
      "functionDeclaration": "def PartitionList(head, x)\nend",
      "testCalls": [
        "result1 = PartitionList([1,4,3,2,5,2], 3)\nraise 'Test Case 1 Failed' unless result1 == [1,2,2,4,3,5]",
        "result2 = PartitionList([2,1], 2)\nraise 'Test Case 2 Failed' unless result2 == [1,2]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "path-sum": {
    "title": "Path Sum",
    "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\n\nExample 1:\n\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is shown.\n\nExample 2:\n\n\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There are two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\nExample 3:\n\nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since the tree is empty, there are no root-to-leaf paths.\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PathSum(root, targetSum) {}",
      "testCalls": [
        "if (PathSum([5,4,8,11,null,13,4,7,2,null,null,null,1], 22) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PathSum([1,2,3], 5) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function PathSum(root: TreeNode | null, targetSum: number): boolean {}",
      "testCalls": [
        "if (PathSum(TreeNode.fromArray([5,4,8,11,null,13,4,7,2,null,null,null,1]), 22) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (PathSum(TreeNode.fromArray([1,2,3]), 5) !== false) { throw new Error('Test Case 2 Failed'); }",
        "if (PathSum(null, 0) !== false) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "bool HasPathSum(TreeNode* root, int targetSum);",
      "testCalls": [
        "if (HasPathSum(createTree({5,4,8,11,null,13,4,7,2,null,null,null,1}), 22) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if (HasPathSum(createTree({1,2,3}), 5) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "std::vector<int> createTree(const std::vector<int>& values) {\n    // Implementation to create a binary tree from values\n}"
    },
    "python": {
      "functionDeclaration": "def PathSum(root, targetSum):",
      "testCalls": [
        "assert PathSum([5,4,8,11,None,13,4,7,2,None,None,None,1], 22) == True",
        "assert PathSum([1,2,3], 5) == False",
        "assert PathSum([], 0) == False"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean PathSum(TreeNode root, int targetSum)",
      "testCalls": [
        "if (PathSum(TreeNode.buildTree(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1}), 22) != true) throw new AssertionError();",
        "if (PathSum(TreeNode.buildTree(new Integer[]{1,2,3}), 5) != false) throw new AssertionError();",
        "if (PathSum(null, 0) != false) throw new AssertionError();"
      ],
      "compareHelper": "private static boolean compareArrays(int[] arr1, int[] arr2) {\n        return Arrays.equals(arr1, arr2);\n    }"
    },
    "c": {
      "functionDeclaration": "bool HasPathSum(struct TreeNode* root, int targetSum)",
      "testCalls": [
        "assert(HasPathSum(createTreeFromArray((int[]) {5,4,8,11,NULL,13,4,7,2,NULL,NULL,NULL,1}, 13), 22) == true);",
        "assert(HasPathSum(createTreeFromArray((int[]) {1,2,3}, 3), 5) == false);",
        "assert(HasPathSum(NULL, 0) == false);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func PathSum(root *TreeNode, targetSum int) bool {}",
      "testCalls": [
        "if PathSum(buildTree([]int{5,4,8,11,-1,13,4,7,2,-1,-1,-1,-1,1}, 0), 22) != true { t.Error(\"Test Case 1 Failed\") }",
        "if PathSum(buildTree([]int{1,2,3}, 0), 5) != false { t.Error(\"Test Case 2 Failed\") }",
        "if PathSum(nil, 0) != false { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func buildTree(arr []int, idx int) *TreeNode {\n    if idx >= len(arr) || arr[idx] == -1 {\n        return nil\n    }\n    root := &TreeNode{Val: arr[idx]}\n    root.Left = buildTree(arr, 2*idx+1)\n    root.Right = buildTree(arr, 2*idx+2)\n    return root\n}"
    },
    "rust": {
      "functionDeclaration": "fn PathSum(root: Option<Box<TreeNode>>, target_sum: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(PathSum(Some(Box::new(TreeNode { val: 5, left: Some(Box::new(TreeNode { val: 4, left: Some(Box::new(TreeNode { val: 11, left: Some(Box::new(TreeNode { val: 7, left: None, right: None })), right: Some(Box::new(TreeNode { val: 2, left: None, right: None })) })), right: None })), right: Some(Box::new(TreeNode { val: 8, left: Some(Box::new(TreeNode { val: 13, left: None, right: None })), right: Some(Box::new(TreeNode { val: 4, left: None, right: Some(Box::new(TreeNode { val: 1, left: None, right: None })) })) })), 22), true);",
        "assert_eq!(PathSum(Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: None, right: None })), right: Some(Box::new(TreeNode { val: 3, left: None, right: None })) }), 5), false);",
        "assert_eq!(PathSum(None, 0), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def PathSum(root, targetSum)\nend",
      "testCalls": [
        "assert_equal(true, PathSum([5,4,8,11,nil,13,4,7,2,nil,nil,nil,1], 22))",
        "assert_equal(false, PathSum([1,2,3], 5))",
        "assert_equal(false, PathSum([], 0)"
      ],
      "compareHelper": "def assert_equal(expected, actual)\n  raise 'Test Case Failed' unless expected == actual\nend"
    }
  },
  "permutations": {
    "title": "Permutations",
    "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n\n\nConstraints:\n\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Backtracking"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function Permutations(nums) {}",
      "testCalls": [
        "const test1 = Permutations([1,2,3]); if(JSON.stringify(test1) !== '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Permutations([0,1]); if(JSON.stringify(test2) !== '[[0,1],[1,0]]') throw new Error('Test Case 2 Failed');",
        "const test3 = Permutations([1]); if(JSON.stringify(test3) !== '[[1]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function Permutations(nums: number[]): number[][] { }",
      "testCalls": [
        "const test1 = Permutations([1,2,3]); if(JSON.stringify(test1) !== '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]') throw new Error('Test Case 1 Failed');",
        "const test2 = Permutations([0,1]); if(JSON.stringify(test2) !== '[[0,1],[1,0]]') throw new Error('Test Case 2 Failed');",
        "const test3 = Permutations([1]); if(JSON.stringify(test3) !== '[[1]]') throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<vector<int>> Permutations(vector<int>& nums);",
      "testCalls": [
        "auto result1 = Permutations({1,2,3});\nif (result1 != vector<vector<int>>{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = Permutations({0,1});\nif (result2 != vector<vector<int>>{{0,1},{1,0}}) throw std::runtime_error(\"Test Case 2 Failed\");",
        "auto result3 = Permutations({1});\nif (result3 != vector<vector<int>>{{1}}) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool CompareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def Permutations(nums: List[int]) -> List[List[int]]:",
      "testCalls": [
        "assert Permutations([1,2,3]) == [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "assert Permutations([0,1]) == [[0,1],[1,0]]",
        "assert Permutations([1]) == [[1]]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return sorted(arr1) == sorted(arr2)"
    },
    "java": {
      "functionDeclaration": "public List<List<Integer>> Permutations(int[] nums) {}",
      "testCalls": [
        "List<List<Integer>> result1 = Permutations(new int[]{1,2,3});\nif (!compareArrays(result1, new int[][]{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}})) throw new AssertionError();",
        "List<List<Integer>> result2 = Permutations(new int[]{0,1});\nif (!compareArrays(result2, new int[][]{{0,1},{1,0}})) throw new AssertionError();",
        "List<List<Integer>> result3 = Permutations(new int[]{1});\nif (!compareArrays(result3, new int[][]{{1}})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareArrays(List<List<Integer>> arr1, int[][] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n        List<Integer> list1 = arr1.get(i);\n        int[] list2 = arr2[i];\n        if (list1.size() != list2.length) return false;\n        for (int j = 0; j < list1.size(); j++) {\n            if (list1.get(j) != list2[j]) return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int** Permutations(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)",
      "testCalls": [
        "int* nums1 = (int[]){1, 2, 3}; int returnSize1; int* returnColumnSizes1; int** result1 = Permutations(nums1, 3, &returnSize1, &returnColumnSizes1); if (compareArrays(result1, returnSize1, returnColumnSizes1, 6, \"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\") == 0) { printf(\"Test case 1 failed\"); }",
        "int* nums2 = (int[]){0, 1}; int returnSize2; int* returnColumnSizes2; int** result2 = Permutations(nums2, 2, &returnSize2, &returnColumnSizes2); if (compareArrays(result2, returnSize2, returnColumnSizes2, 2, \"[[0,1],[1,0]]\") == 0) { printf(\"Test case 2 failed\"); }",
        "int* nums3 = (int[]){1}; int returnSize3; int* returnColumnSizes3; int** result3 = Permutations(nums3, 1, &returnSize3, &returnColumnSizes3); if (compareArrays(result3, returnSize3, returnColumnSizes3, 1, \"[[1]]\") == 0) { printf(\"Test case 3 failed\"); }"
      ],
      "compareHelper": "int compareArrays(int** result, int returnSize, int* returnColumnSizes, int expectedSize, char* expected) { /* Compare logic here, return 0 if arrays are not equal */ }"
    },
    "go": {
      "functionDeclaration": "func Permutations(nums []int) [][]int {}",
      "testCalls": [
        "if !compareArrays(Permutations([]int{1,2,3}), [][]int{{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(Permutations([]int{0,1}), [][]int{{0,1},{1,0}}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(Permutations([]int{1}), [][]int{{1}}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if !reflect.DeepEqual(arr1[i], arr2[i]) { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn Permutations(nums: Vec<i32>) -> Vec<Vec<i32>> {}",
      "testCalls": [
        "assert_eq!(Permutations(vec![1,2,3]), vec![vec![1,2,3],vec![1,3,2],vec![2,1,3],vec![2,3,1],vec![3,1,2],vec![3,2,1]]);",
        "assert_eq!(Permutations(vec![0,1]), vec![vec![0,1],vec![1,0]]); assert_eq!(Permutations(vec![1]), vec![vec![1]]);"
      ],
      "compareHelper": "fn compare_arrays(arr1: Vec<Vec<i32>>, arr2: Vec<Vec<i32>>) { for (a, b) in arr1.iter().zip(arr2.iter()) { assert_eq!(a, b); }}"
    },
    "ruby": {
      "functionDeclaration": "def Permutations(nums)\nend",
      "testCalls": [
        "test_input = [1,2,3]\nexpected_output = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nresult = Permutations(test_input)\nraise 'Test Case 1 Failed' unless result == expected_output",
        "test_input = [0,1]\nexpected_output = [[0,1],[1,0]]\nresult = Permutations(test_input)\nraise 'Test Case 2 Failed' unless result == expected_output",
        "test_input = [1]\nexpected_output = [[1]]\nresult = Permutations(test_input)\nraise 'Test Case 3 Failed' unless result == expected_output"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "plus-one": {
    "title": "Plus One",
    "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0.\nIncrement the large integer by one and return the resulting array of digits.\n\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n\nConstraints:\n\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0.\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PlusOne(digits) {}",
      "testCalls": [
        "const test1 = PlusOne([1,2,3]); if(JSON.stringify(test1) !== JSON.stringify([1,2,4])) throw new Error('Test Case 1 Failed');",
        "const test2 = PlusOne([4,3,2,1]); if(JSON.stringify(test2) !== JSON.stringify([4,3,2,2])) throw new Error('Test Case 2 Failed');",
        "const test3 = PlusOne([9]); if(JSON.stringify(test3) !== JSON.stringify([1,0])) throw new Error('Test Case 3 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function PlusOne(digits: number[]): number[]",
      "testCalls": [
        "const test1 = PlusOne([1,2,3]); if (JSON.stringify(test1) !== JSON.stringify([1,2,4])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = PlusOne([4,3,2,1]); if (JSON.stringify(test2) !== JSON.stringify([4,3,2,2])) { throw new Error('Test Case 2 Failed'); }",
        "const test3 = PlusOne([9]); if (JSON.stringify(test3) !== JSON.stringify([1,0])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<int> PlusOne(vector<int>& digits);",
      "testCalls": [
        "auto result1 = PlusOne({1,2,3});\nif (result1 != vector<int>({1,2,4})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = PlusOne({4,3,2,1});\nif (result2 != vector<int>({4,3,2,2})) throw std::runtime_error(\"Test Case 2 Failed\");",
        "auto result3 = PlusOne({9});\nif (result3 != vector<int>({1,0})) throw std::runtime_error(\"Test Case 3 Failed\");"
      ],
      "compareHelper": "bool compareArrays(const vector<int>& arr1, const vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def PlusOne(digits: List[int]) -> List[int]:",
      "testCalls": [
        "result1 = PlusOne([1,2,3]); assert result1 == [1,2,4], 'Test Case 1 Failed'",
        "result2 = PlusOne([4,3,2,1]); assert result2 == [4,3,2,2], 'Test Case 2 Failed'",
        "result3 = PlusOne([9]); assert result3 == [1,0], 'Test Case 3 Failed'"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2) or any(arr1[i] != arr2[i] for i in range(len(arr1))):\n        return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int[] PlusOne(int[] digits) {}",
      "testCalls": [
        "assert Arrays.equals(PlusOne(new int[]{1,2,3}), new int[]{1,2,4}) : \"Test Case 1 Failed\";",
        "assert Arrays.equals(PlusOne(new int[]{4,3,2,1}), new int[]{4,3,2,2}) : \"Test Case 2 Failed\";"
      ],
      "compareHelper": "Arrays.equals method for comparing arrays"
    },
    "c": {
      "functionDeclaration": "int* PlusOne(int* digits, int digitsSize)",
      "testCalls": [
        "int digits1[] = {1, 2, 3}; int* result1 = PlusOne(digits1, 3); if (compareArrays(result1, (int[]){1, 2, 4}, 3) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int digits2[] = {4, 3, 2, 1}; int* result2 = PlusOne(digits2, 4); if (compareArrays(result2, (int[]){4, 3, 2, 2}, 4) != 0) { printf(\"Test Case 2 Failed\"); }",
        "int digits3[] = {9}; int* result3 = PlusOne(digits3, 1); if (compareArrays(result3, (int[]){1, 0}, 2) != 0) { printf(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return -1; } return 0; }"
    },
    "go": {
      "functionDeclaration": "func PlusOne(digits []int) []int",
      "testCalls": [
        "if !compareArrays(PlusOne([]int{1,2,3}), []int{1,2,4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(PlusOne([]int{4,3,2,1}), []int{4,3,2,2}) { t.Error(\"Test Case 2 Failed\") }",
        "if !compareArrays(PlusOne([]int{9}), []int{1,0}) { t.Error(\"Test Case 3 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn PlusOne(digits: Vec<i32>) -> Vec<i32> {}",
      "testCalls": [
        "assert_eq!(PlusOne(vec![1,2,3]), vec![1,2,4]);",
        "assert_eq!(PlusOne(vec![4,3,2,1]), vec![4,3,2,2]);",
        "assert_eq!(PlusOne(vec![9]), vec![1,0]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def PlusOne(digits)\n  \nend",
      "testCalls": [
        "result = PlusOne([1,2,3])\nraise 'Test Case 1 Failed' unless result == [1,2,4]",
        "result = PlusOne([4,3,2,1])\nraise 'Test Case 2 Failed' unless result == [4,3,2,2]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "populating-next-right-pointers-in-each-node-ii": {
    "title": "Populating Next Right Pointers in Each Node II",
    "content": "Given a binary tree\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n\nExample 1:\n\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n\nExample 2:\n\nInput: root = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 6000].\n-100 <= Node.val <= 100\n\n\nFollow-up:\n\nYou may only use constant extra space.\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function PopulatingNextRightPointersInEachNodeII(root) {}",
      "testCalls": [
        "PopulatingNextRightPointersInEachNodeII([1,2,3,4,5,null,7]); // expected: [1,#,2,3,#,4,5,7,#]",
        "PopulatingNextRightPointersInEachNodeII([]); // expected: []"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function ConnectNextRight(root: Node | null): Node | null {}",
      "testCalls": [
        "if(JSON.stringify(ConnectNextRight(parseTree([1,2,3,4,5,null,7]))) !== JSON.stringify(parseTree([1,null,2,3,null,4,5,7,null]))) throw new Error('Test Case 1 Failed');",
        "if(JSON.stringify(ConnectNextRight(parseTree([]))) !== JSON.stringify(parseTree([]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function parseTree(arr: (number | null)[]): Node | null { if(arr.length === 0) return null; const root = { val: arr[0], left: null, right: null, next: null }; const queue = [root]; let i = 1; while(i < arr.length) { const current = queue.shift(); if(arr[i] !== null) { current.left = { val: arr[i], left: null, right: null, next: null }; queue.push(current.left); } i++; if(i < arr.length && arr[i] !== null) { current.right = { val: arr[i], left: null, right: null, next: null }; queue.push(current.right); } i++; } return root; }"
    },
    "c++": {
      "functionDeclaration": "void PopulatingNextRightPointersInEachNodeII(Node* root)",
      "testCalls": [
        "PopulatingNextRightPointersInEachNodeII(root); // Test Case 1",
        "PopulatingNextRightPointersInEachNodeII(nullptr); // Test Case 2"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i = 0; i < arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def PopulatingNextRightPointersInEachNodeII(root: 'Node') -> 'Node':",
      "testCalls": [
        "assert PopulatingNextRightPointersInEachNodeII([1,2,3,4,5,null,7]) == [1,null,2,3,null,4,5,7,null]",
        "assert PopulatingNextRightPointersInEachNodeII([]) == []"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        raise AssertionError('Arrays have different lengths')\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            raise AssertionError(f'Arrays differ at index {i}')"
    },
    "java": {
      "functionDeclaration": "void connect(Node root)",
      "testCalls": [
        "Node root1 = buildTree(new Integer[]{1,2,3,4,5,null,7});\nconnect(root1);\nif (!compareTree(root1, new Integer[]{1,null,2,3,null,4,5,7,null})) throw new AssertionError();",
        "Node root2 = buildTree(new Integer[]{});\nconnect(root2);\nif (!compareTree(root2, new Integer[]{})) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTree(Node node, Integer[] expected) {\n    // Comparison logic here\n}"
    },
    "c": {
      "functionDeclaration": "void PopulatingNextRightPointersInEachNodeII(struct Node* root)",
      "testCalls": [
        "PopulatingNextRightPointersInEachNodeII(root); // Expected: [1,#,2,3,#,4,5,7,#]",
        "PopulatingNextRightPointersInEachNodeII(root); // Expected: []"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func Connect(root *Node) *Node",
      "testCalls": [
        "if Connect(&Node{Val: 1, Left: &Node{Val: 2, Left: &Node{Val: 4}, Right: &Node{Val: 5, Right: &Node{Val: 7}}, Right: &Node{Val: 3}}).String() != \"[1,#,2,3,#,4,5,7,#]\" { t.Error(\"Test case 1 failed\") }",
        "if Connect(nil) != nil { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func (n *Node) String() string { if n == nil { return \"[]\" } return fmt.Sprintf(\"[%d,%s,%s]\", n.Val, n.Left.String(), n.Right.String()) }"
    },
    "rust": {
      "functionDeclaration": "fn PopulatingNextRightPointersInEachNodeII(root: Option<Box<Node>>) -> Option<Box<Node>> { }",
      "testCalls": [
        "assert_eq!(PopulatingNextRightPointersInEachNodeII(Some(Box::new(Node { val: 1, left: Some(Box::new(Node { val: 2, left: Some(Box::new(Node { val: 4, left: None, right: None, next: None })), right: Some(Box::new(Node { val: 5, left: None, right: None, next: None })), next: None })), right: Some(Box::new(Node { val: 3, left: None, right: Some(Box::new(Node { val: 7, left: None, right: None, next: None })), next: None })), next: None))), Some(Box::new(Node { val: 1, left: None, right: Some(Box::new(Node { val: 2, left: None, right: Some(Box::new(Node { val: 3, left: None, right: Some(Box::new(Node { val: 4, left: None, right: Some(Box::new(Node { val: 5, left: None, right: Some(Box::new(Node { val: 7, left: None, right: None, next: None })), next: None })), next: None })), next: None })), next: None })), next: None))",
        "assert_eq!(PopulatingNextRightPointersInEachNodeII(None), None)"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def PopulatingNextRightPointersInEachNodeII(root)\nend",
      "testCalls": [
        "test_case_1 = PopulatingNextRightPointersInEachNodeII([1,2,3,4,5,nil,7])\nraise 'Test Case 1 Failed' unless test_case_1 == [1,nil,2,3,nil,4,5,7,nil]",
        "test_case_2 = PopulatingNextRightPointersInEachNodeII([])\nraise 'Test Case 2 Failed' unless test_case_2 == []"
      ],
      "compareHelper": "def array_compare(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "product-of-array-except-self": {
    "title": "Product of Array Except Self",
    "content": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs inO(n)time and without using the division operation.\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\n\nConstraints:\n\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.\n\n\nFollow up:Can you solve the problem in O(1)extraspace complexity? (The output array does not count as extra space for space complexity analysis.)\n",
    "difficulty": "Medium",
    "hints": [
      "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
      "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
    ],
    "topicTags": [
      "Array",
      "Prefix Sum"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ProductOfArrayExceptSelf(nums) {}",
      "testCalls": [
        "const test1 = ProductOfArrayExceptSelf([1,2,3,4]); if(JSON.stringify(test1) !== JSON.stringify([24,12,8,6])) throw new Error('Test Case 1 Failed');",
        "const test2 = ProductOfArrayExceptSelf([-1,1,0,-3,3]); if(JSON.stringify(test2) !== JSON.stringify([0,0,9,0,0])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function ProductOfArrayExceptSelf(nums: number[]): number[]",
      "testCalls": [
        "const test1 = ProductOfArrayExceptSelf([1,2,3,4]); if (JSON.stringify(test1) !== JSON.stringify([24,12,8,6])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ProductOfArrayExceptSelf([-1,1,0,-3,3]); if (JSON.stringify(test2) !== JSON.stringify([0,0,9,0,0])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "vector<int> ProductOfArrayExceptSelf(vector<int>& nums)",
      "testCalls": [
        "auto result1 = ProductOfArrayExceptSelf({1,2,3,4});\nif(result1 != vector<int>({24,12,8,6})) throw std::runtime_error(\"Test Case 1 Failed\");",
        "auto result2 = ProductOfArrayExceptSelf({-1,1,0,-3,3});\nif(result2 != vector<int>({0,0,9,0,0})) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def ProductOfArrayExceptSelf(nums: List[int]) -> List[int]",
      "testCalls": [
        "assert ProductOfArrayExceptSelf([1,2,3,4]) == [24,12,8,6]",
        "assert ProductOfArrayExceptSelf([-1,1,0,-3,3]) == [0,0,9,0,0]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True"
    },
    "java": {
      "functionDeclaration": "public int[] ProductOfArrayExceptSelf(int[] nums) {}",
      "testCalls": [
        "assert Arrays.equals(ProductOfArrayExceptSelf(new int[]{1,2,3,4}), new int[]{24,12,8,6});",
        "assert Arrays.equals(ProductOfArrayExceptSelf(new int[]{-1,1,0,-3,3}), new int[]{0,0,9,0,0});"
      ],
      "compareHelper": "private boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "int* ProductOfArrayExceptSelf(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1,2,3,4}; int expected1[] = {24,12,8,6}; int* result1 = ProductOfArrayExceptSelf(nums1, 4); if(memcmp(result1, expected1, 4*sizeof(int)) != 0) { printf(\"Test Case 1 Failed\"); }",
        "int nums2[] = {-1,1,0,-3,3}; int expected2[] = {0,0,9,0,0}; int* result2 = ProductOfArrayExceptSelf(nums2, 5); if(memcmp(result2, expected2, 5*sizeof(int)) != 0) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func ProductOfArrayExceptSelf(nums []int) []int {}",
      "testCalls": [
        "if !compareArrays(ProductOfArrayExceptSelf([]int{1,2,3,4}), []int{24,12,8,6}) { t.Error(\"Test case 1 failed\") }",
        "if !compareArrays(ProductOfArrayExceptSelf([]int{-1,1,0,-3,3}), []int{0,0,9,0,0}) { t.Error(\"Test case 2 failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn ProductOfArrayExceptSelf(nums: Vec<i32>) -> Vec<i32> {}",
      "testCalls": [
        "let result1 = ProductOfArrayExceptSelf(vec![1,2,3,4]); assert_eq!(result1, vec![24,12,8,6]);",
        "let result2 = ProductOfArrayExceptSelf(vec![-1,1,0,-3,3]); assert_eq!(result2, vec![0,0,9,0,0]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) { assert_eq!(a, b); }"
    },
    "ruby": {
      "functionDeclaration": "def ProductOfArrayExceptSelf(nums)\nend",
      "testCalls": [
        "nums = [1,2,3,4]\nexpected_result = [24,12,8,6]\nresult = ProductOfArrayExceptSelf(nums)\nraise 'Test Case 1 Failed' unless result == expected_result",
        "nums = [-1,1,0,-3,3]\nexpected_result = [0,0,9,0,0]\nresult = ProductOfArrayExceptSelf(nums)\nraise 'Test Case 2 Failed' unless result == expected_result"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "remove-duplicates-from-sorted-array-ii": {
    "title": "Remove Duplicates from Sorted Array II",
    "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of numsshould hold the final result. It does not matter what you leave beyond the firstkelements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArrayII(nums) {}",
      "testCalls": [
        "let nums1 = [1,1,1,2,2,3]; let expectedResult1 = [1,1,2,2,3]; let expectedLength1 = 5; let result1 = RemoveDuplicatesFromSortedArrayII(nums1); if (result1 !== expectedLength1 || !arraysEqual(nums1.slice(0, expectedLength1), expectedResult1)) { throw new Error('Test Case 1 Failed'); }",
        "let nums2 = [0,0,1,1,1,1,2,3,3]; let expectedResult2 = [0,0,1,1,2,3,3]; let expectedLength2 = 7; let result2 = RemoveDuplicatesFromSortedArrayII(nums2); if (result2 !== expectedLength2 || !arraysEqual(nums2.slice(0, expectedLength2), expectedResult2)) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0; i < arr1.length; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArrayII(nums: number[]): number {}",
      "testCalls": [
        "const test1Nums = [1,1,1,2,2,3];\nconst expectedNums1 = [1,1,2,2,3,null];\nconst k1 = RemoveDuplicatesFromSortedArrayII(test1Nums);\nif (k1 !== expectedNums1.length || !arraysEqual(test1Nums.slice(0, k1), expectedNums1.slice(0, k1))) {\n  throw new Error('Test Case 1 Failed');\n}",
        "const test2Nums = [0,0,1,1,1,1,2,3,3];\nconst expectedNums2 = [0,0,1,1,2,3,3,null,null];\nconst k2 = RemoveDuplicatesFromSortedArrayII(test2Nums);\nif (k2 !== expectedNums2.length || !arraysEqual(test2Nums.slice(0, k2), expectedNums2.slice(0, k2))) {\n  throw new Error('Test Case 2 Failed');\n}"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}"
    },
    "c++": {
      "functionDeclaration": "int RemoveDuplicatesFromSortedArrayII(vector<int>& nums)",
      "testCalls": [
        "vector<int> nums1 = {1, 1, 1, 2, 2, 3}; int k1 = RemoveDuplicatesFromSortedArrayII(nums1); vector<int> expectedNums1 = {1, 1, 2, 2, 3}; assert(k1 == expectedNums1.size()); for(int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "vector<int> nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3}; int k2 = RemoveDuplicatesFromSortedArrayII(nums2); vector<int> expectedNums2 = {0, 0, 1, 1, 2, 3, 3}; assert(k2 == expectedNums2.size()); for(int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "empty string"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArrayII(nums: List[int]) -> int:",
      "testCalls": [
        "nums1 = [1,1,1,2,2,3]\nexpectedNums1 = [1,1,2,2,3]\nexpectedResult1 = 5\nk1 = RemoveDuplicatesFromSortedArrayII(nums1)\nassert k1 == expectedResult1\nassert nums1[:k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,1,2,3,3]\nexpectedNums2 = [0,0,1,1,2,3,3]\nexpectedResult2 = 7\nk2 = RemoveDuplicatesFromSortedArrayII(nums2)\nassert k2 == expectedResult2\nassert nums2[:k2] == expectedNums2"
      ],
      "compareHelper": "def assertArraysEqual(arr1, arr2):\n    assert len(arr1) == len(arr2)\n    for i in range(len(arr1)):\n        assert arr1[i] == arr2[i]"
    },
    "java": {
      "functionDeclaration": "public int RemoveDuplicatesFromSortedArrayII(int[] nums)",
      "testCalls": [
        "int[] nums1 = {1, 1, 1, 2, 2, 3};\nint expectedLength1 = 5;\nint[] expectedNums1 = {1, 1, 2, 2, 3};\nint k1 = RemoveDuplicatesFromSortedArrayII(nums1);\nif (k1 != expectedLength1) throw new AssertionError();\nfor (int i = 0; i < k1; i++) {\n    if (nums1[i] != expectedNums1[i]) throw new AssertionError();\n}",
        "int[] nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3};\nint expectedLength2 = 7;\nint[] expectedNums2 = {0, 0, 1, 1, 2, 3, 3};\nint k2 = RemoveDuplicatesFromSortedArrayII(nums2);\nif (k2 != expectedLength2) throw new AssertionError();\nfor (int i = 0; i < k2; i++) {\n    if (nums2[i] != expectedNums2[i]) throw new AssertionError();\n}"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int RemoveDuplicatesFromSortedArrayII(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1, 1, 1, 2, 2, 3};\nint expectedNums1[] = {1, 1, 2, 2, 3};\nint k1 = RemoveDuplicatesFromSortedArrayII(nums1, 6);\nif (k1 != 5) { printf(\"Test Case 1 Failed\"); }\nfor (int i = 0; i < k1; i++) { if (nums1[i] != expectedNums1[i]) { printf(\"Test Case 1 Failed\"); }}",
        "int nums2[] = {0, 0, 1, 1, 1, 1, 2, 3, 3};\nint expectedNums2[] = {0, 0, 1, 1, 2, 3, 3};\nint k2 = RemoveDuplicatesFromSortedArrayII(nums2, 9);\nif (k2 != 7) { printf(\"Test Case 2 Failed\"); }\nfor (int i = 0; i < k2; i++) { if (nums2[i] != expectedNums2[i]) { printf(\"Test Case 2 Failed\"); }}"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; }} return 1; }"
    },
    "go": {
      "functionDeclaration": "func RemoveDuplicatesFromSortedArrayII(nums []int) int {}",
      "testCalls": [
        "k1 := RemoveDuplicatesFromSortedArrayII([]int{1,1,1,2,2,3}); if k1 != 5 {panic(\"Test case 1 failed\")}",
        "k2 := RemoveDuplicatesFromSortedArrayII([]int{0,0,1,1,1,1,2,3,3}); if k2 != 7 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicatesFromSortedArrayII(nums: &mut Vec<i32>) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![1, 1, 1, 2, 2, 3];\nlet expected_nums1 = vec![1, 1, 2, 2, 3];\nlet k1 = RemoveDuplicatesFromSortedArrayII(&mut nums1);\nassert_eq!(k1, expected_nums1.len() as i32);\nassert_eq!(&nums1[0..expected_nums1.len()], &expected_nums1[..]);",
        "let mut nums2 = vec![0, 0, 1, 1, 1, 1, 2, 3, 3];\nlet expected_nums2 = vec![0, 0, 1, 1, 2, 3, 3];\nlet k2 = RemoveDuplicatesFromSortedArrayII(&mut nums2);\nassert_eq!(k2, expected_nums2.len() as i32);\nassert_eq!(&nums2[0..expected_nums2.len()], &expected_nums2[..]);"
      ],
      "compareHelper": "fn assert_arrays_equal(arr1: &[i32], arr2: &[i32]) {\n    assert_eq!(arr1, arr2);\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArrayII(nums)",
      "testCalls": [
        "nums1 = [1,1,1,2,2,3]; expectedNums1 = [1,1,2,2,3]; k1 = RemoveDuplicatesFromSortedArrayII(nums1); raise 'Test Case 1 Failed' unless k1 == expectedNums1.length && nums1[0...k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,1,2,3,3]; expectedNums2 = [0,0,1,1,2,3,3]; k2 = RemoveDuplicatesFromSortedArrayII(nums2); raise 'Test Case 2 Failed' unless k2 == expectedNums2.length && nums2[0...k2] == expectedNums2"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "remove-duplicates-from-sorted-array": {
    "title": "Remove Duplicates from Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nConsider the number of unique elements innums to be k. After removing duplicates, return the number of unique elementsk.\nThe firstkelements ofnumsshould contain the unique numbers in sorted order. The remaining elements beyond indexk - 1can be ignored.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.\n\n",
    "difficulty": "Easy",
    "hints": [
      "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n\r\n",
      "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
      "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArray(nums) {}",
      "testCalls": [
        "RemoveDuplicatesFromSortedArray([1,1,2])",
        "RemoveDuplicatesFromSortedArray([0,0,1,1,1,2,2,3,3,4])"
      ],
      "compareHelper": "function arraysEqual(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedArray(nums: number[]): number {}",
      "testCalls": [
        "const nums1: number[] = [1,1,2];\nconst expectedNums1: number[] = [1,2];\nconst k1: number = RemoveDuplicatesFromSortedArray(nums1);\nif (k1 !== expectedNums1.length || !arraysEqual(nums1.slice(0, k1), expectedNums1)) {\n  throw new Error('Test Case 1 Failed');\n}",
        "const nums2: number[] = [0,0,1,1,1,2,2,3,3,4];\nconst expectedNums2: number[] = [0,1,2,3,4];\nconst k2: number = RemoveDuplicatesFromSortedArray(nums2);\nif (k2 !== expectedNums2.length || !arraysEqual(nums2.slice(0, k2), expectedNums2)) {\n  throw new Error('Test Case 2 Failed');\n}"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}"
    },
    "c++": {
      "functionDeclaration": "int RemoveDuplicates(vector<int>& nums)",
      "testCalls": [
        "vector<int> nums1 = {1, 1, 2}; int k1 = RemoveDuplicates(nums1); assert(k1 == 2); vector<int> expectedNums1 = {1, 2}; for (int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "vector<int> nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int k2 = RemoveDuplicates(nums2); assert(k2 == 5); vector<int> expectedNums2 = {0, 1, 2, 3, 4}; for (int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "std::equal(nums.begin(), nums.begin() + k, expectedNums.begin())"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArray(nums: List[int]) -> int:",
      "testCalls": [
        "nums1 = [1,1,2]; expectedResult1 = 2; expectedNums1 = [1,2]; k1 = RemoveDuplicatesFromSortedArray(nums1); assert k1 == expectedResult1; assert nums1[:k1] == expectedNums1",
        "nums2 = [0,0,1,1,1,2,2,3,3,4]; expectedResult2 = 5; expectedNums2 = [0,1,2,3,4]; k2 = RemoveDuplicatesFromSortedArray(nums2); assert k2 == expectedResult2; assert nums2[:k2] == expectedNums2"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return all(x == y for x, y in zip(arr1, arr2))"
    },
    "java": {
      "functionDeclaration": "public int RemoveDuplicates(int[] nums) {}",
      "testCalls": [
        "int[] nums1 = {1, 1, 2}; int[] expectedNums1 = {1, 2}; int k1 = RemoveDuplicates(nums1); assert k1 == expectedNums1.length; for (int i = 0; i < k1; i++) { assert nums1[i] == expectedNums1[i]; }",
        "int[] nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int[] expectedNums2 = {0, 1, 2, 3, 4}; int k2 = RemoveDuplicates(nums2); assert k2 == expectedNums2.length; for (int i = 0; i < k2; i++) { assert nums2[i] == expectedNums2[i]; }"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) { if (arr1.length != arr2.length) { return false; } for (int i = 0; i < arr1.length; i++) { if (arr1[i] != arr2[i]) { return false; } } return true; }"
    },
    "c": {
      "functionDeclaration": "int RemoveDuplicates(int* nums, int numsSize)",
      "testCalls": [
        "int nums1[] = {1, 1, 2}; int expectedNums1[] = {1, 2}; int k1 = RemoveDuplicates(nums1, 3); assert(k1 == 2); for (int i = 0; i < k1; i++) { assert(nums1[i] == expectedNums1[i]); }",
        "int nums2[] = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4}; int expectedNums2[] = {0, 1, 2, 3, 4}; int k2 = RemoveDuplicates(nums2, 10); assert(k2 == 5); for (int i = 0; i < k2; i++) { assert(nums2[i] == expectedNums2[i]); }"
      ],
      "compareHelper": "int CompareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) { return 0; } } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RemoveDuplicates(nums []int) int {}",
      "testCalls": [
        "if RemoveDuplicates([]int{1, 1, 2}) != 2 {panic(\"Test case 1 failed\")}",
        "if RemoveDuplicates([]int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}) != 5 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n    if len(arr1) != len(arr2) { return false }\n    for i := range arr1 {\n        if arr1[i] != arr2[i] { return false }\n    }\n    return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicates(nums: &mut Vec<i32>) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![1, 1, 2];\nlet expected_nums1 = vec![1, 2];\nlet k1 = RemoveDuplicates(&mut nums1);\nassert_eq!(k1, expected_nums1.len() as i32);\nassert_eq!(&nums1[0..k1 as usize], &expected_nums1[..]);",
        "let mut nums2 = vec![0, 0, 1, 1, 1, 2, 2, 3, 3, 4];\nlet expected_nums2 = vec![0, 1, 2, 3, 4];\nlet k2 = RemoveDuplicates(&mut nums2);\nassert_eq!(k2, expected_nums2.len() as i32);\nassert_eq!(&nums2[0..k2 as usize], &expected_nums2[..]);"
      ],
      "compareHelper": "fn assert_arrays_equal(arr1: &[i32], arr2: &[i32]) {\n    assert_eq!(arr1, arr2);\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedArray(nums)\nend",
      "testCalls": [
        "nums1 = [1,1,2]\nexpected_nums1 = [1,2]\nexpected_result1 = 2\nresult1 = RemoveDuplicatesFromSortedArray(nums1)\nraise 'Test Case 1 Failed' unless result1 == expected_result1 && nums1[0...result1] == expected_nums1",
        "nums2 = [0,0,1,1,1,2,2,3,3,4]\nexpected_nums2 = [0,1,2,3,4]\nexpected_result2 = 5\nresult2 = RemoveDuplicatesFromSortedArray(nums2)\nraise 'Test Case 2 Failed' unless result2 == expected_result2 && nums2[0...result2] == expected_nums2"
      ],
      "compareHelper": "def arrays_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "remove-duplicates-from-sorted-list-ii": {
    "title": "Remove Duplicates from Sorted List II",
    "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n\nExample 1:\n\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 300].\n-100 <= Node.val <= 100\nThe list is guaranteed to be sorted in ascending order.\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RemoveDuplicatesFromSortedListII(head) {}",
      "testCalls": [
        "if(JSON.stringify(RemoveDuplicatesFromSortedListII([1,2,3,3,4,4,5])) !== JSON.stringify([1,2,5])) { throw new Error('Test Case 1 Failed'); }",
        "if(JSON.stringify(RemoveDuplicatesFromSortedListII([1,1,1,2,3])) !== JSON.stringify([2,3])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function DeleteDuplicatesFromSortedListII(head: ListNode | null): ListNode | null",
      "testCalls": [
        "if (JSON.stringify(DeleteDuplicatesFromSortedListII(arrayToLinkedList([1,2,3,3,4,4,5]))) !== JSON.stringify(arrayToLinkedList([1,2,5]))) throw new Error('Test Case 1 Failed');",
        "if (JSON.stringify(DeleteDuplicatesFromSortedListII(arrayToLinkedList([1,1,1,2,3]))) !== JSON.stringify(arrayToLinkedList([2,3]))) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arrayToLinkedList(arr: number[]): ListNode | null {\n  if (arr.length === 0) return null;\n  const head = new ListNode(arr[0]);\n  let current = head;\n  for (let i = 1; i < arr.length; i++) {\n    current.next = new ListNode(arr[i]);\n    current = current.next;\n  }\n  return head;\n}"
    },
    "c++": {
      "functionDeclaration": "ListNode* DeleteDuplicates(ListNode* head)",
      "testCalls": [
        "assert(compareLinkedList(DeleteDuplicates(createLinkedList({1,2,3,3,4,4,5})), createLinkedList({1,2,5}));",
        "assert(compareLinkedList(DeleteDuplicates(createLinkedList({1,1,1,2,3})), createLinkedList({2,3}));"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) {\n    while (l1 && l2) {\n        if (l1->val != l2->val) return false;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    return l1 == nullptr && l2 == nullptr;\n}"
    },
    "python": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedListII(head):",
      "testCalls": [
        "assert RemoveDuplicatesFromSortedListII([1,2,3,3,4,4,5]) == [1,2,5]",
        "assert RemoveDuplicatesFromSortedListII([1,1,1,2,3]) == [2,3]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public ListNode deleteDuplicates(ListNode head) { }",
      "testCalls": [
        "ListNode test1 = deleteDuplicates(ListNode.fromArray(new int[]{1,2,3,3,4,4,5}));\nif (!ListNode.equalsArray(test1, new int[]{1,2,5})) throw new AssertionError();",
        "ListNode test2 = deleteDuplicates(ListNode.fromArray(new int[]{1,1,1,2,3}));\nif (!ListNode.equalsArray(test2, new int[]{2,3})) throw new AssertionError();"
      ],
      "compareHelper": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n    public static ListNode fromArray(int[] arr) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        for (int val : arr) {\n            current.next = new ListNode(val);\n            current = current.next;\n        }\n        return dummy.next;\n    }\n    public static boolean equalsArray(ListNode head, int[] arr) {\n        ListNode current = head;\n        for (int val : arr) {\n            if (current == null || current.val != val) {\n                return false;\n            }\n            current = current.next;\n        }\n        return current == null;\n    }\n}"
    },
    "c": {
      "functionDeclaration": "void DeleteDuplicatesFromSortedListII(struct ListNode* head)",
      "testCalls": [
        "DeleteDuplicatesFromSortedListII(head); // Compare result with expected for input [1,2,3,3,4,4,5]",
        "DeleteDuplicatesFromSortedListII(head); // Compare result with expected for input [1,1,1,2,3]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int size1, int* arr2, int size2) {\n    if (size1 != size2) return 0;\n    for (int i = 0; i < size1; i++) {\n        if (arr1[i] != arr2[i]) return 0;\n    }\n    return 1;\n}"
    },
    "go": {
      "functionDeclaration": "func DeleteDuplicates(head *ListNode) *ListNode",
      "testCalls": [
        "if result := DeleteDuplicates(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}}); !compareLinkedList(result, &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 5}}}) { t.Errorf(\"Test 1 Failed\") }",
        "if result := DeleteDuplicates(&ListNode{Val: 1, Next: &ListNode{Val: 1, Next: &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}}); !compareLinkedList(result, &ListNode{Val: 2, Next: &ListNode{Val: 3}}) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveDuplicatesFromSortedListII(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode::new(1))), RemoveDuplicatesFromSortedListII(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 5, next: None) })) })))));",
        "assert_eq!(Some(Box::new(ListNode::new(2))), RemoveDuplicatesFromSortedListII(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: None) })) })) })) })))));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def RemoveDuplicatesFromSortedListII(head)\nend",
      "testCalls": [
        "test_case_1 = RemoveDuplicatesFromSortedListII([1,2,3,3,4,4,5])\nraise 'Test Case 1 Failed' unless test_case_1 == [1,2,5]",
        "test_case_2 = RemoveDuplicatesFromSortedListII([1,1,1,2,3])\nraise 'Test Case 2 Failed' unless test_case_2 == [2,3]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "remove-element": {
    "title": "Remove Element",
    "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\n\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n\n",
    "difficulty": "Easy",
    "hints": [
      "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to remove that element per se, right?",
      "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
      "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
    ],
    "topicTags": [
      "Array",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RemoveElement(nums, val) {}",
      "testCalls": [
        "const test1Nums = [3,2,2,3]; const test1Val = 3; const test1Expected = 2; const test1Result = RemoveElement(test1Nums, test1Val); if (test1Result !== test1Expected) { throw new Error(`Test case 1 failed: Expected ${test1Expected}, got ${test1Result}`); }",
        "const test2Nums = [0,1,2,2,3,0,4,2]; const test2Val = 2; const test2Expected = 5; const test2Result = RemoveElement(test2Nums, test2Val); if (test2Result !== test2Expected) { throw new Error(`Test case 2 failed: Expected ${test2Expected}, got ${test2Result}`); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveElement(nums: number[], val: number): number {}",
      "testCalls": [
        "const test1Nums = [3,2,2,3]; const test1Val = 3; const test1Expected = 2; const test1Result = RemoveElement(test1Nums, test1Val); if (test1Result !== test1Expected) { throw new Error(`Test case 1 failed: Expected ${test1Expected}, got ${test1Result}`); }",
        "const test2Nums = [0,1,2,2,3,0,4,2]; const test2Val = 2; const test2Expected = 5; const test2Result = RemoveElement(test2Nums, test2Val); if (test2Result !== test2Expected) { throw new Error(`Test case 2 failed: Expected ${test2Expected}, got ${test2Result}`); }"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "int RemoveElement(vector<int>& nums, int val);",
      "testCalls": [
        "vector<int> nums1 = {3, 2, 2, 3}; int val1 = 3; int k1 = RemoveElement(nums1, val1); assert(k1 == 2); vector<int> expectedNums1 = {2, 2}; sort(nums1.begin(), nums1.begin() + k1); assert(nums1 == expectedNums1);",
        "vector<int> nums2 = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int k2 = RemoveElement(nums2, val2); assert(k2 == 5); vector<int> expectedNums2 = {0, 1, 4, 0, 3}; sort(nums2.begin(), nums2.begin() + k2); assert(nums2 == expectedNums2);"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def RemoveElement(nums: List[int], val: int) -> int:",
      "testCalls": [
        "assert RemoveElement([3,2,2,3], 3) == 2",
        "assert RemoveElement([0,1,2,2,3,0,4,2], 2) == 5"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if len(arr1) != len(arr2):\n        raise AssertionError('Arrays have different lengths')\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            raise AssertionError(f'Arrays differ at index {i}')"
    },
    "java": {
      "functionDeclaration": "public int RemoveElement(int[] nums, int val) {}",
      "testCalls": [
        "int[] nums1 = {3, 2, 2, 3};\nint val1 = 3;\nint expected1 = 2;\nint k1 = RemoveElement(nums1, val1);\nassert k1 == expected1;",
        "int[] nums2 = {0, 1, 2, 2, 3, 0, 4, 2};\nint val2 = 2;\nint expected2 = 5;\nint k2 = RemoveElement(nums2, val2);\nassert k2 == expected2;"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2, int length) {\n    for (int i = 0; i < length; i++) {\n        if (arr1[i] != arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "int RemoveElement(int* nums, int numsSize, int val);",
      "testCalls": [
        "int nums1[] = {3, 2, 2, 3}; int val1 = 3; int expected1 = 2; int k1 = RemoveElement(nums1, 4, val1); assert(k1 == expected1);",
        "int nums2[] = {0, 1, 2, 2, 3, 0, 4, 2}; int val2 = 2; int expected2 = 5; int k2 = RemoveElement(nums2, 8, val2); assert(k2 == expected2);"
      ],
      "compareHelper": "void assertArrayEquals(int* arr1, int* arr2, int size) { for(int i = 0; i < size; i++) { assert(arr1[i] == arr2[i]); } }"
    },
    "go": {
      "functionDeclaration": "func RemoveElement(nums []int, val int) int {}",
      "testCalls": [
        "if RemoveElement([]int{3,2,2,3}, 3) != 2 {panic(\"Test case 1 failed\")}",
        "if RemoveElement([]int{0,1,2,2,3,0,4,2}, 2) != 5 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool {\n  if len(arr1) != len(arr2) { return false }\n  for i := range arr1 {\n    if arr1[i] != arr2[i] { return false }\n  }\n  return true\n}"
    },
    "rust": {
      "functionDeclaration": "fn RemoveElement(nums: &mut Vec<i32>, val: i32) -> i32 {}",
      "testCalls": [
        "let mut nums1 = vec![3, 2, 2, 3];\nlet val1 = 3;\nlet result1 = RemoveElement(&mut nums1, val1);\nassert_eq!(result1, 2);\nassert_eq!(nums1, vec![2, 2]);",
        "let mut nums2 = vec![0, 1, 2, 2, 3, 0, 4, 2];\nlet val2 = 2;\nlet result2 = RemoveElement(&mut nums2, val2);\nassert_eq!(result2, 5);\nassert_eq!(nums2, vec![0, 1, 4, 0, 3]);"
      ],
      "compareHelper": "fn assert_vec_eq(actual: Vec<i32>, expected: Vec<i32>) {\n    assert_eq!(actual.len(), expected.len());\n    for i in 0..actual.len() {\n        assert_eq!(actual[i], expected[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def RemoveElement(nums, val)\nend",
      "testCalls": [
        "nums1 = [3,2,2,3]\nval1 = 3\nexpected_result1 = 2\nRemoveElement(nums1, val1) # Call function\nif nums1[0...expected_result1] != [2, 2]\n  raise 'Test Case 1 Failed'\nend",
        "nums2 = [0,1,2,2,3,0,4,2]\nval2 = 2\nexpected_result2 = 5\nRemoveElement(nums2, val2) # Call function\nif nums2[0...expected_result2].sort != [0, 0, 1, 3, 4]\n  raise 'Test Case 2 Failed'\nend"
      ],
      "compareHelper": "def compare_arrays(arr1, arr2)\n  arr1.sort == arr2.sort\nend"
    }
  },
  "remove-nth-node-from-end-of-list": {
    "title": "Remove Nth Node From End of List",
    "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n\nConstraints:\n\nThe number of nodes in the list is sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz\n\n\nFollow up: Could you do this in one pass?\n",
    "difficulty": "Medium",
    "hints": [
      "Maintain two pointers and update one with a delay of n steps."
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RemoveNthNodeFromEndOfList(head, n) {}",
      "testCalls": [
        "let test1 = RemoveNthNodeFromEndOfList([1,2,3,4,5], 2); if(JSON.stringify(test1) !== JSON.stringify([1,2,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RemoveNthNodeFromEndOfList([1], 1); if(JSON.stringify(test2) !== JSON.stringify([])) { throw new Error('Test Case 2 Failed'); }",
        "let test3 = RemoveNthNodeFromEndOfList([1,2], 1); if(JSON.stringify(test3) !== JSON.stringify([1])) { throw new Error('Test Case 3 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RemoveNthNodeFromEndOfList(head: ListNode | null, n: number): ListNode | null {}",
      "testCalls": [
        "const test1 = RemoveNthNodeFromEndOfList(createLinkedList([1,2,3,4,5]), 2); compareLinkedList(test1, createLinkedList([1,2,3,5]));",
        "const test2 = RemoveNthNodeFromEndOfList(createLinkedList([1]), 1); compareLinkedList(test2, createLinkedList([]));",
        "const test3 = RemoveNthNodeFromEndOfList(createLinkedList([1,2]), 1); compareLinkedList(test3, createLinkedList([1]));"
      ],
      "compareHelper": "function compareLinkedList(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); }}"
    },
    "c++": {
      "functionDeclaration": "ListNode* RemoveNthNodeFromEndOfList(ListNode* head, int n)",
      "testCalls": [
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(createLinkedList({1,2,3,4,5}), 2), createLinkedList({1,2,3,5}));",
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(createLinkedList({1}), 1), createLinkedList({}));",
        "assert(compareLinkedLists(RemoveNthNodeFromEndOfList(createLinkedList({1,2}), 1), createLinkedList({1}));"
      ],
      "compareHelper": "bool compareLinkedLists(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }"
    },
    "python": {
      "functionDeclaration": "def RemoveNthNodeFromEndOfList(head, n):",
      "testCalls": [
        "result1 = RemoveNthNodeFromEndOfList([1,2,3,4,5], 2)\nif result1 != [1,2,3,5]:\n    raise AssertionError('Test Case 1 Failed')",
        "result2 = RemoveNthNodeFromEndOfList([1], 1)\nif result2 != []:\n    raise AssertionError('Test Case 2 Failed')"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    return arr1 == arr2"
    },
    "java": {
      "functionDeclaration": "public ListNode removeNthFromEnd(ListNode head, int n) { }",
      "testCalls": [
        "ListNode test1 = removeNthFromEnd(ListNode.fromArray(new int[]{1,2,3,4,5}), 2); if (!ListNode.equalsArray(test1, new int[]{1,2,3,5})) throw new AssertionError();",
        "ListNode test2 = removeNthFromEnd(ListNode.fromArray(new int[]{1}), 1); if (!ListNode.equalsArray(test2, new int[]{})) throw new AssertionError();",
        "ListNode test3 = removeNthFromEnd(ListNode.fromArray(new int[]{1,2}), 1); if (!ListNode.equalsArray(test3, new int[]{1})) throw new AssertionError();"
      ],
      "compareHelper": "public static boolean equalsArray(ListNode node, int[] expected) { }"
    },
    "c": {
      "functionDeclaration": "ListNode* RemoveNthFromEnd(ListNode* head, int n)",
      "testCalls": [
        "assert(compareArrays(RemoveNthFromEnd(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2), createLinkedListFromArray((int[]) {1,2,3,5}, 4));",
        "assert(compareArrays(RemoveNthFromEnd(createLinkedListFromArray((int[]) {1}, 1), 1), createLinkedListFromArray((int[]) {}, 0));",
        "assert(compareArrays(RemoveNthFromEnd(createLinkedListFromArray((int[]) {1,2}, 2), 1), createLinkedListFromArray((int[]) {1}, 1));"
      ],
      "compareHelper": "bool compareArrays(ListNode* l1, ListNode* l2) {\n  while (l1 != NULL && l2 != NULL) {\n    if (l1->val != l2->val) return false;\n    l1 = l1->next;\n    l2 = l2->next;\n  }\n  return l1 == NULL && l2 == NULL;\n}"
    },
    "go": {
      "functionDeclaration": "func RemoveNthFromEnd(head *ListNode, n int) *ListNode {}",
      "testCalls": [
        "if result := RemoveNthFromEnd(sliceToListNode([]int{1, 2, 3, 4, 5}), 2); !compareLinkedList(result, sliceToListNode([]int{1, 2, 3, 5})) { t.Errorf(\"Test 1 failed\") }",
        "if result := RemoveNthFromEnd(sliceToListNode([]int{1}), 1); !compareLinkedList(result, sliceToListNode([]int{})) { t.Errorf(\"Test 2 failed\") }",
        "if result := RemoveNthFromEnd(sliceToListNode([]int{1, 2}), 1); !compareLinkedList(result, sliceToListNode([]int{1})) { t.Errorf(\"Test 3 failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }"
    },
    "rust": {
      "functionDeclaration": "fn RemoveNthNodeFromEndOfList(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })), RemoveNthNodeFromEndOfList(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })))), 2).unwrap());",
        "assert_eq!(None, RemoveNthNodeFromEndOfList(Some(Box::new(ListNode { val: 1, next: None })), 1));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def RemoveNthNodeFromEndOfList(head, n)\nend",
      "testCalls": [
        "test_case_1 = RemoveNthNodeFromEndOfList([1,2,3,4,5], 2)\nraise 'Test Case 1 Failed' unless test_case_1 == [1,2,3,5]",
        "test_case_2 = RemoveNthNodeFromEndOfList([1], 1)\nraise 'Test Case 2 Failed' unless test_case_2 == []",
        "test_case_3 = RemoveNthNodeFromEndOfList([1,2], 1)\nraise 'Test Case 3 Failed' unless test_case_3 == [1]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "reverse-bits": {
    "title": "Reverse Bits",
    "content": "Reverse bits of a given 32 bits signed integer.\n\nExample 1:\n\nInput: n = 43261596\nOutput: 964176192\nExplanation:\n\n\n\nInteger\nBinary\n\n\n43261596\n00000010100101000001111010011100\n\n\n964176192\n00111001011110000010100101000000\n\n\n\n\nExample 2:\n\nInput: n = 2147483644\nOutput: 1073741822\nExplanation:\n\n\n\nInteger\nBinary\n\n\n2147483644\n01111111111111111111111111111100\n\n\n1073741822\n00111111111111111111111111111110\n\n\n\n\n\nConstraints:\n\n0 <= n <= 231 - 2\nn is even.\n\n\nFollow up: If this function is called many times, how would you optimize it?\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "ReverseBits(n)",
      "testCalls": [
        "if (ReverseBits(43261596) !== 964176192) { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseBits(2147483644) !== 1073741822) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ReverseBits(n: number): number {}",
      "testCalls": [
        "if (ReverseBits(43261596) !== 964176192) { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseBits(2147483644) !== 1073741822) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int ReverseBits(int n);",
      "testCalls": [
        "if(ReverseBits(43261596) != 964176192) throw std::runtime_error(\"Test Case 1 Failed\");",
        "if(ReverseBits(2147483644) != 1073741822) throw std::runtime_error(\"Test Case 2 Failed\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ReverseBits(n: int) -> int",
      "testCalls": [
        "assert ReverseBits(43261596) == 964176192",
        "assert ReverseBits(2147483644) == 1073741822"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int ReverseBits(int n) {}",
      "testCalls": [
        "if (ReverseBits(43261596) != 964176192) throw new AssertionError();",
        "if (ReverseBits(2147483644) != 1073741822) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int ReverseBits(int n)",
      "testCalls": [
        "if (ReverseBits(43261596) != 964176192) { printf(\"Test Case 1 Failed\"); }",
        "if (ReverseBits(2147483644) != 1073741822) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ReverseBits(n uint32) uint32 {}",
      "testCalls": [
        "if ReverseBits(43261596) != 964176192 { t.Error(\"Test Case 1 Failed\") }",
        "if ReverseBits(2147483644) != 1073741822 { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ReverseBits(n: i32) -> i32 {}",
      "testCalls": [
        "assert_eq!(ReverseBits(43261596), 964176192);",
        "assert_eq!(ReverseBits(2147483644), 1073741822);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseBits(n)",
      "testCalls": [
        "test_case_1 = ReverseBits(43261596); raise 'Test Case 1 Failed' unless test_case_1 == 964176192",
        "test_case_2 = ReverseBits(2147483644); raise 'Test Case 2 Failed' unless test_case_2 == 1073741822"
      ],
      "compareHelper": ""
    }
  },
  "reverse-linked-list-ii": {
    "title": "Reverse Linked List II",
    "content": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n\n\nFollow up: Could you do it in one pass?",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseLinkedListII(head, left, right) {}",
      "testCalls": [
        "const test1 = ReverseLinkedListII([1,2,3,4,5], 2, 4); if(JSON.stringify(test1) !== JSON.stringify([1,4,3,2,5])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ReverseLinkedListII([5], 1, 1); if(JSON.stringify(test2) !== JSON.stringify([5])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function ReverseLinkedListII(head: ListNode | null, left: number, right: number): ListNode | null {}",
      "testCalls": [
        "const test1 = ReverseLinkedListII(createLinkedList([1,2,3,4,5]), 2, 4); compareLinkedList(test1, createLinkedList([1,4,3,2,5]));",
        "const test2 = ReverseLinkedListII(createLinkedList([5]), 1, 1); compareLinkedList(test2, createLinkedList([5]));"
      ],
      "compareHelper": "function compareLinkedList(list1: ListNode | null, list2: ListNode | null) { while (list1 !== null && list2 !== null) { if (list1.val !== list2.val) { throw new Error('Test Failed'); } list1 = list1.next; list2 = list2.next; } if (list1 !== null || list2 !== null) { throw new Error('Test Failed'); }}"
    },
    "c++": {
      "functionDeclaration": "ListNode* ReverseLinkedListII(ListNode* head, int left, int right);",
      "testCalls": [
        "assert(ListNodeToString(ReverseLinkedListII(StringToListNode(\"[1,2,3,4,5]\"), 2, 4)) == \"[1,4,3,2,5]\";",
        "assert(ListNodeToString(ReverseLinkedListII(StringToListNode(\"[5]\"), 1, 1)) == \"[5]\";"
      ],
      "compareHelper": "std::string ListNodeToString(ListNode* head) { std::string res; while (head) { res += std::to_string(head->val) + ','; head = head->next; } if (!res.empty()) res.pop_back(); return '[' + res + ']'; }"
    },
    "python": {
      "functionDeclaration": "def ReverseLinkedListII(head, left, right):",
      "testCalls": [
        "assert ReverseLinkedListII([1,2,3,4,5], 2, 4) == [1,4,3,2,5]",
        "assert ReverseLinkedListII([5], 1, 1) == [5]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public ListNode reverseBetween(ListNode head, int left, int right) { }",
      "testCalls": [
        "ListNode test1 = reverseBetween(ListNode.fromArray(new int[]{1,2,3,4,5}), 2, 4); if (!Arrays.equals(test1.toArray(), new int[]{1,4,3,2,5})) throw new AssertionError();",
        "ListNode test2 = reverseBetween(ListNode.fromArray(new int[]{5}), 1, 1); if (!Arrays.equals(test2.toArray(), new int[]{5})) throw new AssertionError();"
      ],
      "compareHelper": "private static boolean arraysEqual(int[] arr1, int[] arr2) { return Arrays.equals(arr1, arr2); }"
    },
    "c": {
      "functionDeclaration": "ListNode* ReverseLinkedListII(ListNode* head, int left, int right);",
      "testCalls": [
        "ListNode* test1 = ReverseLinkedListII(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2, 4); assert(compareLinkedListToArray(test1, (int[]) {1,4,3,2,5}, 5));",
        "ListNode* test2 = ReverseLinkedListII(createLinkedListFromArray((int[]) {5}, 1), 1, 1); assert(compareLinkedListToArray(test2, (int[]) {5}, 1));"
      ],
      "compareHelper": "bool compareLinkedListToArray(ListNode* head, int* arr, int size) { int i = 0; while (head != NULL) { if (i >= size || head->val != arr[i]) return false; head = head->next; i++; } return i == size; }"
    },
    "go": {
      "functionDeclaration": "func ReverseLinkedListII(head *ListNode, left int, right int) *ListNode {}",
      "testCalls": [
        "if result := ReverseLinkedListII(sliceToList([]int{1,2,3,4,5}), 2, 4); !compareLinkedList(result, sliceToList([]int{1,4,3,2,5})) { t.Errorf(\"Test 1 Failed\") }",
        "if result := ReverseLinkedListII(sliceToList([]int{5}), 1, 1); !compareLinkedList(result, sliceToList([]int{5})) { t.Errorf(\"Test 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }"
    },
    "rust": {
      "functionDeclaration": "fn ReverseLinkedListII(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {}",
      "testCalls": [
        "assert_eq!(ReverseLinkedListII(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })) })), 2, 4), Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })) }))",
        "assert_eq!(ReverseLinkedListII(Some(Box::new(ListNode { val: 5, next: None })), 1, 1), Some(Box::new(ListNode { val: 5, next: None }))"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseLinkedListII(head, left, right)\nend",
      "testCalls": [
        "test_case_1 = ReverseLinkedListII([1,2,3,4,5], 2, 4)\nraise 'Test Case 1 Failed' unless test_case_1 == [1,4,3,2,5]",
        "test_case_2 = ReverseLinkedListII([5], 1, 1)\nraise 'Test Case 2 Failed' unless test_case_2 == [5]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "reverse-nodes-in-k-group": {
    "title": "Reverse Nodes in k-Group",
    "content": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list nodes, only nodes themselves may be changed.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\n\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\nFollow-up: Can you solve the problem in O(1) extra memory space?\n",
    "difficulty": "Hard",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Recursion"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function ReverseNodesInKGroup(head, k) {}",
      "testCalls": [
        "const test1 = ReverseNodesInKGroup([1,2,3,4,5], 2); if(JSON.stringify(test1) !== JSON.stringify([2,1,4,3,5])) { throw new Error('Test Case 1 Failed'); }",
        "const test2 = ReverseNodesInKGroup([1,2,3,4,5], 3); if(JSON.stringify(test2) !== JSON.stringify([3,2,1,4,5])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function ReverseNodesInKGroup(head: ListNode | null, k: number): ListNode | null {}",
      "testCalls": [
        "if (JSON.stringify(ReverseNodesInKGroup(ListNode.fromArray([1,2,3,4,5]), 2)?.toArray()) !== JSON.stringify([2,1,4,3,5])) throw new Error('Test Case 1 Failed');",
        "if (JSON.stringify(ReverseNodesInKGroup(ListNode.fromArray([1,2,3,4,5]), 3)?.toArray()) !== JSON.stringify([3,2,1,4,5])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "ListNode* ReverseNodesInKGroup(ListNode* head, int k)",
      "testCalls": [
        "assert(compareLinkedList(ReverseNodesInKGroup(createLinkedList({1,2,3,4,5}), 2), createLinkedList({2,1,4,3,5}));",
        "assert(compareLinkedList(ReverseNodesInKGroup(createLinkedList({1,2,3,4,5}), 3), createLinkedList({3,2,1,4,5}));"
      ],
      "compareHelper": "bool compareLinkedList(ListNode* l1, ListNode* l2) { while (l1 && l2) { if (l1->val != l2->val) return false; l1 = l1->next; l2 = l2->next; } return l1 == nullptr && l2 == nullptr; }"
    },
    "python": {
      "functionDeclaration": "def ReverseNodesInKGroup(head, k):",
      "testCalls": [
        "assert ReverseNodesInKGroup([1,2,3,4,5], 2) == [2,1,4,3,5]",
        "assert ReverseNodesInKGroup([1,2,3,4,5], 3) == [3,2,1,4,5]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public ListNode reverseKGroup(ListNode head, int k) { }",
      "testCalls": [
        "ListNode test1Head = new ListNode(1); test1Head.next = new ListNode(2); test1Head.next.next = new ListNode(3); test1Head.next.next.next = new ListNode(4); test1Head.next.next.next.next = new ListNode(5); ListNode expected1 = new ListNode(2); expected1.next = new ListNode(1); expected1.next.next = new ListNode(4); expected1.next.next.next = new ListNode(3); expected1.next.next.next.next = new ListNode(5); ListNode result1 = reverseKGroup(test1Head, 2); if (!compareLinkedLists(result1, expected1)) { throw new AssertionError(); }",
        "ListNode test2Head = new ListNode(1); test2Head.next = new ListNode(2); test2Head.next.next = new ListNode(3); test2Head.next.next.next = new ListNode(4); test2Head.next.next.next.next = new ListNode(5); ListNode expected2 = new ListNode(3); expected2.next = new ListNode(2); expected2.next.next = new ListNode(1); expected2.next.next.next = new ListNode(4); expected2.next.next.next.next = new ListNode(5); ListNode result2 = reverseKGroup(test2Head, 3); if (!compareLinkedLists(result2, expected2)) { throw new AssertionError(); }"
      ],
      "compareHelper": "public boolean compareLinkedLists(ListNode l1, ListNode l2) { while (l1 != null && l2 != null) { if (l1.val != l2.val) { return false; } l1 = l1.next; l2 = l2.next; } return l1 == null && l2 == null; }"
    },
    "c": {
      "functionDeclaration": "ListNode* ReverseNodesInKGroup(ListNode* head, int k)",
      "testCalls": [
        "testReverseNodesInKGroup(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 2, createLinkedListFromArray((int[]) {2,1,4,3,5}, 5))",
        "testReverseNodesInKGroup(createLinkedListFromArray((int[]) {1,2,3,4,5}, 5), 3, createLinkedListFromArray((int[]) {3,2,1,4,5}, 5))"
      ],
      "compareHelper": "int compareLinkedLists(ListNode* expected, ListNode* actual) { while (expected != NULL && actual != NULL) { if (expected->val != actual->val) { return 0; } expected = expected->next; actual = actual->next; } return expected == NULL && actual == NULL; }"
    },
    "go": {
      "functionDeclaration": "func ReverseNodesInKGroup(head *ListNode, k int) *ListNode",
      "testCalls": [
        "if !compareLinkedList(ReverseNodesInKGroup(createLinkedList([]int{1,2,3,4,5}), 2), createLinkedList([]int{2,1,4,3,5})) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareLinkedList(ReverseNodesInKGroup(createLinkedList([]int{1,2,3,4,5}), 3), createLinkedList([]int{3,2,1,4,5})) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool {\n    for l1 != nil && l2 != nil {\n        if l1.Val != l2.Val {\n            return false\n        }\n        l1 = l1.Next\n        l2 = l2.Next\n    }\n    return l1 == nil && l2 == nil\n}"
    },
    "rust": {
      "functionDeclaration": "fn ReverseNodesInKGroup(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(ReverseNodesInKGroup(Some(Box::new(ListNode::new(1))), 2), Some(Box::new(ListNode::new(2)));",
        "assert_eq!(ReverseNodesInKGroup(Some(Box::new(ListNode::new(1))), 3), Some(Box::new(ListNode::new(3)));"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseNodesInKGroup(head, k)\nend",
      "testCalls": [
        "test_case_1 = ReverseNodesInKGroup([1,2,3,4,5], 2)\nraise 'Test Case 1 Failed' unless test_case_1 == [2,1,4,3,5]",
        "test_case_2 = ReverseNodesInKGroup([1,2,3,4,5], 3)\nraise 'Test Case 2 Failed' unless test_case_2 == [3,2,1,4,5]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "reverse-words-in-a-string": {
    "title": "Reverse Words in a String",
    "content": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\nExample 1:\n\nInput: s = &quot;the sky is blue&quot;\nOutput: &quot;blue is sky the&quot;\n\nExample 2:\n\nInput: s = &quot;  hello world  &quot;\nOutput: &quot;world hello&quot;\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nExample 3:\n\nInput: s = &quot;a good   example&quot;\nOutput: &quot;example good a&quot;\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\nConstraints:\n\n1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces &#39; &#39;.\nThere is at least one word in s.\n\n\nFollow-up:If the string data type is mutable in your language, canyou solve itin-placewithO(1)extra space?\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Two Pointers",
      "String"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function ReverseWordsInAString(s) {}",
      "testCalls": [
        "if (ReverseWordsInAString('the sky is blue') !== 'blue is sky the') { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseWordsInAString('  hello world  ') !== 'world hello') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function ReverseWordsInAString(s: string): string {}",
      "testCalls": [
        "if (ReverseWordsInAString('the sky is blue') !== 'blue is sky the') { throw new Error('Test Case 1 Failed'); }",
        "if (ReverseWordsInAString('hello world') !== 'world hello') { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "string ReverseWordsInAString(string s)",
      "testCalls": [
        "assert(ReverseWordsInAString(\"the sky is blue\") == \"blue is sky the\");",
        "assert(ReverseWordsInAString(\"  hello world  \") == \"world hello\");"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def ReverseWordsInAString(s: str) -> str:",
      "testCalls": [
        "assert ReverseWordsInAString(\"the sky is blue\") == \"blue is sky the\"",
        "assert ReverseWordsInAString(\"  hello world  \") == \"world hello\"",
        "assert ReverseWordsInAString(\"a good   example\") == \"example good a\""
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public String ReverseWordsInAString(String s) {}",
      "testCalls": [
        "if (!ReverseWordsInAString(\"the sky is blue\").equals(\"blue is sky the\")) { throw new AssertionError(); }",
        "if (!ReverseWordsInAString(\"hello world\").equals(\"world hello\")) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "char* ReverseWordsInAString(char* s)",
      "testCalls": [
        "ReverseWordsInAString(\"the sky is blue\")",
        "ReverseWordsInAString(\"  hello world  \")"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func ReverseWordsInAString(s string) string {}",
      "testCalls": [
        "if ReverseWordsInAString(\"the sky is blue\") != \"blue is sky the\" {panic(\"Test 1 failed\")}",
        "if ReverseWordsInAString(\"  hello world  \") != \"world hello\" {panic(\"Test 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn ReverseWordsInAString(s: String) -> String {}",
      "testCalls": [
        "assert_eq!(ReverseWordsInAString(String::from(\"theskyisblue\")), \"blueisskythe\");",
        "assert_eq!(ReverseWordsInAString(String::from(\"helloworld\")), \"worldhello\");"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def ReverseWordsInAString(s)",
      "testCalls": [
        "puts ReverseWordsInAString(\"theskyisblue\") == \"blueisskythe\" || raise(\"Test Case 1 Failed\")",
        "puts ReverseWordsInAString(\"helloworld\") == \"worldhello\" || raise(\"Test Case 2 Failed\")"
      ],
      "compareHelper": ""
    }
  },
  "roman-to-integer": {
    "title": "Roman to Integer",
    "content": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,2 is written as IIin Roman numeral, just two ones added together. 12 is written asXII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\nExample 1:\n\nInput: s = &quot;III&quot;\nOutput: 3\nExplanation: III = 3.\n\nExample 2:\n\nInput: s = &quot;LVIII&quot;\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 3:\n\nInput: s = &quot;MCMXCIV&quot;\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n\n1 <= s.length <= 15\ns contains onlythe characters (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;).\nIt is guaranteedthat s is a valid roman numeral in the range [1, 3999].\n\n",
    "difficulty": "Easy",
    "hints": [
      "Problem is simpler to solve by working the string from back to front and using a map."
    ],
    "topicTags": [
      "Hash Table",
      "Math",
      "String"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RomanToInteger(s) {}",
      "testCalls": [
        "if (RomanToInteger(\"III\") !== 3) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") !== 58) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (RomanToInteger(\"MCMXCIV\") !== 1994) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function RomanToInteger(s: string): number {}",
      "testCalls": [
        "if (RomanToInteger(\"III\") !== 3) { throw new Error(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") !== 58) { throw new Error(\"Test Case 2 Failed\"); }",
        "if (RomanToInteger(\"MCMXCIV\") !== 1994) { throw new Error(\"Test Case 3 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int RomanToInteger(string s)",
      "testCalls": [
        "if (RomanToInteger(\"III\") != 3) { throw \"Test 1 failed\"; }",
        "if (RomanToInteger(\"LVIII\") != 58) { throw \"Test 2 failed\"; }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def RomanToInteger(s: str) -> int:",
      "testCalls": [
        "assert RomanToInteger(\"III\") == 3",
        "assert RomanToInteger(\"LVIII\") == 58"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int RomanToInteger(String s) { }",
      "testCalls": [
        "if (RomanToInteger(\"III\") != 3) { throw new AssertionError(); }",
        "if (RomanToInteger(\"LVIII\") != 58) { throw new AssertionError(); }",
        "if (RomanToInteger(\"MCMXCIV\") != 1994) { throw new AssertionError(); }"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int RomanToInteger(char *s)",
      "testCalls": [
        "if (RomanToInteger(\"III\") != 3) { printf(\"Test Case 1 Failed\"); }",
        "if (RomanToInteger(\"LVIII\") != 58) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func RomanToInteger(s string) int {\n\t// Function body will be implemented here\n}",
      "testCalls": [
        "if RomanToInteger(\"III\") != 3 {\n\tt.Errorf(\"Test case 1 failed\")\n}",
        "if RomanToInteger(\"LVIII\") != 58 {\n\tt.Errorf(\"Test case 2 failed\")\n}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn RomanToInteger(s: String) -> i32 {}",
      "testCalls": [
        "assert_eq!(RomanToInteger(String::from(\"III\")), 3);",
        "assert_eq!(RomanToInteger(String::from(\"LVIII\")), 58);",
        "assert_eq!(RomanToInteger(String::from(\"MCMXCIV\")), 1994);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def RomanToInteger(s)",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless RomanToInteger('III') == 3",
        "raise 'Test Case 2 Failed' unless RomanToInteger('LVIII') == 58",
        "raise 'Test Case 3 Failed' unless RomanToInteger('MCMXCIV') == 1994"
      ],
      "compareHelper": ""
    }
  },
  "rotate-array": {
    "title": "Rotate Array",
    "content": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n\n\nFollow up:\n\nTry to come up with as many solutions as you can. There are at least three different ways to solve this problem.\nCould you do it in-place with O(1) extra space?\n\n",
    "difficulty": "Medium",
    "hints": [
      "The easiest solution would use additional memory and that is perfectly fine.",
      "The actual trick comes when trying to solve this problem without using any additional memory. This means you need to use the original array somehow to move the elements around. Now, we can place each element in its original location and shift all the elements around it to adjust as that would be too costly and most likely will time out on larger input arrays.",
      "One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example.",
      "The other line of thought is a tad bit complicated but essentially it builds on the idea of placing each element in its original position while keeping track of the element originally in that position. Basically, at every step, we place an element in its rightful position and keep track of the element already there or the one being overwritten in an additional variable. We can't do this in one linear pass and the idea here is based on <b>cyclic-dependencies</b> between elements."
    ],
    "topicTags": [
      "Array",
      "Math",
      "Two Pointers"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RotateArray(nums, k) {}",
      "testCalls": [
        "let test1 = RotateArray([1,2,3,4,5,6,7], 3); if(JSON.stringify(test1) !== JSON.stringify([5,6,7,1,2,3,4])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RotateArray([-1,-100,3,99], 2); if(JSON.stringify(test2) !== JSON.stringify([3,99,-1,-100])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateArray(nums: number[], k: number): void {}",
      "testCalls": [
        "RotateArray([1,2,3,4,5,6,7], 3); // should output [5,6,7,1,2,3,4]",
        "RotateArray([-1,-100,3,99], 2); // should output [3,99,-1,-100]"
      ],
      "compareHelper": "function arraysEqual(a: number[], b: number[]) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "void RotateArray(vector<int>& nums, int k);",
      "testCalls": [
        "RotateArray({1,2,3,4,5,6,7}, 3); // Expected output: [5,6,7,1,2,3,4]",
        "RotateArray({-1,-100,3,99}, 2); // Expected output: [3,99,-1,-100]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def RotateArray(nums: List[int], k: int) -> None:",
      "testCalls": [
        "RotateArray([1,2,3,4,5,6,7], 3)  # Expected: [5,6,7,1,2,3,4]",
        "RotateArray([-1,-100,3,99], 2)  # Expected: [3,99,-1,-100]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError(f'Arrays do not match. Expected: {arr2}, Got: {arr1}')"
    },
    "java": {
      "functionDeclaration": "public void RotateArray(int[] nums, int k) {}",
      "testCalls": [
        "RotateArray(new int[]{1,2,3,4,5,6,7}, 3); // should return [5,6,7,1,2,3,4]",
        "RotateArray(new int[]{-1,-100,3,99}, 2); // should return [3,99,-1,-100]"
      ],
      "compareHelper": "private boolean compareArrays(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) return false;\n    for (int i = 0; i < arr1.length; i++) {\n        if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n}"
    },
    "c": {
      "functionDeclaration": "void RotateArray(int* nums, int numsSize, int k);",
      "testCalls": [
        "RotateArray((int[]){1,2,3,4,5,6,7}, 7, 3); // compareArrays(nums, (int[]){5,6,7,1,2,3,4}, 7);",
        "RotateArray((int[]){-1,-100,3,99}, 4, 2); // compareArrays(nums, (int[]){3,99,-1,-100}, 4);"
      ],
      "compareHelper": "void compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) { printf(\"Test Failed\"); exit(1); } } }"
    },
    "go": {
      "functionDeclaration": "func RotateArray(nums []int, k int) []int {}",
      "testCalls": [
        "if !compareArrays(RotateArray([]int{1,2,3,4,5,6,7}, 3), []int{5,6,7,1,2,3,4}) { t.Error(\"Test Case 1 Failed\") }",
        "if !compareArrays(RotateArray([]int{-1,-100,3,99}, 2), []int{3,99,-1,-100}) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 []int) bool { if len(arr1) != len(arr2) { return false } for i := range arr1 { if arr1[i] != arr2[i] { return false } } return true }"
    },
    "rust": {
      "functionDeclaration": "fn RotateArray(nums: &mut Vec<i32>, k: i32) {}",
      "testCalls": [
        "let mut test_input1 = vec![1,2,3,4,5,6,7];\nRotateArray(&mut test_input1, 3);\nassert_eq!(test_input1, vec![5,6,7,1,2,3,4]);",
        "let mut test_input2 = vec![-1,-100,3,99];\nRotateArray(&mut test_input2, 2);\nassert_eq!(test_input2, vec![3,99,-1,-100]);"
      ],
      "compareHelper": "fn assert_eq_arrays(a: Vec<i32>, b: Vec<i32>) {\n    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        assert_eq!(a[i], b[i]);\n    }\n}"
    },
    "ruby": {
      "functionDeclaration": "def RotateArray(nums, k)\nend",
      "testCalls": [
        "result = RotateArray([1,2,3,4,5,6,7], 3)\nraise 'Test Case 1 Failed' unless result == [5,6,7,1,2,3,4]",
        "result = RotateArray([-1,-100,3,99], 2)\nraise 'Test Case 2 Failed' unless result == [3,99,-1,-100]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "rotate-image": {
    "title": "Rotate Image",
    "content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Math",
      "Matrix"
    ],
    "in-place": true,
    "javascript": {
      "functionDeclaration": "function RotateImage(matrix) {}",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]])",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateImage(matrix: number[][]): void",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]]); // Expected: [[7,4,1],[8,5,2],[9,6,3]]",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]); // Expected: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "function arraysEqual(a: number[][], b: number[][]): void {\n  if (JSON.stringify(a) !== JSON.stringify(b)) {\n    throw new Error('Test Failed');\n  }\n}"
    },
    "c++": {
      "functionDeclaration": "void RotateImage(vector<vector<int>>& matrix)",
      "testCalls": [
        "RotateImage(matrix); assert(matrix == vector<vector<int>>{{7,4,1},{8,5,2},{9,6,3}});",
        "RotateImage(matrix); assert(matrix == vector<vector<int>>{{15,13,2,5},{14,3,4,1},{12,6,8,9},{16,7,10,11}});"
      ],
      "compareHelper": "bool compareArrays(vector<vector<int>>& arr1, vector<vector<int>>& arr2) { return arr1 == arr2; }"
    },
    "python": {
      "functionDeclaration": "def RotateImage(matrix: List[List[int]]) -> None:",
      "testCalls": [
        "RotateImage([[1,2,3],[4,5,6],[7,8,9]])",
        "RotateImage([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 != arr2:\n        raise AssertionError('Arrays not equal')"
    },
    "java": {
      "functionDeclaration": "public void rotateImage(int[][] matrix)",
      "testCalls": [
        "rotateImage(new int[][]{{1,2,3},{4,5,6},{7,8,9}}); // compareArrays(matrix, new int[][]{{7,4,1},{8,5,2},{9,6,3}})",
        "rotateImage(new int[][]{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}); // compareArrays(matrix, new int[][]{{15,13,2,5},{14,3,4,1},{12,6,8,9},{16,7,10,11}})"
      ],
      "compareHelper": "private void compareArrays(int[][] arr1, int[][] arr2) {\n    if (!Arrays.deepEquals(arr1, arr2)) {\n        throw new AssertionError(\"Arrays not equal: \" + Arrays.deepToString(arr1) + \" != \" + Arrays.deepToString(arr2));\n    }\n}"
    },
    "c": {
      "functionDeclaration": "void RotateImage(int** matrix, int matrixSize, int* matrixColSize)",
      "testCalls": [
        "RotateImage((int*[]){{1,2,3},{4,5,6},{7,8,9}}, 3, (int[]){3}); // Expected output: [[7,4,1],[8,5,2],[9,6,3]]",
        "RotateImage((int*[]){{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}, 4, (int[]){4}); // Expected output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for(int i=0; i<size; i++) { if(arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RotateImage(matrix [][]int) { }",
      "testCalls": [
        "RotateImage([][]int{{1,2,3},{4,5,6},{7,8,9}})",
        "RotateImage([][]int{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}})"
      ],
      "compareHelper": "func compareArrays(arr1, arr2 [][]int) { }"
    },
    "rust": {
      "functionDeclaration": "fn RotateImage(matrix: &mut Vec<Vec<i32>>) {}",
      "testCalls": [
        "let mut matrix1 = vec![vec![1,2,3],vec![4,5,6],vec![7,8,9]]; RotateImage(&mut matrix1); assert_eq!(matrix1, vec![vec![7,4,1],vec![8,5,2],vec![9,6,3]]);",
        "let mut matrix2 = vec![vec![5,1,9,11],vec![2,4,8,10],vec![13,3,6,7],vec![15,14,12,16]]; RotateImage(&mut matrix2); assert_eq!(matrix2, vec![vec![15,13,2,5],vec![14,3,4,1],vec![12,6,8,9],vec![16,7,10,11]]);"
      ],
      "compareHelper": "fn assert_2d_arrays_equal(actual: Vec<Vec<i32>>, expected: Vec<Vec<i32>>) { for (a, e) in actual.iter().zip(expected.iter()) { assert_eq!(a, e); }}"
    },
    "ruby": {
      "functionDeclaration": "def RotateImage(matrix)\nend",
      "testCalls": [
        "test_case_1 = [[1,2,3],[4,5,6],[7,8,9]]\nRotateImage(test_case_1)\nraise 'Test Case 1 Failed' unless test_case_1 == [[7,4,1],[8,5,2],[9,6,3]]",
        "test_case_2 = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nRotateImage(test_case_2)\nraise 'Test Case 2 Failed' unless test_case_2 == [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      ],
      "compareHelper": "def array_equal(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "rotate-list": {
    "title": "Rotate List",
    "content": "Given the head of a linkedlist, rotate the list to the right by k places.\n\nExample 1:\n\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\n\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Linked List",
      "Two Pointers"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function RotateList(head, k) {}",
      "testCalls": [
        "let test1 = RotateList([1,2,3,4,5], 2); if(JSON.stringify(test1) !== JSON.stringify([4,5,1,2,3])) { throw new Error('Test Case 1 Failed'); }",
        "let test2 = RotateList([0,1,2], 4); if(JSON.stringify(test2) !== JSON.stringify([2,0,1])) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function compareArrays(arr1, arr2) { return JSON.stringify(arr1) === JSON.stringify(arr2); }"
    },
    "typescript": {
      "functionDeclaration": "function RotateList(head: number[], k: number): number[] {}",
      "testCalls": [
        "const test1 = RotateList([1,2,3,4,5], 2); if (JSON.stringify(test1) !== JSON.stringify([4,5,1,2,3])) throw new Error('Test Case 1 Failed');",
        "const test2 = RotateList([0,1,2], 4); if (JSON.stringify(test2) !== JSON.stringify([2,0,1])) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": "function arraysEqual(a: any[], b: any[]): boolean { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "c++": {
      "functionDeclaration": "void RotateList(ListNode* head, int k);",
      "testCalls": [
        "RotateList(createLinkedList({1,2,3,4,5}), 2); // Expected: [4,5,1,2,3]",
        "RotateList(createLinkedList({0,1,2}), 4); // Expected: [2,0,1]"
      ],
      "compareHelper": "bool compareArrays(vector<int>& arr1, vector<int>& arr2) { if(arr1.size() != arr2.size()) return false; for(int i=0; i<arr1.size(); i++) { if(arr1[i] != arr2[i]) return false; } return true; }"
    },
    "python": {
      "functionDeclaration": "def RotateList(head, k):",
      "testCalls": [
        "assert RotateList([1,2,3,4,5], 2) == [4,5,1,2,3]",
        "assert RotateList([0,1,2], 4) == [2,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2):\n    if arr1 == arr2:\n        return True\n    else:\n        raise AssertionError(f'Arrays do not match. Expected: {arr2}, Got: {arr1}')"
    },
    "java": {
      "functionDeclaration": "public ListNode rotateRight(ListNode head, int k) { }",
      "testCalls": [
        "ListNode test1 = rotateRight(createLinkedList(new int[]{1,2,3,4,5}), 2); compareLinkedList(test1, new int[]{4,5,1,2,3});",
        "ListNode test2 = rotateRight(createLinkedList(new int[]{0,1,2}), 4); compareLinkedList(test2, new int[]{2,0,1});"
      ],
      "compareHelper": "private void compareLinkedList(ListNode result, int[] expected) { }"
    },
    "c": {
      "functionDeclaration": "void RotateList(struct ListNode* head, int k);",
      "testCalls": [
        "RotateList(createListFromArray((int[]) {1,2,3,4,5}, 5), 2); // Expected output: [4,5,1,2,3]",
        "RotateList(createListFromArray((int[]) {0,1,2}, 3), 4); // Expected output: [2,0,1]"
      ],
      "compareHelper": "int compareArrays(int* arr1, int* arr2, int size) { for (int i = 0; i < size; i++) { if (arr1[i] != arr2[i]) return 0; } return 1; }"
    },
    "go": {
      "functionDeclaration": "func RotateList(head *ListNode, k int) *ListNode {}",
      "testCalls": [
        "if result := RotateList(sliceToListNode([]int{1, 2, 3, 4, 5}), 2); !compareLinkedList(result, sliceToListNode([]int{4, 5, 1, 2, 3})) { t.Errorf(\"Test 1 failed\") }",
        "if result := RotateList(sliceToListNode([]int{0, 1, 2}), 4); !compareLinkedList(result, sliceToListNode([]int{2, 0, 1})) { t.Errorf(\"Test 2 failed\") }"
      ],
      "compareHelper": "func compareLinkedList(l1 *ListNode, l2 *ListNode) bool { for l1 != nil && l2 != nil { if l1.Val != l2.Val { return false } l1 = l1.Next l2 = l2.Next } return l1 == nil && l2 == nil }"
    },
    "rust": {
      "functionDeclaration": "fn RotateList(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { }",
      "testCalls": [
        "assert_eq!(RotateList(Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 5, next: None })) })) })) })) })), 2), Some(Box::new(ListNode { val: 4, next: Some(Box::new(ListNode { val: 5, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 3, next: None })) })) })) })) }))",
        "assert_eq!(RotateList(Some(Box::new(ListNode { val: 0, next: Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode { val: 2, next: None })) })) })), 4), Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode { val: 0, next: Some(Box::new(ListNode { val: 1, next: None })) })) }))"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def RotateList(head, k)\nend",
      "testCalls": [
        "result = RotateList([1,2,3,4,5], 2)\nraise 'Test Case 1 Failed' unless result == [4,5,1,2,3]",
        "result = RotateList([0,1,2], 4)\nraise 'Test Case 2 Failed' unless result == [2,0,1]"
      ],
      "compareHelper": "def compareArrays(arr1, arr2)\n  arr1 == arr2\nend"
    }
  },
  "same-tree": {
    "title": "Same Tree",
    "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nExample 1:\n\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n\nConstraints:\n\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SameTree(p, q) {}",
      "testCalls": [
        "if (SameTree([1,2,3], [1,2,3]) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (SameTree([1,2], [1,null,2]) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arraysEqual(a, b) { return JSON.stringify(a) === JSON.stringify(b); }"
    },
    "typescript": {
      "functionDeclaration": "function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {}",
      "testCalls": [
        "if (!isSameTree(arrayToBinaryTree([1,2,3]), arrayToBinaryTree([1,2,3])) === true) { throw new Error('Test Case 1 Failed'); }",
        "if (!isSameTree(arrayToBinaryTree([1,2]), arrayToBinaryTree([1,null,2])) === false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": "function arrayToBinaryTree(arr: (number | null)[]): TreeNode | null {}"
    },
    "c++": {
      "functionDeclaration": "bool IsSameTree(TreeNode* p, TreeNode* q)",
      "testCalls": [
        "if(IsSameTree(BuildTree({1,2,3}), BuildTree({1,2,3})) != true) throw std::runtime_error(\"Test 1 failed\");",
        "if(IsSameTree(BuildTree({1,2}), BuildTree({1,INT_MIN,2})) != false) throw std::runtime_error(\"Test 2 failed\");",
        "if(IsSameTree(BuildTree({1,2,1}), BuildTree({1,1,2})) != false) throw std::runtime_error(\"Test 3 failed\");"
      ],
      "compareHelper": "std::vector<int> BuildTree(const std::vector<int>& values) { TreeNode* root = new TreeNode(values[0]); std::vector<TreeNode*> nodes = {root}; for(int i = 1; i < values.size(); ++i) { if(values[i] != INT_MIN) { TreeNode* node = new TreeNode(values[i]); nodes.push_back(node); if(i % 2 == 1) nodes[(i-1)/2]->left = node; else nodes[(i-1)/2]->right = node; } } return root; }"
    },
    "python": {
      "functionDeclaration": "def SameTree(p, q):",
      "testCalls": [
        "assert SameTree([1,2,3], [1,2,3]) == True, 'Test Case 1 Failed'",
        "assert SameTree([1,2], [1,None,2]) == False, 'Test Case 2 Failed'"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean SameTree(TreeNode p, TreeNode q)",
      "testCalls": [
        "if (!SameTree(createTree(new Integer[]{1,2,3}), createTree(new Integer[]{1,2,3}))) throw new AssertionError();",
        "if (SameTree(createTree(new Integer[]{1,2}), createTree(new Integer[]{1,null,2}))) throw new AssertionError();",
        "if (SameTree(createTree(new Integer[]{1,2,1}), createTree(new Integer[]{1,1,2}))) throw new AssertionError();"
      ],
      "compareHelper": "private boolean compareTrees(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    return p.val == q.val && compareTrees(p.left, q.left) && compareTrees(p.right, q.right);\n}"
    },
    "c": {
      "functionDeclaration": "bool IsSameTree(struct TreeNode* p, struct TreeNode* q)",
      "testCalls": [
        "IsSameTree(p1, q1); // Expected: true",
        "IsSameTree(p2, q2); // Expected: false",
        "IsSameTree(p3, q3); // Expected: false"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func IsSameTree(p *TreeNode, q *TreeNode) bool",
      "testCalls": [
        "if !IsSameTree(sliceToTreeNode([]int{1,2,3}), sliceToTreeNode([]int{1,2,3})) { t.Error(\"Test Case 1 Failed\") }",
        "if IsSameTree(sliceToTreeNode([]int{1,2}), sliceToTreeNode([]int{1,0,2})) { t.Error(\"Test Case 2 Failed\") }"
      ],
      "compareHelper": "func sliceToTreeNode(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n    root := &TreeNode{Val: nums[0]}\n    queue := []*TreeNode{root}\n    i := 1\n    for i < len(nums) {\n        node := queue[0]\n        queue = queue[1:]\n        if nums[i] != -1 {\n            node.Left = &TreeNode{Val: nums[i]}\n            queue = append(queue, node.Left)\n        }\n        i++\n        if i < len(nums) && nums[i] != -1 {\n            node.Right = &TreeNode{Val: nums[i]}\n            queue = append(queue, node.Right)\n        }\n        i++\n    }\n    return root\n}"
    },
    "rust": {
      "functionDeclaration": "fn SameTree(p: Option<Box<TreeNode>>, q: Option<Box<TreeNode>>) -> bool {}",
      "testCalls": [
        "assert_eq!(SameTree(Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: None, right: None })), right: Some(Box::new(TreeNode { val: 3, left: None, right: None }) })), Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: None, right: None })), right: Some(Box::new(TreeNode { val: 3, left: None, right: None }) }))), true);",
        "assert_eq!(SameTree(Some(Box::new(TreeNode { val: 1, left: Some(Box::new(TreeNode { val: 2, left: None, right: None })), right: None })), Some(Box::new(TreeNode { val: 1, left: None, right: Some(Box::new(TreeNode { val: 2, left: None, right: None }) }))), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SameTree(p, q)\nend",
      "testCalls": [
        "SameTree([1,2,3], [1,2,3]) == true || raise('Test Case 1 Failed')",
        "SameTree([1,2], [1,nil,2]) == false || raise('Test Case 2 Failed')"
      ],
      "compareHelper": ""
    }
  },
  "search-a-2d-matrix": {
    "title": "Search a 2D Matrix",
    "content": "You are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\n\nExample 1:\n\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n\nExample 2:\n\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-104 <= matrix[i][j], target <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchA2DMatrix(matrix, target) {}",
      "testCalls": [
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) !== true) { throw new Error('Test Case 1 Failed'); }",
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) !== false) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchA2DMatrix(matrix: number[][], target: number): boolean {}",
      "testCalls": [
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) !== true) throw new Error('Test Case 1 Failed');",
        "if (SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) !== false) throw new Error('Test Case 2 Failed');"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "bool SearchA2DMatrix(vector<vector<int>>& matrix, int target);",
      "testCalls": [
        "if(SearchA2DMatrix({{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3) != true) { throw std::runtime_error(\"Test Case 1 Failed\"); }",
        "if(SearchA2DMatrix({{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13) != false) { throw std::runtime_error(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchA2DMatrix(matrix: List[List[int]], target: int) -> bool:",
      "testCalls": [
        "assert SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3) == True",
        "assert SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13) == False"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public boolean SearchA2DMatrix(int[][] matrix, int target) { }",
      "testCalls": [
        "if (!SearchA2DMatrix(new int[][]{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3)) throw new AssertionError();",
        "if (SearchA2DMatrix(new int[][]{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13)) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "bool SearchA2DMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)",
      "testCalls": [
        "if (!SearchA2DMatrix((int*[]){(int[]){1,3,5,7}, (int[]){10,11,16,20}, (int[]){23,30,34,60}}, 3, (int[]){4,4}, 3)) { printf(\"Test 1 Failed\"); }",
        "if (SearchA2DMatrix((int*[]){(int[]){1,3,5,7}, (int[]){10,11,16,20}, (int[]){23,30,34,60}}, 3, (int[]){4,4}, 13)) { printf(\"Test 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchA2DMatrix(matrix [][]int, target int) bool {}",
      "testCalls": [
        "if SearchA2DMatrix([][]int{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 3) != true {panic(\"Test case 1 failed\")}",
        "if SearchA2DMatrix([][]int{{1,3,5,7},{10,11,16,20},{23,30,34,60}}, 13) != false {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchA2DMatrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {}",
      "testCalls": [
        "assert_eq!(SearchA2DMatrix(vec![vec![1,3,5,7], vec![10,11,16,20], vec![23,30,34,60]], 3), true);",
        "assert_eq!(SearchA2DMatrix(vec![vec![1,3,5,7], vec![10,11,16,20], vec![23,30,34,60]], 13), false);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchA2DMatrix(matrix, target)\nend",
      "testCalls": [
        "result = SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3)\nraise 'Test Case 1 Failed' unless result == true",
        "result = SearchA2DMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13)\nraise 'Test Case 2 Failed' unless result == false"
      ],
      "compareHelper": ""
    }
  },
  "search-in-rotated-sorted-array": {
    "title": "Search in Rotated Sorted Array",
    "content": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by3indices and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n\n\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-104 <= target <= 104\n\n",
    "difficulty": "Medium",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchInRotatedSortedArray(nums, target) {}",
      "testCalls": [
        "if(SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchInRotatedSortedArray(nums: number[], target: number): number {}",
      "testCalls": [
        "if (SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) !== 4) { throw new Error('Test Case 1 Failed'); }",
        "if (SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) !== -1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int SearchInRotatedSortedArray(vector<int>& nums, int target);",
      "testCalls": [
        "assert(SearchInRotatedSortedArray({4,5,6,7,0,1,2}, 0) == 4);",
        "assert(SearchInRotatedSortedArray({4,5,6,7,0,1,2}, 3) == -1);",
        "assert(SearchInRotatedSortedArray({1}, 0) == -1);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchInRotatedSortedArray(nums: List[int], target: int) -> int:",
      "testCalls": [
        "assert SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) == 4",
        "assert SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) == -1"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int SearchInRotatedSortedArray(int[] nums, int target) {}",
      "testCalls": [
        "assert SearchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 0) == 4;",
        "assert SearchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 3) == -1;"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int SearchInRotatedSortedArray(int* nums, int numsSize, int target)",
      "testCalls": [
        "assert(SearchInRotatedSortedArray((int[]){4,5,6,7,0,1,2}, 7, 0) == 4);",
        "assert(SearchInRotatedSortedArray((int[]){4,5,6,7,0,1,2}, 7, 3) == -1);",
        "assert(SearchInRotatedSortedArray((int[]){1}, 1, 0) == -1);"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchInRotatedSortedArray(nums []int, target int) int {}",
      "testCalls": [
        "if SearchInRotatedSortedArray([]int{4,5,6,7,0,1,2}, 0) != 4 {panic(\"Test case 1 failed\")}",
        "if SearchInRotatedSortedArray([]int{4,5,6,7,0,1,2}, 3) != -1 {panic(\"Test case 2 failed\")}"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchInRotatedSortedArray(nums: Vec<i32>, target: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(SearchInRotatedSortedArray(vec![4,5,6,7,0,1,2], 0), 4);",
        "assert_eq!(SearchInRotatedSortedArray(vec![4,5,6,7,0,1,2], 3), -1);",
        "assert_eq!(SearchInRotatedSortedArray(vec![1], 0), -1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchInRotatedSortedArray(nums, target)\n  \nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless SearchInRotatedSortedArray([4,5,6,7,0,1,2], 0) == 4",
        "raise 'Test Case 2 Failed' unless SearchInRotatedSortedArray([4,5,6,7,0,1,2], 3) == -1"
      ],
      "compareHelper": ""
    }
  },
  "search-insert-position": {
    "title": "Search Insert Position",
    "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou mustwrite an algorithm withO(log n) runtime complexity.\n\nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\n\nConstraints:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104\n\n",
    "difficulty": "Easy",
    "hints": [
      null
    ],
    "topicTags": [
      "Array",
      "Binary Search"
    ],
    "in-place": false,
    "javascript": {
      "functionDeclaration": "function SearchInsertPosition(nums, target) {}",
      "testCalls": [
        "if(SearchInsertPosition([1,3,5,6], 5) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInsertPosition([1,3,5,6], 2) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "typescript": {
      "functionDeclaration": "function SearchInsertPosition(nums: number[], target: number): number {}",
      "testCalls": [
        "if(SearchInsertPosition([1,3,5,6], 5) !== 2) { throw new Error('Test Case 1 Failed'); }",
        "if(SearchInsertPosition([1,3,5,6], 2) !== 1) { throw new Error('Test Case 2 Failed'); }"
      ],
      "compareHelper": ""
    },
    "c++": {
      "functionDeclaration": "int SearchInsertPosition(vector<int>& nums, int target);",
      "testCalls": [
        "assert(SearchInsertPosition({1, 3, 5, 6}, 5) == 2);",
        "assert(SearchInsertPosition({1, 3, 5, 6}, 2) == 1);"
      ],
      "compareHelper": ""
    },
    "python": {
      "functionDeclaration": "def SearchInsertPosition(nums: List[int], target: int) -> int:",
      "testCalls": [
        "assert SearchInsertPosition([1,3,5,6], 5) == 2",
        "assert SearchInsertPosition([1,3,5,6], 2) == 1",
        "assert SearchInsertPosition([1,3,5,6], 7) == 4"
      ],
      "compareHelper": ""
    },
    "java": {
      "functionDeclaration": "public int searchInsert(int[] nums, int target) {}",
      "testCalls": [
        "if (searchInsert(new int[]{1,3,5,6}, 5) != 2) throw new AssertionError();",
        "if (searchInsert(new int[]{1,3,5,6}, 2) != 1) throw new AssertionError();",
        "if (searchInsert(new int[]{1,3,5,6}, 7) != 4) throw new AssertionError();"
      ],
      "compareHelper": ""
    },
    "c": {
      "functionDeclaration": "int SearchInsertPosition(int* nums, int numsSize, int target)",
      "testCalls": [
        "if(SearchInsertPosition((int[]){1,3,5,6}, 4, 5) != 2) { printf(\"Test Case 1 Failed\"); }",
        "if(SearchInsertPosition((int[]){1,3,5,6}, 4, 2) != 1) { printf(\"Test Case 2 Failed\"); }"
      ],
      "compareHelper": ""
    },
    "go": {
      "functionDeclaration": "func SearchInsertPosition(nums []int, target int) int {}",
      "testCalls": [
        "if SearchInsertPosition([]int{1,3,5,6}, 5) != 2 { panic(\"Test case 1 failed\") }",
        "if SearchInsertPosition([]int{1,3,5,6}, 2) != 1 { panic(\"Test case 2 failed\") }"
      ],
      "compareHelper": ""
    },
    "rust": {
      "functionDeclaration": "fn SearchInsertPosition(nums: Vec<i32>, target: i32) -> i32 { }",
      "testCalls": [
        "assert_eq!(SearchInsertPosition(vec![1,3,5,6], 5), 2);",
        "assert_eq!(SearchInsertPosition(vec![1,3,5,6], 2), 1);"
      ],
      "compareHelper": ""
    },
    "ruby": {
      "functionDeclaration": "def SearchInsertPosition(nums, target)\nend",
      "testCalls": [
        "raise 'Test Case 1 Failed' unless SearchInsertPosition([1,3,5,6], 5) == 2",
        "raise 'Test Case 2 Failed' unless SearchInsertPosition([1,3,5,6], 2) == 1",
        "raise 'Test Case 3 Failed' unless SearchInsertPosition([1,3,5,6], 7) == 4"
      ],
      "compareHelper": ""
    }
  }
}